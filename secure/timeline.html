<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #4CAF50;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #43A047;
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #76b852; /* fallback for old browsers */
            background: -webkit-linear-gradient(right, #76b852, #8DC26F);
            background: -moz-linear-gradient(right, #76b852, #8DC26F);
            background: -o-linear-gradient(right, #76b852, #8DC26F);
            background: linear-gradient(to left, #76b852, #8DC26F);
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>




<script>
    // do not remove this comment, it is used to detect the version of the script
    // STATICRYPT_VERSION: async

    const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 *
 * Mirrors the API of CryptoJS.enc.Hex
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassphrase) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassphrase
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassphrase) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassphrase(passphrase, salt) {
    // we hash the passphrase in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassphrase = await hashLegacyRound(passphrase, salt);

    hashedPassphrase = await hashSecondRound(hashedPassphrase, salt);

    return hashThirdRound(hashedPassphrase, salt);
}
exports.hashPassphrase = hashPassphrase;

/**
 * This hashes the passphrase with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(passphrase, salt) {
    return pbkdf2(passphrase, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(passphrase, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(passphrase),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassphrase, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
    const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassphrase = await cryptoEngine.hashPassphrase(password, salt);


    const encrypted = await cryptoEngine.encrypt(msg, hashedPassphrase);
    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassphrase, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassphrase
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassphrase
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassphrase,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassphrase = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassphrase, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassphrase = originalPassphrase || hashedPassphrase;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassphrase = await cryptoEngine.hashThirdRound(originalPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassphrase = await cryptoEngine.hashSecondRound(originalPassphrase, salt);
        updatedHashedPassphrase = await cryptoEngine.hashThirdRound(updatedHashedPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassphrase),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
    const decode = codec.init(cryptoEngine).decode;

    // variables to be filled when generating the file
    const encryptedMsg = '1979f38000c18e08f429607c96623264227b292aee0d0ac1b5ca45f9495feae3c47d237cbadcb0f7f7264c96175712cfce55d7aeefba39016193e72c245daaabd43e005a67d9f5de55591e3add17d1f97074c94e4c7ad85b8cc70522650f0cdbf26c385a5488156a33b01fa638a5bdedd44276d4889b10a90947f0f2db1e26943cb2c42da9a3ae681c7139ce26e008160b29e9b03fcfc3d8b566177e9dc29ed44fb94b20bcd2ad2fdaf01711fe38d96e3fa7abc2643b187fe52dffe4780232379c10498fa807949632eca10a615e3953ea3a6189b279a31e49bebf075a43d4f6b5089be6d97e0e408d357d44793dc003d0b1994be62d490be0ba3b8fa45e8139872f90471e7dd0b7086efd6bd4362ff523cadacc7a99fa09f7db38cb943b312388119929821ae7889dd789853b6d196e7ecc47eec46c27c5eecbc85f5f2ea57f72a6300e6469a522a8c1a3610173d67d631f5aae65729ab9c95a2a4334d158a8edfcdb9aa2624f614a7985c9421f12417d1236891eb3f29df49309e4be368e366d0bf22929b9827e6a67f0c18995ca1c1ca505fd972bf40e63545c0241fb1186e2336fbf6690455a4df46fbfa774833648f3d9403c9f652fbbfd227a688b227387282a00d0a9e1c49a974dac08a169bfb03297f4a84a72827eac8e9bae60da75c28bf11e677766fbb8c3c27b8ee930e0612adb8d748c8ea820c73e6abfa3c01ecc25b066eba92c21b8edf7bb98d37a771ea7c5154e39e12b7747bb614b0caaa25c68789bd51f1969a3e2c2ca5580d92e204f738e5a49e6e3cd985dfb78a7e9c73a2d4713d7048fdd68f18c934b03681ce21d86c863a8fe4467ba4ffa8ea5dfb6526edbc1bdff2316837dee3182a53eee58b439a244db0cdfab6ed170c48105f888b9148939b2969e715458d80bc9b5fae3aa6009aad9b4487f9801f686c5f81cb610bfb4b856e06189892aacd2f4e9bb0f3f4e00ffd9183a45d522f543ec6180213e8c0a7822d465622de8ee5ccf4de93df55370d4ada014bbb04addbe0a3978849db6d648d5e0855eff4ae9f240995f58c170e6a0e7323e47de4afe8cd0bc35a708cd52b8dd0c64250d26cedff55942ecd8721e4a376653396f1554ddcb83dec1935c45a4fdc2b1c5adcecbda8b07b5f1985b2104796117cd83bb4d3f663880aa1d7ee9e76a0c67a77f0f937b109fad3350a4bde9c3e964ebd450f742fac6e71cf581bfb818b7b323e576f92c0043a175f249ca04c0b1265237a6ccfe03429d9873b12a47d2f2806cd91c5ca64ba8c7d9402c0a9a15d3ff3df9439e2279b796fbb5d0a96463e0563d11e16793abaada53065531615def13a7dfff783ef152894c3fde6ca94785d0878deea08c87c310ecc8aaaaa9e0badac894b159cb4cddba50ad486444ea03d7fa3963cf66506d3664a094e98e184f1a58a423251ae00ce9bdfc7490ee2202e46caf400852ee859a8069a6d02bafdbdca0a85b06a16a8529ee96642a8964590c1844b3fb1ca422fd39f9e1b0ad257e14141fdf8f712947abccfb80e59b8a5bc7e31b7192ec6dc413604ab39b49346ffa732b79cec82daf19b18f620782cb6daa2e3d72d5c2711c8e62c274390b822f05011bd4be7c01e65d1fa1e4d9c10b9e2c739b354365627c6267c4da85fd0081385cb37b295c6d5cdf11f640fe6b256d8d2913d8239ae21b2d582f8ff303ffeb316a487beb244c22334bd01a279bdca97e7fcdcde290e8e250e50f7392426446f1a6e118d9044601517ed3ac128287e21f1fe5e5e62cde6134b89a638096fd60100df6811c08974180351a6a9f89d920ef033c8ded5d5c3e833d57a3f9a0e96288344c6bc7f974fc78160ff239cc0affd42cd4ff020c89ff99401982b4ac4ce76e419870726d4ec09bd7c91a5768a781df37bea53e219aa848721e4e4527ea3156360109a4920a7cd7e8a467b4e83366f9ae315faf89d392ac37fa8c9716872cbfbf09ccbd96dd37217fa7f976d59b4bb8648bb7dc3b3ffc7fc906d5fd16d3f3547acc3a207772e341615bcb74992e22a1477767385ef3bbb908b53948e4a8b20e9d72dc58101a07ab56699f3280aeb6040a984511a3186fb08c7c9c8017eaf2623e393384646eb3da95fc22dbf57127fedb0ff3611d14fba2c346822844676303e343d9d3aad9168f55b8f28cd467ada25e3c80c70a9075949277de59d7864234a4b8c07da4d495229a89867fc89ccfb85571645bc5aff3fc45fa05383e6a9590b0666f1a8e5060b5942c639dbd7541a14c8133635fbfdc23ee6701496adf47159e5241cf5e9636d836319af106067b370b8f45d61601ad99ef99731757a10c841cd43efa0bfb8496241c796a661a2e034e234d411fd1b9dc90f4e65e4bb3951a7322045750c4fdc1d14ce49a8490545679059abf2e86ad1bc1071b4ca09da97dbb30a46bba9ebeebc58a988c090b8c6befc9b0edfc4c2fe83775980e97b68b0b8c03e35d99b63228851f4227507c27a0a0a9d44531e0a670174b4553402e65d583b334a2f2a0337df0508f69afa096f5938c7a663643afb3c2ac1a70c289eb2814ab66d501f46cf6f33b4f2379d0de23d4a2314ca7a45a893d9b850cf21533ff5702a5ef4f96a1039caff224d942d57efb2aefc65e70c1e4f3bd6eb1be330b5bddc98bd2a6ecdd160fd1584719af89565eb5bf4bf4980ff99a4a744bb3e61130d623d636fd1ae01bfb8d3fb62cdd8408f1f718c8608fa94cf6c042ec3bd7065cbc1fa685e6efe04d999f615fcd9622d4e38d67806c4d6094bf009e7f171e65a60b260072451b2a4eba61f305862fe668ccef9a69644a9f19fc359b56a886e5aad30538e41fbcb50cec0650b514caaa84c684b0f2d900ae3dff963d3f225ec4fc87375e150a4647847420568ac2bb762c62fcad36007605d2b9c3b608dc82365abe3edfbebb22b3ded5ac86c2f58705dd8588bc7c4cb22bd27ec924548c79d17ce7b00cac632af50e310884cf232f1fc59d7cd841660451d650b65203e2862f2b6adf74d894ade4cddc424fad2c30bfac8d979190df8a2694c0396c4d1b05f379e9af116ebc2ac924f5d46e356f70cd7b5dcb55b238f5a72cb374af2e82bd8eeab7b6c8932ea40bd0d218166ea3be8bcc927ad46a51a6edeb6d2d511b8fa0c12f018cdec3486c0157f332bfa2f1ff15227c7d50b9e55d12a8329b1e2237b9861f5e95d367cc60fd74235ba958894e023206c8cdaef04272be8c116ab5ac23443e0da6b491597bc6a560911757790f191134b205b284a22a5b87626eb6912fc95397453bb2a8971c6f507f514676a61960856157d5a68bedd79447b2f6f8b21ba5e09823b765201cf34c1522124d30150024107e88c99611b790d35d3915e88f8c52658f5185e1d1609d68f31f319d6e68927ab003d655a74265afa5de092ac1f36bd6f90aa9b85a2469fe6519c7102cbab53b16fd5851ff0658dbf5db2c202957816e32237e26608ea751e631e05d575d4571e63f271c7dc790a81e3ea735f66e5d7d954d3c35beccd05f9b8688f88f452448df64f5dc5be532f19b3ffe288300b9a90e6588608b4090cdc1fb7c502a03bfa78470c1388e351e6ac558d5c6613c92b55e1bc673a54ecc2ec9a02aadd0b8a274b149a178e8748235c302c660f2daa3a9f51c8ce5a3a235b2d84f808221024d423797e07c385955fd3262f03aba33abac666c5cabff88de5aeb68c2b00ee32af761a6d69e53de81a64f207be45d2f8cd9267b163a015c8c3ed9bc0cc32e9534f534c910ca1796bfbcc1ba2c3935a12b23efb356fa8d60d9420d376c3339a0940280b241eb56547dc881d61a32cc1839f3e791bd42794f53741dfbdc1045cb5a74eff448ff127d99114d7c366f43e73413722ba302623b8f40ca54df11536600f71aa848da39112706b926c01a8f6c09ef7ab6736ff4f2a11e59088e33230445b5215210dade58c56483aaf9c4236244c6894aeca82384dd8b0d5fd62da30b77d617526affa0d315cbf67338e8df53f03d649849a5faa948a4e30d44eb9e76345bc6ca8b03d814ffc9684a60bbe7a8aa819be6bcea49479d8424f74afe06b91bcb1d9e32756502a15395c1a134b966d82af00d2c821b3eed4fa4b66178d3d03c62232e03bfcfc86aaaaa9a79077c4e6bfde997fb3ce80268d2b307dc9972b8d9c5692b65b692ded8dd9ed1404f44d9994d4d17d197ddea1ab97ad7065383146f1e54545dbd9819e3d522aba5bf52ebefd71e81bfc245bed3fc445f6fe84a81f15c1e8dd414947c53050197d4738a36d7d911d96c14b55ea98498c7f5091dbdbfc17fd9259f477083d020a4f0cf3032d7cc839d4fd46f25f8fb18039dda3e47d9a864fef456f57684658898bea4b84084df6827be3baee625f18a35222ecfbfacaa36c563ac8591db8a4bf1c7a9dc6ff6925ac539b246ddaef6b69da59bc2316c1bedd13a59b283d416e541b18726239b399de194adb4e44d4b88983811da64dbee8a3c270c7a1c4778b0e8657d0b118a4aaa742980dab1b32c085e1b5c2e798ed6381fbf6300e3ae3c92d0707d5c70c01b71f354a6560f75c0ee96c6a419150db1b9a469b7551f42773d04f6a1e8a1a9cd252726e608ef8a74631d1a18db5eebf80b5e5a69461e7cc76ef2ab1be78aefe6687c72dc1c33d8f8e7f8b609bd68486f30a1441c1a65e23f8f042be05e8a660868e98c437bc3c8e1a7136639b163ad5f0c1ae99509208458e692f0b9018e98a01619ac75c73cfbb23677d7d5e05f26603b5a058d6c82757e35c5ee9b60892045a404770eb83d0198f995b8830848741a809be6f7a3bc3f9191a4358132114d12ece238d57e73c42a46f286957eb2c2fe60490c52753bf882e45f8d21e93e4f0dc146c09f8b937a250eec3fc946157b10dc86a5a16aab6e92110fcc556259774834330aa6f4d65af5ec5c8aa485b5c1ccbdba1a926d4fbf2dd4977dc3c4ae7291149986c106fe78c9058229b98022b243b72a2ce30f0e8e5f9a3b947f69af81c09a037c3bb62a3796ec8d99bbbfc6f5ac9956e52306ee8e5a81aa00ca0909afc54243e6b5a843086322ff56db638f9a614a56723548858108c9d429304531b73303c2b630616fd1d61520ee052f81b84ea8cd2cfb9af9dcabfc32e177d4c24a1a6d2ed5c8d9b569d3099bf52d1420557b29da3c067f7f838c2ffe800a1b044094c2a77fe77e80d534c87c3d1af88a6e49d2bf228e091d97bf7eefecd9a1314b99d3a28cb876c3bddaec70779c3650633c248f3491663e158542e6b54f14c379c67cc30e5846041a3aa9dcc7eec5b855c3a6045e63a7652e8395ee441968f59839324501687819ae7f7218a6b4ddf0c0320e704ad83bcfe2cd0ece9887881e01a780e8fa58da251997211cc450e4ef5747881f1b851248af72db57a61269a7691ae66831f15bcbdfc423c72a00ffdc9ec430ff11bb4b4065407cc475e89751707f51c7963db6e6cc2dbf31f7cff80f411b6d60eda4ed408c9ebabbdafbe835b7436160309271e8a03f43f76bff16f2427719858512eb532a894bc0b1f7544addd0d8b98dd7efbf9caaaf4973cb99c697eae40822dcedfc254cbc48d14445550871ebbf3ab6d56b4eaf78c27eda22ba7684ba4571ff9828d2120543b13b4482942fcdcac2fe88bd1e625b5560a63fafdea9fbf56ed80d9c2751f129f5b2f12ab4d70a48d85a59e15aaf0181561bbaa03eb1cddc5d7c7036200baa2fbdd12e0d8f9f39e4c221a94dd68bd47e6b2ca4b7185b22effc95a6c35c09ae960a3a7076cf23a202d5a03841064afbc373a09543db0aa5ad8ea9f5370ae4f3b2e8a810de44f5c899fa25ae0b94bfb40edb8cdd355a12660f9abc0d9b0db3da762784eb983d6ea7cb793a7b8f87e9ae7fa8343c55a16dcefd3c5ca4bfef05200d69ece0f6dd4ca0d1b058433a229f4eb33e1fe2679b67cba0f88df7667ccce8a2faecdbcbf552394f03fd6ade38b8944df12d7eff4a701eeb3c3ddd5eaad4adc4ba5d9e9c02141979638c6e194805acc07b024cb9346ad0c5be4b418ee96605e6678a2ca9a27d3f3ceb3aaccefa51a2b7bb37b609160f289e30f502307172f611e78c97c0d4eccb5b57bf7cae02e2f01d4d2b37c76b617f0b81b6deea643e92a82ea62c81d45bbc9bb1da56024bf42c34d6ac38998ed1f39bce323caf029119f1851b07241707dc8748e6a7e55a7ebde21ba79642e5a7836c08e2244b08f8d90c98f42d11c96cc36f58547c8f27fe05653337cba027c739adac460b2a37f4adca3a5820ffca09c65eeb8d76f8481f3c91c0050cb66655d4dabd041e3d36d52781a7313cf6d43aaeffa34473ac8eb00c0c7d0d1b4fab10f535e9738d49b8510163584bd1d993a6535e84ec43c369ae3cde2cb50075fe7393429ad917a1090dffed9289c7ace82b91d7fccacbc236a6bafe853ad0e76a026b10bde8ee48e94e76be4dc014c6be1c65185a5a44ebba5ac629891d21247f3f44ea62d88740076b8bcfa1fa8aca50fcfe7eacc93de23c59c67e714bcfc13772df787b5272e0733fe1760cfc55e18698dbe2ca00153354bdf7526765a8143364e59403cbbf203eb46461450da37549b433bfed874d121743de33a580e2d797a80bd2bbc1f04331bbcafeefb2729a9fbc0cca763ca78dba078ce087f226eff46d62ca5bee41e124173efa5dfb070a20190c17cdad44586dab8088cfff39b49cd72a917c059bc27bc1326c9e8cf3c2eda8c959973dd1b2709c933fe807517699d5f584e9664d1a4c3641623aefdcce0f479787223c05ec18c6bd2fc216901790ce8b1df3d226b241ed3149cf2ee3037f5c95de495579c404e32e3e53eea57cf8278be50675ae08be35c891e7a735e32663333a9890a88c752dfd0cf408e14d0f716ef3526d7daeb59f26d754454b1ce9efd74487efd9343772072ea7f4421cf10bd83586475d86046c69542986409675f33f07ef876a26397855095e1a56bc5b655ea2bd10e480574b0fd5060e19225c24b3b0b0312a7f9ebfc77b9426260257ce5db15fdce4cac3adc3695a58c6921a42d3b409c82edbf4a0c3d2d70854d59779f9baa92040c63508ee54483aef5eb12137203c886af206af848222cdf1cfbb10e0076c76b363a86c25a685f656da7bba0986e03b9ba020dc8cb0cb465e26bb5afce0be82758db997297056fcdc66fc84309b050fca517fe23e1fb7f01f88909634b02263ef8b9c580f05a9b17d79cddebef5cce74894c2b5d38f4cb36eb6cd20e614f5cd00e93ce93bbf3e1d87bf768d3e61701094d7c674c658e91d776ea6adcbd9686893a9d2255d3b2889f3a33e8af6e1ce7887ef91936dec02bc200665e143c5ccb882e02e76d86795fdc62568776dd4f079cf0b1eb63a52528bd61c3b8f15207cdfa192a30870de7cdbb219f57f778cfb6281ea8c34f030700bfc8787dac9cefbff01ab5be0c6734283ab55d06712311c974b40e423824159d9e9f453ea0cf55e07e339afdf2f9e4f6f39a2c5cf65b7ae42bf181d69257fb7c997f27d81fde54493a89fcaec61fa4f11d9a7e6d7d81b34fa1192075ed6fb2ac3a9fb74d9809f06d6d95bcfccdd9c9923a1ab5fa5b9ab7a5a34e645b421914c0590ad69b4bb6eacafd454f3efcbdae1ea768716a10360528796f1415837439ded00c5c9c1d127bb48c5523ef0f322ee458c902b6fac2baa7c7f4afef878680d6a7ec904100d3f6dd8c291bdf17c1240abc7a8e9462160f2fbc79def045a7631b4083e68caba93ebbf75f93b8b472fb8714753cda74c1ee6aa0452db653941e7c7160e7b74f2146e874bbcee14ba87f68ba4d057defc0cabba8486276e8e3452557d4d005a71453f34512da683548cc28a2c2528ad1581ae210ea15e1cd67edfc336c45a8b5c49f49908728d335504a2a2e10b37013b84f5c211b602e1d19c193e8802c8aa35cfaba12c3b7c64e11410290f6369ada5880447c0a3a9cae59d2fff1540cd037c3ebfa3bf4d89b8d50f8ff080e6ee0c7a6b5f21696314dd3e2851988915a93045be506d385899d16d1cc476cfa745e65957b2d33f4dab58ee794520950da09341ce157d1869594bcefe3bced77b440e308f6967c09646f57353941a6b72b04c55372fa6f0ed9a2eb01ead8f1ae096e25df0b25138ceb58c85d726eec96a15c6b965bfc8fc8536746bbbcbb179e0dcdb4ce1afac8e242f6f37716dd00fb697046c687105de616414dcda0cb80c00825bd808051daeb949d8bdb0af2f4804f9e90ccb932384b8ea73d6c01ee9407cc150f2d1933f76a35aef5baaa62ae58515d0042013aae10632a5ceb1ea1fdb83cd5e4a18661477e777422efcff931db462188ff8e59b4fbafca4d32174ddcd7255f8b83be97eddeb86b6c99cd4525021f0fd2ed2dda2a7ef9a25d93378c218eff9ccf3ea10bde3b878fd0219041d8d3ede30d3bc053bebd4b55b85cb56c52ec51f6625748d0827386277596651152521e5c4b247e2f89a5eda67002e4e1a66434b96f68233c02fbc4b7b9f89f072e2cef378035e106dfd95f87f67686e1ffa002505a529f47154a13f8a0f685c7d7d3a8d935920296fa431a17d559b70894da7845b701802972b74e8f640ed0a20eeaec593449d2d59e8eb7126234e43694e01ec8bef6cb9595453c7128fc05c76bb0132dcd0160bca289c6b1d7256664bb18a3db7bb7d862065c13e2bcae1c8ae1461db531eb855ff4e35ccd4673bf1488617b7f7190fa553a06cf37fb777181a6595f181f4724fda910c52c9eb4d1a48800bc77baab7ff9a2094f972877217e139dcb84d293248cff6b6528fa0696b31bded9b08c1a38c0797a836d54434b303c51e1b3fdf3f23f4b4b5972b82565600b74e02a19e7f53dee9b2f0c42d4e68da17cb1a984161a648f0c63d78945720ed35d3c58479a1e6d645cff1bb21424fcfae5cc64d62f4f7cb7d5570c10483b9b261bbeb899537f756490c3cdffb77875c7ae98c835b5d262de632bb12978f1a90f3587b837c914853da958ef79df46ff1ff99f711ce74478ba722d9e2204dda9b5febb3a160292e0dc0ff6d852c661f562dd3903e8b7ec5fb4bd866a21b1dddb8dd553b279dc61538a8dfed822a9224b7c3c13bc78bfaccc4d00447cba4c1587b261e26ef3233fc414614d217b053a56eb672ed5c30fe5b6efabe0b2ede71e7ccfac3702bcb634d6885939b614a85c164c5b629278dab355109f8e3254c9b4e55209089641b4c9b306fac90cbafe839eadc5bfd5604251d4b4465e22d267f3fe671edb5bfccf61522883ee2b428b14376c4f2e0ab83923154a9a101034eba1a08b88cad93ea556936800bb28922b268d3c5d410f2f7495ae55c523cb5be94d4c2df12487325c239ff14034912f962734c3c3c46f247ccc6e1aee7edcaa25cd3db04a5a3aa8b1a107b8f61e085608829e0b4198eaee968f3fd28b59669404d335dbc5b7bd346a785cdfc90da1c263dca380b41829c678309066b9e9cfc1909d6e57ae80cb285bea364ede58e7f636f2a64fcdd6ce82605c84d3ac51825e2ab0283e48cbef969d0476b8d11d59be46f2ae47432c12a4ef1d0aa61bc95e782e3dd5c5698e92654c93a8b3139c198564fedfb35b4c7c6bc13c464fa6c840c4cdeea0192bcd5b3d35ee9edeb13c4330e7ff317fa5ba4c833ab707d4da4947a582e184b18d0ccc75ecec50afa16c2f4ea4d37bb95a878e7b97227bbde3b22c7c39c568cc2bc4860205dec6774ed98b950a34bdd824a576a082146169dc80a0276ea5518fed79dd5621cd0efd0af5078b7a4286160e0c480e80ca216970e6cfe1f23091dd894d392801586d3de8bd2ada31454bf0bba622879c4c66eca30220c3172d2c153e4b45e80cb3b93c0a39c12351fc1eb6dbe95a7714b4cc36f6e89997ca5c7203b9f6a1c48952064bdc9222f430eca1c165cb2fcdbb57b405289daa85c05344a0f9cd6d0a6a344aa10d3a786e49421bcf03180893e4e49bf1795840fe98d533fb89dbf5b753df63f2347b613a5348d1c1eb2a2843334a5910632bdfd106c07d1e650fc12bf4b184917f00ed4757a4720bc54d69f8b3c73bc36beff8344af40733223b2e2cdfd33a235f039ce8a50edff674c8b2b90df06db8c9497870d11423aaaf511a55e4bf6da1eed407235e23ab067397ea8bddf572dabbb81947044293e0e4510d406ed464f4316dd412b813404771473d55154ae38afd0b7efb76f8f48ef786760e47abd070db0e1d92ff1acf5cbfcbbe7935db8a962d07a3f67f10824b6e2e92031403fe3dacb533abbc22669db5f5661353d59916b11e969b6edf8629fc331758cbd95f7b38bab1fdaf31268948c07973349e9ddf741a339e90224b12562831589af0df897f7f053cd99e633b4b3f764116dd432aab7979da8a74e679a85daa5ce4b02f7c038195393926af4649de0fac629d886ab6353ee6e40c713028bae251eab3a1b8a68ae6febf10b839c2f4beb2b68a700cdf3cc36ac7a02630789950b197d80ddf3e7d1f36ef7dd99ab2c6a496f141500fd1bdefa2c55e6d8c980438ae5046d6e72065520c24477bee5a20f3582e662a47561a93b6f8e66e267e39921b1b4a07c65f110e608d1b2696e8b7aaf745780d5aeb4df02370a71aaef40142eb351b9781d2e4186b752ba5f556193e95d3733e938ff105276ba2342a9f7c27a2e4a8fcce5922fd2c575bf55986342738aa74a827a6783e49ea4ad6f30bf886bedba1d570240c95cde80a08b85d923c247a9bfb521e6770d2993b0ee848cf0063c3ca02b6da68526516e6e2c896c3386884bc55840f8425fdd19417057368da2e4a279fa82ef2d63ddf0f5dd4d74234e158879f36c1c356de1e8d1107a7f2f0b6f9ab496182d232766a2ba55ab280bc2ec9142c7345c453867d2d1f0815953376464d84cad8b4a2368d23e4af9fa9c5a890bfb40705c95169de941efd1b253ad4e4af8a32425397b640f7eab323389f42d4ec567fdcfc0705cac2729a172786580b7874bd478f544dcb5c382dbd3b9ab589679eb74240e0b04efb62dd3ca654f1c71d522a29ffcea7824df4f48b87976174d0b2a7d76dc4e8a2b13ec22f40f64cf46490b5242cb56b53eb67fc76b2013b897fdd2bd528326e490f2f5b6d05f2486f813adc40fca830440570564089ef0b92683615bfea311025d835a79577291144a13a28b060c6029dae7ce58bb5aa4c43455e6a70c01f26b4fb886698483df56ab558cba48f0b16dd264c23db9eaebe84ff11a1d63b6183f1720887489e47a3df37d7145fa19b24e986704a370b31efd70c6b08bb8a932a9139b33a8bab759d2914b6a92e9a6aaad6dd8f5c7d5814c5eeec800e9d738ad931aaf92363f5b743b5772c5281f6b817fbdb0ea95a22c43a134b19adbdad168081d7e0a4f1ddfc9ba9a557809080e3b47a6c8a0a46e9f162d9cd7adfc66cf2bf6ed0d063eb7d7bd579b3414d551bc6bc6ab05b4577584ba829f509c2b6fb90ffe7f7d566b38d1c2e54d9781525ed51dac9a4ac1a7fa017985da26d7ac84abd1de0413b8ce8262adaef3ab26a01957518b72598b20b23e08af6949b94c0f53c0fc7d4618969dc9de377f472fb00e7fd886295cedfde3c879a7770c74fbd48d429ba0b3c76f365dd3eea5e970ab316104a9cc8bc191025077f9110a3c454d11863678e869884f460bc933673648dfe1917d3e7c9d722bc032a85c48c1e25c8c545a6593b1822e15fe33c1b7f24ea63b7335453d3c06418e7ce594650a2b42a6a97d75375adbdd183d513d8a5cfd5efa4a0e4d539db0798b0783667fa46e14a325f617cc35daaedb2dca2709e1ddc2e2124a51d0caeecddc51bada4b64cb621132b884e62d13e3e92326e25362b35377ffc804853e69a3e939dc7f68aa04de11e940e7a1e2e15851310653b62a8cef6a60e7f6e5540f526b39fd305e0d36b871e5c585612a07bb830c4f09c750eaecb5de34d3e3af616c0c116a2047e34552690216927b076cab6ebcc6483c69a127448786925f04a3c6615622059d0675cc40f4ce8c0e27b435ce8d866e58c9b084223f0b04a09a4b2f9cffa38cae2a8bd769cfd60e606c88b4642fae0e736c785ca8174a41b52af0b9682e5a9ffe0ce7c31c856271148b0a755becf9026515a9c3a5c69224dead5448a10f404e0584e4a9b687e341d89f4708aaa6c489018c973334d2309269569c46b7bea5737fa8ce70d48bc93b5bce23d4ccf4b897013c09185978133e84b291260090d1752fff96e3dcdbb710f6bb8c2049013d9fc1c4db4ceabf418ffb68790d2a85d4ac0adbf502ada167d1d3a7f9cec73817e7ab253854920097e1fda960d36cb150560ebf7a842382dbaf70ff76043f7527f0a1b33538f1963dbbffbbe913f6f6d292a11470b964dee6b7ed608e80fc8d1bfda17ce048ea7d0d4ca0d9aac6e16442ce17a5676f682d45280e57ea54783c937eb5a86fbeba858bf284166d7e032bc3153313ff80af3bd7dfd8328f4cbfcd9d247aba97ec653a86c941dce80954d8589a0df90e4a5028ae7ff23924a41a193a40fce24d2b530d947db56847e5934834f4d3359455e35b517b499f2a0b0d5ddfabbee3f5458490b815d0678481cc986f20f42689f50010b9a838ca67cf0f6dbc93ca018158ada3216931e7ed4d681a5250c6d6b803d26e40f5ac643c7d4a68b865d976c7b128f8a558a3c2f4b380ff815fd06240d59e6f58019f2460e3eb0e06c88f05f839fadde953d21d2de75274e5b9c1c5f86b8ae03526b39b8573e976da1cbda308c92292df4fbba8edd996ca4436525caac51829d026d6d6b6f61ec990dc0999628acd45077c12495805516866723a39dd57b25ffaad3e12fd88847c489f029888f3607f43fbd2bb4d27c86e90e1c54bdd04cf0202ad2c92c58ed0eb83003dd36b932cb13cd760ed5b14d492811c33fb235bc861996deac8e4374459e5129fdaed27bd31797866a09a8e11202e7551d7f0c3b5d47bdfdfb183b875ab3d18ad2bb4c2c4619cad043be7f3969ee7052fd2a5c74e9af6fe38dbca62e6c6528574ad8c83237d8ad42e332e901f2a80d0322765a71d6ea9ae5454ac0d30585002866afbadcd082ba28669f2c8de4368477aac6a417441554f43b469487ef216a426de69631d14c5bcdb82fc0b793b30ab721607a9b492fd654e4ddff11af76cc5a4fc135b514eafb9638ee36d8d5a64929efccc3441cacc59571ad99cdb988f147b24161fdaef1e9d5eef2f933a4dd35a80adcd8c2adcac1394a1442428d455962ade96765f53308d1c97744075c13ace6d7a70e7a88f6bb461621f39bd0c10e690e3cfd9b95b70fe4b0befd341dd9674b96696c8b9ad38704b4248c54ee41df3ca38aeaea8b6455df94498c2b6904d44e0d9a7dc32b3ccfc1b19d1a219b90275ca746176f5735f497def36bae556613d216c16273c99257e5b89e76c969be0208ceed0627977a99b59d3d0d2fe580e7e8252117845ac251148f8c88e466f30d581316b5a5ed930b9e158047ae3891d60d6685518726e2c1210e8570355cc84bdd93bb74113a884eea167cb54bf95e158c19f97ab0fb1970134916473c981c16de2029c1b6e8abbfad551f246c1e5e7818aecc2b9d81df17d0bb81aafbbd3e905dff8c3ba4abd896894f36e6d151cd82d9b5b8a45dcf79758aadce83edb15e3b66566094cfe3b67beb5948ac673dea06d3e58df486ed4a2490e05d9d27c1831f4bf7cd75bc01ecc07c33875c56e799921e7ceb744359540ae6cd830ca888999d68fcdf5d93e13248808fdf16c4b7c64e137b3077a6cba6ddbab4b7617bb423d249814290282f7cf3b09d80b980ad998953712095dfe7886f75fe2dd2023965afea0594c2c833c4e0afc2145641ff19fe7b87b2da6fc3175bab140d93d2a4676913f59e179cc089f79ffd23a3a2343ab579080341f590563197a92e207e927ae8e79b34882413a885f33992648f28a1c11b1f9f3fd7f1625f101c6f5147d65a6167b3012f4dce1d4f745a19d06e76ec1343fc5475fad95b11da45fc2e38e9d9c60900430fa2e30a57ef1cb9d3bd9f9fd37a9af7c46debe8fe616cd196852133843f014b71cfeec85c84f65b310c47510ce873b32b1e87150eb5a0ca38fd0ea25ee6e52b2a88da4cf93666e3946ef89ce6a47555abcbcfc3d072c70b49a93629b0e063723a1ff2b8fe001c266ee1a5f8be281d9768adee91663fe5b37ab089332ee7845219abe209b0a5f4c0ff531c56cc0e0f482c8123fb1d8b51af209c98319317f588f880281be030795c2634a9f7240846fd8d4eee34ed9f01ab59ae4eb364f55579e6436cc24d4231f86219eff6b70e4d9ec7eacbf13d7d38e4e89fb67164f2bc88e30963f7c45fb0ace8678a80539c2752c16e1160b83eb7f286afe32a5b08b2ef071d5a47264f5884421abd7a69f41d2513d7595b7dd6dc8994ce131b10b5883484fc7bdf0c40760af11638f264446c06f1c7c133be6f1998e3a4f37ed351f7181a53eb2c8fe4fbc6ccf1cb27c6aab8cef3e1d75e7ce2556e521f3967d1028c0a5de88eb2438259b1c96284cecf84b871153aba77e7384221116daa9840060730aceda8c74b06d7924f6b03534071cbb79f83599c983fd46fedd94ef10eafee6066b6878675dd4c456c975376c645a38e87d65ed4490cdb6af153749bd5de6414e7030bd9105708d72bd2bd6291f0553b17d034af1996d0ed77b22ac6a3af10eba10c76180a157d3f32d80f099202c5137f5ae4ecf9dfb7d900d3f57d736a4278568afd47ae3c4a18a33dcaf84f3ef9efbd532a1670f14ecca9b3f35226154832a782ef229e8ce39bedbd34adeab5fa3344033f09431ed22550dd810a301beea1593220617f1955353b92c3f78347404fe9867f3bae68155270cfda33e4d6de2d3c61082bb7975cca72b1d664263672035355735ced61ac45c1f8333cd560b26c5926eeeddca4eda4c5a75c4c101276dbc0f4788a7a1ed777033c2347bebbd74a31f6d3023ccded3af79581c9e8f7d40a883d20dbfb260debf0a4ff6043344cd25321ad586354e368f4c952efa3b7bffb6a01bf7987858aeb0cca6fbcd3fd8784fa3ab765b5c77aee718db9442a61f0411d3c1b2ad02c277f5f516b234da0df2977fb532629ddc28d6a643b1c8159eddd2e1f6f2aa837b26058ce1a2b43749ab6e4b5e9b071ada5e30bbc0ce726926a113be307022d7e0c0ad0f6ea9041823e6001bb567c03475112bd2cdba36bedf70abc48dbd8ca74105bf545dc1880976518aa3e653bb307fc4222e561b63c9a1db0fae',
        salt = '47cbfbd44d8efa0a980f7286458c3bd6',
        labelError = 'Bad password!',
        isRememberEnabled = false,
        rememberDurationInDays = 0; // 0 means forever

    // constants
    const rememberPassphraseKey = 'staticrypt_passphrase',
        rememberExpirationKey = 'staticrypt_expiration';

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param  hashedPassphrase
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassphrase) {
        const result = await decode(encryptedMsg, hashedPassphrase, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        document.write(plainHTML);
        document.close();
        return true;
    }

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        localStorage.removeItem(rememberPassphraseKey);
        localStorage.removeItem(rememberExpirationKey);
    }

    /**
     * Clear storage if we are logging out
     *
     * @returns  - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        if (!isRememberEnabled) {
            return false;
        }

        // show the remember me checkbox
        document.getElementById('staticrypt-remember-label').classList.remove('hidden');

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassphrase = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassphrase) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPassphraseQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPassphraseFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassphrase = hashedPassphraseFragment || hashedPassphraseQuery;

        if (hashedPassphrase) {
            return decryptAndReplaceHtml(hashedPassphrase);
        }

        return false;
    }

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        let hasDecrypted = await decryptOnLoadFromUrl();

        if (!hasDecrypted) {
            hasDecrypted = await decryptOnLoadFromRememberMe();
        }

        // if we didn't decrypt anything, show the password prompt. Otherwise the content has already been replaced, no
        // need to do anything
        if (!hasDecrypted) {
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const passphrase = document.getElementById('staticrypt-password').value,
            shouldRememberPassphrase = document.getElementById('staticrypt-remember').checked;

        // decrypt and replace the whole page
        const hashedPassphrase = await cryptoEngine.hashPassphrase(passphrase, salt);
        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

        if (isDecryptionSuccessful) {
            // remember the hashedPassphrase and set its expiration if necessary
            if (isRememberEnabled && shouldRememberPassphrase) {
                window.localStorage.setItem(rememberPassphraseKey, hashedPassphrase);

                // set the expiration if the duration isn't 0 (meaning no expiration)
                if (rememberDurationInDays > 0) {
                    window.localStorage.setItem(
                        rememberExpirationKey,
                        (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                    );
                }
            }
        } else {
            alert(labelError);
        }
    });
</script>
</body>
</html>
