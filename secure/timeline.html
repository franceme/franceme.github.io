<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #4CAF50;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #43A047;
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #76b852; /* fallback for old browsers */
            background: -webkit-linear-gradient(right, #76b852, #8DC26F);
            background: -moz-linear-gradient(right, #76b852, #8DC26F);
            background: -o-linear-gradient(right, #76b852, #8DC26F);
            background: linear-gradient(to left, #76b852, #8DC26F);
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>




<script>
    // do not remove this comment, it is used to detect the version of the script
    // STATICRYPT_VERSION: async

    const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 *
 * Mirrors the API of CryptoJS.enc.Hex
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassphrase) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassphrase
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassphrase) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassphrase(passphrase, salt) {
    // we hash the passphrase in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassphrase = await hashLegacyRound(passphrase, salt);

    hashedPassphrase = await hashSecondRound(hashedPassphrase, salt);

    return hashThirdRound(hashedPassphrase, salt);
}
exports.hashPassphrase = hashPassphrase;

/**
 * This hashes the passphrase with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(passphrase, salt) {
    return pbkdf2(passphrase, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(passphrase, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(passphrase),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassphrase, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
    const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassphrase = await cryptoEngine.hashPassphrase(password, salt);


    const encrypted = await cryptoEngine.encrypt(msg, hashedPassphrase);
    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassphrase, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassphrase
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassphrase
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassphrase,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassphrase = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassphrase, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassphrase = originalPassphrase || hashedPassphrase;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassphrase = await cryptoEngine.hashThirdRound(originalPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassphrase = await cryptoEngine.hashSecondRound(originalPassphrase, salt);
        updatedHashedPassphrase = await cryptoEngine.hashThirdRound(updatedHashedPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassphrase),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
    const decode = codec.init(cryptoEngine).decode;

    // variables to be filled when generating the file
    const encryptedMsg = '40ed0316258f8935da35e6036f672ad4856f2479bb6684095000ea5a6a716fe616ddf6c42e3a08142fea573c9d41ca547743dcc4fa97d2b05cf64d7a10ecdb6d56827214d973ad9f13b457b565ad2d85be67a7b6d602debdb34f5c6e215bdebb069549e1e6455e5a4844f37b2218918387d1236a73bb8122894191bf4941508f5b0cf62d8e4e3232b24a691df4fb61189de19755c5a031c229ef1ec89c9db6c2f36daacc0b4dec779ec69fd043d8120c9ba573dc62a344559ba9213228ea11e490dc3282ec538be3f998610493cb2441bf950232302d4507345d206ca76ebd089d7d19cd38216e43a1d34427315c6c02ef625f2356656981f392a9bc3f4246e2feaa88aa06d7ae1251ce318dd52949c829a55a8b3e9133ed84ac49f7e21a4495a35be678caa0fa218eb4c85786dd01d61e42ab15cbd40311fa63b4a5a5282bf5f1f8b51f913b0003b83b479d1593e195c8abac0cc24eecf21ee678b58e6f3ff58c0413eb73fd8ff256ae9c2d5e37a70dd9009f28524b6df7dad8b2418ebdf0d85ffe255aae20fbc2b8a4a767bba2c64126cc2f31f3c6652cd19fb4127042befe96a54d16b99b35df9bc084e38e024f4102bd11e2c21a42e85062f585af7cfdd49547a8fdef05e82bad88fdaddeb624ed659d0521db8cb7bbbb8c0e0041ef26425ab6dbd1f82a67c439518ed71aad41c526b3fcce06df8ffc23becafd711a618b5e51fe8d17202a7756e57e9c992826e964cdd2625b386fafba68faf1462aa8a8f3fae7d8bcb3dcd1f5768e62ffc5657c1d245dbbcc9b34ef07f563d5b5d8a96c8a258b43827d9f55be328a47ea5127d922592e82bc6407a0f92c469a4d2012816f3f9c14d509d2b3a021fe462e5200399fa4b366fd6d38f6043119817337025e748530e65c56445b5455f938d67e248aa76e9dc82688e35f9d50263dbb6955956eee8bcd10aa86d4b515db4a4face0161fa822113b384faa04afa37c929fc73cbce59000f3d999df2846c783e2f5c69ad6b00ee70e34d66121d2b5b9607e063e48de013cb45b90ec3ab5117624b181f9909b11420df36df09ec5cc8cf80e96d37beb5040ad9df9161416bdfc22472539ad9053855df9f3af497c1e9f7d758e7d7b37e75866ceb4c562f577302c0f1a373fc0c2000caf55115e80b6284495ea28469970c83dbe19c9831d91b88ee0220e1fb32085bc509ee33deac9e4693ba21734b2c0863cfe4da35031e9f6f476159f19d5349380ad4ad9ce2d0f8213e14809937cdbba93a3c55eb014358ce740fc0b36999215e82d596c01ef5e055cc11531308c6be251615747fd4cad69fa604abe25601469e1ec5fef650f119f6dd2d1a0352f508b1095937071c7f1f0008ff05aa9dbc82d0c8a7790da93acf6cf7b545742914671c22d919da1ae11a84ae34699569bb6821689fbb59c6e9efdfe4b2b632dd4474f890e1c7ac32d00f325c542203557525da870873de3ac7db10ecf3dcede8ca59e1d177f97ab6861513dcf1dc76009722207512e9349dffddd75ce2f2b9ffb4e4bbe1c11b4ab88a29b0ed81dd98b395b942b355d9e3852a76a1ee7f7a28cc8e543f42ceda9d4d0bdbe281d99bb1696a44c63440ab4b1bf5e307edba57dff849a2e6655248ee67ea2e04d5ac8a0f91edf6fc22b64eb68dd272cc8c4c12bf74731ed7fc788fa1c12360f45080429daf64726a1cb77d1022c0741a897a6c9aa8ecb5c73d72014a535847dcc7c46da1b3b794948f668d59dbde210d8ace84316731628b3ec3712a0fae8671cf274708feac9cd6ccac0a5aed2ba4396cd8d31500683db3009f485ec719a4ac623112c193e4fa568cf7a5070e895cabd366ffdffd0ea34c7ba60e6671606ec2530f9378877b5600178226dd1728bc5e7b60c948396b133491513e57025e02492cef7d3b8bdf06569d83c6c2f1c0854f0dab6de36105ab13a6bceb9a17027188ba4ec85f283bfd94656cd7a376bf427c539d34234fad39d08adf2a4627a8b7f36dde982c81f837563acbac2fcce21e1f833561fb9624efba03226c67cba9883d31c1725a96aa03b925af0e2dfdf9f2052012430440332bb4c0124f412f4530d1365c6c3b00e388cb5e279992a5b0d150570b49b8ae610f7820866a52a3bbddb8760197b17fec85217f29e799394628364c1d12b2a1f3f272f0fe01d11a4aa1dda5ea2369302a3443ff9219e6fe41e611f7bd49853872485f1468bd5f6a715a100fcad419fb7e3db52fff8d049ff212ed246a4399fedbc24cd4cae5eefe8cac5fbd785fd949530e6a67d5b62639bc009a85980c00f461d42ed43e106dc910076c9f9a830db8507f066a869a01c793d75dd31964746e5352991b63b42b98a7f6333e9e936c2afd8dc878f972d23dffea504b4bd6b7b263b70fbefde8b3a15eb73e9f1c4565ad393256cd677eb2b01638cf82f0ef0509ce59a131aab81a451b4eda068c5b3baaf423ad58a29a0d6bdecc2b5ad6b25704cf89cbfea5da85d6d2cc699bd84d5531ede5a632c9519960b267b125f0aaaf699297a7be8607521a47764e51d329414fa14277734dc2e33962a06f57fa353f2d9263368505f90edefabc53b27b20a9cc3d0be75c6e60e2e0360520b13829bd3af75cbcb203c2db340713a90090586773d12183999e13bda5d8e49c101025109117a63637a344d4fde2a186be3dc6ba1dd63f1902397e292deda0e13433ac48a47a89c4426960b4eec9caed354beb05b817972256c83ac11a84970752460683afa860a2178ae6623d1f17b5df39b0b6231baede4e3fdefa386e8c7e3403868e7edc8417f76991792bc40faf35753d75045237e69e4b7177561dbb2ce0e333092bc50bad4245b23b61cc7cedc9fcae1e304faf7f2f066e4afbb15505baab330caa567564cb39d2dadef661feee40e226a50aec9cbc4732bfa3fe53818f3c8ea24eea040753866de96c3cafb1f626d57727141467111cb8f82ddb4c25bebd6c8072c6ddea34bd3b1f28661dca514295802dcced70c83150b610e8e059dc25ac91420a662915f7d6b67f12ec58fb65369eab53d6599c6cbf6ff3c1d4fc1aa20ec8b39f74320dc69024ba84ab0a97ce8e0179af039fcc478b12a6ab9a566ee5cd89934b0cdc0cba013f88dc8a6a0764df417b787e2046e6ec9378a1519d49f5d6fca8fe5f4b90641efb57ecb9a64f7c435c523a40f9d9ffb5121951fd87629963f384af072a4ee078ca1ff50fe7097cdfba10f946d71afb37a8c305245dadf87dc7b3e3f11910801c8d01fad8f44bf7f885b3e9f976714d200b293f8b3795f7c53641a94891876082440d6fbe15991b9d6dddf79494a4c7f731d9b3b08e37aec4b3bcbe287797f5916f28326b4fe54cb2d2bc631a9417a685ccb19366615aa7737216451b0591f984c4ed2662a6758c1b710bbf4915863db059e577fb5cd4103850be399c1abe8921372a522b2b8e739f7e56070c6fd4e0305218182f90471323bf1724002b253e5b9a808e7a344e5d90497435c1204f001bb67eba494ac395c88849909695c32ae8bfa58a19363e428929763486b73b9e732c68d8fc317d151f43e6cd8cc123b96b691083bb9e1228611168905c7f5210f80b4fc96eb2a41b9903fb0e4da271d37db4a5d24df361a2676f1bbb6425dc43ce1fd24d29a313ed0a1e7a11948e699747c94e5cc80525828411441ff08c5143ac8515f86dba57ce2bb02baa18b3e14102f2ef896c8a1be750d28a694610427491ba0c68d81222301f99adc9b42ed2424085ef51ccb26aae5f77b6ee868c0a922805f9d30360438ccad11ac1cb1f66253b9f088070a1342dd1a75ca0956652ce23fe2007a8176d82ab1c2dff50002319435d2d46706d4c42bad7004fde0e9f79278d52eaf9e1bd70d7b238ac3aeaf248c2bc187cf4f6a714599cb0a109e60587bd9948798e6a71b868a2700c26b1a4772c09e4585aff598895efc6b8422ebef64a25e73cea55e939e32d2f5a23c8cebbbd25d196cb3c22883dae499a6071971ecad8b0c4e8085b624a79d41310fe10c6117d148ce13a98695b06c792880f20657ccedf728702296b9909ce091b0126b20d12c7c59595837292844321f90f1bb8145eba9f1a1ccfd4cf4815681a3fd91c672e7cfffc24f6a5531f85c832bb700ad26ec79a80adadffc134f2aa7baa570513fd2df82768f548cf0aa33599d1119e5374a3130070f7fa43f69cf788a5da57db384a79f065af9f77459134ee30fd3e86afbbe3a521e19b971a8447659db4ce207b8add6d907da15647df4be4b70efb11ebe8c8a8c7718f25d8a0535ccdef4a757403639645c2bb63ac61fba65460020953563265d6319758d916d9d4f370dbcc3ca4da848bbf372075046759e92134ca10fdf8285a647bc89810b309d07e23cd7933a54ab68529f7dfeb81ead335479dab15e3642192bde0f88a0425754168f1e505d452110e43d22dc454f3bc710a39726c8a43228e7666bbab5d19c8a8100e695435118ca43cb3e2e52255ba6fa705dee1558ad12d31a0d443d014b934de52e84f11c3f74d51c08fbbdd0c4959329c37d45295aef983d3f5ab1bafaf434c2f3110f242e0e2457934fd1f671b2b53ec5bf986663be24039103bcf1cd8c6a0c8bb391f3e1da8571a015b1fa9e31b2f6625383216a353bdec34ff0b32963726605dcb7a75e301868cf88754f63194d9d2e45888d85767f00373e90379b2b3a3d35dc1af3cb4240b8b2f95d2ea0c94e40e6890d1a1fa988dae6b4fdd2b2ec478e877e4d71a2e0b776a39d443e993a7b7ac18e207967e8a4207dc54a084bc47f20001bf940ece70f0e83e662d78ef908125bde4d93a3c75cee05fd7d0e87a3dbe73688b618f8d2a669180b5717e2f1c1e851e309ed3db735090a08fc3f21f2982dad3cff8ced4687e2226d0e4e0a7c3882342671d44a90fdf1e64bf205a72af8ac76d33fddbeb019cc889bc1c3ecaff15e96748210e8ba41a3b4b216fcd73bcec86870eb83c777cb6f53d0242efd84e6bb599a7354adea8240bdcf2edda236ba1bd05f14e4706b2891f870a2599149175d091aa8cb7af36cbd97bc267752ad156c127e4eba27e13a0e42dcb0db9e4175249f3bde9d3348521b84ab645306970b33be41e66c56fa2ba322a6d47ae3cdca1b16b319059fd5337a686171ace800ad869dfa87e49522f486898da2bcef047accf85e949f9a5ea54bcbde7362114fff4a177977d835db37f46aa5c3cb665d0b230753684d6ba38765d06ce057a8bcec8dba45ef0ae4b58b14304cc08f966a9c3ebe66109043ae6601db2fcaa68266d0b6406471c8a148a25feba236dc3ecc901c0f9cda5dcb2c127ae28bbbf8cde349de04b93fc9ca46081fdf15e38b2af7ab1d9f3539d4c89fc7165504d0496c74ac94a5548fd4020f1cf9ad6b114c174b02514f02c7e868efac144bb8e3cd80577ea00b509e511795c24f50dda3f38b0fc8eeab038f0c1de11cf02131b0513cc93db3560761c0966dec332cd9ef560d8c9ce73535dbab70c76bd1f1f59386104343a649f10c70314fd596885d0a46033affa3dbbebdae39b039a021a6ba5d423e1c09caaf9d0d0a4c69b22cc98e91525a85691a8a034eee2ce60d7b243659ff6851711376c4808b8901a16bf05128b097522edac75db18bdf032b32e87d5938555e6801253f81ddc23ee4062c9c4ba3a14a7259090af4111020012f6b5e9c84239cac7a6fd27d018773b89ca4f1c1cce5bb6c15fefe75d60336f66ff180576d19503447d1d54f3d90e7c07f55252c68330becf103d37eda9aa32ff1a2cfc4a18363021474967dd6a6da8a740d26cc719e97a88d462139b7ec83b2de3c1e3849888207d3e472dff078f791988fea00208911058a049859257ce4b10d42d11339558bc5bbb9475eabf7abf83d5a098fcfc3683149de57a1148eec70f9941e8be52ce88d38448e3bac944a7025064a21fb7a0696347f1a088f80a99987cf9bfd78f3399427c07d3d300df7f107ffc18c10709d1d526efb7712ee2aa13627e851ef92e270b7c8ef975c7ee6381bb6d2458ef2805cedb6427586370a4252d8159e1e82d0e1bab89619f8a30952b11e12f794f48bf030dd5344474fbe0539c49f746b9d0a7a9155325a1852fdef3edd7273707a5841bff56f5f8113e991a143920277fd21e891f9ec4d25f12a68f29050608b910271c7890abefcd9b63597464599530444d59d3d9a5a39883e711215350e045df3431e88ebb22dbabbf876740dfc0c6d8ece970364d6e72afd2a927d32db8becb8b5ec1b5ca5a7c0a8b87418a3e1527480badc2fa4c64bdfc6456a8945516785aeec88e058cf79c4f34c42e9a331eecaedc9c9b8c435b46ed717781a8b864589a81cd433496924057afb993b414941cf953b8d2aedef93770e56779a60ba28caa0c288c94483d581bb4da2e9dc0b05590e1ac0f76ae8c84ec5aaeb494417c538e26409e274951efa6b596e17c8360e4d2ec77d91536f871581cc711f413ae0ef908ecb7cff8e267b39a2dd2183c03847a2ea86e0d50fcc76d535819096e7ede624db0aedc81742390976c6e4ef451ca4bd722af6cf234dff9dca3652ba477ab1323fa5c5cfddee0a1fb85c8cb96be424d0f0306846f4d98a3cb056cb3a0e578aa06b672010598862d7ef869469e8b8732928ba8c471dd97cbd257ceda4c902aa7068b29758e131614026b20f161c04c7e8c54612051b7b480077c5cf9956268e9b042e97b1125ab1a63a92325b7690c196a483a97e71bca49734eefff9198d8cd34a43c0e230a96f0f0acac45db16c9e85fc29b209fbaab089cb3e3da3ae9cf460f63f29ae057e59f08d1abf09679c68ac3b45d8bc26c2b77d7324fd45f470c58c4d8bbdb0d2f30db4f1e9a58d8ec7983f04815eb0423d9507b0dac46c2b417b58406b85a57e256e12594f37f0859521e4c6b5b12b1001a51a454f4587b300685648441a64d3c977343be9e89e0e56c22294a67c55f55b729dc22775e072e782bb8a3c8ab79283bfa858984a337f9bf03977dff7abec9c1ede9e19e1ab1e0350c70d312706f7016e708aff3c66379b927a65d3110ed500a8ceb00d130259c164c88c1de4d1eee2f33c265c9fa4b525569c5ffe8cc053c8db2ed74f73f692fb8496c4a978f918c54b47d2598d56e3ffb97c00b4eccb1b302021ebc8fc87e58b326ee0ddee808f64b14e9ffde44c04c16301d62aa3d6e5e70bc54d645b4d17839782babf7dccf1aed43f25cacc6d0a08e74a1144352e5f86d4dc17140b634f57faec4fda1906e5f3a6f10c23bcc67ce261ec17ccdfebf53c0fa94eb81befa779e74eb08cd0d91cd85dcfd3ca84910d223bcc5fd930d2511e03353bc5530081293acc5c3ab6b697ed4c5352eed57de673e7a9cdc4e4f21c6e6d80830b06475aefa53431808fe02d791e5f46a45a5010d171c749b9a606a642c69c9e474ff3fd5304f7a4de5406defcfc6a7a366f28f4f9809c96e454141dac4b75ef378cd8ebbcd648f90a727f75d86625ad20af88c726523252b2a90315f0fccc0d93dac7b217e8e1df265a6bd0537d6e34f02ca7570f164750343c6ca7f22fc42a8ce251f3a4eab6c190f31f4456e10cfca1855b1a9f8807f755597f772bd47e05608fde2d14658b52f18ebd6ef25f533e6d0c8ffc852c7434c1c2ab20330e2744f24310b2f8080d8b2ad22f8a8be61178c2bf60a56989ba03090332d456565798d32a4fa3ce0577e02c355e5b83e163ddb675a5ff2b1779058d40ed43776def19a2d5a2fed60d3af1922e2e5896be2024e690835ab017fab7ce78e0bb6680ec388a7f88be1eae763b8e1eaa64c00a25fbc02423c59152731add1b291325add91671e874f6d5dfe3261b88af05c070c909945354974f0923bfce77cce563e1f33b4570552a9387409776588da0ff50985dba3c1a860fbd9fede8d0f7a74a76b5e3d29cdbfb0278c7dbf49a0a7fb0336500b0eac47caecf4f9d616b935b2c17ea8718ef56a0798d8e3c98070e6469743d60144f11e20e32236d126c95625b415a71eb16ac49c89a69c97cb50f89af46f45591915daced302e744dabf3e0aae1cc0715dd40172b3189902cc14cec4f5b829bdd8bbe352faebcaac771376e8bfa200b0049599c77199b9af9ab87ae1ac602ac68282fc08daa7aeca7d7da3d3ec9bdbd824267cea199ae5aa237f93c9186f965ffad4b8e6425c29ae70deb68cb71cd7a9819f89f2cfa57bab3b3668d9af461ea83f185f85dbca4d44e8831a35db4805024fa91ee11cdd2bdc5167aabd30df8e9742c251045fec13c616ae544901ca94a5474282d571be005676f1eb2b24bd2961c14071f56f894c11368e79f748f42f58fa0cf9884aacd0f9e2080d7c30efd1153b9a363a241b7e72dc57338e89f6407c7f86ec7346df83098b08ca9323b3862e0ef1c1c5828c3edb31959c1e11ce81ebab4e4e21da49b711a70bd184a75900cac655ef507a75b3ff374b113bfc8bc62fdcc335d0b36608fd9af936a9615a99b605da05f411e892edd7a1a331e8d1888ba5161a788f30a2006adaa7b5e0471858a99ceb295de8c66e46ca9a54642ba04a304852f169b3c09348481d96c9db57829122e24156f8617b30ae6f6ed59593d9a99ed7d7211ff1b368d4b2bef76c717c1c3418d806a37a86a5e3eecd4de95f07bed6eafb5aedc6e04ddda82870496f4d3807fd0003a4cd171f6ffc66607b38ae9266e54b91311b57d8c6c01c20e8f87a773a893a17079f9d6e85946f63a524ee9eb2f8d3e8ed70d7253de92a384d04fc90a297d01af8a50cc03c652e863bf5048ab558de9762f0690c8639fec9829a246cd50b789d4d89cecb07a0680aae917485a577e1a3ad353094cb7a0be1c87e57014618a4d78f30c68bd4292e5b43faea9ed106031ff7edd1a3d9283eb441c2e1cbb273e17e3893f335cfa447f45f6d3e5ba375981171db85d2d983788bb2eee407b198b3dea562768fffff18a658527b10a1f0fd407efe16c4a1b356cbede8acf8f95f241ada3b882c0dbfa472e0976a692460b8fa24bed49c7c7c525fd797ce14cd2a3ccd34112d0d2e9b579f369154f1c7e60cace4305528a5841eb64bd9465c710000277a5be133602aa443eeaea0765c0b0cfa4d9d6ec1ade4f8d62e530971334bdee452bd53bec679785271db5902bf9e17338ea38773968d4abfa42b66bc8ca721de6c18f8a5e2049e0e9c7155af3025135206a3485392d10f58082d3238b6e175b6c51465becc603cfcf42844609574b0e3d45b4f143e10130894d3e28afc5c3500db620fff518a8f0aa32df1daf23f00c0fc748f39f755986da28b8f4a36a7a64bcf6a6689d2556f5b0900626932d9935b0a9c27e20f9f3c501988840b415fe5ae537af34174bc9a51a41a969c7dc5ed0667c74208f1e6812202bf2cf26fa03f864c017e4e281a06dd201df2717faf87b822bf4972bc84b7c26c2fe3c54473c2d365ccc298c7eb89a49dff7e3a4b11f28e2228dd1d090d5c9574d5e6168ec89318cd49a73ce197209178d3eb11682d7e8d60f13778acc9452a98d73a65eec13905c4ecb12c076dd32e9c259f00dd3dad9c1083971801a356f9bdf3393ac88f783f31748385c17c94a747f64ea1dd51c6bd7142c303dd7b6efd2e299e0ba61ce450fc178a61cfc767d8a6cb6f9d5ac3a879916cd54965b6644032efc47eb623497fcd9497acd1fe0758f113baf93eaa717971a4ea3dea24185a7e83f551e4fb403670ee39fc0b4f2b4495d7bb7afc5616bd14c2b632e17a83598bb5e8f12e347af38066e83b0dee88ffa5edd508fe77b63c9c7db53135dd616164795ec38cca554dbb9ed676d7d16dfdeb7a202a62fed22561f4147c189ab059bd5cfdd13d827ec572f587619085eb2f793ebf9c8c57a8fc2e65d42590a32f58f3762ff915018047b8a816aa4794a6cc9470334f367a9e6ad33446cfe4fde5f3b8365b14713a608213ca4bf9096c450d801c176a3539820235a107f0e4638048c721cb2b05184833317027c063d7b26337a4dede6aa9ac757576c654a52e9f5a0d19b5f6d68989fbc1b4a2309b357d1974294cb8ef677774280875243ea4f7b300a92fea1a36b68455355e52a00f18f9b0591c8a78abab5ccc38fd1ec92b4b1e9f24d073f7bbb1a072d524e8cc650a2b82e1e58b98520020bda0e8e4eff25e4c58c50682993f94e5d000e39dedb718d4cb8103b53332a6792bbafada03924358b3b488e703bc8e9bd53fcc98e7b03394eeaf86888c4989689feb4d9a4817cdd16978f7fccc2141e55b8224f87d7f5f542bb4c46794f8221e1f8aded67ce675ca2a2f3a162ba176cf4a63fd9775282cdf4dc13a85dc5d22858d5e512b5332c5f1afac6a8cb99f55de8a19f44c3e5a37d974ff95bb5f9fba0fa470e61dfe297864ffd5f073c413edad0b6667d59afa46beb8b8fd8d504fc1ad81698252f23432e2a1ed63b8f3945e92cde965e8ae599784982175d22b3614fcb450e27771273ca2247dfb4efe82ca0b11ec2375027aa50c6fe6301c51a597195a696f7843c66178f2df87d1ab76bf529047757d62485b344b4219cc093809ebe96ac0d7522a0bcc3f6800647840234955c75d8958c5975df8064e8b00fc1d71ceb35c6d77abb6a5b44485f42f3191f08825f3fd503816f3a8107cd73de03118445599feca669812297af215f3c60c15d8a616574e3b92875b6a03c551bab2ba41abd829d2b140d4596f09b0beedb1f97c542c0644309486786971d84ddef03b04144ad18afcd1a8968d861f2014a88cd763b6a62836c2e6f308bfc8bfe94f9debace56240b9e5bcb6c84e5b27dd528c41c3f7bb52303b3bfbc7ed6adb048f572ccec0abec0c6bb26f98163980bc2414f57e3a375553e4a2195fac508112eddd4846b66e03baee4c51c90b555cb98f8f53ff243e5a3b8af011514b9ad7bb9c7ab24fc8b2b292582a0a80fa0df4d7041d016092a68565f6c9b7552878bbc3b2153e0b11d6b02446175b2aac7523cb3a82b08678c014378e365bd8b0c3071c1d1716f47e8ddfcf1897daf4d39b47aa2b00dec98903ea95f2c6af805336e80a22b35a70ef608f1ee63e341576b0282512edfc63d72bac8272f9bbf65b042de002c235a4763141208b5ecdf6c6583877effb7abe5af96cf136ee7cba55132e86ac2054645cbc9c1758c5695d711fd104a99534baf1437fd165703371fa2b9397fdfae5662f0b3ff5eafeca2412693da4aaedd889080ca75c693d666840e8138a3cd9d5b48fa20add2243136e4f5da08f4c0a632a712a0ccc266fa0b933c9dac224fe24cf636013c59e4e82115bc51aa38a4031115ea3585907036c67fab42f2799926efeaaba9154cea340db25ca577f74325a1f5e05e07b2484b47c54172b5272fb12d3bca1602bf261eeec7b3632a1e358be170b7933f7f5c1dfa4e15a36ab0949b4dcdc752ebdba16d9d39a8aa75f0fa1fd99b6a8ee3a99415431b84e955244884da32fda01e196b3c6e5a910af59493f7c74a4187d079c084b8caf3eaf8ec3c32fdaba558f24567f8d398cea1bb022779ce35ae06763acab71fae1c1eef891daf4b2d7afa667a5e922dc49d328295b07cb5e387e6ba4ef3f44765bb1d81831c4259719dca517e89a5f137b745c37b8debd54c176423a828bd49a141e980f694ac4e6880f2957de93782eb75cc487d1d0ad03c039062d77f4e97953fd35d70de30c8e3d5e3c2e98c95deb840dc3cc300db3d22fa4ebe276039f68d6454ffd52842438f3ad461a70fa7c767f6e00f5b7d9879a4e0fc38ac1d6bd4874bd7c707a38a2c1749c066e5af9ddf7e1706d683d9c7187c73578c3f1cb5780f2ff2e12e3fed69781685f1f181e70c8f4802184fb35bfdecd91cd6dd96756811dda4c0f7cc25f8eff70247a2d6f76b73316c40668021d1af5e2f32c8778ed96a6adfa3218d70209ea0e4d82687fa2b90743d7712b056459107debacab73ebe6c91622829f9a72e308b8b0c2ecc76cd18c8acf69118688596dd5a0442a65c1bf139753a7fe547d49106231bbf39b61a23e7e68c05a14a9a7db50109603a1c82731e2d75c31cc715e220e0aa9b7bdf16635ba9f4962e40feed2e4d3de7419aef50e1113044ddccba053339c839880852f33618cef63af2678aa3eb6a138538b8e9f6e1b8e645a474112775b8c0aadc79b3f40dd8f041654536493be1adaea1f3fb7db8b8ad855720d455bd104d23609834256afa5cee2c2f8e376930fac44a6f021d6cbe50a40a937568dbf93e2f7ed7c742dc66377b6cdae931c0cb5356cda75b606c601d65d2e4f657d6dceafccd45f0dec479b583a94e2493c11f2b2f221a8cd76571e010fa06925c1e1d7879854d19692432688e5ff85281527ba3050ef260ddd50416ee35b07fd9cf91d893031fe0c2269098fa6b849af58667fc645ebdd77fd215eb16c0de6853669ddbc8c79e219319adb707d507cff4ed54dd503c9af37bb56ee46e6cc5a9a012e9098ad9b011f22d2e9849f6ed171dcdad3e5640f5e294535708566845470e6c0a7514008ae4ad2d0a8c6bad75002ff665eb9544f693817dbc1072e19ef1b0bcb4ac673383a9a208897a2bfdcf9f0357243704003c71037d8837d9b5f447b3ec85fe9478a6c9decbd044ac35bf020a8f93622e771f93fcd702c6f8845d07fa4c303883f1ec51ee86831dfb98894cc4a2ef07d644e5d7f81e70eae297d1cf6c21256f1b4014fc4f4c309062951ccb82a677f5427f1c198e1b5f94c277422efb20211c567c3e59c7a4ec72407f6f41b3a5d567a622e53a99aac22d84a8390de5d3880b8d93435c0075693b4ad62e3a18ca294d9f9e1fb715b5fa10ac5c0039f190328320d27810f4899a8e8b0adbec6d0169c157f643897321dd8f97dc4aa1f45a12df49c24290c55cc34f9a9fb739758f3aba8d4bf331b117101aa466d83df284da608ad4d09e8dfce3663b58b0b9edaff90b5fe546b1d8b4ded18cd1a3090eea45ff1fff5759a0dd0f0167211bb4381af36414e009657640e3867f583557b819df2b9838e9e4fa496c54d6c10beb243fe09f49658e40da6d58da27651406cde2ad04a0ed27069edc07bbc5a4269202a826824ae97fc83a0faf3239636096f46cbcb00e6eee8a96106ff665a24f342b186f3b4c5faf735393e80042e8bb862716a5db789902c3ccefbd760cbd16f94d66e525bb402b03b0718dac23428833e9098e9b6673e33df90e55e6463258bcc814bb93abf881c92b8d62fd4dcee42847e9a33bc4922ffd4aa7998b44af1919cd31840aaff5f8affa3cdaa44d1ac78cbdaea16e6939ad4009a2746f4aacd4c19a86917384c1eb21ef7f310b39de610cf493836c037d3a8b4f03394987f9f506c32c4e7edc9d1966c92cba718d3040c7777029719dc61aecaa33e20e51f7cecf9064969dd48ddda993d9f42ee2e15d8355e1a54ba978816e94ffdb8a6a209c1b69c1976dbcc9011d718b5002b5443cccbd89f5adbca559ed86f182a889cb805d53ee2f85410a0ce274d5d55f60e5815bc07cb837ab71e859287660e58bbbc2e6811f0cbe03f756f281371975f2d8bedb3e7501c0f9b4cb090112e170656d69e5b06765e376ec1d66619ca9b30d0eec0e712c9b8c8afad99dfde28cba2000d5217e7d9d097e541c89e817a0d602bd202daa09034f58cacf045758ba1983b97b435d13020885b3c4b6d4e3b3cab23e61a43b6ff556c3a931c33f3e0d961aac2076c52f44e0807ebb2c58bb1a474285492dfd6baacea8feb989e4ffd08dd9ed2508ee7be5f85a971b63c12a6721e25c0ccfa944e4a499a68b3d244170dda745d0f2366024b11d797ca7db346628320e06c17d7e4916702b536a82d8af0f8590377a757fd66eaecfa92e3e0f6134a31a69f5d843af224b39d47aed26a8c24032ba7b1e3073f0536a17f82c874af1f16566c3ca9a1404d0c6d55a0373a472bff5dafd8c7574270c8df18ed6148d29505122c0556e419758b68ee4cecc10ea79db0a9001a3c3ddc643e529b5cc804e7bba8db6ce6e116a16e2dfbc893f1cc90f2bbed2208e72470326befd604afd314a25ef5968ac51148c9acda45a890fa548a0ff8c0698f57b0e1a907b8ec633aadac92f722aab6cae6f49d356a960e636d009d36462ea16a820e4a1408c03464d9c13f4801f9dafc04d82ab4b001a83f6d040a0fd7244275fddeff31ef88c96b51726cbeb9a20d50e4c0db179d9528cad6c6bb3c80593e832701236fd9f8bf09ca03c1fdd963d1df80ec96f511d1551ba509a456187a2fc7f140866d782b1036891d451fdc0cfb1187a22ec902de1ddf8f2ed48dd8d319623853d2f060885a2f09dc0e2c33b8f10885ebe37fdbb5852bae4e332691617f7e4e43da01ecb1419c4ee042687c3978e8288a65ceb281e186a9149bfb51aee6b3ea30d63d71347ffb14def4f9f90df0d91b960b10cfd00e1a1534b7b7f50eff2d8e8a900b1465e8c973841598bc7afe02b8b3954d82af455c981d682d2f8aac8d7139a4706b1c4427a5780b3aa38f09e8ed79870c3b84976eee2f1b1e2bc0e5f89649ffe1e1eb7aac0a7375ae1b53cb18a1701107210312a24506218237aa27bb59ec37b803f2e1cbb1c128b08acb6f2ae534d46d2a901abfcef3053e851b6f880be2bc8dfde8440a71f547885128d70dafbdd116e052fa99c37d7ec4d797f4a06691c78a64f109c878423afa14bda80bcb8061ef518f2e1225a2cc295424bb558f659c2d1c24c50e50207e15d74413bb26167a22761073323ee08be98ad3492335bce09afaa9f811db8360c82d5ed15ddb44f253abe8a7f5587ea3eaa76f4cc356d816656af16a75343f066aead9710fd3000f27473da11e290520254f470064fa3b0adaf1c6f499423149812e11eb50d6bf4c0ce8be9fa2d9881d6b0ad0b177f2831a25117fc38851085cda93cf5e64d4c47edc1a52242989962ebfd50c8547271e99ec742eed2e8b18ade85685daed0daa755fd14fd7d2abb8cff1da724ea46c02df3ecd8f2873133ad4b6919db400c012793e10586b83224a133bdc6b25511870885bb568c2113d50b4f336f556b30224901f26d817ba599cb84ccbef1b381ed48df17a025efa176c8151b4a501c65edc6106048f04c3f1e298188eea86eb8aa680f9b7a429f0caa095a4add3b225fdf7dbbb45f09b81a9574b1d20bd7e994fafd243daf44fc79ad3a060017055cf1b9ac96ee7772dd0d28de920681bb2d214fceefde7b4366e614322416439a6541b291dbda229d7c9a17336f65605a6cc65ad64c4d49',
        salt = '9448493c95a0bcb5427ba856c8026964',
        labelError = 'Bad password!',
        isRememberEnabled = false,
        rememberDurationInDays = 0; // 0 means forever

    // constants
    const rememberPassphraseKey = 'staticrypt_passphrase',
        rememberExpirationKey = 'staticrypt_expiration';

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param  hashedPassphrase
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassphrase) {
        const result = await decode(encryptedMsg, hashedPassphrase, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        document.write(plainHTML);
        document.close();
        return true;
    }

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        localStorage.removeItem(rememberPassphraseKey);
        localStorage.removeItem(rememberExpirationKey);
    }

    /**
     * Clear storage if we are logging out
     *
     * @returns  - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        if (!isRememberEnabled) {
            return false;
        }

        // show the remember me checkbox
        document.getElementById('staticrypt-remember-label').classList.remove('hidden');

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassphrase = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassphrase) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPassphraseQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPassphraseFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassphrase = hashedPassphraseFragment || hashedPassphraseQuery;

        if (hashedPassphrase) {
            return decryptAndReplaceHtml(hashedPassphrase);
        }

        return false;
    }

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        let hasDecrypted = await decryptOnLoadFromUrl();

        if (!hasDecrypted) {
            hasDecrypted = await decryptOnLoadFromRememberMe();
        }

        // if we didn't decrypt anything, show the password prompt. Otherwise the content has already been replaced, no
        // need to do anything
        if (!hasDecrypted) {
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const passphrase = document.getElementById('staticrypt-password').value,
            shouldRememberPassphrase = document.getElementById('staticrypt-remember').checked;

        // decrypt and replace the whole page
        const hashedPassphrase = await cryptoEngine.hashPassphrase(passphrase, salt);
        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

        if (isDecryptionSuccessful) {
            // remember the hashedPassphrase and set its expiration if necessary
            if (isRememberEnabled && shouldRememberPassphrase) {
                window.localStorage.setItem(rememberPassphraseKey, hashedPassphrase);

                // set the expiration if the duration isn't 0 (meaning no expiration)
                if (rememberDurationInDays > 0) {
                    window.localStorage.setItem(
                        rememberExpirationKey,
                        (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                    );
                }
            }
        } else {
            alert(labelError);
        }
    });
</script>
</body>
</html>
