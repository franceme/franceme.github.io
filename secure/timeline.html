<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #4CAF50;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #43A047;
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #76b852; /* fallback for old browsers */
            background: -webkit-linear-gradient(right, #76b852, #8DC26F);
            background: -moz-linear-gradient(right, #76b852, #8DC26F);
            background: -o-linear-gradient(right, #76b852, #8DC26F);
            background: linear-gradient(to left, #76b852, #8DC26F);
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>




<script>
    // do not remove this comment, it is used to detect the version of the script
    // STATICRYPT_VERSION: async

    const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 *
 * Mirrors the API of CryptoJS.enc.Hex
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassphrase) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassphrase
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassphrase) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassphrase(passphrase, salt) {
    // we hash the passphrase in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassphrase = await hashLegacyRound(passphrase, salt);

    hashedPassphrase = await hashSecondRound(hashedPassphrase, salt);

    return hashThirdRound(hashedPassphrase, salt);
}
exports.hashPassphrase = hashPassphrase;

/**
 * This hashes the passphrase with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(passphrase, salt) {
    return pbkdf2(passphrase, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(passphrase, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(passphrase),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassphrase, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
    const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassphrase = await cryptoEngine.hashPassphrase(password, salt);


    const encrypted = await cryptoEngine.encrypt(msg, hashedPassphrase);
    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassphrase, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassphrase
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassphrase
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassphrase,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassphrase = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassphrase, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassphrase = originalPassphrase || hashedPassphrase;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassphrase = await cryptoEngine.hashThirdRound(originalPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassphrase = await cryptoEngine.hashSecondRound(originalPassphrase, salt);
        updatedHashedPassphrase = await cryptoEngine.hashThirdRound(updatedHashedPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassphrase),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
    const decode = codec.init(cryptoEngine).decode;

    // variables to be filled when generating the file
    const encryptedMsg = '7ed01f8d06cc7f41f0055fbbe872a828938cc1bc5a5dd5eb3c7d07cc523d283595a9b9231465c0514879252a89d2d0777a5c7bba556dce4047737e33378ff4391d4bff88da7d632050fcd18009eabf5820245c7502c4210b69d28df74b9ca791a3b1b4056422ad09ea99cc8459fda2e1851ced1c90068381996012184bb4345a28a74e5edab24f98845c4ef769079f5deccbbf0fc5a1143f17dcfaa66c8b23c72d8614860d455eec12d7315ede54e987b55248502ba96a183c7367e2ea48b11d1b1df3848b75e7a2a6d9aa803df00b1abac2c2d43c8d4d553acbac98a95d6002432b889d1ad86fc1b629d4b528d96b81e47dae341a7b49fc5a1bea3eaf893d64a4ef5acea560f58973b32638f4375c834625c3e1045086961e98543e858812b2a80bd9c924369ed1234dac3812e03ec9a5b357cb9aa45fadc230e4e68948d667dc531b4d41dcd7a7e4f9a8fbf55b24a6867b2c0ef9544468b66f4cb77a96d650d9a0303c71794834577cf71a0aeeb2059e66bb4642588e15c94d1d3bc28be45d5afa62e9e71ff68073d65c9c2bfe3589d641632bb698f71391e1a47dfa909045a01835c0f8087a49c87b7c6b85293cb1c21f6c08df027f95e90bbffd744be3bc8822e917cb3cffd722ec46aef1dfd6967980dc490a0d35e0d967a79e6a31b30c4fea0dbd96fd9522ac80b45714ab0dc99627d8e6ac142439c2f703b390a253286da12501aaa1806fc3ccb18c9ae75dba824b1fac8e651323e814a89eb59a54cb3acb1cbfd79d442fa4665c4ef5162b9a2d7f0be67099e5452d663cd6c3be95f954710edc8c5a1fb55ead3580cb7a950f6113659ea9d57313e10eef3f2821bd00ff834d43df960805716ccf52651da99e17e0bacdd2875bfd1ba2d86ae04bd9e1f0b275730daab995387a0440ac0048ff91b55616725ebc4f7a239f2bc905e878d084bc0e48b82325cb3c2240dd87e64efbacfb75bc178a6c312ded5143a70e973a65b103304c099a083ee6a94a82fb8cd8111fd8185e0faf1ba645a3aee8765774f6c6c011a955be95ab4b55046b8143d5fb37dcdff46e8a7eabfaf5e60cb37d9ac92e11fb253961dc82537574f1beb809ae04a336126c7e545598a00a632cc079689d5982e38dba0502116947b1d0500b30a40d799a86c1b250c317d0addb5ef8beb6e81ddf1ae80e8b7b78f2edd2fe50108a533e31a81f9ff717887ce96376c8e981dde8f06bd6d94932970d0d5c5041c2fff024350cc4e7d88d1795d772482672de005eda8dc885f3fb9f30c2e0e6403f5f2d81c56b5467d43207929924fde7a5036a390cd7af8125b7e97c3b52e46bf4597c7fc895c00b0ff9d6ea13c6901d1c1d73d8d7ca0e119df164bf67f2e26b088dbec908614bd702821d5791286a0d4811ab51b382b5d77ec63677f2865566de18cb33deef984aa3716eff3098cb1e99cee1a839f374e2741fc294872426227517fc9c825a538bf7452662f4ba0f4610c42a51ce4e2e08ea702d7b891bb519e0874bdb09c8aeb8fa8ab3b3b61f8b28db73c795c013859a82034080e2504d3efce7ceeb03ad631405e7d8027a68f4d6fddfb5d8243702fd9e3cc862b090985c40b1cbf2cfdda18039d9fab6178a3a62579a6dda067291a420797d12ced1263e77c996428b814761a0f7c7197d2ccb4e3e5f180f18930f86bf982112dce2ed6e04bf75c4b97f08dfbb19410cd7b8c5a361207241d08586515b3a0c7e3f46dea745a4b7eea57a0699b2ba34103c6f38a85c1b2e39279b3860d271335f6b65af9049374358b37832b6fb7619480030446d138426e4c8b3baa87b93042433244eaed6d72f5169d87eed971cfc8da9682d3b517d9c1880840fd95080b9f1962a13ba86ba2493b0ae60cd73860be92fa2dbd00243e95f0c6df28bbcde05b9d8a55aa4042edbc4b028da11ef39384d483c4be0729fd6b1d96f5240d539f391104f91ec72ea61a5f208a84bcc69d56e2cac4a4c2d30c28c602917e4658428d07e09d5ad531f7dfacd31d5df0638a2982ca9bc36ba09df6b977e825c2fd036936592ef4a7e10976f70babf31dec129980e1dca95cd0f4c30a2367f950a5146d6f190cf1f70a0528a40f0cb1f96347c86403c2611d5a17a9bac5180344be6a0ddd8d71185132c81b0cb180a3e959fac6db31d0733100c91f9bf1d48d2aa19b7c209fbc900aa72c31d3a6196718db0c4c234b3d8a4e92a07fd994fcb452de777096231b34437d06b5c3929cbbe9dff08c7eb06302bc7cd5769b3382424532617dac94a32c2008a08f108649e9066c9e2f97c568beb2e996c7ceee4755ed68acde67fc83df9ffdb72c489617a5d5b10158f63e4acfb7383f8a2a8fc75164d3d22161998ac87013ea96018631290260f4bdfeb6fcecacd0d274a8f973a1760c9e6d3b8ff3f2a43ba970b55db68cb1bd4649c49e9c5b2b3ec6f49beb060cbc759460686147745763e02980d16091639f6549493cc063cfdf2561d0a478246d56be13ad4566c8e384bffa721e9fe72b04690ab319a0a79d14ff989f3d347f01546b30601b4fd21cf02c3ea2aa5265876b1eafb914f7cf7f98a5859635b7543bf13205bc8d97fe3f5032f7765d702faa5981aeb9a37be42903bc901436eb26502e9a0d2a4b9c254ac93223d6eafa2a083c4676644ae8aab2fc0ff855b0c00212b6b9a8d20ac0dfd87b9b4f0ac8ba0c46e6f88e644da75221fb2b1b011308e125ccb6134075bd595396df023f101fd75508cacf2895ad988e5f69907f0f62c8686dd44e7d855213e38304b0fe13d8ae56388e768bb0a57ac06d481e6f82b90d5a343c0de07f93073f55e08b8f982d33f31bb9d725788bb75a520369b12c2ec7fadb16430863458e309847fe6a7bf999684fd4d8e7d57e951956c371ad0c2b22e1b2303d53233e3971ff2627901427777033e8cb16aeb32d9cb84ae3f50b27ac777e5bc631672a48a661a1263fa11d0e8436ffa0e48a3ff47b7d99c1f7cd33e9d9a18c9c09268acc30b1e3eda9deb1e184b790715f9d73cf32a26efb583363851d4948be3c7535a128f9e0bbd1b625f728ec584b4b3b2aaa938dfb272416929c49526ed7a3b23cbbf5ef1939cee8ff787677e23df9dcabbc8b472c90905b49168ff1a6e20aab19c47832ad691586e2dd3766afe35646ec95ace9a8727b27b487ee6c8889a2032af590ed0ae2c9721dd8c47872bbee8d15ddd36a03c512fe3844bfa6ca8944815075d77a1c0b9151e0cff6841380461115ff17ae0233f0755ebd48e7eeb158de5293c054b677dfa614d5b0262608b3d113fbb5dc36d996d2c0480fee6307e98f4796f9c23ba949bf5501d694ed3276dd6c6775c80a4fd2168fdd7f360f3b0157dbe0ab0f54138074c447849f0620c7cfc0cc0c51b097962b392686d5330b52b587922d53f3662fbce73907dfaad3e4c1f7267caf746425d189e27229f4eefcff0b1fe0d03412be182876d63f0c58d76f8bfefe7b9157ff8a890d470d8e41961db4b175eb2e1f3bad5c4a8ef0f313957a664138eac37ae6c4af16dfc90615e513e2804a5b441ce9e8a67a1bfc2bf8b48d1bc3a61e4f29750a2fd990284251076250667de6c6968175bc883c36608f19d013cbdd65e28f71e36a74b2de1076b3d02159cea3fc1e961f9b6f19eac549bee52843fda9ca7b0893661baf8ae1a092a6147de2ea2e359f6debc59bea3a233873feaa8d6bc3161d2dc773a1806b50f96ec1e84e78641fb463555f27aa64307f7ef905dbbb6f6da4656a84ef518922535cb136a6c16370086192fb6846eae360a3a734865351f9b1dc12edc4f6d79973c7cb6351ff0b35c8763c2a9a19ea516303d12f780f45928a46cac2db8b03000ad6a01fa44529d6911b80aafaa8b307f209bb277122accf94ae4e7d64d94cd5b375aeb831e1e1d4a2016f23d4411e62a2c676859a933b6f78f53547a4a5993ffd5f50d9cb5049e47253a7bd04aecd27cb65020be51fd346be5d56cdd9d7341ad459efaed685bc745c52413ec010ede4a96390a592c89a5c7e68fff66e28b551e8b664d58436e75683ecac9ba8f7561fb3caf705b105803b82563b55560221fc01fd08a68e45b65834b0468ddad57b5ac828d7d8bba83737e57174a950c53778f74c061144a4dbf5dca0e7e68820b77c2fed7fc932509ffbcc1a53ed6e65ba74ecdf8a06a87bb328a2955e9b7620ee17e74690ff4e8d20e7ed0f35558764f5759667970d35960f50eb378da658dc550eb7cef47971ab1473c106ecf91b5a3e634d85b42bfb3934505d92012027b2b93c81cdef8e7e584e0c6e8164266502af1047b81d25566338070fc9155d0e930c92bc30d9d31bcadd22e51187a9bbe2716098baa50a1a88b1b032440e55d4e128e233894a664737ec7353a9e8825119aa6158534df4552e680073d32d53101b2248584cdd1d4996ca4c8f259ca404a4833a24bd6ee9d712bc349d4e0b963199c5915380ad1f2598f43e24619650cd18e64877275d78b2f31d522e1de931116af549ee3e8b640624daf0b4b3d843673b82f026a7bc8d1f39bb562754b0162e222cbd44ade2da8ed87f7d20488b46fba98decc3aa9ac2833c3d2b9c5f57c105117bc564719c59bc172918ebacb62e8c4c528118542dc6a42ec50579ba29ccf244ccdd1c917936dec682f5f28c2de2717be1d39469d9d51933ac5d771c2d57f58a42abf7399a87f250e4a5dffc03f0fdbcb4ce0046cbb214c7d7f42c1252514ed2ae1e54ce607c7ae22d3df3ab521c37d0f8fa02494da91f58a3ed88b94ae82ddf6ddb9529cd95a581a69a948ef4dcbec7b1497704f90b3b9cec5099cfaadb3390505945915c938097d86e5d41208be462116f13580a65864b327b7e3f540814c4862e7373227d7b392232c1da195c74de6f096f08770d7771bfa4af4adbb53e53b04252aeb191a75df7b278cee77b9baf3240d1ed955ab1d3adddaaa9d48c96ee7931a0051ee3e753d655ba6a7e80d4dd427a7b0292813c863fd7bf0504d30aa85cf8b046358dca8a5c0b8d3496273c2ac9227cbb21481967506d0fcbe11258992c4e16f1433233379a53e11d7ac0def6ba4c33162b0c7cea3bb621630b916c122c2d6a8c33d3cbb182b11cfd3dd226f30b5af6ce5b294c9503970c0a2cd1a7a931e7ccfe679ead5220072223c55a914dcb43f5932f41398405ff5e700ebf59e86bf8f8934e129e8dae298b44b9c4bb754e358ee0d9a5e133bcd0c7fc478a4136002b701b143ecf1062b16d4781b68468734edcfb437523ea35c94f25f29ee8facf64fd667fff53bc677a0693de04cf6016b904c8c05b4e438386b54d347459c368c8d492f3996342bb3a1d540b1e8a52ed015703c30f649eac820bad5f387a74816d106ef8a28bba65c460648b2e591245088d968f1d44fed968ca0d201f91553c2f1e9d1f1d99836e652bc43c760168b88bc4afbc3f72cb5dff18f41268fa0b1ae6dd970b3afe840b91ae4bf58929c161c9ae725d23d4f8d201aa99f4f35283a49607ac5a582ac4fdbbb65718b6ef8c3a36054873e5eff1238d3396712866eaaaf9c1cfc32adf63b2e4ce4ff32e7459de4025e64a3a3a47305b5d73b4c4e3c4f95a45895c585eaeeab90a0af07323ff682f219a89c01755d178acf5a5f0b66e2cced8e1c48e064adeb4f483a06dba06fe6da13a757f9f2dd25352f4f022ddcc02d961e9e9ecfa8961fd63b8d4d6af98a2510fe65f7441cce44778127cccaead271f4829b435a7a0e0da63c66019592d0039a40cbcc7be39838ba9ec00211a73d35eb093f4ba7df6892b8f5cd3c2865fb554059f91bb156212aa6a25bfcdbd09346d5fb30041f894cb95a7ba369244d28d8ee211f039803d607d190871bc0ae529a1d4850d28af8c3d6cbda0f5f6edd82f6c1c0792d54486bec898eb944c5790dcabe6d79749dbffa344350fcf3eddecdbfff1b87f411ea20efb565dfb6562df0126bc1076575883f34670108dd21769ffe5c3a98310c3d72ac1617b85c4e754049349df73f8821ac27342fb74c3d8ff786ce028836945fdd878bd67d6fc5f1dda73051aa449bcd3ef9914291edceb0dd23283758db1eccc49423c991fe17c43ca2fbc339cc1b484141d0e58d71056820fd9aaa71703142757a5beb70cf065e75886b8150f6641d3a0e2c7f2f294601d00c52867eb25ca5cfa74d49323a38bebffb553b7b32d3dd170ac7a5c124e5ea9172ea1fec1c4833524dd1e2e9011e09c2c4fc39f7af3966eca1062cdf37f76dff5a4f4066983d76db996f196297170467037dc0fb07807ac85a41ee29ad00b63abc067967eec745ab78783649184981a15aa23a18f3a0c694152e74b610b4256b8ddd39548f4916a6b991f531228b50c7bedb50d2bb80c251e8c9e50aa47b633b2d35c0a03480e43b52812de1a382b7b217339301f322847fd3ff357fa32d7b92115c814b2dd27cd7eb4c30bb519a0a03681411620ae32a0d74862b1a19739ce99fb62e175f7526faed1602b7d363623c6cf1a1af8b2d5faff40bf924502e7a6834063a186787a90196a035dc3e3a7fad9477e89da591d4b3d7921cd4cb039f4df35f5baa2a02619421fd69350afbb7a2cfe134c4e41a44efab83247d5c9f21b3e57f8d77278e6c20a7b8dc953973c3f002efe1229d4e3a1b446aff2d2d142f3f9fa605ba5f832b6aff50bc20a70394258ac5647a653a9019ce7789c0eaa2f34e6d97be8f6d35a358b5975c7589659d903aa497372dc3fae36ce6051d11c1f294363c376ae81c67e1db8a56e730216f9ae1548e2a74a51dbc4a97503b08f5039e937b68b61bb6aef189a96ea7737d26be8c6d2197fc8e02cfb6f65f82914ffe6de1a8d9c64704e3e1eadffad4375d54f1caf185c385f28737d9737f3c12ee72a8dfc4b78ad2dd9159a281b760a3f049d2ab6ef6a6a7643732653b73dd0b5d685e98f9df6c7fdd255b9787bef5fda3efe3617f9d5a530b3145e2f4b93d996a2ebddb0ba0c82cabb383eedca687c387f73c17f3b75242ba14ac38d2e4f7d786b9e4fa7edf027ee209756db9caab0daedf766b598dffe407dd0cff7916ee318b60718401ed86459ffa7be9e4354b8b1588de9cda45b9ce4b85cec554a6b5d0eb263b03f2a4a3b2cd18d6c0f84358eccf53477187d555a851b6d95be5abe1ce4b290e82bb8ac2e93ff3fdedfb6e5a71a54565c0f37c8c304f3e9f1c5cd6ee448b1afc09db051767590f85b9a0ba0432ec607e1425c70a797400b6d8571985f53c2f72684cfb76f29071066c9ca46f39086ec41fe313721535743bcba158de9028859e5f45ade3a15b826a28ece0004a8cf9303bb9454c3262e0dafa8b2a0148bd0ef7304a8e0e36876a99dc085cb939454fcfae3206c3d8cb8f49775f1cdbcc1510a3ad000200da96a970170f59f8da3552d09b53539d4ba1ee9d8b7626db301a7377850317ecbf0f29db3fbdea8317c5293e51ad97d99c2a4ff525c320c416ae61868ce9e72d8eb7f1f05592fbe600cb48e566151f1f89a37945773f8cbf5f12843ec4a91c5fb21382a564380b5c79ecf129ddceb260197bc1fb8584a54a4e1581f6d2ad30c9312051398af83e441310f2af03120708ac2dd48ae123d1621e48ebe74150d7a95a4d3ff522511a1be4adbcc87c4dd93ca1ffac36f3667535ae4a0de16bd8ee83d6ef97d23f14cbd554ff21f2601fbfa399c2e516cdddcd992312230fa8432d3949a70e5172a2e70bd8f5d9f339ed3105275729bf4499eb1dce7a7a0be2aa09dd4a3ceacbfb7ef561d1625a84819ecc4dba08772fcdc780581c275a8e08607e3801899b715f83e1955ab8038fec80e1738b076fae248397e0c280c5c0f925187516be9b8ea51a491c5f2d4f13a65c20d413fc46446acc19f2b55dfbe475e0682bff677a235207d88ebc164ba0b7d001b00b9dcd38961b4fac219c943c5fa9b57bef58421573c46fb0a4faea7cf68dbf78b3010170f49742eb86c864113b22101558043f41ce5ce6cf51dae1f15adbd249bf4edbeccceabaf6781dab9e78875b1572577e87530c8ded895c0547b3e6411ac117293b223ddc69106bfb07e3ec2f4492b08923ff8eb7515880cd4a61b4291d3daa646448b239c378bb9b2e17da243cb455348f41568bc748d4babcb2be4b4616b61f6051c85fbf32cd69b971f4c5cc7ec848c9065e49ad73f232fd0142d8ccc196ce92fa3c6d52aeb00d1172a20cd2e92159e427c064cd5b45fc1a469fa33f2f2a22fb1716873de5568c562e0a991219eaf94d4cfdde8e8215cd36d83dd5f0808f0534d10eaa9d32269b2c71768506cfcc7956d9d3c2bbdcabbf2da8bef2f629512e61c06fc9c8de0199496e587851ac14c62db9753c2d2e201834e56c306fe93bc2c0a2aaeddfaf860bf3c9e4aacb1fd09be96f89157f07f5e5055473257c4dddb3cf1ef754e954bf7a81b62d2d643cfa2c9cab8229a2fc779eb1b55f7ca57c927cd07b7de3adb352b75d887f3cfe7d0ee263a38ffb958d0f1aed68f8908b5dbcf1e761d1c44b4e3b49a68b4b3591575af6dd190e52dc7c1b1a9082289141b709d66e834cb647b4c652ec7eb7a5442af6b0b0f36a734c8d0d1eda9ec4948aa18219b49482a57b9014d116fd11f659fe70de96381eb4ed684ce67179bfdf329c5f98ca07293ab09fc7c6b72220c90828c6a28ec7a52b1493573cfb9bcbe616b9056dafade1f193261cedbf1041926b8c0295d43a3dd4a2c8ca021d01845680a987ec697515b62be375987867a214409193207a66fcafec1272674d3d6b4b9eac2e956ecdae5427819cfccc2f39d5127e1888a15859b6f7c42b4bcfc5a7aefb670ef6a94f0686ed9e39097343a517ee85306913165659015eea125ff855cd9d6809ca99227cb3c1cd090958a7385fd52e9e45dee793ef9ddb5ee2e302eedcb44985d61a2dcc1b9ecb88082f51996f7c4966b1ba2222786f65747d3fc423c2c27a37841ba7385bdc173fe50c37b4d4a781718c70a1c78ddfec8c3914be4e0e1e1f6428b3ac29f1692cd92a7b613362d106b251f75a66c2e2d1a6b0a6c1124fcf0244550e4abbbfd7c22b08791561a2d32a96be302a3ea9ef45872bfcc2ab6fc5c5e6cacc5eeed358c42a603ec22d78a5904f0c0740b50d8ed80ca2103f6102cb3756ea88f71b5a8192e7b5fe1e799ec59fd78ea610734a620d86b4d297b4cae69554a05b0318ea404b6ad2335e07a59567608d76444d823898e81dbebf609d04aca0f88bb13388f51b29459c6bd3360f537c80b582c66077e84da272482960aecaa901dbde209dd14cdf8205f4067ecb965b65894800de56f104403745aa1f866b95618b739ebca4d834e22340d2c9acd24f527446cc37e7c59d80762fee6d3e163bd38fdaa488f6f6dae76648e0391835fc1961540f43f4b6356e6de075ff2dac32bc841602285bcf9d00637d112eb82a3f6742d5ba6a9df0027f71bcad362710bb502acfb4d7aabc51b824088881c18d6ac279b1ef9c001e69f1609c70bf89470c44279102f4d3d26788b1229ae6f480cdc47665b7199d4bb79d5415ea53736cc4aeb27fe489a900adc4f61b5922ab9355eb6be3b3dfce306b7a7eb9c04a963343236d6dda986523a7f754796be48293132cb15f7a52076262d49bb783a11966b1273cf985f309f45a7d24959cd1145eca4d27882217017acbfaa5fc65a8547dc24ff468949ea939c726084200101380858c784d5b8a23d7b50c3b68bf6c05cee32b83884df328fc59268b8c9e0ed033e5d7d6d9b6c91a1e4fde583d0914355a82c42e7a05709031a074acd8ae025f244a39c56312de8116f72a52996de7495663b076e40360c9042145c7e4d2d48364aa4c973511bd9192e2e9c97104dea08376735ec48b12529cdd815aee8677e141352cc7db4bc87a403ed9b5c8b02aa9b35071e5795b64712562a051ca133ee217f3b7982428a27ce22f29d72807c78c125a14b894c21c7f989a6033119490821dbb7ad1c529b94739d0f3df7bbd2fe82f24a0245e6fb8acf81d2bded4ef69ef25863abb8b20c0dd063efef60bd0de9451ef6dcde875face347504905952687003daee0b4ca33b753a024b6eed4640884730329b981c3efcc0f4197412372dd8c5c7e043227f8e7e22c95a300b6ab86c47c39cba8ec67ce7b409547975a1bb4059e583c177ad94c12de25fa8265a6c965a9e9398835e69fa9ef1186583e0bffdb19b3d81ab7a1edd2492c0e8deb099d065a96a38d2659003d03c2b98a22c641ec4423c209b13263d37dc5ca0d984c716b64b789e6860c140dc5edb0418c8b3855124c5c3cafff5bce4a6a99070b9177d3d1fcf8aa9960ed3713dfd58af79edd79de73bf10cb19e4588364018c68e80607e27be26db3bd59a54d391a028367b0cd8a3f68a13ae6835d30b8ae97e56c7ec4fc53be70e6e535ca14526e453a4164cde199838938183616aa1cd43a1706239517ea447446400361bd3e68552bdf7a71b8da720f6df1e67d433ad131858a0e2432ef32ae4abb29079dc779ddd6a1a18c6ad53a3e62a3f20c348cf3ca0742ac7a3864915072e2cd4e5ef1562e640dbf2d64bb92fc88f7538921cd11ceea94de71ea8a698a7fbe5312f74870d98ef0042a8cb121d44a809ffd520df2a6aeaa186cb92bbec559ce3c265b1f7f255cfcfab0e19027959adb71848ae19b6004b00fb4ae9a800dca4ed132181608066545c334676408da48263939e447e8427f25f4d4f4bc85c0f230e6d320057b183f5156a71966e353638e9b58337b111c5ded807c823562ca96ed620ca22edc213811ce35c90dd3b7d4d44126c98cea8d4100ac90508830684840f1c58ef2234b3169d63c0dafbd879de26b54bc25a17ea184c2a8003b8c007e3d506316592df05ffd1cd2b52dc19b6d4b7e381dcbce6127514fdf0d4c20e6f92a1238140250f57894e0c425e47d4b502e585f8a9941a9f45739fd8239f9990f5dbfee0cd5ab3b013d090345e0214cbea5f86e43bd9f52eacb0ed998203870a601374ce6aec588d5cd3a73ef1979df79b328331f78b8f3a4ede731a49e1eeda0898a73ab9831dd3b8c051f5322c690ffaf53324644d26f2aa5e9d53410a18f5a09226db2a705d1da4c207dd4ccfbf0d27dd9d6880792926911eae82de1e1e540fa0a3df5fda7824d78adf13761acba0e547b93f40f50517e1b55000cff03a409c7f01d90a59d2074d58fa4a4f863e507d9508338288ac58070e6dd6f2acb3f43a9eb44f91e38fa5a3783d66b0246ab28b22949dd0bf4fec1de09b93d9c6e6aba07bddf2e77db780639018b85bcad861696cd0f6830a103b2f5f2ef530937f61000179e753dcf152fc011d91c7b6886d6e95f174a3bbff3513ee00b3125a4b997674fc13291ddaebf1f08043d5eec16d092d06911fa67ca796067518c66871744641a068a840d1932541eaa1ee34bb5e0f5e2c62107e8af03388fa88da84b617a46563df28300de3bb72472a622c7e5ec2fb71b52b316138edc3afcc43d0ae85d29d33fea4a7c14ead3fd654ae4b93933c5a402091a89b6b7ff4e4fbd07cd4912e2174ae4cfde3a104cdb76a988059f64e61fa9ba05a42405d282feeaaf2ecc500e8264612d08df3b6f831aef0bc848586b15cb4c98ad1eeb44bab03d1f4bc1a10a29f6dfaaf102b519304eae32318ec46e754ce43b697e17a069cdd998ad7b9867301f78d8fdf1946f581c784b173393749913eef2289997423d7f7c65eb33a0e66432e2dd5cc792f40a698a00dbee38d71185de087be232fc70356c12f195183055fd7a669f8c8200555d3e394ef0d53e1c47c7c0235dd84768af1ffa59cb17d762f56d6cb7f8f2f878cd45fe78f8f365497785ed7f1ff4c9c51605b4b3bb451bc9a1c5b73893f81c6d0411d3e3515192666ed53cc5dc2e8bd31972b7301bc67d785e7e4c95d12cf2972570dfa4025b8265a89eae592b8d2f72da003abddba27d8760273c8e4a64c35c2c464ff2cf6f56a94e85b2bb69927c8bb4473731369253a462c4ea2c62315ed6e3ed3f547385f1049edf3293af89fc708ad62597770579154d2f688cf2b42b553852ba2d9c9a0c086318cf2568473b63d970a32ed06a910660cfbf0cdbb464c1b5946019aa68a976062d05c645bc7cb71868060178798ae641eccdbd455914b57c256e59963ebf39700be16890f75d181883f74e1f61d9e0dd8b907bb9516732f8de0ba41612afe57ffd795e640d6f976fc82b7179b9565c75cbc6e99a0bd903669492eba290ddb8fad784dea3fdfcaec50cbcca39961411aa244c3140a6f18a3169598ef5d4cef712b505c4720feb7ad8b011813637e7920155baee5502bf9ed17620a0d220241411a44bb1cfe8f8a5741f810e8317a726a475089822812a55c304ad603e33cf163b895f4264faa0a9ab9e8549efbd48873c7de4b81e12c52c03dcb0ad4329a131321fc1e8074db05b7b8dbdae1952b119095c5cba12a9dee8d691ff2aa868c6c58f838a1e8c42587f70c67ae27f7ed549c1227ce9dd852495979ea628b282c8f5731283fc11e8c3f6a6c9baba31b2ffacefed8e27b7c3aa3275ac8ff4a4b5e08aca7565a566ba1d9cfecc5076802add980f867e37135bc88edf21689497135bc0be6441b554fa2caff46a7ad9563fa7addbd5e4653d52cafa46f1683a6776eca43c4a85656dfa71eefa1ab974c534bdd3ce37238375fda2385a7770e28ff92cd12e6bd16f6d54af2ff5edbf7fcdb6bf2a202bd24f589bb0f20d0a9c65071e58f69275805ec493b0825f54bd71f1ac43786535a590378d191af0264f9b251327974baf14951af221eded92999b3510f261d4a54606e7789257380b0bdf9c0f608e16f326a97ec0af065d5d37110a89a211b23cf47fd89b36921ad2af922897548865f02da380bdeb2c1ef7384387fd9fcaca3d7ac659371a044b1b3637e84adf91f3157421ef0707150e03cbabddd84b0c04b4f7076ae703fc46f6fa58870117a07360b0fec74734387813e4be0044ae806357de02989d12aae0d1fb70e50f00b5656c2af07836643af4db0c731204f1243d6bd755ac5de6214643375029a927e746de5a60e2f3abe1b853af736b4cc2081f593eca56f356d271a3052b488715252c0b4c250c1321293d9a1225f9f8589db5947fd72cac37f7ae09c51df86aa1e64fedef706990027aabe6ec70d47e508632638fcdc2edef7faaf76370e50f751a031145bda63232336e100ea749045f3403ed432f9daaa10280da83e695b095cede300e4f09191be15e1652eb4f3b331265f5ba9cdf8a034fabb1c028a6b269f3d421262cdf9654dd05cbc73f463e9c0fc85a4c849ee82349646f247b915a208f190296d6a02f39c8d63e761c5154a602351f79022a8ede0c568f87c2df9366a0cb3c7b54cd358e8ec00c37a28ff249bb6cc9f2f998ca12f92d9dd43e8de8b5c10634e9e1d643e14715fa45091b77f1f75bb1e7c3b1c7aa352876d1f96dec4ebab0691e1c17bb7cec0fdbd5ba35f5cfffcb54a38b6808b6f8620bec265fd2741cc102d5dfbf84ca092ae681ace14196ca38efa59945bfdfb43e14c2d403a646c59412e7bfd741ebedd629d836e99b178aa93834b08c76c999ab9ae5270771ff4f4eac4f0c1b3031c00d57fa19754e519e690aad0aa9abccb9dce7e5ac678486fb77db03d914402eb678deb7057f200bd60023ae3dd656c1aa92852a556ca8ec9ac43187478492439382c7a246c7fc025b8432e34a99734569db4676fd7ffb77e2d05c822ab3eb8f583d7c4b98bbacaba18327aa0adae830bef97edee2abcd8fbbfdd8da9f2938fd061a43f9cf4fe833ae4c8ea63085fb8f02b0db9971376b57f342bc6577c451693218bb2862aa51119d67fbf4221396ec1c63fb4ba954961eef2dc94f933c744e7d4a3f32d36f9c0e6f532d730fa1febfc01142d7cdd22fee840790f25439c18ab4d87f34f5f6f69cb7e6935eff235090226a2bc15b4ebf148b26c09586b890f61fc1006faa0555aadaac7de7c9bce3fdce5f79650d02f4aeff441a5ce8f369660d0e65cf090953d72bbaae230b606ba11369fc68b8bd738d54d146501b07904288edba6e2230b97f4221e5f800af217d23971ec94fdd51b3705cf2f4b3025e306be5dd8a2c244746e64ee6261d8fe585c3fc5266cac5e17e220927c3fc214e98ca49d0c9d620a8d70791d210b058039c0a9a8e545c3ce568ef4d31176de5cb2d70bf326c76ed6c618c76eec231b1f8255211e8e0aecbab107c5841b0bd5c28662f2f27e40059b6e41c6a66e6a71ba389a0e4061b18079682e191a0b287891d19f04c6b7177d5f43a2967522db7a1fe92adad41b24066032c2461c288005f91ed9b42403e06f5e09a6e3ba01b75a858d741f195f94fad3b16c5c8d5840edc6be70dbe4268a1de68b79a00ec22d5e516dbacee26218b153dc3c476f86d3f53cbcd41fdd5f220e0d416478083e47aa688252c989fe14527a94c24dc30d6738477a306b9d3366376647ef1461df29b8bfe86d41b8bf9d487659030fd76a3ad49dee328774ae26d5a7613bcaff94c1826c8bac1e7f42977138df5d595c8e388b3a72c652c88dc4448ea4002cbe9630fcafc176381d3f3555fc492ed0540eb3e4b4d2b243a33f6002bb65767686907ac207e51443091fdd1aa0807da23b1f3458c3cdaae2072b88601299b0ee496ce7af4db3e8ed7af51ba3989e0a475c774c2b6ee2c4529edb9427ee25c33c2e4008e96621bff84141a873f33138af7f42ca68e211a1ec559678a90f1a57b163cc360305f44e957c5f61b0b2f5a8b926830d2f9a3b4ad524dd6a4daeadf35ddb06ac552743e0947d05c17086985782a6bdc28700531fbb0dad7b7debb025aa0cf36b9ab68e15986a6595621ab8900b4cefb7c243e1f626bb4c14c792f939fbe1ab30a0b3b5519adfe02974375bbc31e0db5a231826c343a4ef844a7baeab2f55f70f21f559de8ea5f3279bbe9ac41767ef798a6538e47cdff5061744112262d6024e545369971f7c7163d55361f1dee8b528656c3f99f9135407dafd34a209ae3178af41f97e77025d99143151a6a0d6aad595108b4cf6e9d656a15ab1dacdff3c6df2d361cca6ae13a004d0040fc446e4a1438f43a8b73633c4943d7d64f950bea6611556ed02702e61af2cb82005b00c18dee733af72302f2b8897a6b76761a8f3a048f565b2d9f22424df90d23551493fb37025ab5c14635efb7cec481a012a4ad79e1f599343d7d89334ef039f32d3b9d73bfd4964a9c3dd47ee6fbee41a7f9834d3e7717f4f',
        salt = '478a444d45276bdb530fd2706a2f0ac8',
        labelError = 'Bad password!',
        isRememberEnabled = false,
        rememberDurationInDays = 0; // 0 means forever

    // constants
    const rememberPassphraseKey = 'staticrypt_passphrase',
        rememberExpirationKey = 'staticrypt_expiration';

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param  hashedPassphrase
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassphrase) {
        const result = await decode(encryptedMsg, hashedPassphrase, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        document.write(plainHTML);
        document.close();
        return true;
    }

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        localStorage.removeItem(rememberPassphraseKey);
        localStorage.removeItem(rememberExpirationKey);
    }

    /**
     * Clear storage if we are logging out
     *
     * @returns  - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        if (!isRememberEnabled) {
            return false;
        }

        // show the remember me checkbox
        document.getElementById('staticrypt-remember-label').classList.remove('hidden');

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassphrase = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassphrase) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPassphraseQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPassphraseFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassphrase = hashedPassphraseFragment || hashedPassphraseQuery;

        if (hashedPassphrase) {
            return decryptAndReplaceHtml(hashedPassphrase);
        }

        return false;
    }

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        let hasDecrypted = await decryptOnLoadFromUrl();

        if (!hasDecrypted) {
            hasDecrypted = await decryptOnLoadFromRememberMe();
        }

        // if we didn't decrypt anything, show the password prompt. Otherwise the content has already been replaced, no
        // need to do anything
        if (!hasDecrypted) {
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const passphrase = document.getElementById('staticrypt-password').value,
            shouldRememberPassphrase = document.getElementById('staticrypt-remember').checked;

        // decrypt and replace the whole page
        const hashedPassphrase = await cryptoEngine.hashPassphrase(passphrase, salt);
        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

        if (isDecryptionSuccessful) {
            // remember the hashedPassphrase and set its expiration if necessary
            if (isRememberEnabled && shouldRememberPassphrase) {
                window.localStorage.setItem(rememberPassphraseKey, hashedPassphrase);

                // set the expiration if the duration isn't 0 (meaning no expiration)
                if (rememberDurationInDays > 0) {
                    window.localStorage.setItem(
                        rememberExpirationKey,
                        (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                    );
                }
            }
        } else {
            alert(labelError);
        }
    });
</script>
</body>
</html>
