<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #4CAF50;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #43A047;
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #76b852; /* fallback for old browsers */
            background: -webkit-linear-gradient(right, #76b852, #8DC26F);
            background: -moz-linear-gradient(right, #76b852, #8DC26F);
            background: -o-linear-gradient(right, #76b852, #8DC26F);
            background: linear-gradient(to left, #76b852, #8DC26F);
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>




<script>
    // do not remove this comment, it is used to detect the version of the script
    // STATICRYPT_VERSION: async

    const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 *
 * Mirrors the API of CryptoJS.enc.Hex
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassphrase) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassphrase
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassphrase) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassphrase(passphrase, salt) {
    // we hash the passphrase in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassphrase = await hashLegacyRound(passphrase, salt);

    hashedPassphrase = await hashSecondRound(hashedPassphrase, salt);

    return hashThirdRound(hashedPassphrase, salt);
}
exports.hashPassphrase = hashPassphrase;

/**
 * This hashes the passphrase with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(passphrase, salt) {
    return pbkdf2(passphrase, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(passphrase, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(passphrase),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassphrase, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
    const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassphrase = await cryptoEngine.hashPassphrase(password, salt);


    const encrypted = await cryptoEngine.encrypt(msg, hashedPassphrase);
    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassphrase, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassphrase
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassphrase
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassphrase,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassphrase = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassphrase, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassphrase = originalPassphrase || hashedPassphrase;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassphrase = await cryptoEngine.hashThirdRound(originalPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassphrase = await cryptoEngine.hashSecondRound(originalPassphrase, salt);
        updatedHashedPassphrase = await cryptoEngine.hashThirdRound(updatedHashedPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassphrase),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
    const decode = codec.init(cryptoEngine).decode;

    // variables to be filled when generating the file
    const encryptedMsg = '2e52db81d2cb6aeffa57dbe01cd231a52068120248926692c6641cbaeffb4828570d638529c725feed2fd437c8e889351a41bb84749085451f187449b4ca4b87b25cfb16cb2ebf84ae05c0522fcdbfc7228e95b3f8c05064f40af0f0df269b5784f4cfbd8caa3279a8043c9f10cb7a0573a924cb84aa65451054694f9f69083b216b77f3c31da57fbc8cb4d3055001877d6743a3d802666f295305f94e1d0ad1fc59fe1874571d67b4d51297db6426933b47a12536256a0a0a35e4a0aee1b833b8150415172673c444c7ccc28a055fc5384d3be4ed3ac39f42272c6aad55a06d688c00862b1ee8137af5f1e4cd2f36d486254fe28554c2dbdc8cc69963c01dc5022a2f12e466d9193d6c53959ab56dc76c56df15ad4a38e1e034e6ec5362c5400362ef70cf0e292d4035fa67011a040ab553d02bbc6722e2da7aee8417aafc82c1814ce2ae0f5e9f9f1d62e3dfd7bc15644b1c8d4937b0666379633d2ffeb6b5837730f272231b530e30ba84859fa6a4e3102c3841c63df154010e2a689323496905d59189f7a7dc494addf8b6f0eaf1baa59dd2367625194e9766bdacf354596e1c18696523009314091306fb331739f107653ba7e3896469c4f27679be4e80e7af16a8d5b7669a09bb741dca7dcfd76af572d383943d9215207a1a81771131d89366d94125251a8c0fef1b18ea0b655833d73ccfd177e7d12a69e6bded5e183a04dd20ad6d849ca7dfda740ea3acee61f98db9e8c36662751379a43361d50f8c62e2d9d26c6ee018a5f2b8bd3fdbbae643bd9a5ce96e1cb8a57ea4e3bb105d88ee8a3c7196f4f61c8a3fb4202c742e495b1f4bfc42e0bd2f48d8857891ac2b09f04dc75c5930526c0603a32fc3022c577f21b4b7fc4531b89d389a17e2f67ee59432306576e7877f1ce80df4184b68845a7c30b277deffe4a67cf5c2932c130080eac9a1e219b329a9e6513ab1a3608b6bfb34f93f8d21ac3d91bccd2aadcd02a19b4d13d2c265c8c8717bf155eb7b1ae1e68d2c849677e3b00d93738a49340179e46108d6ebf1bbe99f1edde6c34fb533af8f6eaebd1363e87c1b1fa0f87c3b7f7a5361239d0a700fc0e7dac81bcd876ec6420496b7345b405827d08bc26e9a3e674665f06d2f69d23811c395f76619dedac8633482607bf47303329c177118f6d240b798dc2ae2b935fe5ff4fae130a2de925b9031524c3f2776240d939337768ad2127e737b6c3b588b42b925af3252142a1059bdea8b135d58f17fb2a40a2a4c49e31623a362d5c63ac8dcf2f0308f9716f3b1649486a595dcfceae96f0a4065c40228a980c0d6ca76a5af4742f2304df12dc46639e418be928bc76d2c50de701954ee353b88928ae9d4d53d08ab1e9a4f82989d188908e1e26a179b5d132028457db50d7ef2a3addbda84f6dacf8ca55bda508bb55657844f43c63d71e677f82ec315f55b2301e93f8fc391732178b3ac940ae70334388607aa308b228ef0008f480db04b39cf245c06d7e4aee6832373099abef8052888bb9400aea3b1ff92189afefb85282d60f1948492e98695b4dfd3a9c26050d22ef27a57c9d8f8a2f868d6b4ddb1a22a13744144ca1953ec39488388e7d129524120db186cffbe756837a9834398e51230ace2700115e8fb955060f6eb0c14d2517fde8e0ce62077405b70d489084e1284467126c2857fd8620bba0093b88055e73a2d515ef366b088e3cb48b1b64082e33d5381ff35b8c4f0f69f46ec540345d3f737cd9c5576246e743e5d9f5fd585e24f7fd3eac69bc6807aae3b2cd2492971ac1e353694b91884b78c592187c7a639caac45e44a3166a0c0076d96c00b9d1394c25ec583a40ae8f69767db44076e1d31e4ce42ceb8cafc8d7efd81d3e2cf640f0ddabf97e39213730c24e055b1ef0fac2eeb2bb3cfa2aef43826cd06d371ca219924114192c8be98409430d064064c8e2108ba8120393233e116559602f557ae78bd26d3d43e3369c2f40a0d79c1a9611e455ea6d2a61d24ca97361151fcfc2c57e39ea448555362c915eb8e436eeb907d4c27412216b5b1952f32a4c6606656c552fca489422f4f03674934877dc233e438ee14d614b8275004877f917723fa73d2a99924401b6423a368c3a81a3e2e6b7b2a3bf5617a9d1fa31fc5c62a0acf3e8b46b0d5e3410db0f7ec5a36fb68139e8fb61662487494b8c7c80c729cce95b69f36c9d64adb2df3b33a8124492e9309207a5b2e4254fcc358bfccb57b3271a00dcd98b82bdf6df484fe2373a3e3c2e414822bd483f34a570165996be4d94034d38057114f1d50451f09148bc74a12dca8be373e7997b17a5bf8d394376768204f534bf1bcec355f6dbe33598250be159f17033e918fa0c0507680427d69fb1bb789a011c4f388f321d97baea96a1d59ec7f3fd1e401843d101aa7b2a5718632290cbd90002b64549ce7059a9725ea4fd9a43ee1974b4ac890592443e8c60e4badccba10a35dfd5fdf307a764c19756bfe80797d67eeb11a794b816de748e70e2e108f1b6ed69c0f761e3efcd816bce351b46ce1efe200e6652e55ec0a597b56089f2c85b2c0c14ac1df8453d45df2896519b3ea55653f97ed727ed9e15262be57469dd3fe390bb3229fb950f9d68fd94c881d46a09000a1873a7d63f11a84fea657d81ffc6675fabe14444ebee7c27d6436f560d22b05a283b38ae8c690fec298eb7baa1cb9fb0ae9936e942e0a1aa43fd0c80df777a71d18a932f122543e5a00bb5f416e1184ba4ab995fd55be2920c59698fff5ffc8af1305eb5c60ca1f24bdb608dcdde7ccb885d5ae84483fe422506e928d29230c2fd973781f8b561808692ae1a72ba07a2c68193d677422805802321c9d902b424c460e84612c3c1fa6dda7db1a08bd25a3515f94fc6bd69427a607ae20736c2dd441e7aad1f72e35fa7ad11f3244a8620e80db35164504854e044ef1d73b7c9c64b462e20ae199f79af24ff2f0e98c7c383f1de7d203f02415899b0fb6ae8f1524c6ca88ff4da6a1efa9f65de01c48d1d53b6268b6782518fd1331bc614c715fc6761e1a5fe05fc168dc91dd0e128b78e8043d7de0d97c0ddab851d748f1fbb205607a34e9a9714d8fd86967b1d361d3d0fb62ae5f1d05d7831232a33b622766dd4a0e4565aca6d83581792b44bc3a856a98b1406927f831ea8231db6079dcbb33f251eece4b0243d5f190a578b0c04c1b1e2ff85cfee24a05846326f6f4b771b4277aed0fc41d7215b05e79921f29fe75936e28c446f2c5dfc7472f68044540a277bd4c595999af70c2e899c435637cbf153b6ce19f549154c07bc350e85687aeab0140b046d2fcecfb924035b518fd522750a6c9302c483f2efeb23223eeece46b33072a597fd2f5bda81240e169643a1c1334ab3fb1d857606d361bd6c7e4bdb95abde77c5194d52a5c9ba4747a89eb99aa9d2327a6110b10989b9851eb5ab0177cec33c391be03c7dbd40c8cbf783d05b805ada95832204995c107b49217689a35ecbfa47d6ff1e5798ff1f64f6290ea1f5508f1537af3e0880fffc026939de75432d2f01e2778324d45d821accdfb742cee5f86dee2d596e43a51d1deab7ff18c4f194c21cbe99ab5fc6b8c2897dc92531dc4acc1694e13d438d5c28a4fc0b5344af0c64074ad3752d2bd700efcf6cbe5a61022e387ccc77614943fc5e10c37ebfafcc768e74253becef28d51aaefdd38195c3f812d5819879b2c2b96b914a28ae09f44e16be4933098afbb7a09e03bfd83f76b15021537db62ba746c084e7d576af76ef51138a4f594cdc3c3288ece523c28b87c1b9c4bc0e04393d94a811a1308a611ff5776df6fe6ae0349242a67b1d968b8d18c00de787c25dd82662cf577077465de8ba89613b93bf416081ac84f09c89e739d8bfe6675f9fc308c7a9c4dd2493a88cf01815fa9b3129fa49a8d858ab5ebf4c3f07414cbd1486b261dd042731bdef45721126b26b160174fa689cf972d0db458c59aa954436b5714ad13266330bb1e6079cebd14ddf4d40be25a9bb3d2a184cc089f65fa6d0897fcfcaa18eec9164115301306fccd476580f53857fbd1bab25c524eea9085926620290d248351e7b4f3f79e99f6e3ebd0b86083f91734ed77b06a8ad493d6c0e9acd7bfaa488196eea0799ede299a8b4454860c9a95429e79d18c11b764526240b92e425996357f96d8954c4599e8e9998fdc261c469dd6cccbd54f912374c89ef4dc1400f9091001d54c6573564295c635417e27f9295ba4e62c725dc09b0b9accc8d3947e06ab65e8c0be43d23a0343f3fab3d328a6df86ba8aead11de5e261cf60a97a884b18759c6f48c94a6147dedd1b341aae6c246ff1ebdb9446c3090d366edb819b4639c190042e6ddc1829e585af923e4bae3a7cab7b76bde8b279253f732c1f4919f0f8651757f2c6ae830dfacca039dcd1368bb9d7cf4aa36290ee9607c7d019a26bcb7f5a5395b13cf1d5a1f69e4515cb710c80f2cb3d77a0334917b30ff36104f87845991ef8c9914531ba8e3b3af96b4e649bb914d52e45c821918580cf8f57d4f0ca8e4102e2250ddf103fac487400cd05b80965327c7de310db2068d3f0602dbc16ca0467152f4ef906f2c7abecd82d99c0c1b93c20681a24c0149a15ad54301ef531f7719b59250686c5acc7b6c9bc0248e7e0e486de6b4f1a8d7711c2b1707ad2c6822da09d1c6a775a17aa08e9d3d31455c521c69a485ca1cf216ddf64d9d3174dc6ce53cd4ccf6c3d4fe8f5367e9f5924c380d18f04026ab49b6c747483f9e012b26132e216a5664217dfff7c572b38ace53119de0bf7b4bfed8ed0fe339f8eb51952c7a173fc9e48cb990fabc0e1f2f168a64b2c1947376dd52bd532c95662a4079cdd997a457b0cbaa33620d9fb7d9484b7a7157eac38bfe56be155d0b45231e76d968dbd39e537f9cfaec433da4a0d31b0d6fe99a516eed79b5822350e231b436700c2e95d940b64c0c6569db921d1b3b7f3a38e7e32cb9b15cb169f749aa757a3b546cdb939e4b49d34c19d4271699146f850b5b9d197e76488916d5c2fa5904ddcbcd52820daf14c389a653d445472496b93023f9b75c3b4db3a0939825315caa78751b20a2a8248c19fd42c9c5c1a80a90023ac5138d6dd76a9c245dc4ce2828e5675b439021a34c64066dc2ce3ac1a2b38f9d07b7785edc4b4bc4a5964bacd096712a6ac236a67fa451aa7b949f453f1df4f2e15d90ede40bd17799296a39eff11ad2d256815c8b66c3ca4ced8e85a3aaa0def569e8ec4cd4f9eab1d80291f31db250259995d454734cb2c16d3c5b54bd159cc8d5922e00d6395d94ddf80b37ff085aaabdd4d37b7057a46bd89336f730670cd4494afabd18996ad59491eeabaa954b23aa22a2f552b8e3b77b4cb769eb9112b90494891242db80bd0a0654f07355d53c68d6456bb1e0274440110206d738ca0861ede644dd8055f6018430b6af33ebdd70b805922aeff9137651704c4d2e096fe676c3d1cdb796473df53e0e19e53a99b692ea2ac0cf6261296bdf0aa30eae4c29476f9a44d489cb01245e9d413dc59ac641d2fb99c684ded4f5d1f451d66c4eac09c3679ba8232fa6d75f21044fca4c430b3240313a51c26d6e2e9c6f6eacad98a7135f7c2cd0092ce9b914bc76c8a3a429bc4f6f455513e84275f18b51a2a91cc4e6511d4447cb157af26ead974653bf9e58f160c13d8cc4b37ad2a6da2ba11681d8e33b1cc8394572148b49f1d4c68d134708b3b7e19a2314ec4ff6acf5b276602bfc8444ac84b93a0d755781d0503c4a02371e5e55a0dcce09235a169cd4902ceeb41556c995fa39ffb6998815d2c9f0bfba4d3505be477ab3bdfaa7894902c69dd8b0cb3fffb90ebaa4370d674c48e1dec967dd90d63b19e47120722aef0068fd3d1a355aa93abf880d9e5bbd8fed32471563ad47545737eba74e70ec196650a07d5e122de4c4a7723a083ed458c490697de538a845575e6f4e1808e2fb4687fadbba5c952ad725cb952b7c8de6fa660e525f425f92026df7b16751c27ca301aaf691b3fa62ad1a3dee0dcf6bf1c416724d4ad03c8225c53ac64b250ac3b8aa94e4853f0076cc1c7cde1a94a6449733192b3c7e000e23535ecb67380b9fdc8edaca24180ba58c7263b47142a7918d9bfd172e06aaf8ba9dfc220073636c2b1c9633c6387d62593ce174ff90172b2d270cd9387723d38eb4f4aaf0ebc49d9907d687020fb5b614ddb457e45857d919ac319286bd5d059cedc608846e2d32369834dc6a455f8d8100b6fd2b55ffdba91854f613e6020c56015979a65f543105beeb58212ac1cd0324e815cb0e95694d5ad14835269f3ce41871b7b8727e55cfe801273ccadc065a2ae8fbff5d11831a2d2480a45f1534a23f5764328eb27e22960e696195b50b86b0c12255549c3dcab5579f583c17419cc567f0ddc2d08d2af3c7368ca3d17e2103a74143883a840df2f8191e9fe778fb1d3c3858333690ad1d785bc3194d0e04a9c8bc426c0aa01a58c139bf918bfa80b4cabbfc1c8d759294f745f9c1ea4eb18450efe4b90983f392db3f79049a75a5a7f4bd18d64d03811d2d12c12ec38beb32701e6011825abfb5c06482a38c6ff6bac866586d5595075a781370da0ddc13148e57f3bc9f6500885f84825ca7374244148834c408ad61667a201ac6dcd6f285841b5fad00015cca3d5ca0e44ac8a7d2b8b506f74bb81106ae3f5294b2a2ec9343562fca07533706c333b0e0f0d3048d2f6e99b91084783b7d32d11ed35ac8ab0e58f83c33b32b8838315896e19057cd6b9bd7ef0c50a0cf871ea2bb47c963c64e8dad4039ebf3916913ae3af39e01f98083c839d67bdcbca42da8d78ce70b407a2c495dd695373758292064f06c7950a5d50aac5aef1bf445a85812c00881668d9b17bebe7c77111ab88f747aa08543299d2ba4824fcb6c6e634c79f26673216b4870b6ba0bed959fe86a1d34c984ee7e8f79a7bfa3d008f2fcff3228bc284dec4d7d54aae46545b4bfc3ae9f54743298a76384e0e88f845c7bd83215a646ea1c7316681e526013ac2d2f072d713e675d2c33a16a35181422e67a2e5e175745323f2870ee34531d0c29ff65b27cfdf079043e81e58653a47ebb128375b15310b64806f11f1fe76c6978500c5a2481f24685a462ae5a4d8bb76c8278811157bed9fbbb09347cd8ea9459d2970770c93f32406f0a6305bcdb8d2a20fcc40464ec5af13d9f6945da561648966d360d9b2cfefaddc60cc50cbf3da8a4915824f043a9c1c402d4dfd36452ebc5e0c2b364c1413813b91f029589a39af4d9010aa0294527f95445448d8d0c9a922af21d4e5e309d031527bc6ec081075019daa8000a6ce31778c4551b5a010224c895db0cce82c15e2ffcb86c7f6f8e9b105fa52e99014dd1013970fad1261d41216e39da8c326aab1f8a151295b12451a390986f8097cba1b1fda3de76c8b07839e15463176917b84d8ed8cb6817f8c9fbbd712e8ca7a272ca49b4febcb79ab7416c3ed43753646fa2cbec45ec1f8f07ed929f0e88db1c9e5e4c629c6bb3eb27fd7bc5dd47ed081320a505a8e0252af2d8c1e2e59be023e3a347eedc2b8bc79fc024e3ed7b3e0a8defad2097078bd09aaf9431cf07c7646b3a9456d6819c1ad7bfd2cc2a1f16f863239ff7b7646a997faca823c46fd7a9a50b296b46f50bf9fefb3f527f5c4f9a24391a3ece0c0800bc026b01e75b19c908352255bae408a56d27ed4bd57ae8b4a0c7c06fbb7af21fd3f9cb667fa3f5f428d85a2a9a5eff57c3dcf2fbd7f359ec3ddc92ed5140a5c1cad6991f0a58b52f50ea2da8079caa778d6c73ab143b839cb376e6beb362dd2eb626676c05090f14ad21000bd6c7e2d895271e1e52376e4977db4408147f759222ba4689a9a913e93a04a9b58382a32a8021ceeda5a7aa7de9cb8e292d24d64d2c183fb4d797089dd630a3121761476cff3e91a6fa1fe59026149c43f54683689a17de9008a5f1d770a027f6a928b300146e63883f6bf691f6d48d1051df442d6d8570c2ee810c5d9d3fca532e5da538ed0a4ea91ce0c52d8a76859f375c787aef24f88741d7972edcef733c9ddc5e4593f6ed38516cd1a590dd16caef07e39e527a9b4bc97533bbba87b2a0390b9d7fd5b7f2ecd56a6bb252ec302a97d7ce63e6ef125ce0b9dca6b948158373b7c4840d4ca1c4eba94edeb431bccf8d8098147fee262659ed9afb2108cf62014cc52883aea2a11fa7ccc70b7daf68fe64ee1fc1320f2544d81c07275946df93b1adf75e5b3d5e17436828e5854bc85a8dcde6ad13a00a3ad2828fffe2a2fd770bbeb317e9e8601c6ee1ed93a2019582bf0bcac89f7ec6cda794a7727249b0ef50a299fec4d072ed5d4bb658bf1147ad3d903566a8c2f99b0b952c928701a33e62b62b0d2924a530ff3a5f778301ffd985063c6f095d0e9564b701b7f16f55b120d59068f52664ef5d794bca33a9ef6dbf93f0b661ce9a6082f23a0ac5c4376ce5ef5728c6a2957ad03764b07ee2a2c4f6b46f7efa6b1f2877050dcbdfe1ef19f86c4d0e245ba698893ea03f51923392f5ccb441accb481e3fa6b8be03ea38af8d787d62fbdbd2bb10112ff5ca09e92b01d32e51d9f29338fa127b3cd0c82074c5ccd4277f9b67abb1c2db6e03d8619450a4e88e98785a89488a7ffd2c57c9e5779e42f4482b1f251c35238def368c567d517177addeb62f6b78010396c40ce02a4631eeafae8796ede77b4ea9311e255021ae861125023a4352f4f387d7ee39c7dae3c05f511bdc1c827337e183fef9200f80e83f16d607385399bd13e900cd7f23123df143bb252286d1ab0b1b68f141c6a6cf152259e1e65e805be71a6539b89fa78f81635d4e0a84a8368cc1cdcc95c78a8798216b06320decea65441077dcce1ada9dcabcc153513c1b6083ae37cc5341382cf89a1758d9beb52c0458f27a78e241c3215c6522bcd4e88aebd3701040b789cf17ee84759da230dbaf0b0718fce48299e606cb3c219947f75b7175db4d74ae1d151d0f85ccf4dff9a4e749b903ffb318b2df66c19a039bdad938a1b1dacfa7b6106fd46196b62fe162474ce8c1642665e0a826dd1263f92f107e54512cb1a9fb4e1396b0dec04816d864191dc3a28a9007d87cc03553c9582f183eb7f5d6f5a5fd347f375e68bb8be87a64ec3a8af321097aca23538d8cebd8e177949b14fcf5f059bc088a6e1121603ebb17b587f65fe784ff4f3c3009bb3208ea5d9f7044041809d1b0f43fec4c83adcb400bfb71fa85decced93aed8f712d1e56630f8fdf0d7c28a6d87847d97cebdf0bdd74cf1df5d3263468a50d5c6d694bb61de9cbc09f4f04da2d04e8dfe6cddf39b0570953a9625d216d7eb5f98b6fc7490dea6e4c2eef7779e4e9202af01a34d1d99ae708f6c9550820f8f2ed73a4fdeebd5b64094d89ffae1b09e338859738ca93b43cc52f75b8a613fb8653cf1df8ca413152098fd5ee4f56591c2ef61fbc52e63f7383236823123b2026470a5a20d9daba3540b3af092c0cc26920b1f879f7d7267a23ee98ad22d4f79164926697201fbd60efefd72ef564b694baff0bd2ee95db5eaadc578a883084fa9d229d6368f48a192ee65f5b014d95e5e3187dceb189ef53fc55ac53ed3e9bae2cb3a39d73ef7b4ad693056618727a63d4ceed32eb999a44f2f8827fda18b1d4ac79f1fabf4b188e02a2f9074cbe3e1f521d1423f33420dba02db019c629f7cdbc9ae03b3618df061f5c6dd46f99b65e2091dd5681298402f1ce4150957ffd5cd3f1cbaf262c21eef8ad759f6c114dd901a59c687910928b523d023d06aaada1c871373a660e95fdefa9372a7abb7434eaa4202e5967135465c2a8e86aafc7732057ebb57d718d7fa256197abe5accb45b03d12fb39961263b1731fae83d21055af80c482ecf72f7e92a551173eeebf5068ee5789c331ce0e9e95e601d54b24505df34f77f2179647e21323903af9e1912e2488238ab9b86872f0656aec7d3aa1f5b8341de27a53915f4dffbc0135b55d86045bfca57f25701911fcb8003b37aab3b8c82e69fdb2dc937c62fbbd2e52a7e14fa7e12db755a54d102795cb6bb2c21d3252f863821f4ac8647fdc649de3498ba6f6d3a9b9b9ad657cc79b35f09d3163a96767fe9dd19155ab45556234595dd64db59be5e39446cbe38413e117e51c64849638cba98379493e890b937ea62f60b9129b7856f05f274c3790b83af06f38bb3e710332a8362de247252fcf34b718d8d3616611354e608fe230b51c1c8a94ced8ac21e20bc9e863467ab2c74f4c84abb4783b11b2fcbf05f4d89a11065cca4f23e5c10ff2052d9f6d471f46923e6de0662bab3bedef71b85fa99c4afab14a459ff7dec917d2597d2d05653bda4c098bdf357342443b037147b9f49b479e3b04bebabae035355dd5901a0be369914a3b6c54b2589f593405e769f5ee279a41b7343945ba169c7f3a59b390872b340d608966b1b183c803e40816cd308da2855edb136e24a2880dde72e5c74bf4b2af4a3c7570a014a59dbba9858439a61b68d2e0cf38af015f28bfef1335fcfbb777e911a2c0df861fbd371b937508f96462902b95532ea26cda140e1322a7a0d6e7c2d3171cfacd3f34482a12218114c2098f9706b9ce3032357ee2bb7b6208017883c03ed583a91ee8f58774a8bff62a47a4a007c3381b99bf43871d268e72426775185287687448103c69339e6cff5919e38d943283b73e8cd58c31a54381eb0538593dacea914a2a452088d2ce7314bc163324257dcbdbda2f2732f97e6777feb3009a61024ecbf5eed33e88e277dde7bb397d5f25422c2b8fc1ae5efa8ac1a5e89ecbea5b15502158cd603b19669038bf8a8d745a9c9cafda19738edc9e8e0d517f04ae83d7002671bc079fb36101d7428d5b933ae420e749c1fecc99876e4226cce475119d8a1e6127865c1ad3d188c8bad862ac6d3e13a9c7bf63f755ff505f50b38d307676a4a2df2a5fbe2816ea3acea80d812bd8ef36a1c31e222985308175d3e3058ebead1889a96fa180eb124b700ead2bf54f1423976a4c6ad7ec3dddad436886380cf7c2383dc25edd94b4240f0646838736afccacd8bfa85282853c279bc02b00ab7a853bd2028fb22bc8b5c8d1c76743978448715dde982f05ae6ea90ccd41c0f4b60af66bcb7ed18a5542a65b712c9d9783ee87d3017a89ff70a613f2c119ec8dc1ae1ea1cea4b3480842c1242cedbf8601b08c2b12327fa6524252d49958bbd020c2dd7b6f21458ed738269d2e7066dc5e1c132a03948bde30b3bb819ac0f259ca535e2f3c80888379f05ecc25654ae3b30d4d2401b195059a3373f303c73596b87afcef217aefc7a04061a883561eb318404eafb15f293e66884bf1495291a90bb280ea0adbc0b3217e05a2009da920a59a0fd10a6e2abb0aa7050df91a5088d4cd39362c28736e15da200653948452789073ce79edf936aa736da97dbb7303f1a1ff9ecb43a9427e5b9e01da2e72d570344423fd4d6a5d1c49fac38b9c1b3e9b6cefd99b274f5487cf198c5f23bb951417408e7458cab6e7acf433e55c4b8feaca9e49104246a03c71935bf81ae9634577b58d38dc424aaed4c8212a8dfbdb1d9d3007928650c5786a0d686adc5aa3107ada5ca78220fc4aefcf1f167f833398f5e3d01acb3fff722c90ac9452eee7c69d7c0a285771f3be1e180aefd3233d9ffb0d2c96c8507a63b411e761c1ad06e50e41588e4c1d852fa533d1d429a3a400b24540fa2ebf706655a0608b6bf10134a5904cd2625b7f5c6139ab21fa34e937efa7d380238dfcd5840d236f5872db1eef215e5486d649264bfef6ce1e6e8b984164a05cf90df8999aa325d597433c105d5f2935cb05f401d2a618721ac68e9edc3434b69ae12c3786746ca1f78b5bee2b0f393350f70fb914e89d019a9363daa2c754f850128c26c51ba6a6227ba43aab49882fea38623e90aed0075ae367d60c3558692c0de15b8b94a6ad5da5fd9f515a406501e469f439e0c19fe9f7bb23973768c6d0145f8276d22611f11c06aa7340ce52f619e1616900ee91a343a335457221d7bf2a8dec2d8bed63c9b2908082e34e4d5183035c5363dccb1c528d478fca223de4a615e6b6ff1fb292e72ca1430e0c32b098f79b82e9cb2c45a8e2c9fb9226af6f6cd04a96bc255b721e052fc64a9cb8eb0ff2f6c8019403e0495344c0a1485b5b008e3e93d8b4dbd74e31095af96e1de9ab75202a057c2adbf4fc4cb9bb3ebc9348c325190c9fea4b608ab4b9b1fd7707cc2b2857114434df9d69c3ce9ac4e7da18cb2753a2d14c03057d6a7c66f33e8b486eefb49a42d9bccae1d2d0a2760e4bdebd3d8df0b89b09b77050b37d39f1efc04931e616026b1c504b9515783e49e46eeab3a7660c64132ff27217f3b4658e8830a9dc024ddc848dfa2f6fc796f7f99e1f8bcb58c892ad0ddda00f0c82e5871cb4dea8d812d0dc77e5bb58e79e9ce928288cba9842f07f1cadf50e001f36728298f4c4f08b688fa7ba2a4821bd36305039876b8237bf5ad3bbfd089fa6cfaa888bc264905a1d9b152d2b1cdba3c91ee0ca8f06bbbe924dc8d95b1d1f958ff52410372d860088e2007bda2f43f7950d867249d9e13a069bd7a912b0c9126ca4717a62b43f62f888b4a1eaf6ffcbb855745f70ecc25ddb16a1f850e78ef2d186cb24674144500c1600b47b467d7d008de8fa63bd4da1728bee22e8dad32c471a3bbb67c9fd94edaaeb5f9e549ef57d72471e731fda6e6c900685e925b65097ce31f11f8f045b3b4285cbc36ef0cf515beff208a04bacb6e1fae2cc0be1dfdbea2f92d848204ad7a84c4baf057ac47a21b99a1bbd27a483cb4b409cdebb99c649044a4ab7f6fc2e53d0cf22bafd11bd176e624fa707fb2ac6436dca3f0c3022fdb51df19e3f8ee9a70c6754453d6aec41a9fe4c72be8c2323c3ffae88cb514180bbc662fd4cf73c653914979783eeb06f4f4495f7fbdbb5b8ab67f8962c797fa62df80d2ab00c0293f7dabd1ccb17237215a454d13cb216026e013f4a7f8917df826ad04dd7f7529906d4d84998f80fc9b62f835b1e04cf2ae7543436a938e74e59f5ea1165f6614c97d82fb88946b56eca1ced3987c4b52ed366d53cd2624402e675ecf6be774db2ee945e5292eecab2151465d65ea2b2f989760fcedab4812c75db1039bd4afeeaf17bd3c83d454767c2d016d08f71cf4553296c2465e18b308207bc36e6c0950b55b6d243a06e72c4f6acc963b2983328d92c362af1395e4e7016e5494f0b5d9afcdb1286345bbffcb5a9a2ff694ac1940d4aa5e2f0a0367986efb1739bd694bd9c228fa5e7b3ed71b1c15c18371248d0b1553558bddfbcb54a6dd84e2d5c6d4a42f3ace9098b890af5284798ae878662c8911978800f276aaaf8f794c704426c3b07508aadc1f04fda9238e2d0fa633afddde32492c2bbc8486c8bd125db27a37d72e43ae6acde762dce2ab6f503ec331c9464f0db448f8c12d0b97592c6b17c16a91878dd24ff7ae664cf08411084ef9e0e65b819a94da1d4369578fbbec502a3f23c9a2d7edb66263',
        salt = '361a6bccc9d96134662dcc80b99b33db',
        labelError = 'Bad password!',
        isRememberEnabled = false,
        rememberDurationInDays = 0; // 0 means forever

    // constants
    const rememberPassphraseKey = 'staticrypt_passphrase',
        rememberExpirationKey = 'staticrypt_expiration';

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param  hashedPassphrase
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassphrase) {
        const result = await decode(encryptedMsg, hashedPassphrase, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        document.write(plainHTML);
        document.close();
        return true;
    }

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        localStorage.removeItem(rememberPassphraseKey);
        localStorage.removeItem(rememberExpirationKey);
    }

    /**
     * Clear storage if we are logging out
     *
     * @returns  - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        if (!isRememberEnabled) {
            return false;
        }

        // show the remember me checkbox
        document.getElementById('staticrypt-remember-label').classList.remove('hidden');

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassphrase = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassphrase) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPassphraseQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPassphraseFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassphrase = hashedPassphraseFragment || hashedPassphraseQuery;

        if (hashedPassphrase) {
            return decryptAndReplaceHtml(hashedPassphrase);
        }

        return false;
    }

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        let hasDecrypted = await decryptOnLoadFromUrl();

        if (!hasDecrypted) {
            hasDecrypted = await decryptOnLoadFromRememberMe();
        }

        // if we didn't decrypt anything, show the password prompt. Otherwise the content has already been replaced, no
        // need to do anything
        if (!hasDecrypted) {
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const passphrase = document.getElementById('staticrypt-password').value,
            shouldRememberPassphrase = document.getElementById('staticrypt-remember').checked;

        // decrypt and replace the whole page
        const hashedPassphrase = await cryptoEngine.hashPassphrase(passphrase, salt);
        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

        if (isDecryptionSuccessful) {
            // remember the hashedPassphrase and set its expiration if necessary
            if (isRememberEnabled && shouldRememberPassphrase) {
                window.localStorage.setItem(rememberPassphraseKey, hashedPassphrase);

                // set the expiration if the duration isn't 0 (meaning no expiration)
                if (rememberDurationInDays > 0) {
                    window.localStorage.setItem(
                        rememberExpirationKey,
                        (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                    );
                }
            }
        } else {
            alert(labelError);
        }
    });
</script>
</body>
</html>
