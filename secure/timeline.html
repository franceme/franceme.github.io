<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #4CAF50;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #43A047;
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #76b852; /* fallback for old browsers */
            background: -webkit-linear-gradient(right, #76b852, #8DC26F);
            background: -moz-linear-gradient(right, #76b852, #8DC26F);
            background: -o-linear-gradient(right, #76b852, #8DC26F);
            background: linear-gradient(to left, #76b852, #8DC26F);
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>




<script>
    // do not remove this comment, it is used to detect the version of the script
    // STATICRYPT_VERSION: async

    const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 *
 * Mirrors the API of CryptoJS.enc.Hex
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassphrase) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassphrase
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassphrase) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassphrase(passphrase, salt) {
    // we hash the passphrase in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassphrase = await hashLegacyRound(passphrase, salt);

    hashedPassphrase = await hashSecondRound(hashedPassphrase, salt);

    return hashThirdRound(hashedPassphrase, salt);
}
exports.hashPassphrase = hashPassphrase;

/**
 * This hashes the passphrase with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(passphrase, salt) {
    return pbkdf2(passphrase, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(passphrase, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(passphrase),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassphrase, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
    const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassphrase = await cryptoEngine.hashPassphrase(password, salt);


    const encrypted = await cryptoEngine.encrypt(msg, hashedPassphrase);
    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassphrase, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassphrase
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassphrase
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassphrase,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassphrase = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassphrase, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassphrase = originalPassphrase || hashedPassphrase;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassphrase = await cryptoEngine.hashThirdRound(originalPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassphrase = await cryptoEngine.hashSecondRound(originalPassphrase, salt);
        updatedHashedPassphrase = await cryptoEngine.hashThirdRound(updatedHashedPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassphrase),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
    const decode = codec.init(cryptoEngine).decode;

    // variables to be filled when generating the file
    const encryptedMsg = 'b0fd7c5f9382c71477e677f23dff7b03933a5904e0dc703db9b1c3ac036bf8181a6f1235e41f56fab58071a9dc99989753a098b64d2c654930e3557af84f52194926b48fa9c5a83621f3e1d038f3c229604cf514fb345b3fb315bf6fc090ae8967b973f33f6e0714ef273d169060a23f16639ebdd4b37c93f775fbf12bd9f55fb5fa86c139b0319c77e08544533fabbfb022ee668ee2b3eb5e45b158123b8a5b6fd0ebce0786612753eb9287e44f4c831fe2dc24d9bce5dd4580d9fb4382ab145b8129925d738436dd4ed0532d9183350a3965b7ff32dffe5d7900abe22b2833eb3bd6c2641488f68ddd7643f5449d66f5d61ca76516642af2ac8cc20e6fa190f86340d4c4bfb50d83fce6fd9009745bd479edc6bd421e180c19b2c201525b0c2d0e4169913b309b4e64b9e40e820b3226b2fb27106963b10515e7fe812fa520aeeb6e6366f49e6ba328230836bf238a1ce4a6a8beccb08e678aedf42b60abb493cc2caf8648b82abb3f3e0b7f53896eca5711826555547f6bcbfc404f9b1a35d47ef88da6b6e154a357d037a705bc7cfbac68ab41e22ffb0d26ba07e4b92608bcf70952f17bd45edc86e4c4e0d3733ec997aa14ebd593a784d87c1c0566c1f48bab73690fa4d5da5e10c62e994795e51e211ad55acac8624523cdd326ab58d83b46723afe773adcac2db3d1217264febc8c8a43bce4667a624b645e4f2c114572c46a42e4d52ea32f2bd7a5b2f7c8a3df4155dabf2dbc75ed0e2d86563cc6a6a98a14ad785e95636ea87f90c84c7110cf8c846710f2a222d3f0a98693ab1040cd89b2689a32a5eb2eac91fee3dc77c2615cfaf36c82e247d9ad497f0aa98d50186471f5a4ed37d90ef76ceddb817d216836d74d4ec76991493374a07ee143d8e51c6a8189e3fc7731dbd15777764fd4c256ca531e40643bbb949cfc2a8b4faa468ed1a765c7c2fdc0faa138d74ac468e2da59aa2c1d8287ecdfbbacd7de1131dea8ae904fa8f45dfc60e22f977dcff00e5336244761d504cf0c4e996c759173bbe770f3ed98756de993f72f66f5763bcc3d6d1f27f1ae9aca33b9da6febf67d61ef37c57b8220159022371836692ee05d24e30d7acbe8ab91cf485237600ca68f3c48f10d6fb6538003ebe6a0f5e5fe48053a253a44b0943cb8842851bc89dc16eb41b2ad25a87fadced51985b9a227509fdc49c240884eb78fdd0f80578acda4ffcb0bd19e36b9a0e24874638d248d8e11e61e09e980ff6c6edf09095163fc35bdee484007a9cbef7b05174be8aa9dec3dba23e0a84cd5ad5db0549fb27d224fd552411d10e1f921b7bc43b63ccc99c416fdd31558ea7602e1e1a0c0b87b81f114c7fe1c30fd15eac8834571cf83749f71bb4f493490baef029fb335c16a94c3051f511b9ecfff8b74d165d89b17cd0a6b1c7dd8273848cb6030ddd5900483632ff25527e0d522f82adbb67d3f76da4a09342df458df009ba2d7ce57bd7eeaf863ac796c1253c5754c498028d38dc67b46b227cfabf9e3bbb0b3a6b952ba4c455b6aa49b2213f51095f488a2cccd326a2512b11b18c2ffbc0fe4a5506897cc688c13e0c0520101f1f36ff99ee5e69d1fcbc906b1ccdac218f0974d3dde5110457370e0a7011636f8da2f0abbcb9dd6c5731a2507bdd67b0645f5d643bdd22316ae175d8d8508655b2e686a0a1a1078f9ebce09f50c477fb158eab149018d55931577c3ebbba7d263c52c7fb0d2ef93c067c0575d834257a65fe6911438cba7548d8d7c172ce25dcd5eb7da7912a613b19f427779e5e33c7b8e8bb9579b638b4f4624b0b220c92e72891a1ec15b14a019dd3f2932c2e6070d40b67559ee7848599b863f3b9d9fe40901ab201db943b5e2b80c94ad8a52dc9bb6f7c84a6b6387f9778eeed9932bbef996a749a1240588dc3a87b831f7b1d0a61878b6aa89582b0637ee2209fdddf9caa0df82738446dac3b886cbd0e460ccc0a98e0448d048613593e4a9266c57737626906c6367dd53aa4f73d3720d3589352650ac2043ee8b4697b8ded111b3eb2bce51a9fb96173660d78acb32cb4a5a44e5d0b8dc2b5962e087933b94910e421973d351ae59b6de345fa3f0c02c5cb2a746ccf65906d762e4cb1430fbf7c02bc277409c7407f6a3510dd035ff11aa917ae88bbbda38cfbe4b439ff82fd37d38d0fc6cf645c3d7ba3d019522b6a22039fdc9dd322784a221f5f0bd0521d1ea39b22608e0d3cf742fc058688b7be2adad5e4e62c2ecbe199752d192a078776e89d4ceb1dba5d371be7766fafc4f171932233be994db396fdec195925b94296d07fcbb7d2384a775a5e7a50616f4230d25d7686f14dcbb56069930b2355a546a3827b2c9a65dd8a7fcec49aac6b3d711beec9cb6aa3320da6ae8314ccd3e069136956de7a455172c87f3aa7510b2f2331865e3c13549effda4d914575a4d06932997217c72d1d9cabdee5946276f54a2095f19e2559561d4a733c7648427e149c6f8a484ab6f0faa32c86324f08a84f87f0de56f2abc760003c840f6fff247f5e583bc61faebe95e361036d522cf3e00b1db0c8a943be932e18e01113a7230463efc0e135f8f0ca010456c998664366eb8a9fd5248226d4f6f6beeabc71b681001542b80c04e187b101c70182ba2842e79df8690aafa5aa09ad691c53318762464521ef4825b5f5ac96f1e18c557e6ac0a7e1701f3410e26f9a54e3781ca5275885fedeb24f6585470f093bbddd99d790b7e9bd183d5738fd1fc214076aa0f8068f68d4875dbdcd9bc0316b2eca04441d8a1256c868a35da44975eb82520cd541327d9c6a67c72c0721bca59df4017d7695bda88ef0a8f3fbd746ee54a5b6eaaabcedb07f67839f944ed99b251bc61c429c4be011c5b7b2dc4555d14055081eadedf01a3ffaffc97b67b29fab84554b63a48ae23f3cc44c71b509bf9611995f78e93330b581c40faa8586dad1d795ec4013959ef7e8db405faac64fb6c3a2778aea727791c48017704aa89701a762520b5e12c2c2f76d767854639c985acf02f087afea9f941a7eda3a5038fffb475270fa48ec2f7c74ca02fbf5cd969c24b202ea217eec53795a9fd71c8a26efe2c5f54fca49636c3b067e4b72282a3fa4a2f0d5fd6219bdd0eac7185064d62911da9c070e1171e4ee30a4900db8da8c956dd2529d9a6bc49bbfcf54fc419718441eab136877fea4ca1a70154a8216bcc668ec4edb05b2f41ae82fb9de76ebc967cce741918d15943a2a7df9fc0a35d1f5a09bffe6e36a70e0dbfede66d5acf71eaed22d51f49a4a62775307609d897a440127e344c37ec9d10edb2b777426db52d2e2a6e8ddb851dca4fbc9e68975664cbd3cdfc2839432cb4aec5d7239c29f1e502bdda1040565da476c86318b3ac6ec2d652680baf51ae1365fae2a905570bc3c885335560a74775b5d95b9221732b810c2203e08ee0a37c750e9a35bfda2e526e047321607a0c42f555b38cd436f9df8fdd1f0cb5b71d8e7eac2bdd32aadf0805ff9a2c0262f7ec2db5752dcbce34e77c226f7ac0e475bdd66f653cf1e5b810ecbcf907e6bee004c2671b07b092aac8e16298f79766aa52082a28c7427c9ba7920efd23efa18e7d3e206f822539273716b88de7b0db5a1c30d381893ed3f2059539beb17436b5ffd9b31f65d85c743fa14a89825161c87cf4682d450cfab54468ac1e244015e3f4463e8bc1a586b3a11c44dda370118d5aba9e3beed5ef94d016ece0d4a73050386693e5315c39867c878b3a9c76fe3327e525f71c99f020866e9348e16ecb888625de22e3f7e61d09eb9753b174d7f22f4fa1ebf6a28729630a2f438e8ae0d5efee47d84ed5f930da7223d92b59291f0d05c97502f56ad889ae9ab3d4922f79da6a5029142a8876ee74ccc47f418e5a057b44f6f1e7de7db0b3a6cfe0fe16190417ab0b7af32a032fdcbbea725b062808768adabc3c62fd41304021c767c818e3e2020c8642f85b649e1b677c18c2810a75670009c88203c9e5c496f558cfa5153ce609690ec641b0ae0dadeb51a8bb8c0b2057595df7ed83258d71c4a18ad6f4b45dae7188241edcde394c7cf098f2517c8d00d39f12fb5113e143b07d4348f5959fffc8b3961084c8e194f7f0f79aa912df9917a76267e145eb12931dfec368f48e8931c61f14f1d289f6ab217ea92bff25fdc0ab0867867333af3785ed05180173bcd2b098e6105754bf733e373c5ba3d49ac48a3750af4dd312bcfd9db4811a6acfea0bb37ff1eca644d0eac30c61faa127268bc08b025f24f2a0ad745c17aa15c21487e5b205ee60df0c9d815ce0590213ba82217531ab4eb7b0985efcb6061d11f0d74fc011a4bfc0eb1e67960861160eae8da6ee9c0683c2a581be24fc6800ad78d36b24579f0394e1b24e963023c2cfcfda0f6be33a4bd605437c7c4b3ee7a083b64d308cec633d04c304c1ad0d46de823c255e3695228a0298174158235a52c1b861e8b71acb32d4af20308321d83411011dfdc337c8f3e40e12c8e4e70637c9258377dc3eb0fb9b3876e05b7595e1218336c8cbca3651310b5ea7523785d8e627fba5f42df8f7e106db8eec00f5a6174da4e61af62363f2c2f1a57d3145f85cea6d6d5000c3388b099736f43013d6e2d0802827e8589ecb49f7e22b6d48e48ac4f573dcd10727846892394edde63ea01fb4edcb873679eddf030210255c929a67659e9c5e72ab49e6dfffebcdad4bf3640654ba1bc4b7c86ef0b229cdd18325650fae72178203514c1331d50587956a1cc7291d7c2a613ba4edcc282be307b28aa91d6a05f2e644a538d5b91164045a86d55f475991bba2a13cf72e9d5bb38f115b62cf2f95816c7d9319ae95a99eccf1fa314bd7dd8b77b133a7e232aba508f3724a1357f914cd874a877c0ec0116d00bd1a8f87923c31f39ccc494b10907f22b9156d6cdc09ef9f9bfd558d03b3bd957d78482ac83be8f672e9b0d9af5c8b7049af3c9348dd12413bf60546495e5242068383c56b229305bd2a90d8614b1dfd6921881e37172f028e51d7bf5b795df04964a71fbf35aea8e2daf81d29bbadafa03c80a5361eac8ce186cb80e9ffba7ac08607a7fdbc71edfa84a90ad645b52869de12a3af7a3f0de3a94d077bce5c6955de9fc95c7a07a716672a29373e11e568efba972509e23c2c1f190f41dba7bac69514865ca01e2e6eefb95c6543992b8f4cba3922b75d065b86b31ad8a6099552b23b8c0ff1f859d5c5f483810e216f42d07402b8d785f568ba925efa6132f4a8bc25f3f68e68a65a1b89b14da5498af892d502afe045a310f59f874f3734815099218d64bd28436f1e4a1cf16cf6b31baf60460ea436d85d8be9dc31ba17999fbf5dd4fb022c9414d8a93eadc3b9d84f6e98583c886170debd8f32f84c5682da81e8c0803f2baf5260db3279ba5853df007f95d464529cff233a62e353feacba56900f39652bb6b9b18b93ed3c4ef2de978a1e1f653e07e891e7cd5014f8c52721e5cc3ccbc1332215ff6bc4b9208ca94be4144d04d35f0573f5bab440caa8fdd2b7c3ec74b9577c4c36d3431b2b6ec476a4e6635a54722c3822ee0939f89fb208a01c0a7cadee84b2597e3dbe2d1c2bf7c313964a7cf07923000f50b442663da235d374e1dc338ea300e1709ad3aa5461211dee4ea91c4c5369ad57eeb565ada4ae54d3463b94a0d4eb6332fd5f070f15645668f8525c49d177dc1f55ffbff8fbc6187845bdf1f0805ea2df768a002bdc608600bc32c8e941637d29e69806ec52cffc360df8592f8cecaae01fd30e87d9e3b6a52aaaa9963ef97b1c9741afe34653b2f22028c3355297d786451d586fcba7876205c3b38209002c9f5d62cf27a1df6c492c1d19f554c5b8266b361301f965386d54348e266d017ad43f552b53675121f26416e4633046f79dd2d390b39e2115878c5c309d27edccead7162229fbb7d3f6b8d7979edda7f27193018529780a66ad84f95dd4833b277545c78d4286b803f6febe6d77628728419faf5ec49ed2980a9176d5e780e5378f323d821c28a384a6e5468c0d61c6d89fea3f469c4348f416680040c62102951db7bc4eb36dc47236d64973d86a8177d7fc9dc7addaea14aed099c3475499a904380591353a6c8d5080ddb6647314e418977b526cae6e4ac502e9d74ac76c536be645c5cf5a6cac0dba43367dd944517e230dbce9705845791df691454272c91a189166ff3ed6cb0bcfe34b158b600519615f6147ec3e02702e92eeafadeaa05e4be04984c0379b634f0b3b4f1f9d706d7972b76a8395539666a6480681fc8d6209a72bc8d4cd2ce3070338ff25326ef7676854580ef9c20b7e65b7eb69a57201ed34532da610ec915878085d7edb4cf69cb2f10fd1bd17cb038c58cd88f4b0ba219da49c9d8ebbe80aec51d51bcd823c09adfb411212de93a2f8251424f236cecf5a1a6cf57a1d0f411785678c8992658587009f0cf02f5d48d6b7e931f03b7e2138e5547fab3e1780197b94b3d61dc9fb2e558fa38fb27cc8d5b0e69231fca714db97a760a3aaad9870d89c8d576a0406ee3a4302c713e351bf9a492be54d6288fdd5f065b3665c794072312dba62599fc6a19906258672c25cc36d1ba95c525a6f5c6a64e30f4df78180dec1f1798ea1149e5a29630c895569aa66f388f75ad5194484799f991076980a00688eea821df964d0f5f27cac62e16109d6b2a3fc06073baa8d8b4a614319f63ddce01305e49b890bfde6502cdbcd073fad42e0fa4b75d8b7ecce50738b01ae64765fba20eae76578b2e37c26fc7c491bc08e2371d1ad832820e969f2b96c520da79ade31390b442482e4872eb63ce611947b263eb3e6bccfd85116812e3da6a042d0634f5f3a8d2c1e0057e88ecb992f1626ded03893ae4f880849b9d2c972902a49cdb31a1e45c6bad98e4b29622d1a1915bce9dd3d039c18cf334019ee336e9e278953f3ffed4292434d0ed5f6891eb8f7fc7a0da0097cb0008e7f583f0caf5e547f8af76f33c8302fe7f0e813aeeb5f5f1e22c4b62736f2726b972af543579a461b160296261d3946793936599d3ad814b87b1622a2647f40d2ca74517a15d25f3b7a7a0128fa93f09b5f02bd5ddbdf96b0046a221ead05e4edfa148e57181c772a109173855cd1e40873bddafafb8270b9109837e7b7cb017aba474d27d171dcaa6da60a1a86a524f13915510b54ce4e25cca2c6f5a5996dbb85252730cb46b0afc8220dfbeae38db4f913bd046317494eb3c826f0e73264fb35b9a52dba0ee265ada3205078ff2a1a43f946061e01dcfafaae66fd27b60b646a91b7c887cdce99535a456f2e81cf7db90ceb2fe26f354955cbd7e9823d0b87e579eb26533de45fc88d4317e8baa3a5e986c8d50d1b9c2e2556f84eb81f462e38ed2c978a8f0a05cc69cbf55116a49c18d2f2dfad5200da3fe71f12d1eb6d94b7b43648ddbb1abbbf999c9bc4eec75633f70fb9d0d19882ca9b4be187eb418a6ccb55c300d8cd22053f62166e8b38d26af9f357eeccbe01fbe7c01edcd090d2e85ace137968e3b9f0966a3eb141c05592708ea6dc6e7cd8c079b55f08c3b68f5e01cfd1bca2cb3295be4a69271b95979b7a2f11a4fef1c9e4737a1983b1bd489177be83262aa21ba0fd8e79369666c7e6dca490ddbd34b840fd714ffa0db403327d091c701b2d77d6cca9a4b543e7b870a19b4bdb8f7f261485dea378d2a98b3e4ae1e4c86c191b53106115774417aeb7eb7e0f27c8429762ad01d6b6315d51664b08c076b569b9fa4b44fcf0d0a66063b4da82943f79a7d36be8dc47a4681fddec68d5c57f1c2f36f865473f0a8fa8cdce2e28577300233362693803bbbc8ea71a9b93651f537bc05da3659b68bd8b0e207dcdc1b70556757a9003de6213a246bff1695c4dd473d2c5c3354a9fba2c7b890fc662b9e8b86a382d51791fd4c03d52cc6ce83362c2f04172b6755aa388c58a0405c971fe11f290af67727bed5a4278785927ffb334f89e3a3f131ee94b28453a03b86881f71c0873cd12aa5d8d22bb9fee8ed9b5cc0126266852e51eb129a7c7d40dc764b2f7066affcdc4a0bb89c1f83989c5af50f069016a255897a5ee799d71be2ec62847abb8fce981f06f84698a4cefc8af9254889de19c044f7c9c40cf1f1343d9a291084a87733337be563c22b42ab33d263a12417fc5b3bd6dacaa7863a03c17b292b0bf2d21c664a5e8efc7674abf1a112142f0f60209d4b12b92bad587d64d2f7642595000370934730fa7e5d191509be0c9ddf064f306aad82686afca9976a07d0b6f188c0aaa4732bc228ade712f0126ca2c3142587f6acb777497cfff272d8661ef142b46c64dde9357a0d3577fa6ac4c1d888c25fb15b2dd2f2ea7e43f1591d09dcd881530c82d481eacc20cdfaa6da8765582a3d3740be07cd2938382163789e784ad1d278ba99bc479fc0876cd8478f2996400285027d17447cf146f05adae0c06ea75b08a0efbb47a46d158108a22b8084ece7801718748d681804db85e1082dc2faf9009be8420b3a45fb86edfba09c8c37c0bcf4f1c9017d64b58ead7c93b41271166a472a66e7699e64296bed92d7507df1b063e0ddd1b2b24eb1d1b2e322612c3fd708860360bc1d5d81c5516f4342c43ee8b7d3ea53477d6598220c97efd729b3935eae24f59a9d3d636625f0e6b2db2ff1c5e2c3bd0e75b96b47c89de40101587896e7d70f9b67e9fc5b7ac3b8a1483d5050fb3a0f9bd60f3a2bc330b7b090980bed433df40728eadd1c96a3a7a8794c873003174fad34852a778e21dbeea297bd2b66a05b4b6cecba61cca12a66a5c669c58be5cf3b8f97f9d1cb23a710b33ce8e781ee7b13919274f565171cdbbddb7cea3ca050a1a42d2864c74a315fa7fab77d798da69d487962e62c88dfc4d24376adb26ab7385c229c249d3af885d9c8cee05be4f7de8d5817dcc38db7b514aeae4ab2e0e5e9deed6a4fe651295a359c7650986033ede64672f6b74ef6fbe7eb65b97885eadb3238e8bf4c34371a2da30771da08460467f1d8d7a07892b33b957d6a4ad35dc2668dc384142ba9bc5b5ef28863c8190ee25b9e75927967f864733ec12b5842ba459c41c212c03175223a21809bfcae409f668d275355ef3c867f3efcea4614f42872516db6f5ea3af3529990da3d4cc024757105525e4fd8d432c86f49a9d954f8b38836ffe788ae4b22f4530ffa584660348afb1533c5099ece67a023c869f0ca1cd95c615ba00f9393757ca4daa46022e4afbe026d3101c6f2374501f6461b8c0c794e42210367bb0d7eb49549f580420f7c9c63583e29ac6095cb10a65352cd07b2446696130496b7bbd964ef37a21e500a71c6ca8671545e998f321ca12d30cfbf6db8ebdb2870c841e76d62c2273a3d3875da5ee5ee52bc54bd3be5677d5646e15e2b6fe83b6f38654af58dc350a0915c5ab860555b2834c67be0f1f78eca371b50765269c900e6b395a8db1c37bf97644a9bcf674bd8f1824a558a14ee66496e67631e559e3166e56a509ef192c8ff3835bbf2f5ef7b332302055135460bc3f44ec0588109888f7bc09da539729936dfa032f972c305f26b2ba3b94a467b2b2db89e840a17a4993a1e1025a6bde7b566143183d99be8c66439a14075b4c4dc834b8afe204d6911d2f550da51c7bcc5067f0ef38addb02e226a04317fa9ede8a271713019b03ccc98a7c1396bab205ef1cfb08c65facd993d80eb7dbe0486249c5b1824955c16f16c8fdefc142f12f912add3d80dee38afaa6924ed3bb7b4708f6fdf9272d480eef80fefe5b587441727bd2125d963ba336d64a329e66703fb0cba81c24dfc7a944794c8ae920f4902151de51fbf0e0d3455c9b75c194bb0140a8e7c48098e005e11ce08dc17e4a82867897eb8f4f6b894e682d6d7f801f04cbc09222af2291192c08323c737113a124a299b3722c63264e581b85daf98a3dca448995a035bfa59c000959b3af0fc53b654e8e1ccd08bb52b9ec6ca506461244b7cf36971e54107480892aae753610b3395063d0509f5a58d85bade40973409dfca7d36dad6b03fbd8292e2912b29daf744b828bc54b46de294ac7b6890b4f89c5c6444c8f4282db099911b94c0d0383b68aee5e7f94d0b076d767cd68d8e66ea94ec86b22449e88432f004b73d29d286da76a82e031e60a7f6a39264e06f35f0e079a47926740c7231d4a76a119fbfce8302b2c335d07a88586a6deb6d77527ad49b4aff9e3e12c0f16676dafd4917a2746630efd855961623a2a73f39f2fb488b12be2ea57be68199b487b16059ad6953115945c1e827f4959f19f3ed67b2637ee423d2aafaf79100c71843c1e7fac22a08ef80a02e8b6f19b302f882e13436682160196614259091763d9fbbb38c2c76226a795dd86759d71003888062e7795d05816b0e60001b3008cd1bba6e8029c0065b2f6b32f1394b4e68a33553cefc3fdcb68e400d6d785c7771b4c15eee6f3b58ff197536f42ebe71af7d473d24c1fe12d6c6074c05270218df9bd5e49f0a6fee555854b1a21f990b849ef47cfeca2cbc72e07f4a6dfb0b23ef22719dfe4aabc9bbb772f15c931812991b57f50e6083cbbff58bdc07bfaa69905f436ca8bd8e7746e9fd4b985dee4e1b7b67fb98bfea3677d21e96d416d317c6c40ebf8df1e514476d4174e02aa954c1ce089191a55dafd38a998954044f5566a3fb9aeae6e83013ed007625bf839e62e17289be6031acaa7da9c918074665db0d92decdfbf3cc6e489f8ea57bf71c5da1116353085dd651e5c67f71a0bf4918ce7c558cc82ddacce948910819e7b510ff21e33cb785631f95e723ffc1c1c732ac36513079efa791acf5486fcf68ef03081b91fa9c25ad043a73d5081c6090f235c3204cff1a588e1a5b5c57133bdf22dc068c985c595fac6afe59c751479aa52d145f2098850f52debaf6b156fe4e204dbf67c57d290949ce7560a6c707c0e387a08bbf0ae53336acef6c062881bb874693f96ce79c41443e37d5f945d71c928619c9bb13e77cda15ac55531fe2e9a63ead4aeded788583366982faa813b51e26cd1e1cf1bde7bcd0b5236f864bac80ae9f821fd775d5a7b30e2306703264b8e7f61ea1331f56ce62f339afd7f4515824393a94733ddf096155fe6e339495ef91df4d570a49b9a921986af6e81cc447d5e77d36b4b538f104bfa458aff0cd187f815d170267268787080de4e4e4deb347f08b907509da3282b220cd1e376ec5019b15ca352f089ccc82c1c8bfaf84c38ce90e85b6072e94d72b7e9b341e7f3ca695d4fdb3eeab86c5d49bf28cb625ac1f8a6be79fabe44a653942ca11da0caeb48d8c8c19bb6cf0fc2a577a6bb009d9184f7576a0bdcc4db2f6486c9cd4caccfe23275736adaa0095e3fbf6f1ffb13bde2eb25c69a359c25dd4e4450d7046fc8ef3e762bcb8636c5ae18538aabc5510b9b48cec9a435dfd41134897a2d12f1b147e3efb719dc394ce997601914e88f639598a33a15398325b620c020d636a58d5ebca1427ec25126a14bb4ddb83a079ed9fb555449c245726f06b628fe4a259382f4b256b71f5407e642b1478a4facd0ad545c7fa46487ed152d320d9042697f37a8825d574d5314fcc79b69e0e9bd35bb6bad951dacc9ecaf8bfca06776b386fd9b7e2e6372d5607d652eeb53608f0e99efe50cc6d4a55268f794c2a34d3dccff9be07835e1c603239864caec1f1526d1ba203d485ce5880be6be2e4d0f2773f51a02889c7f56c52e7128e8c8b29c55d45fc235df1e2f6b3bdb8eddb1bd3191bd9f6a2f6883a21486beca4a3d533272f7f1f6c32f50346972a52f22ed686b0ab1a58e1c89621eed59ab1b079e1d22315627c651320bb32042ed2a3fc2231eb0962a26c2840ae2e3f5d592791b92cdd84b14be6f90579304a94838af51ad3dd29f85004235dfd684107619dae5f4ab33c80934bbae6233e3de52a79d6847dc41e159dbb3866e9a2a5d4d0e1b4944597787199aeb3738bede3dbb0c94bb51848a6d590027b439f82326aba5f24208abe18167cbd1092cefe3e55a674441f81df04e4009c3216adbc3220ad1c0dd8adde4a1af00e5c9df7a6d1236135c3647c0c72228ba8947e724591d6552300da2dc5e2816dc1079d122ba2dd08b6d3ede2d30cb2303525ef77ad8a028f57d46e663e01d039a0a41c3e258f28909053d7035a060811d47d58047e44d0f207fe84272c45d32194ceb218e413d72991e974711b86cf9ac3934825bd8a6d3b967f7653a408b59f78b308066b25896c307ead08e642095b6bd01bc0706fab5a638a9ea45729459d347228385f4113221d4aee5f94e2043fcdc9fa0987d63463beaa3838f38121068d8c75c640233d85ee363b7c3853589f08c8ac39a36c252e88edd7376dfb1368b85f549524fce1846cb960af8812a97b61aecf1965b0debac0e2a73499da7e8eb28f76574333edc1b8e2b3613a795547a0fb6435830f8f72b493c40f926fcf2749953530e0564259094ddca51d509b779bf77577c03c41b532085c14f919927461696d9ec77c02c2be46205408f6b452ee75aa43c7598d769617335641d64e1febf3e4a40c82ffd0ec1f4890b496090e0fc1ce68428a4ec8677875c0b293fc7da59a4d811da7de7c1dda26799b1c3794960d4951e40c5f9ef68109f194aa0c67501bfd9d9b623fd7eed241b3bb69def69121bf3e45552d3d1667f28a49aa256eb27dd2fe5c35fdf6033f6043ee6bffac1f105392bfbea1859260848045c3cb7cadfefa1cafb565238c3735bff28085f0003cfb9f409fed9b672d67c5fe2b6674aa1c30835dbee7c57f14e369f8fb98132143ac77d2cb5f1dfaa6637977f451716b0e51c472d7b72c61872a52454bd9ac8e4b2d3144393b2bc702338831ed68c73d83f952b3f54161fe54241f56482df16343312c66f4b50b003b221df6d4b3735eb61cb88c13c6b9bb2464c66f3d8f2f20dbb1d7ece9c3f8497893409e07e5731fb86f2eecd250d9ac7c72e88d4b75ae5fcd481fc32640077f79b2bc49a1d196855e08fdcdc03b52128341d168c4027b90a81f339a1307b726fd263391844d6f732f65c3bc191381abd812fb92c7ead994a93c92acb54933c3bb810541266cf2c0546a857104f6ae2aadbedd6c0b16d1aaaf16039f0532305789da9fbd962d7e4fa8c5745e865af5564c4623b3606ae202aa7a4da1d8600104b3e10058bc70492a200a427fea87641ca61ddef2e8bf8ce1313411e5e6e87759b554f9ebccbe6e57e8242d105b0135eb3884e476185bc4679fca80653da3b1fc201656227c92fffc720c0ee13a0504cfa7d036dbbbfed457700c05fd4aa9e279b1d0d6d22020c28bab485b6dbedd9e0bc0b3d058e31b188b18ba8385798ca12a54610ab3578ebe612e54fe2fcc6dd7b80b2131cc68a5629939661bd3f8a9fb819c2b4da0942ebd20229a603a9642acd0ff7751011d1fe898430cc62c87f38f62f2675bf9f5ea4fa82efef03b14fa740c66603340305d75f00f05eaea2882562c78baf0d39dfd6f213573c74a21272d34fd36430f672e50f93dd6f9c5668bab0924e00d406e4c2c10aea0dfafbf6b5681ad525416f7783046f732918e56297485dfbc2b75381b842bbdb788e0e1995bec7dd6f71f369a42170bcf35ebac51e294486536c0c5da78b3001b2cc519d536c877716a6140b03406ece9f7d29a03fde0b7d93e382cfdcefb568dda5c7800e3241bc2568d3430848b58c0bfa84788cee39b9ce77182c864c6527d47417351a337997539da8625fa3631bd3b42e90059d5c79bfc955c2597803ac0ca78baebd945cd06a793cf0a8e13099affa6c2e212a25871df32117929fd6532b6c78a114a3682a206cdb8420f33d46392d666286bd808c5340c7ebc92a2f546d9639bec589f99711c364a622967e60b1d537881c02b48345d600b8f82bc7986f0c0c410b4987c671b175e4c12a472d97bab2c943d75efb9ecf4d5e17b737b9f2f0b73011a54cdeaf16e75382c7c1c0e675bfea996a5f393fd37ce951fe7777546ad686ea7679126db8a79101960b1497a854bd8c28e89d38c685918f6710567a8b4ed1194033245d4b166dd856018923f553f4c581b20c55425cbbf4a2d13372f5c9fefd9fe6865a58d83ece07c88ee9a07b256f472b8f5b2fefab8f9bd5c297f61cb389eed45b3d5d335431417af7b3ea6da2a9d9d87cfc2f1773591863cafbd908aef38bc21c711814cba786c09392e38ac7271768c0d30c88eec52fe064b3818cfe34b9df86a8eb05b41fb83d9284a6d7504785705c3203ed205a5c092ba15e3269f5b7ce5da1ea444891dbf94529c20b583d9705028e750072702b742030269c18b22738a1f32a74d1a1f458836d9045c031b5682a0468db20a7768c4005674809fff9210a8194d8d54be9c9b6700642fbf64f178fa87c8c52e4ba44dd1b19c11831d65de0ad545dd77488e0316cb68a2b9a48f836e932144d48fae798980aa4b2dc78f5dbdf95d38304c50e41abba2cb634c78a2c00070a2c1134f448f8d7c1f299b99bd2482d8eafc13a5c3dd475538784c9561ed0fb572c3eae77c288a5761141c375840c7ebaed714c5b438744147b085eeb707e937f61f2b652705a38d474f94c6e9fcded5c6a9bba45dd37b9e326c0734c265c9dcba24c166d54124cab723a581489e901247fe2bd3d605e02465be4b8bb013a0a242f70d6067f81d080808b272070a8942405fab80c1aa12869c5237750236d7f6a4e335c9f0994d97aa7e44d8238e9c53cf0f95d91498993b92fd1eec4c6bcecd54e0c4d793cdcaefe86ca30c3acf7de4b24d49229fd43439f78f309d23bd081d8f118009e12518407fad9f22d7892dbc411a79e7e35a832311c04f271b2b4be874dc4d6601790cc727e153e6096709ed4603a5eb065518904a7daae67b7107548392980644727b2e49830e32e8780c296de324d8a22ec32a653a5ebb03d3fee1b2f9665424f460c56488214e0f44b92ceff6071ffb37156edad5668786b109e78f1d20096dadd24245977d44c690e18b75c053a91e7e6b3f0fa99d63e9bdadd9a40fdab21a5d8ebcb0c97427271bde495380e49279afeebd2faf131fee113d1790f922fad9ed5aab61effc39d4f25dc38f31b2e9f3122c72d70f32f65f426496be5f5936670ada10c6201b85a93ae1b50f129fe628547c29a744d587b3ea16c68d929b835ff9a65e808f7d3d94ea459043c118b19020a01958724e9a3983ee1318eab05fceff5',
        salt = '3c334ef4bcddae42bcfd19a036618fb2',
        labelError = 'Bad password!',
        isRememberEnabled = false,
        rememberDurationInDays = 0; // 0 means forever

    // constants
    const rememberPassphraseKey = 'staticrypt_passphrase',
        rememberExpirationKey = 'staticrypt_expiration';

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param  hashedPassphrase
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassphrase) {
        const result = await decode(encryptedMsg, hashedPassphrase, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        document.write(plainHTML);
        document.close();
        return true;
    }

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        localStorage.removeItem(rememberPassphraseKey);
        localStorage.removeItem(rememberExpirationKey);
    }

    /**
     * Clear storage if we are logging out
     *
     * @returns  - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        if (!isRememberEnabled) {
            return false;
        }

        // show the remember me checkbox
        document.getElementById('staticrypt-remember-label').classList.remove('hidden');

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassphrase = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassphrase) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPassphraseQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPassphraseFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassphrase = hashedPassphraseFragment || hashedPassphraseQuery;

        if (hashedPassphrase) {
            return decryptAndReplaceHtml(hashedPassphrase);
        }

        return false;
    }

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        let hasDecrypted = await decryptOnLoadFromUrl();

        if (!hasDecrypted) {
            hasDecrypted = await decryptOnLoadFromRememberMe();
        }

        // if we didn't decrypt anything, show the password prompt. Otherwise the content has already been replaced, no
        // need to do anything
        if (!hasDecrypted) {
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const passphrase = document.getElementById('staticrypt-password').value,
            shouldRememberPassphrase = document.getElementById('staticrypt-remember').checked;

        // decrypt and replace the whole page
        const hashedPassphrase = await cryptoEngine.hashPassphrase(passphrase, salt);
        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

        if (isDecryptionSuccessful) {
            // remember the hashedPassphrase and set its expiration if necessary
            if (isRememberEnabled && shouldRememberPassphrase) {
                window.localStorage.setItem(rememberPassphraseKey, hashedPassphrase);

                // set the expiration if the duration isn't 0 (meaning no expiration)
                if (rememberDurationInDays > 0) {
                    window.localStorage.setItem(
                        rememberExpirationKey,
                        (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                    );
                }
            }
        } else {
            alert(labelError);
        }
    });
</script>
</body>
</html>
