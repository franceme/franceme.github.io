<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #4CAF50;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #43A047;
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #76b852; /* fallback for old browsers */
            background: -webkit-linear-gradient(right, #76b852, #8DC26F);
            background: -moz-linear-gradient(right, #76b852, #8DC26F);
            background: -o-linear-gradient(right, #76b852, #8DC26F);
            background: linear-gradient(to left, #76b852, #8DC26F);
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>




<script>
    // do not remove this comment, it is used to detect the version of the script
    // STATICRYPT_VERSION: async

    const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 *
 * Mirrors the API of CryptoJS.enc.Hex
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassphrase) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassphrase
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassphrase) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassphrase(passphrase, salt) {
    // we hash the passphrase in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassphrase = await hashLegacyRound(passphrase, salt);

    hashedPassphrase = await hashSecondRound(hashedPassphrase, salt);

    return hashThirdRound(hashedPassphrase, salt);
}
exports.hashPassphrase = hashPassphrase;

/**
 * This hashes the passphrase with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(passphrase, salt) {
    return pbkdf2(passphrase, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(passphrase, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(passphrase),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassphrase, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
    const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassphrase = await cryptoEngine.hashPassphrase(password, salt);


    const encrypted = await cryptoEngine.encrypt(msg, hashedPassphrase);
    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassphrase, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassphrase
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassphrase
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassphrase,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassphrase = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassphrase, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassphrase = originalPassphrase || hashedPassphrase;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassphrase = await cryptoEngine.hashThirdRound(originalPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassphrase = await cryptoEngine.hashSecondRound(originalPassphrase, salt);
        updatedHashedPassphrase = await cryptoEngine.hashThirdRound(updatedHashedPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassphrase),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
    const decode = codec.init(cryptoEngine).decode;

    // variables to be filled when generating the file
    const encryptedMsg = '097cbfaca13360da1d800cc11f0a72842952056156b94f654cf950832ee656a3eb0ba3b7c40110dd0ebef63e5eae5effaf8bbcd79c4dd3883f276580ec22190b61a8ecf3de78b05b530719646d958e76c41d8fe2e596f90805f6c066c335616817b9d324a2c7b17de016193722bd62ce2c29229408cf58bf95863e43e72f33923b302c31461c757ccb64de15a3f756a7908c51f0d5bee9c0d73178fefd0901f46f00efbe2dafaf6f849e0e1959ee9872d3bff46174cb62fb22c42f2ac01589a81f7a41423a7d76c68aa331d89a10f30e98fe361ac5c18e1e4bebdc4613699ac8e96d99e1a93b9b58dd429b1bb2b41524010470f53fe356ad327429c4f68aaee3b75cceb6d0497e78ef400eda406a54707dbaeb2c174b6511c327c14003d459dce96ecf96357b2e120100dc128d9de3c5435c899e1500dc0b461116f30b524dc52cbd825348188573cfd1d22ea3dff3b21dcd17c7ef39fe418619b4f960afbf6fb79dd7a9ee06e9f15a1becf8b096c43fe0cd3305bb7286850a5913ba896d63d6cd940a0251d04bee846cc128e16a6e1ea4cdf6c0dfa58224fdf8e41a8ea0eb34e0a3ffd32ac9d962d147f0fee46c76218e00f65e673848c04bc97499eab5c657bd2b1ee1843475ca668581c70ef3208d07e579abae474b7a61dc7c92da1a99a9b77a496d7dc8b4abad1db274ecc855809305e01c3848d547c960418aacbb52cef038fa286ba48ad05b97d54ccd801d5c2daf3f8e2ed4a7418336a430b4b061387c2539bf901b9b1dce10dce04ab3661e96e591133da4c38ab38503fe8b0f63d2bf70f1eb64fd2edb906150cc377523fc75ba714e6bbffec6ac0d052e4461bf9230a27bf17968f208cc5c1b080d37f534ed2d4641993149cf7075ef471ee2c9f13540fbd49420c65d4a4c8ba128d6cf50c22cac82fb1e044cd5a6bc6bd0fc14c389dfa3aef8c9c6cde2a00431a8f3548d4dd35a1d1c16e3d5a2adf2ec75244314af266cf9b1d02a50ae2be61d2406f49a440e6e6e5c925978a265dbf17d1c26b4cd8b2f48d9293016f0ac2a3dd8aadaa9dff1d58a9d729c2e16d1d6bf2b57d34eff456ef6505459af3df915b5d62d16e00a118c28ce612833a2fe3f6db182ab42239c08c8c879368cfb63bede62d53aa880d01b43b436150d90f04be2b245e295c620e0ec6265f097da06983dff600e9036d7599df5f52c74f8a0b9fbfa5638bce185912ac59379440f6a4e7d7568820cb429613e381176ecfb176ce625942863c660944b74e9cce72e7e6248893a0be19fbaed29462f27bb94d7a186d51f7bddd1fa9909d792d4f7f90207a8282b4fe983f4220f35f42278aed52ae162248024639ef6fc588777be3433d4db758e206970473f05b010f02563d5e384e1076115044f236c6ed87aa9355217184a78602b796eabfdb3b26705a3edbccbc597213c7baa7f2fed42303681003fc0a65060d22f03a7de4918bcdbd9f451e2aedc084c8cc82a1c166c6d49c3fccbda423e18b1678a9fd8300fb7a7a352ab417ba6821057a1a5a96fb3854799ddd0e450bbfac27fdb2327056b811c635ee5b71bc7c0079330a0b39c95ec053fb3c4811ce34cbdee54fa0124bdee7cd4792e923a7e86ff0ef7467a8b1abf3616bd084cd807f0644548a8a22066acdcab0f9bf7899b73ccd03b9736c95adf70dbe16e21f069200e60c4f04cd384840350b8db4da55982b9d950d743039d63751138b5a11133ce93c5cc00d4f6a7e7b4ba64fbad82c3c6d2faec48fce06ef7d4b1ac64487dc3ff773999d3f86b3c0de2418820890c3f4a7926dfeeb6ce3e7e689de001fb4e54a3dce28560b5e72c48545435f1a0dc199063b6a40b35566dfd58ae68e8b08abcb182d95f49e1d7d2e958e64d5f07a5c1718313695e0bf5d5fe62109accdcc19d30248ccc74b34d0e1466eaaf4c2fbbfb7f1b4be61f137461f6fc7aa9e6e8d02b7250fe7328f1c31069e9c7f2fb57fb92024d14d91919337eac3243a2dbea961765783194f63e2945e12251b462fc58d3808ff72ea8747b9dfeb31690e98aa275743ebeaf9110bf5039dc9872b1e8f23788cd630f186e47b34df0fa025059244447eb6852c8db8bdc5a1b113f6139d9559c2bd25f46181b4dbf23bef405f5c1b719de3f6d7e2407c5db79c2ea82a49aeffbfaa59ae6048f974915e20172c3c6f17703e2ffcdaf46ed0569ca13b77800b69972e5c432e9338a94e1026b6caacf11974f615f4d0d53c542e4c622e8f8bd4636835dff1159e4f8dd3d6b2309987f4041afb0d428c75054e921c5db2eda9bce32366bb62bcf94b6b965f3f3ca9684523d33b0035ee5df40b693ef89da5c15b339e971a39560c110da86e464c842482fd63f95618f9b65f9a90fd3e0b482be12e832337797a1a78bd017de0d771d08a5ca7699834b4c023a62234cfc9b7e5e29795296ec8d36e0938c193727a2a150ce3710c7021fbcb1efaaf782b2a493c08b9ae8ed1b0de17ee1a643bb3cd4047afe3589b6e5774e29db88b68f22557876d8a0b36876c17d30683a14c5c420dab35d49d39cc2c7099c1fb27a73bebb8bb2acff05aba45d57da52eaff407bdd7c5fff52fa69fefbf811218217b0e61502310f72e00d3f98ac7cfe9f5dc38fa7e21229ecef63ca01c2522cd86a82500fa4267fe65e6dd28480db73522de9b8142cf58c8db0fac9bdbfbb01f2eaab7ee98faf1131907589c624c8ac01f53d929fe7794f1725c73d6d9c379f9c6f3eadcd06135212471988208fdfc92d58eb5507c1dee749b8da3730964646d58fba0a408bf22fcde6bb6d96214d4b21e0ba6777c35a1b0a7b36e29d4088618cee5ec112c0d40ea393a81937d648f2b9956c99445eb8d4f710ef91f7a45ecbb3f757f4c702a7932a8489042bae52cd03c18236f6b2f6c057de415048bb9fed9c028af19988e0fe4c8d980e0855bb10176962f988e1d7a1d60f05910eefd63f930f01e62bc201441cbfa732fb52e26b2a30eef536e5f5be7092b553a244c490c3dc6c0c7f6961a8b175d5deba267e553bfb0376defccb0dbbf5530371759e852bb4f5dfc29a1584db54490a2ba49a21defcca7b4193c21b6bf4ab3b6109aa29283601ae44dda881500b5bd699351b7672b3dc3eadbab5612a551a496de4454e0906424741f035162c93abb4e3ed5df3e8f74ebdf57895ead4301dcc445817be808c8a342afe02d6503e93ecd4de2a4ff5e5cd7795188319e580c78ea37bbb37ab5c0cd42edd5bcaef69dfb807addd7513451038341f5fa1c7d0793bd43310a6fe467fb87338f9a6e5ea84693cca5f4a6e0d796cd4ee20ed88e6106c68df355515c63f9e1190fd6de5f031d2e22f6deeb0d2f29be3f7407c70650c79d4b229b78e991db629551d70ae59395cbd7f78ce53760882c41f2cd1f386eeaf9e0bd984dece1f082f038e81c8ab71418d017e0a3fe9c2acd97b0742da87430637fd2752e4b02d5dee788ae04ddb07c9523a6f4d5a9e72cb01faa0262d775736d21fc9ef52f988156c4cf65cb57f595e13bfb591f0d9f0741d8e4263c9df2e825b3f77746a3f2b2625d2cb42dcf5cd313421ec8c7ded97fcae81d58c628f1d0c25b29e0447bcd92bc7583dba78b95d60b7b0bed2cd0dceff0f5a2bbe850ebb5e7fd01480a49559f7688ece7858c2709a9a23c09b1a79b8162eccf626c74a8090c46d9d1777925719892ddb7e71c4e988d225f4255e9c89f893666dc433259b3eb413070d0ffbb91d8993f884930c7fb0339f1bbd700bb3f2edd44d2ac3cf1b00968762756052a19f6d69a603a6b95611741b129912457db796f238ac8d3c293eff07dd8ac87ab5f9dc776bbc0719b7414865cb922bddb45c3e41c81cc06bd20929fbbcb02bcc6de98e70df76ed5bea0f8b55312a2697272a33e57892e23717bfc1f41268e4722a5dde3cf4af4f356bdaa58ff1c09d7f4bc9b0a4c227479e6cd0bea2b813df0bcd97859eea87b8aa65d1f2459d348090d9dff260a91ac4f60b718b1e8d148efe2febafd686bd85e9f02ff3f3e9cd7e1f74358c0cfcd43c4d9d0ba2424423da4c89b019bd3c3ba5089e21f603e9fb901eebf7ac62ef05d3706480158a63c5aebfa07202dec96873a799f301fe26df78872070463ecd7a700120ac3a25f1698fb6d4cb5c8330f1fe4fdbfca0386054af973ed66a32b167d221fd944cdfd198f1786d014fd3dd5cc8fdb92b73d7f67972f4a08e9be525155a18f6f316f23c76acf537aa17736d5e008587717c2f2af25b53f3e418c0847b3de6132169c368a8c2d1249c9239d19f1c428168ec863f00b9b507a822f4b37311d6defa204047bd92f5b9b6c46225581b1a7706a838637af8db8ada4d5a7d7aaec0b52afe2fa558beed103a0b263ae98c641e3e18b792cb06ff3b4f6d78ae37919cdd96121f32bc5247b656890d84adb87629f9ad945c6913c2b51f5d51ef85e92b71a49bcf403991532d57ccf9f9cd536784c100c007a29c9e377a865f75e1e67a2011c1b995070dcc1b7583b7bf4daef41e3919ba0cb7decebf0d5ddec9a419195fdebacd11c4178fddac24751fea0d47c47bd0195c1b2b7c1fac0d3497f2677e6dde6ce5ae02af59bee2e3f9c78e5553d6da3aa3fb5d60cb1e00ee98b990aa370749f7f5de6ee7e65c6df8a8535f65510dafff5609144404046fcaf6fae8224ca844e24f5fe34df317eb4ea92a29bea45620ecdf8213a7a03d723cfec9f4f545669f0fe8cf03eaff4e182429ed2235ece641acc7037a4849927da682c9622641b5f77c59d54a8035f1a857fd2449763799eba604fb45149208592dfbd9b45c8a3dcd564947ffcda9da448b97eb48e135644b02adf6260a5dc3c03eb142cb361b147bb87fa412f985fb6f447a2abc9a9e53c464e3de6079c93b5a5e8480a0098ab680a0015034dc63a9081635e25fb2ff1eb4da040ca20e745f125c3f66c9e45abfab3a9ff97938b20f5541e60eaaee622fe1041ee4cb798d7a9afc924840e84ffa0a8f5fe6ac1a6bcfad0e5bc1677e99fd81c85d8c11cfb0c08b18667e41ad24cb5fc5a8da7fd7873bcbd69a4350a25fb8fee4a65596dfa0f71217ca7f222a0c14f23ca53e657c13181fe834097203ed5f95d9fe411d33656c3a81fc7e8340e5cfd64b6a05f3a7838d2795cb3de079f67c49f31045044c15107d961ce1a76c2f62701bb2c5a627a110d193dc0b26fcad91e3d855341b09cc483f0a1348391b91219b4be8449024c3561721fe58e0c396ef1fd44168b198bf6b378e58e2ad580fa4a84741aa026f48d8995b33b128d84dbccaeeff41d245d0ca175be4954e8492ada18d676fea0ecca80e52fc792b58bd3e76c107886ce40637463dc94b2ea1a5831732c1c2a7a2b4d12634cdcb60fab66c838fa2a9db9a43374022f3d1645a42bb258eb0b66ccfd0316505ff6b364be6247f1f6da1744030decba59258d796ff23513b6ab4b4f7749b2bd07942045950d2ae3f81fb36ccbbdf6ae69b3691b842a9e641fcdf23c6f5450612c6ed9cb2f1c4262b810f7c5a4a75b68a6eeab2a15125a561c4b85e5948971087f60a074b6b7dab938cc21ad7c992b96a9e82c4e914e051a1258abb09ff9b5a89ea0ffe6b46725a3d7dfceae20663c09ddca82ce15dd5d771e6a599cb53c056758a303624aa63346b1a3b9fb71ed35ad35380f4d1438fa6a73916cd640299e28dca6b93696a2a3cf1bd99dd717f2a17a35ed78937d22883e3cae859d8eb6a693439bec14b7f2d90360c7b10ba39187bad88487e4397309d0798af837236f02b35926d9553047737d3b9068c3ccc2fefb6fb03cf04d801d4c8c96add98858d59755430572636d3ee8840dbd4f33cf272b2f2fc51f35739769ce9a83152ab8ef6f734b7cff4ae63b009d30d840a7caf13ed59bcf1fd9e466ca86e2ee14bc7fd718deff6f2209a231dbc7db02848e1bef01e39cc1d2815c4f6992f56f057df9a41c782b78e5c5be00d75f03510c14f684c101e7c6ddd79eabaf5549db2ec7d42b453b8f345af15e6a5e26ccbb00d0934c3c3e4a889556ef0f4b4b6621e6c7ddb946857fda59f8a4d6b42ecabe3f2dc6eac23dc5dc91a13039bc68f834b8739703f7e41594d03188f8a1708ebbe6e5263fe9532edfe6e9acb585aeeefbaa48742a9cbc319a86696d250cd44f5ae76fdeca337d632ad3ff4f430c0059741316d55434febb0ba47981a8de26fc34b6ceb44c069b5bc93868fb1c17f0689849a8447d5e15c4eb64fee6f7ba9cc6ed59787101599c3f671f7f23ae3c264c91f5c2bbb73f92da89d3303c9b48188be73ccbadd1eb995287f68f2d5278b9fb89bacc23d8b4cfe1b0d8995cd97d51a0071a6828245b9eb5ce93a503c63968f21d08d9b58f9fc54e4029b43214551961214f0b27ffc382a6552a579bb283d32c50169ee9ac2607639c0138d92204606e460a478aba9af14db4e4d7508dbd0072a111e3e0af5d357ba933d36b72ce4dde322534a8493daabda96bde59d6e2a35bb690a7c5db844f39de1f92724621d16fa8dd5ee3bfbe484984369e7855dd36f4341319029070c878d6ac0e068d4673c201534a6801cbea8089851c6e6386d16785973cda8a66efcb6068bb4e6ce82d03cf80e4f74352ad3113ca0b80840edb69af47a5667794a9f462712d325f0e832c1181203af2f4ba7986ebf6f8e9a1412e9326ccc87209ee3a9b60744d7a88f3676209a8e44bf6f33812ef050df46bc1525f4c4a42a09f12f4738aae835da19150eb23e3b9ab86d0337028782de45f21976986b55c365edf623fb4f5b750724b25dd9c94504a62b90ef608be51d95e0da85eec26f3a3c6f0f9b74c8911cd8e31b6ecfe25160470982e4dbc6d17c09562f85627a512a8535e568b519250b81b7b559e28f8652166d0631d578dccece81109dd5573d410c400110ae3488958f6e5ee17217f0753bd94208be329c0f9966dec69d20bcb673d57dd4fb0852e495382811c82a232b152d1e498fe6f5916648b1c280ab622216b524331e9f33964ece8fd88543b72c5748ff18d0b76470d22dc1a5e8db09a1bbd4006aeec35faaa1ea2158740f3babbaa856b57988c11d7af9e34c8fd39db17413aa42def2617f2f3a0504986c52d07fe5e31b94aff4805b9bdda5905df30329bbee7466c5fa08650f263285a9090fe8a2184d50e87b640a24472ecb3a877e751120c614c18bfeb74e27455996c4160a24cb6403250717bee9d7f53bd5c7197ae84a78c7182ec11b7d84e4c8daf1eab250f723aa3e13b0e07220d1ef0e4e803b94bcb5dcbb12d33e937a3c0c4c38f8e671eee0cddcb314a398917229442dbb446ad99a23fbfdcbde3720d067ec8f8943fdd230d2c9b2480544ad8235dac3553d21a06af338c0dcc352c06defda1aa20303bcd5f6b91d55e9d632d2b664f62dc500d284ae1c98dff34573d2ba1e70d19e10da15d5b64c00e2036e73c39e452b4203ec937c925c839841a2dbee0fcc85a0a44f8e02826b78378dc7e4b8e50744ca8d098d96dbc482a091a59a02cc8ea697889ad13f68d51df33fe676569a4c7a68c774b4b8eb82e5d0dafc68ebc4feafb9d5faab67c9502291a5d3074532eb41c40119b5488b174ac10f212fd62c18f633e4ba8a9bd11899382944a6fe12cb2fdbd8b1031f982b1a146860c306c295d03352b5f55ab21ed957030d42b6c02a9171f066b7f0b8f41bc2910f4286a5c914e1cb5d680c8132125f15c4e903102e47f441bcc17a037aa6843199d9129ea63920a9d623ac4e4315f4446546239979ac9ab2f68321a39505fb445d5cceea4739e4f64a595af52b017f10f6b8c1a390323533d306bfc8838a2288fe921c936e36c03cd44a4637dfe82d453343c83d361c68b7013fcc03b4f5e47c008823983504fd891588f683616045c920735acfca538debadcbca6246eccc73ff4ccd6c7783eafb669aab0a96cddc2d89ad2c1a9f149ccc576369548b6b2d7c999d915def2e0e40f3abd242777a687122441e7e7fe4491048184b162552bca945bea3d5a251d8c95d73563cf30d9beec52ce748d0e2deadcb8398f268b53b2fa7093d80703bf019a74fc67afc5b790c021c2f7b5ae4aa024b86e6a28407c414ab5faa31cf4c3c184e41e85fbeb28c6462e25ad5e6c664e2606ea99ede49f18331ce65d1f6cf1b3fddfd5921b478ec1706cc4d610b30af6a9bd6b74cd3b335dbba9f9c782635b586e030bad712c6fb9d9c891ab55b41d523cb37c4873facb1bfaf4e9919fd8a1d516bd19ba7afe06d235adb3cbed6851fb60a96ff7434025cb1d7f68fda52ecde0cc064dfef0a9569e3233248d5a3e9b52dd4b5fc4c4c94e0007f1de7578630726bb0c070f6693e863fbce77d30edab01816b5e58d0385e6e346429856d559ad347496a73c506eb78b351d4cbedfd6d60dfaab8573a525a21d9f9862decc0e929ee34af926933101cf7b57f3b33b5253f324b35d8f00476c3cd20d6827decbdafb848e0d2b75ef3ba10c1e4db623b5c0aca7674565834ec6dd847c71be87911ed581cb0f73847db9240864c28e157724d7619b750392916d887870f4264b566250fd43a897714bef543b524fc3de93fc9382b65041cdfdf71d0775ab62295ce27d01a86d592cc4ee6211e9c385d5ef1207b7552dd680f96c95cc97b6f0f5b0676c1d721be9eed4872d37803624702094afa4c1565224532557246ff34aecc353a8060a9cfed14736739f44331e6d2c308ecfa92d2abe6f34e4de2b54191d3f21670eab90ee5970e80348d6a2b0dfac6adcbeb2cbca72faad0319ce48c138186b07021d86db27bf3f1a7db0eadf8dabd21857b322f2c956e19a891e241edcc3b8b3affe5940f255428abe5526a9d7315a1655c1ea6417fa0ef2d3350b03dcb94479f73a0ca617550db37609e34542bc960d8c371a3fd1bd533eeb192bdd987c0741bf4deb6c622d2c87f4ede9d424b1688be5192d8c13b903078af89b1b714363f8722f7cfb4643b2fa662b6dca712e5d7d350348a2ec0d84af7c1631fa79c70f8bfa3eae899e7fd3d424d92c07294ce19aea74a93ef3de66f4cbbdd025b3decdd6dae9b331988227fa79d45d29b14eea477b3ed4c96ee6483b21b1c37960befae43a07245670178bed0f95b09d1b49f8ec6103156391e0b225caf07fe9307b27a3c6d899763ac2332a303f39f1131459c8ccea13d9b8034bcb4904aa6f7720a518d2a7b56ae1cd355be4b5d4e9868cbba9a83aafb73210a74c6c08c3a12912248c9d3a92545986ecf16e2d4f0e6600324b825f6bb2ec9c30a5a5995af1cb0ea9bc7c6072db90d756b510d0aa272932aa409afbb8169017b500eacdfaedd559ac01873aeed122dc91daac1121cc8148126f76b6951145c471ce2083637e32b38d1773f85103e065827a17c25df33f2945d9cc98afc96ffe415382c55aa4636560b8869e0b36a7c43b6eaf233ca77a1e10fc8f9221fced48dba5bd21d15045c30b649a55e15590dab035752cb137fbab2f210d250e44ff3d3d068c566fa312c58357f51c00b7ea5baf64460e3620a1573d21d2d45591d13866b4546d977b589ff0f6eee50defa35c90f80fcae04efd4a1d865324a39cecf73154bb4db6e4aec5424a779b0a48823d90f54b78f9a0a6737077349878b1e55864227ce9cc631a355af75e7feebb6c790cc97cbcdeeab4f1d66bace775864a388320017bc40ee8ed2290c0d41a05b97fbd6405305b69408ff2c94df510bda149826972cadfa3db3f0413cde1e50643115ecb9d3b59c77d88d2925b0b3aa96868b0c03f70f40d3c3d6c970734cd77b2f059a1101addfa67dd06c2984553357ff90c1e7cc4cabe6cbcc697e9a0a35fbf22f64e07f802448827f5a44845ad36c2bd75e56bc1e51f2e53a93c19821b48cf5e66b4cfffcac27487029ae5834876b11922cc42653cf067debaa90a6d722b5c18b74aaa0a78f1f96f339d69431b95f710f1fda47088f6ec7c0dea87fb9c8882687329f7caefd3e158584a30ef0100fb774c10eedfa97ee972e35beeb7593febfe803a6d53bd72c7d98d554ddc4d6d13b17f62b595d6152236e23435e63e327cf8c1e948fd185a8bb5dcef3eafa3330bc52e6ba8aa6b31432b6bd36806cece932f410ef9e88012f067e385fe240196f3b18c8c47e011a20eb2782d67dfc97edffdb0eb97af2547f1ad3d850fbd5e81d8489a05341d3f4afacb3392fbfdbd26c118a802a0a2019d8f8eb5826a9c87e50321406b4b3181b7063151673be439ae8b1a8a8fd567cdb7b3ea365c4316e8c0797ee74e60b3f585eb162026f82487e95b907ead80f81b8041f4c873e08b5ee06253b238858a167b8f429975781a76defd105bc6e8d8e868b81726e296af20c187513f090c8569d833d74e5252e09f4265d3740c6828c41b2255ba43b09566551df9cdcfff4d0a85c9541acd1ec5da2856846916c3e1e3dbd216a3723505a6e8acfc194d06308e9d9978fdfc25b83188920faeedf974e15015551ae6839d65ee7c927d476f8bff06bdf8f5843cea6614f73574550fc5b67e01ac3b8fd4565fb40476be3117345df494cd22dc4faeeb7af317786de121cc11828c719fba10facee1dd7dc20bdbb86e74e10432816e7aa53daf5c2893c677201e6577e8dc04d30682266f80b61d272ede4aaaddc7e8cf7c45a3deb4a31ffe4763db0267cf9527db9d4fa00adb153093963d2a135a1b61d6af93fcbe97ddcbecde0456ad5433c888ee159f487b0021df093402c0672bed5c3e4c44de13497ad89eac05eea749b2ae7f584b0c3578e354806106f5183a225301bd15ea6a32349ab6019558e70a152dd72f3e2426d2bbfe1e8bb0c8ad0386f67ba9c41f90689b8ec348620ec0498b9e29dbdc1a61dd72d7aecbf3ff69b2998ecbd80671f9e62fb941f2845bbf682b569eb0c79b4bfa6e0d7625c57b462a4fc84813cd933d65e8ef85992ba3646a965692c5231577525f7330de7c1eb386665a5abd9be840a22eb9cb272073d25c13bc8ee86565df29123c28440c7af139d74dacb30ac46f6ef12ba067213e4319060da27bc2371a7eea0ebcbac3d5a1022e6eba7abcf73f1fbab1785d9a30c200535559f121e8ca73ea18e21be69f5c96d5379e11928bd507a86a15d7dc69383d22b749f30c4161ff237e3e984f530e5331a969019eb40a7b941067cc16e7118736d4a6b1bc8bc175d1047d6a304679caac7d2219b9bdbe42cc0244b401b61c678488ef1b11d004703b7e151b271cad5101acd5d1d836293b7089023017394b059a7aec2d944f61766d419f517144ca05fe81e7917397c59f98eaeecbc4d1a2ea86f00d3e4c2a6ded13c85c35215918a05ea720155337e27cf2a0b8074d2fa685654f3a1c2127c5d575915f37716071a68d47ec10380b02b893959bbef0d28f8f3164245ee7dd233d49506589d42c78e5b28e7d6ff969f1fa661c9cae8250c7a4dfa05297386ad5835c82934fb8006220d4eb1e8eccd245c76d72da029434d4174c4854fc14333ef0340c4b9d477f166de25568e9ba7f6389fd639c90dc27bffcc50609a2ea4ad4dbbeed82a9d42ec448f13fa09a0cde90e6f2a9db73f6c2d5bb86bc4a4981b177ecdf9088ca76104fcb65137a36a2c5cda6f566dfd6352986738ecfad37ba9327dfa26b44cb3b95daf1702f527f8acfad29c0653de0bfb6ce88acc9070f66546a1e19205d847dd64f6f4a5d32c52b2f3998b1635c058df3d2c3f23cd041ab490a0b0cd423a0deba71f8fa096fae8de97384a4b3169d3ed4e59282c2a8e8b13dfa04632eae72886423265889d5df9d318dd75bd6c3e3575a9c35d2ddbbc9fcbc0a8691d510dfa58c7c109fb0d69c634d20d3019b0ce39966b597419979f4b6997c652eee39a96270d4ca50bb6bd7fbe96335abc912cab456c4ea5c39a777663c12c071dc2b1ed9207322e7586ea1a17b8cf706ae7dc695e64cbe9a4318268effeeb3ead63b4e429b32ec63b5d572eed45878006b419d19a56b87d1fb89a932b26263721224142332dbbe5368e65edfa369db145c47d899b749ecc15b095927945b47bb3fdd51b8738ce3fb6f602f8bcfb65483015b2f24728f0662a4117fa90c5d6f0971f02e3c25d34b97d9ebf693717d06a939fbd347edcaa2eaec91367433d627155d6b34a207223cc45de0006ded0be351a0162f5e08814948ac09eb0e9f3a93aaf0a106c98b6da9b5d70ad6bee5ba83d4a328838e98ad4e2da04f68678d6f58e0eeeadf28074080ccc71eb13828eb77006b1995b58f307481598c7e9c0a6b99906464b4e5c1bb53431ca66c302b3c8c5ede35dd764bd4babb8ac0d6bb099039fb05ac1ce5120cfc486a83a034cc7aa049d0dd1eb8a4dbf64dbbb0600810c2fb8e2fc6eb70d9a3b51a30cc941d0f5371448d7e4c74c2d58f91930d36c39d9c0c99023042cdf36fead688cd1156d77e4dbb277f8c892ee2034b4e9aa25daffe9c996aeb5040687d5100d1417605824894dd04354571887c6fb44800e65511a60205422a1e60d87b3fda1f2259a56f712aed3be346098508a63a1dd6df21d56b2568af4cfc550e3f74844e3c3bebd5be536489c3cd263bca5de50c3368b5956bb09e45cd6373dc92c5e592cb11a14fd0d762d416a7e06ce9de8b1b710ec36ed62ed7f757ae204563a8e9c38066a7a76209e696bd481d28385a24c29dd54e07c56135f1a06c841cb2ee3b45bf39ed772680bd99a0790af3b22e300376f5bb92c6f1b0f3bd8673934773debe1c06c60faa567cbfbcbf8c045c88306215e379b0eb2ab208f5077d8d83389fe22106342076c45366451ab4d9fb9b31dbf421c054bb4a72516ae7c4d906766b21ea82316824c0c9ba0c32429d05df5319301a6f5b01cb4e505f4086052aff3909ec3f4248504f870c0f403b749042265587d1bb470b5393acfcd3734f390cd17c8dff18c815685ee9ce837d95aa90ce4580480ca1255b3f9711a4a8bc5a7e47c8484d37c638c39e6f2768ab488c360f7e1b50f1f831027773bbf093b5574f0ec33b88f70f4baa9a0777727fc8c8ef8eec1c675f9a10a1a5f4a18cf3fccecaa5bcd9d3a3a543743e1fb99ab57c2a27cee04a01a7037da73b8f59a4899c5ff53c2bded1dee4e63694c855b91f0c217b7fd96021ff85381f9819a1bb6aa1b0b9cff31d03fb7abe1d36b80b861dd10c3b1a877b0d899d285961430329e089c5ab283844f96f913fa95a4a2b255537819ecdf38a0054da0d52c044b3b1bda5efbf3bd80013555bfcef227bbff2d28a4e71e08b96333e9343ac3ebe58ef3666e2d5addfda431a8ef6811bccb18133d8f63553ffde7f9b206fb539007b76533a3ba2fff4acc15c96c0df75f474646dca2b8bf794e036403a1daa3c3ed711fa4bcadd382feb80292cf8934a907c1e710dc044fb38951f196bb6ec8c16a610605fcc081406b9951d76076ba6786b4c1c052225adc94e7cba1db7a58c0ddb339fe2d7e7f4766cc381d059977dcf8035b4d27911b22e9b1bc9f18c349d8c5d33e29ec55fab67272ddf202543e016685685b6a2b75820bda11dcdb4778820364469ef8d279484dd2449d3f1a38049b69a54cc69794ba78385c3da63fdcacb4d033b3de8c4713893013e1811b50eaac98fe7c2297d60d91703a4af98f6177bc82df7ec5226a322edfd199c821e028aeb2d99c678f2f9b37d0af4d5bfa79fdb465c54284866e0617f3e03f964e75efaea6efd72e4fc252cb64f2f8e2ec2e63a5e02e5cb36c20de45bbb7e178f8eba8dae99bdc262ea22a39225635aba6479fe0b4a320771506b71755dc59747396fd919845bbd44e7dcd22451e00f70fac9f0e1f7f3b1fe0d628b3e743ecf6c8426fa0b3613beae9299cf54628dedac619cb7e572e8507ca3d4042daf68cd6fb7e13770d1af0a6c852b6ab8aa10c1f24d2168606a3cb5a766ebc3814933ae0ebf5c67770074aadfc39ec885e7136fff50f3535e34a90cdf2dffd5f70aa680f8458e5f25c0c83547260211a1fd0604f34e7b224043b59c5216447f96441fbfa61893921db132e76db9f38423d2ea26bc48b2ff7e76533a3460702e862bbc7c83160471ddecb0ea82c758c5e5f2dc67ceba56b69b06d9b42665079cfc8560ed67b6616bf58a12e5e4d96ea8cefb80b8361a5c2c2e377e0c2c16e37792e8e28dcf4c2ef90480b638810ca0547127b5518195d85344479638895e20e4df5cf448ecb92243bc420729e2e1dba16f1f2fbb28221e9b76cd3e18369ddf2c8e16e415a4463b05cba17f5c7b3275fadaaa1f830635c40f897a364b04d9e71bb720d2fb1e7ac778dfc8e06542bfb03abbd406b1d2e5ca70be186df7c79fc15275e636b61e7921be32205356d1d0c2fa77856dbaa36fdc2d2822e6fad86d7df92a3552ec1966900344fe7a61fe84e1c884882c8c64f194b3b685638921a1479db4ec7dbc23159d8bdbabf7fccae85c4092a501dcc55c81a3e265266c558c2888d609d7b1c7b5680996cde45b7d4258d5d9e7231a039fcd79b360a0ddb903cb19b0816e6bc23d1746631ebe41549a69c368cbb019b4a754a6b15305bb9e570f8dc82e3a5bbdcf0d2151e53ffb0c047f3049959f50c72d7a91cbc96052480b6e190da7e89c4031a459604c9039e7a075493132f18921caa3e95cc787ce4da74eb20a882bca2749ad6feb0426f990f2774ec2064e993f16dbf53710d0854d88044085d4378071574d54332117e78dee5ff7862b77c5941cbfe165358a17f6d16cd5cfe9b613e9e7e98850053bc50632f668ea529b632abb580de4fb624515f35d3442cf1c4b8c83b6083addd15fee31e6303e9dd0802be6cc00c78683de6fae6e25fce49c390ec7bd020b268e432ec11ebae24aef30a5c229a45eeffdd3b81832b1bace06993c41cfe47b5271b9cc3c8b7fc18a2add0c821d1e1b065883b2c282b9d5fef3183da962054526ab3453a184e984d5fcd5f8fe9d7c97c04172b0393562304235a93a79ccaf854f6c4d7274401a98cf931d067bb17de46e32002fcf5b8edf11e2107135ba61d028bb2810d99108f203f9861fd4ccdfe54a9d313f1f25e5bc2864d72ccc1628ca83562a3dc1ad29e1d5cafe85ff382cfb99daf6d4d03788bce56a201c5fc768222388decafbdd456931094b2634fba836ed590aa1b154d98225c45b61cde298ada09769ecf22cd04f1268f99f40cc0f63e77fbe9a456b0a50afe2ad5ccd700b1f611c53d769807fe9b7680acfd9a077ed06c4988c412e05d16e7b9055e4055b91fd6d5694f4e593ab9aec86693ee46114a6e34c5ccaca13fa2',
        salt = 'af49634b4c8399ec3a28f0d6cd694b56',
        labelError = 'Bad password!',
        isRememberEnabled = false,
        rememberDurationInDays = 0; // 0 means forever

    // constants
    const rememberPassphraseKey = 'staticrypt_passphrase',
        rememberExpirationKey = 'staticrypt_expiration';

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param  hashedPassphrase
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassphrase) {
        const result = await decode(encryptedMsg, hashedPassphrase, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        document.write(plainHTML);
        document.close();
        return true;
    }

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        localStorage.removeItem(rememberPassphraseKey);
        localStorage.removeItem(rememberExpirationKey);
    }

    /**
     * Clear storage if we are logging out
     *
     * @returns  - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        if (!isRememberEnabled) {
            return false;
        }

        // show the remember me checkbox
        document.getElementById('staticrypt-remember-label').classList.remove('hidden');

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassphrase = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassphrase) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPassphraseQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPassphraseFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassphrase = hashedPassphraseFragment || hashedPassphraseQuery;

        if (hashedPassphrase) {
            return decryptAndReplaceHtml(hashedPassphrase);
        }

        return false;
    }

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        let hasDecrypted = await decryptOnLoadFromUrl();

        if (!hasDecrypted) {
            hasDecrypted = await decryptOnLoadFromRememberMe();
        }

        // if we didn't decrypt anything, show the password prompt. Otherwise the content has already been replaced, no
        // need to do anything
        if (!hasDecrypted) {
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const passphrase = document.getElementById('staticrypt-password').value,
            shouldRememberPassphrase = document.getElementById('staticrypt-remember').checked;

        // decrypt and replace the whole page
        const hashedPassphrase = await cryptoEngine.hashPassphrase(passphrase, salt);
        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

        if (isDecryptionSuccessful) {
            // remember the hashedPassphrase and set its expiration if necessary
            if (isRememberEnabled && shouldRememberPassphrase) {
                window.localStorage.setItem(rememberPassphraseKey, hashedPassphrase);

                // set the expiration if the duration isn't 0 (meaning no expiration)
                if (rememberDurationInDays > 0) {
                    window.localStorage.setItem(
                        rememberExpirationKey,
                        (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                    );
                }
            }
        } else {
            alert(labelError);
        }
    });
</script>
</body>
</html>
