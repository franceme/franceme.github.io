<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #4CAF50;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #43A047;
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #76b852; /* fallback for old browsers */
            background: -webkit-linear-gradient(right, #76b852, #8DC26F);
            background: -moz-linear-gradient(right, #76b852, #8DC26F);
            background: -o-linear-gradient(right, #76b852, #8DC26F);
            background: linear-gradient(to left, #76b852, #8DC26F);
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>




<script>
    // do not remove this comment, it is used to detect the version of the script
    // STATICRYPT_VERSION: async

    const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 *
 * Mirrors the API of CryptoJS.enc.Hex
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassphrase) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassphrase
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassphrase) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassphrase(passphrase, salt) {
    // we hash the passphrase in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassphrase = await hashLegacyRound(passphrase, salt);

    hashedPassphrase = await hashSecondRound(hashedPassphrase, salt);

    return hashThirdRound(hashedPassphrase, salt);
}
exports.hashPassphrase = hashPassphrase;

/**
 * This hashes the passphrase with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(passphrase, salt) {
    return pbkdf2(passphrase, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(passphrase, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(passphrase),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassphrase, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
    const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassphrase = await cryptoEngine.hashPassphrase(password, salt);


    const encrypted = await cryptoEngine.encrypt(msg, hashedPassphrase);
    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassphrase, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassphrase
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassphrase
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassphrase,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassphrase = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassphrase, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassphrase = originalPassphrase || hashedPassphrase;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassphrase = await cryptoEngine.hashThirdRound(originalPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassphrase = await cryptoEngine.hashSecondRound(originalPassphrase, salt);
        updatedHashedPassphrase = await cryptoEngine.hashThirdRound(updatedHashedPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassphrase),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
    const decode = codec.init(cryptoEngine).decode;

    // variables to be filled when generating the file
    const encryptedMsg = '12c3e675f8eeeb85a383f76111658c3a6b73bc73a9dfdc3e01af253daaf83ccaeea11e79d806f9e47c581bb0de8801055682e997fd6ccc55e2b3fc291cbe0961984aa3741093d67cd07ff6dcd271ebc177d2f48b60dd7728ec83ddbe2a6565981b9d7e98a1f1a21020b4df0a3ec539211fabcd100d5dd699ce3c71c31a6f2890fcc2cf2122de769a0d5bed5e71a5e993de87b74540a4e44c03f0135fa9680293a5de5e461b2b040990773b29bc67d9ec8d6bc8a609a62ca98d24287bbdba8eb96eca7dcdc90528401417a542f9af026ff6b336e1633db1f02fd8060d70bf7d94600ca26b3f8a2e89d81db3888a005ad53eb3912c1eb281709a1b354596380e9fff01c90ce81db5e59627dc0af60e807cb9d5928cdd28820c04205568d0e487c5f3b97836fa618a34d86f55dbef48d50cdb269c1edb2fc203ff7a8607dab1ddc24fccdc70483cd21889cf4ffa61bce10d8a81eab376c151fedc234d4bf73482140458dd0321cfe622d1598039a3f8ad6c6bc8bb516edd7aeaecf862c73203ba4a12eebae82f6133c3919d3dff69953d79423588328141e20c8a28cd642268119b15f46d469e3c08cacbe040b0ab4f84fdd1634071addaad76786795968cda695224a13f45d1fe161b35361abf89792cbcc3ca7aba5c152a76890c7ee4ce752f59db68d9d388088deb107c1d0843a77a94a8b251b87133826c7b4069a537637cb8b09595919e9cd40cb5e6092a349aa91edda34118cf55663bce80ae787498142580af806c98ea7fd718d05ac144c728c7d13193c91ca017d733b87fedf6d013817396957f064c660550eda58596309be6f274a5a0428987f301960c5c2e774cfbc73d79b7ffd7222b277f9eef5fdebed531ebb487b428bd0bb1b09f5984d99d69880ea22cce403e0126017c5bcbf52b6d5939396885070106a3db0ea15bc34d379b6865e9b3e6d498c4e2e412d7dc1ec898e28f42a21fdfbe9e5bf21a4874673efd368f715f250725a459cf9dc5a9fd6b6b1211ffadf0ea2095fdeeeeb4d472ba98fa23c8da79bab98f40526083127cf95e1369215c2f53acb2ac367c6704766c8b924b8ad9000f61ab8d9ab9b029987ad84cc50182e097f50e9562f5a4c24018d088e7caf356777de7fd28c7fcbecccac463025e9152ec37e92aad9a900a83b45c9c913167cf02a8550f5284dc51336da9d77355218ff4df74c06048e3537af60a6d21ecd68d48f345b6b710fec7b446a6779a2d660d09e0e5ea697288345c1622fa19beb6107c65961593f1b36271066a1355b2ee18640f0ba52e0cde5c286a7f575c042b6cf61bc03b6c5da96439798b62b0b5049a1db9674f60b1efe1d1c7c5b4be19cd873937a96df49bc97e8368917bcb934111893b93c7fc555d35dd1ecaddc86506baa747cce5ae9f6c4fdeb557448cd007583859cdfa0c211212bc5b832c149acf9ffe9592d5c147945b3a543e8dde9f855ea6bd6f54e0800dd251c0e5ea79fec15958e9f95aee9fd49a9ce99f302af68f05678af82506c378e262ef39de20eeb5a18f91b324ee06a7655027f6cf1cd1f27e75e8cad115bf290662265c171b07f2ad59f56cd3877e565b673a4a3f5797813da223b7b144bf8f9854e7c0c7935cac7c5eb39bf09245f22c6b23dea09acc10d20bea2cd9a114b7dd758bebeb1d6e772941054434f0a49681bcc1758496d5f6c0f6547eb1f0a14791cb02c50d76a7c71573663a03d7996b403a952e4d103e08ec57a6f5d8b05778874bfb50eebebaa4d2ae9cd2bbf43b4404d310679c4d8e4e0342d7006913514b0314d1bd274f76a129b554295beda4215754796192f68ea1db9c8eb5b9414f449a56a1afb8cf4f6966f1047e6487d077b6bfa46d73dc3ed771f100e5fd76089f2d2c9db688bd37e192e4dce4bb5b0320d28f8a42fc021a8c594e9177e512bf0d64811c2e93b77cf5adbea2db472c76384322b9eee399c1a89dce54032ce57a4ec488e79b681f391efc733cbf15fb07d2fc08583d0f086a3dc55e84a1ea1bb1ac5f65c8696fa10fcad2e62f618962d3d31d69bf541c498a4ca5743b0d8bc00296d746073a86d86f8aa514404193ac296c4fe77246c952a622ff327f6e740a6e1e34c4d7c196153f27d7446414608fed32d934468288e08ba0fd56dbd5addc0a60663ec84f523604fc660c7cc6f49a9c4cdfff7fb7e9a0ba63bd18cc81f6a5d6d5f0c43febab62288fe52602f52a239f31cf01f5c833248c05c9190ec2d0325adca4392fa489155706c0ff2860db3d98b262241eadee54b819348d51239bb4922fcff17c60873b166bace3e60845515660a1f19cf0496533f2d706081a16b1e3ce314c034b5bca7f129730b26760678e28cdb46db2daea870e9566182b29681e7de1b87e2cba29fe1c96b0035eb2f365f829921af24c41b294ad9ca415c89004ec052664fd487e3fe01194582c1aca3e72aa469bea004a2bbb36067f37e33146b81158ca6128bbce14e3b88ea05cf60f3f08da59de200fa6b0d903c5c385a8f2d629512995a147d6d45e5c863932d1903e2c60076fc73bfe2ce476d3ad616c0ada8e3d3ea94a4b78d3d755dd91143e27cabf65b4c81ccce1c8988417d2391b78d7aa9825d1092c48b078f542c1f1121ea64ba772391e7009b1b77f7c9418dedb502364249fe830a509798d395d7bb89d3c6c6e430bb1a1168cd2a8d30182839015affd961a1199a703e8d37c3c2c98b673cb67873d3ca4b2055f443dd97d65a3c927d310ef852f894fac31c228a5db82a1618bde7864e227d3727cb29aeed84364e1f8e8e82826a92a6c05aa4bd66c5373f2857743425d59bcabd678e1a6c091fd9a7b598e038612253c06ca5e03afd987961fd021c2e7bebeb32aa9672fc361e3c20ef16ab297c6fdbdc76c76347602a70dcc9f4a2f7ee3717a989a8dfa82cad776b6f0218874c60700d41cd76c97e93f4c915303f9c356013a592184fab5bae432670af07afe505a33735b0b2677d77204a489eddc34e0d9a1b1e99193d0158b1569161e57e59c378fad7f3cc35221493411b93192b3aa44f3295fb50aae1d5aa610738e0f011b841e5acab9972caffde297ffc5966cabdc946214d268bb6f86a262273a1812eb40e75134669097bfcd2725de009b3756a734cf1d7b11c1b983a2f3d5a42ab1201b45585ab3d81ee2e8606bace552fbca62f8d611263c9f5a9a13c136b22c24c8a39a970152e03a9643d9abff94bb853c826e0c549fed5b0357d32490fbae5d34b8e3c8cacf1f8bf6b8e6f748509598acb102b0824a54190ce2216adb50a9d81a17096fab8f9f80d855bc158aafe42d76dbdfdb74eacf9eff7a705d4718bbd2e57a8f216dc1f9fccca41b1eaf522d369fb37389de37f9c679b1fec9bbce5003674df5a886c985bad19f75eca84e95226e2380a64745f99ec774120861b16dcc903c6bdb696b024c3bda11fb7853cfc48f532c0e9e0090f5f2f368c59535f63c3192d0daa765362469f39a781aa0f8f0265fbef54fb0a491f40ebe334e7ae93e642decdb09fa50d7f95a75b918c287d2310000c951944cfea49d8c46ad1cd1dfb2d48a8feb4ecb990573e2d10688ffc882d6c67aa4b8f0f8a1f1de7c0b452f6ce9d32b7c3f1a4796f93045c82992a85296cfab2f877da515d91ec9dcb30aae441a08a18b883a7ac5c59d98bbec535db102a50819a485bd3b3da7bf7be86578e4fa7df902874f6fd58221ff6d008d614ed41c035cfc13c895b765014443eab7dd43a321a9905d713b122347e7d5cbd7b2796afdc6a107f8b3fcd772b6be8e9ae7621b28d38b1d5103351a4f11bfcfc484a726cb2f64673fea0c8beb8a18ab7b6b9f043692d662a8ce1100b48b3403a1a5c3b09ff184120f1d83b7ca587006d9b723d2b84c2bdae194d1597775a8ca0d19d6751a9710fabf0a648b561c5ca63efab560d5d6967681879c82aeaf124dfc1bcf1484f39e26d11752f7662c18d3a3e05a3a544239dd6d5669d0fad58117e5b72188bf299221e3d2a0dca843772c3629b4053d6c8e966b62de2795d8e2465d2c77cd0e5be3f6e895e84e3a254db59575d8c6dddb57531136801541e71b2e85f5791ba381be34004a8212aadc1c8bfdb74bd4d4f3b2a7fb8ebe8cd5fd579b023d4e78da380536ca135f95c2e3a83087a733f3b2d54a70705ef0d3db001fea4eb213c79951ab51812db46a3e82dfda5b91cc8cbdedf195db97bf31d9be01b51c7354cecd6575b8acf03366f897ee6b002b7947994b5c1d76cae03358826cd93e85f57704baef4c9f491d1d6842b1f15e7e004be7d84969052c1956da1a6ed5082d2b996182c4005fcc17ee370ddfc250459ee3a108b3c68d6539f2c4387d9ad2f41cc0fa650a70a3f78e86dfc01053dc8fd6f813746d9c18168442d79ee9e3bb53ec93b6a5f2f1be9fa1d458bdcdb2ac01a4f26bc097c20ffb83b215f316bf43f8b65a772f843371e0211a04534ff1da78cf61103b93da90e3081cb1c5f0328922e4995776ff2f6f030f4cb3002428d1272a18a6ad98ae55ebb854dbf7087b2e9e89a8d135d6d7847b92e30c40f6c324e43c15ef4e28f175f0abf8875ebb883970b50fb838054d3cb54f75a9dcf488be650c3a71697f62daafbdd1fbd89a26e09a795d0d941189400ab60b58493d9287254c48bf7aeb6b1c4ecd75a88e198752eb0c6a54483e1ee9e293fd8572d9477043b72d6d98c955eb13b9c8e5e2eaafca32f266434483db4c475ac0141b3b06022303a2d8137505f264b2cc8792a6061a0f4b9aaa113a7d5f2b4f97a55a623b50d517a40d5968ff4e81e2b992b13222955eb65f355b45d78891a3240f5cca91305ff8f309736cde6b9514c76d4c2cdd1ff2ace5b0fd018c2812420be33c73b48df8cf2cc628c3ebf12d93f5fbd1d64ff2169f31ff4205ed6883166e8a19bf8e08bdd99d9e599518cb884619702f4b132c8de9c119e0f4505e0fdbbca52fe05ed76c6e15155e1e8701a6faa3a09382fd58e99e649f9ad0a74efa0e6bf1b049fd2ec9a2f23be918634e826f794d8f4c593828f70d0782fbed806835e93cfa77e519e7a89293ec798a0093b26a56f96c087a0a1d28926358e969572bbe95e948581a38d80a0f10262d210cd7a8457a7484303e707adb316d801660d64aea7b66d6b33bebe38f893a632e61052a562c5cb0c1bd79f6c17a2ed5b19537c0f96566d8b1e4cc42788e54c53b0f8738d9915d1feae085674b4c5f3d68227274875008c630c3dbd034d5ebebc9f93fcdecf824744395875779fd270c7b11066188aed2c293ce9f6e3900ac8a6f719f279dd509f43f6b03ccdc41be1d5c404ba1bb3aee7ac936a4842266c107da0cf6b1fe394271d6a7fbf5bec3a7b91303d5b7a5dfd1736fa6d0072038bbd2e594a6deb9382e2319077d3ac8f94262212d4befbf2f2380a572ccaa72c0869ba2a18266f1503b912e28456c6a9ed87c98e03c5ebd8f0ebda1bc13835a13932ed3ed51bc406f98f31e8d7b1f0fd32b7395d6f1c148a0c8913da49af5cc039ea6c25bcadc8b78161a55728f47a2878bdf5c97081f90817622613000ab4b6b84631c1c6d5d663421ac09b155500c5b563473e07027fd380f1e3985309400610ceb7c7c8de04a05344634e8a3c28474a8dd161f0b08af0e1eb0292411bbdf06b84790dbcd15a41f7cccd9da5daa3a24d3fab8ee29e27c48aef27084fc0c90ddf08dc2db04424b9f39ecd375955710c91b1e392e29e775477fc804d4acc2b932ced1efa28c4e9d34e757d8d701378613fb54c0d79647cbd07b1efd64fa7254b627f595179e09763de20e3e1c5164152ff16a776946eff84b6f9cc3f9070b661eea2b05534eb7fb4703d4380a53ebc75932f9f5cf524025086ccf015d0fc384928f69f07751f7b75a90e5ad352ca2cf94e617a46ed562ad386d821f2be0997aeab7aafffb8af08a3a4446baaf196d9b3664a8622050f17a473752bc3b647faea5a56b820d66d913e133c2a9ff89224798c41cae4bf723d6cd861ed0aa80f9ef1556d276270a0fb39669cd172ee2093b90ad213e37bd107a984e8cb2854cd4631812a0d346d643a93525ba73b86b127485244466a197d27c003274bff726b5a33ffcdd774487f4de2a9aa1bfaeda0da4dceb3d508476d5c7c475258d9c9bc1fd321b43c386de7b7ca39eaf771542adbe7dc9783dba0cd7af985a9d238bfcca58866f4f478243e52352f6c617eb6fdafcf66fb5732d06e7a9ce6c98e3ce8b79324cd2a9aa5de9ef5981cbbcf07d13b6321c1f0e7e3a462a8a47044d76fe552d493eba589050d44a5b4a9d6effad9ffc52b67db7bdb0fffc457b7499ca1799ef75008b21c24bd578db5402793c611141bd714f0e2b6c6fb21df517cb20d4c3db64ab896617617fa5c182952c858110e3cc1abcbad50b24fd37ebaf6a80f454ca428acc1e7b1a648096ae1bdb680e3677652d776536a7796b54df651e1ac6b2f70f27489a9822a9ebdb7913095d137514bad05dd6c88d7e5f3a41e365dd4a9ce1e960383c842072b423f88d5c73c525d5be18fc7145ffd1f995fb6b7877a9f89cbdb8988f60c895ec9ca3855dd7eedb3082f26c02c3b5fca02bbcce6cfcc311021dc0fa39e22fba7ee2ad6c5d8468e83c497e18db72be205a4d597a537321565ec66b69b69abfc0084aad95e8215ce4e0d01820aa946e3e8c35b4055f4b362d5dc56ebbfe6c08e4b6ff57fa550383a882d4280b3185633882cfba061ca61909256ef03e4d09785d1e8a60a4f76caa86dedb7e4638512133bc286c9bbf73045e6710ee1902b3d4b0883061a95bdb4e5b01d0a28d0db80301b5dc66d97e014ce61d34aa1b7dedc8738f34539ed78c4985d098d8f87ba59921b6655838cdbada67ad6c2988010270e4f82be5fbc0e95b901121edac63394781d36b13ab6a18dfeefb34ccc2d0b5748bf84948419c22f7a76688a4b36669b287dcdcd62de0c5be9ffc16cdd008c324b0e41ccc6c9c2da05ed61c037ca93154669b894fe96126ed28d77bb052e185a88fb54dfb8eb61a75b26fa7c23ca0ce0c78acbb0b81f5c9d53f1782a1aa65d5f8b0cd78c4a08d4d5815575f973011151e20732902029b79e3da65485eb2d35d720ff8508bd790af81a1888449fe9d9d02c8503f702f14638960c67c307632febb1534d5078899605a8475fa442c80a45dc17e14b13bfcfd7af5ab3c318afd9a4d5910c4288590d8198d487c0bb4358da557d5ceb3eb453296ba3295bfc581dd6faf9c3d585a9c606af4248b6277104cb05cc1bc72bba5877e9b6994957607d8cefe088fb01e29e944ffd1955f86805676139216fc8ea2027d80f8dee135551b1d57df30f08921d6a03a70beccf4951576146fef8a24f7030b734280880a04e7d8ea9a82e71fcdb82794beebff4817055af4ed86615791af94098562d2019f755ff8b876f98859861c261d8bb413efe005d243191238fef700d2e251551ae80a72adf769cc9c0139b6d37ec28de59c2c5b48bc5869b6a712112462e288e972a4cd69bda008e5e8952d4890ac2bb75d99e07c0d928dbb5c6417727b398d16c656404f7000a22de58ab385eba10b0480d5f70fff4a13cd111b6a25ec9bd665c4e5f985102e8cf29520c9a386250b807e795765715d8a75d5b95c08e25466b9eba9800b47f3510447384f3b8506fc39d489f4208abcc59b7dc7cc124258f9de6578eb7a0f2a63c76ceba457f8ff21907bab5d2d78ab4f37bc8ac34f1ef29c5e4da2e48b89b524d4421a277f08b3d3f1549bd406f78c4ccc83d94ee8d9e57eff2a3edd13ed0f1eeadff8c81e5c407aabb5f7dcbe0233d56ad35ea6db3ffd6a46dba928d72af9e85fce27c9646d9785d5108817e1b56d8b6c1d501a983b17a8242486b26a3ebb29754a08d093dc88986c7a66918f6d5a08d6b331591d40374ee21f8793d4d88fb21e2db38ffb5e1aea3f86b36f2f16cbc9cc01214d449ed1cb5792c505d22c6e167784d5702f6ca71531ffe2eac20dc04bd0dd18ac52e7291fc0e5d11dc6390da77d4656140ea3d4620f49c36c31d70c691849672c4026fce8664f7fde1c7088d4a084b296e2bac496bcef8e862e35e6e8c805d96248260e98e120917ea3a1f3eece18537700cc51c1869375374adf8cd784a3aafd2dfca0c7f3c11217395a771df08ba32a2d68a3cb547732555908b5c1a6cb36a34528d27f81261d3a66efb8ffd79b8f0ebb604e6ec95de3100699735cde397bf8aa6172e08942b4758ebf28e446bf580405ceffbdd2bfd2265b1def907bc117a845c35012b5b5d394ab7c0a521040670ec58f67f02cb7e86d419a2de23f291cfb9ffdcd46f064831568ca0420bd718caa2ed71b299cfacd2c7cc42149f31dd6240dd85899a15341869d192bf8f40569e99dbf0c7cd554fa5ae25487d59ef20e31b5ba9067536617ec3c636fed05c2e0bafe2813e37370c471184f2659a4d7044d80c9a134190b1ef7391ff115b0ca0632071c1c9b3643d43a971063489e8fc33c2b3044cb4628f3949b5b9ba879ac3ff2eb468c26b037b2f92e1cdd30ee620653370455fb12e1bb4ad479bfa2780c9bfa833c4ae56078240d8f70bb98127c2672631f75058bbe82e9f5df3587d366ee2476ff0272596c74f8b825ee4d9df9d170f8482ca711ff5165634cc6a75b10da74b5ea90c0a53800a6447c1c3d65af9ac533b8ff2fc693c12a5cc1eb026c2750c63e0345e0fce8c75ad46f5632af91e28e761ce18d4f3cae1ccb4aa96555c36521c253b0b1a1fa97ca8ec8934c68e8f7088ae1790173d3296f1279f8adb618c8a418bc09dcc7025999aa891d9e7139450fb9185bae970c2569541a96ecaf2136599cd33b74fc8df7f359f6393d7d0424a697837922a992f51ddb84f4fb0bb83293ebef7a9af5abfd1f9ebf31612ae71d5282494fc63a7ca4e8590ec0bed8261ecae4c83d1cca62ff4c6148d329e789dd40528778092c4da7961c7d2b1a51eeb1fded0660a17e3771c23b60dc5e7564a66f3fba993e5aa84ad0f90edaf2212e1fc9632cf340ed04cddadd78c4f6cfb301983ef7ac467abe1e87fa6302534d995bcccc54d666eed61935bd0ff5aeccd64f747be5846364bb72f1c9af1a2cbe61b3d4d1074409672a4f7c6f0bcf9465292e41e13daea2a146bfe529edc7202bb27becd148979fff41955b6bc7aad1a5ee89c71148a3314adcc9a4583b32be9bcd94536d71e174560d88cc9474cca44b0948138fd01498389a144e68751d9f6625b878adf95c10503479dd91e478b6d9712f616393e244d29615923214448aad7f9aaef5632966110fbd0e01aef69ba872f88da61663e58593929a72f58d624b38c9e5f1a6c44197697ae9226f5cfc3f80c4bf2bca03350bbe67e2c6fd7e1f50ac5e78a6130fad1a609812179029ad41ffe51deeaf853efa9f2523e4bc34f383f2989c959af5e0790c6814cd3e56444f7f1eda02eac5de8dd065aacaab66a632c96e2f13e4e7c239d9e78c70db72805440217eb93c4409d32233daf1cd11d69961e11bf3587dd4125abecc163141b96692dcf664e1fb2b51598cb7b6b325f0f1e7bb3ba25ed1a8e6cc209fe0ecdbc46fdbf30b07628fd777068d00bd4be1ef8c9e1122b8357c41d8e9cca06986f800415e5d06dbb862dc4df0e0f4fd7d4bcecf232c3953bd2882df4cc96d7f6fd5e794e55ccd0b2b6125347830b5de6ef159193633843d2bd469a6521332f387afc4eb677bb950b7036f6a2aa883e7ef05842be9ad0b8c5fac8a2d21939af33066ba4369f3c9969047036e96bb9b91f4950b1730c13e6f1740975bbe7bc4d5e80d417b37b75bad3716120ae5d6901369d6e04a20da70247778a6f8e2014e2f1d5926e562ef3ad47ba69fbe8bf78c41d088a8690cb40e455aad525aefb095e8f7fcc6f1c81337102948f31b4512d942a333c333fcf7fafc096df1b1c92bb09ce76eca6671c209b39508116e7c0069cfe77cb4569c80f936be465156fa881dbbfa2e1e89c206a0d2623e3bb40b90b6506a446285c71619ffcef30c0e2144060f3e677fefcd2b3a409f94ef1ddfecfc8a2bad906e49fb232eed0a1d995346fda10a0f0585413a28f969cee4de6a40d150e9390601eb10970f68790e8e76263a4d5c6526979c70d538b6562e63166428b23aa1d9a05acdb05816b29ece9edce7af5ad458beaf9a344e5e20aedc3f0cb1e99e8420c6b21bc66ea9cce16ebe13b2ea55d91d34e6c94d4c2eda65139756c43794575173defbf6cf3de4f200d8ba75c3bdb7889b5a96946dd6292af55eecd98f854b82e6fcfefb4ca43c34fa708b7c89727f2f5da0bcf77846630f12bc406f87151dc3ef0d4c82ede3fcf0e9d9c5b61d0959711be7ef19d7f234b2db08aa8c5b8632ef6b95b3d6352938f145033d9cf463ca458c89f2f8b95010f5461be3743baed8a720b086651459e15ed265466658eac60b2b92a42333d8dffee5d6b30e4a354cd993dfa0fa6b0a9fbf6a6a068114929fa64f147f5a557c61cfab29682c11343e01196e6fca9ea7af89c2f1e03a341fc31c91dc85ccbb942a845db8cc2541e69e8e40c0e21fbbd7fec51b907f0e72e14da04e1fcbded14696055e71e1af6da845fea471cbbdb673e0b84d9fa416e19402a18f7a721b8f6ca27fc1f93c46eee4ff4d3a3b465dabebc52269df1edaeb86af43799ba643d95329d53ea53aa06236044312d946ebcec7745fc6b01ae7cf11e2e28a84c736e184e3fa48a5e89bf892353faf9b35ca9ba589dc1fa312e7fb7a923f60c04cacddc784f536dd6aeb80039f3493fdb8b4ec6acb0411f5b6833ec8ab46171f9931a860e3f12b8f9b67cd40a1684d6d7b2386ccd3387fa31711f5553fc2b59adf57193c9cc11d7924634fa322fdcdf877f6df0bfe437247ad2e877b81369b5b1f8cae8f714a980f9ac8235361b7c4f33b3c0ccba12b2b766b55fae77970ecea48e0845d552f86de1a6fd532f0ca40620ce2c1f032be76ebe668f5bfb57f04a1127b23d4629e7c86e88aa0d7431dea1522d0c7ce36238d47ae0fb09bb3e93a88c687ec24a0006b02ef453f3e7b1d6f08cd8e7bbf626ca1dc9b62ed8bea9f51768ed77886c76c30e18081262366f37db74f111cdf26a43e8c3a603d90aa645187bbc6bd20acebdf7d61067e90c11268dda1231aa6af7f376f4bac37b7b4bc831d81b32cf20a55ae658d6ef390d1dd11e1747e401f3f1201b8be13a3bfefcef5e341f8cbe5e60dbb031ea6c10d44f0e43780a268b4ddf41328648b1e47f4892d91a8fb20a05decaa80d7219d72ea6708c84b614145ecb4b04e26f89af05235f103748ed8d9b9f6f5f1c35f20f1db76328056ab661f3f58d736c57ec83775a97b6bef275bbf929026beebd3f8c2ea9532502fdbc641ca4e995e64a0b603d16f06815b48aa91f96d0ebe080793100da0fb993c4aa854d62bff96dbc89b4156afcb40e9ef9bc8bc09ee57ce33706fc7bacd83f48da71047216a459a3810e6817d15c297ce78e6302e73c45336077c6042a0df578f5b28f424c38c9eb621cdac40b0476e6d6c644e7170f3df25e63cd21d2242765eb87654151d66541fbb4c574be9578b80306342ac61790af88655bdbd71a64f52ccecd9795e1e11c6970b6bdd7523382739b5479b24d3603927ad2046f0c8dbc6dbd2306447a3d9d98ac1c01e4bdf345ead7ee5ae3f7989277e6f7d6122ed2fd95111bc5acf3299db5477bb3d65679b672e27eb6eefacd93488e7df3e269b951a4349aaf5e849d46856cea43b7031def0a709e1977bbe5457cfdfae892fe4cda8193ed788521f1baeb0b382df0ccdf6e588c0a1ca247c4d0e81b25851128ba310d2e327102f19fa5792a9fc0826ba894e613621057504d3cb2a2062deaa23622fbd4778c52e56b267022b51a5ecf3249b1606d6c16a62523b2965f04fd88546fcb175c38a9eee6fc55820404d2aa0fe42abce0964366f29700c6cd3a3ef4f680c8d955e08944a14963c51093cddd6a3c7d14402c6c70498ad7bc17e50ddfaf7afd42424d0cdb855ef6ef100edee83e862b5e7533cfe743e40baeef9929b645746b02a39b0bfad00d0ff9ef760f5e44ebafd8be14dcf8481bd8b928d249b293384065eaa2b770261294b67bd6b1595a0e18ad998b003b2b87e2d95ff297c99b13fda9eb183d609de90b16da21428a734d43c6fcd20215eb6805ec99b8a345007818f8b7a3ba488770b1c8174da2cdb10f62bd76e8e32ea90f39b42e3589dacaaa54ef311cfa89e42bd7b528717c6d2a7263909e304e283d966b96aa01e03d2b169595279c972d7ac76941f73178b8ba869676e5eaf5281ca96e4e4a7a46b6015ac8c297e9fe8e55c3ea86ca02589531dbf4c76949d6812063b1f4b0b952a79b136ff2f742e03feddea322dc90cf59d5fd4ea6abffb65c49145037b544d33f1eec4f4085ae7a1a4d617c7ddc2a16f6a4ed804f9c422af7fe7c8352765b27a5379af3f5fb2fa735bd66547e376c279',
        salt = '928b582d4111a8769f131c7730a03e67',
        labelError = 'Bad password!',
        isRememberEnabled = false,
        rememberDurationInDays = 0; // 0 means forever

    // constants
    const rememberPassphraseKey = 'staticrypt_passphrase',
        rememberExpirationKey = 'staticrypt_expiration';

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param  hashedPassphrase
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassphrase) {
        const result = await decode(encryptedMsg, hashedPassphrase, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        document.write(plainHTML);
        document.close();
        return true;
    }

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        localStorage.removeItem(rememberPassphraseKey);
        localStorage.removeItem(rememberExpirationKey);
    }

    /**
     * Clear storage if we are logging out
     *
     * @returns  - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        if (!isRememberEnabled) {
            return false;
        }

        // show the remember me checkbox
        document.getElementById('staticrypt-remember-label').classList.remove('hidden');

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassphrase = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassphrase) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPassphraseQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPassphraseFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassphrase = hashedPassphraseFragment || hashedPassphraseQuery;

        if (hashedPassphrase) {
            return decryptAndReplaceHtml(hashedPassphrase);
        }

        return false;
    }

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        let hasDecrypted = await decryptOnLoadFromUrl();

        if (!hasDecrypted) {
            hasDecrypted = await decryptOnLoadFromRememberMe();
        }

        // if we didn't decrypt anything, show the password prompt. Otherwise the content has already been replaced, no
        // need to do anything
        if (!hasDecrypted) {
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const passphrase = document.getElementById('staticrypt-password').value,
            shouldRememberPassphrase = document.getElementById('staticrypt-remember').checked;

        // decrypt and replace the whole page
        const hashedPassphrase = await cryptoEngine.hashPassphrase(passphrase, salt);
        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

        if (isDecryptionSuccessful) {
            // remember the hashedPassphrase and set its expiration if necessary
            if (isRememberEnabled && shouldRememberPassphrase) {
                window.localStorage.setItem(rememberPassphraseKey, hashedPassphrase);

                // set the expiration if the duration isn't 0 (meaning no expiration)
                if (rememberDurationInDays > 0) {
                    window.localStorage.setItem(
                        rememberExpirationKey,
                        (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                    );
                }
            }
        } else {
            alert(labelError);
        }
    });
</script>
</body>
</html>
