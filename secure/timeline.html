<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #4CAF50;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #43A047;
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #76b852; /* fallback for old browsers */
            background: -webkit-linear-gradient(right, #76b852, #8DC26F);
            background: -moz-linear-gradient(right, #76b852, #8DC26F);
            background: -o-linear-gradient(right, #76b852, #8DC26F);
            background: linear-gradient(to left, #76b852, #8DC26F);
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>




<script>
    // do not remove this comment, it is used to detect the version of the script
    // STATICRYPT_VERSION: async

    const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 *
 * Mirrors the API of CryptoJS.enc.Hex
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassphrase) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassphrase
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassphrase) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassphrase(passphrase, salt) {
    // we hash the passphrase in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassphrase = await hashLegacyRound(passphrase, salt);

    hashedPassphrase = await hashSecondRound(hashedPassphrase, salt);

    return hashThirdRound(hashedPassphrase, salt);
}
exports.hashPassphrase = hashPassphrase;

/**
 * This hashes the passphrase with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(passphrase, salt) {
    return pbkdf2(passphrase, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(passphrase, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(passphrase),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassphrase, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
    const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassphrase = await cryptoEngine.hashPassphrase(password, salt);


    const encrypted = await cryptoEngine.encrypt(msg, hashedPassphrase);
    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassphrase, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassphrase
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassphrase
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassphrase,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassphrase = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassphrase, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassphrase = originalPassphrase || hashedPassphrase;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassphrase = await cryptoEngine.hashThirdRound(originalPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassphrase = await cryptoEngine.hashSecondRound(originalPassphrase, salt);
        updatedHashedPassphrase = await cryptoEngine.hashThirdRound(updatedHashedPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassphrase),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
    const decode = codec.init(cryptoEngine).decode;

    // variables to be filled when generating the file
    const encryptedMsg = '1c0db541c4f6c30c2559724283babe4578daa0538edde88664ffd510fb26fb8332134018e602652387ec62ab104bacb3b6ac41464824631c13fccf89cd1684a10d4c9bb558629ca896f5402434f6859444b6ef184c67d642d42dfac8294a97e3e6890c883aeaa9a7e409d55d37000ef3061dfc576b69455ab76c7e2647df1e13e85ded211b4e3a206bc8943e1a75c7dc66f114bdc3d00624e94cca801073cce9c9370830a25771aade850748fd750528caf5919894211b7327a70922f4ae1024f26e2465e21a380133f15013afc7fa6caa7dba20dcfb7d33d5ad764617f04519c2d55fe0731ebd641cce5bc5ffa44786bede0d4e7630d4bf093b93e5d0ac4ea9b0be9f83bc38becfe826d2e46340389549ff69aaf31fbbd0c380f710e4e706ab3b851ad6695943f9857f7c751f3dc00fb00bb0beda828890106b1d238c47e1a5d28f516824a3c38b9dac85c41c9eff30258876426c383231088511088234a717d457d19301a42551a98b3bcdde2d31750995383cd83987bff3fcc30a7079dc0be3c747808e0a2c780a380f1b80b0618d9654b342305a54e35c953e5efe3ffc8296a1aca2f5bc0e8adbb04b345b57c8e8ab2826495142c5f719a1fc3a837cd8f14672fbcface0cc3ef8b064c252ac9b0ad24781f8b2d725b1c3c8a703b113c44d70d15b92d7a058ea456e6637b47610fd9dc222561e2a23ffcb9ec1476dfbff7b0eaaf28cf90f7630076e099b3e52ead36f72e80d6604b94da612fdf2e67f9b6c06a93ebb328e2befe73b934ae5fdf098ad719acbba1c9d93755ea1de254d154cbd154f04b1846c8b83cc9bc176a9837e76c72d09ac49787c0eeed5b0b0a386249e6768faeeeec7491087bda43d276db94395cde6c0eee3ea3047c1151de1f76a2ee19fa7b40f90a63a7dedbe0f128551125a8f7753bed4905ba7528076d68a71479523f5e11a4a9e5f94ce9f1b785983cf7971acd8ff4804cd064cc1c9f93cf33ef06bbaa5bd2dac204e288611ce4eabdab1f117ac7402951534c81c33e9596b32448d0e03e7792eb297b13a9b137a40c0b4b586f0d4e3d5a2e20f69b4587adfed9dbb6101d0b88ce36754d152061b7469937f947d81e5467906d4138ff404c8cbf30f419d1f61f58750136cda5fd1ac772ae06ba562810c1d24b1f1a66ae5c0ac10d5f9a4e47774fc3c86c622e76199ac380db54c7ecd548a0f49020cff9e49069090a8bcff216e21d4f9876ba46cf9ddd13a86d857f3d296d170252d466d59df1661a6474818ddc38202ef0fb000511e3e2080036bfee0f9a9496cff392ce6b62b6f14a575e0cbae18e78de72bca59e3d07dfec87510f574cdbc54ebb95011fd76b8d0b93f21a05a96974e8881945211366092cc27c940de241f09f5fb64d1dd6136e0cc649ce629495e9a4f3285844de9803319fbf73f906429851ffd258f7578168f5180501f48b8177cad0dd55e3359271544287af16146ffbfdb797134d121ded7a8b68b15225ff3937adb74bec911ed4cf811a8306865385a26e27e50503ff5a3cc78c578bf4adfef9e0a35b7900b54d565b74e24cd29b5397545bef3ec4d85039625906734ce3b3a3efb01e3a9df29d6796668dab5337c1066a7bbc719e9911de2a702a52fe14b1ee023c721511ebdfb15797a58e493b46c2adf51bb31f7b77cb83d2be1482efe14fd517924f193d90695e256b56881313c36aeea37757f6c69ebda7dcaacffb99521da9b3c0e2ddbc8742c7262590a32b8aac8f8e56b329eb7625b3970b219c96a5a3df6b14045fb0c4ae887b2778e101d616f575ec1fe966e17cf9a1965f0b1011c55420e4694a0eadc27092b03ba1b16bf9d0537352639e8b1450dc545216c753df07453b6779d2a94c70371c46b8a98149ada0ae883e28d9a14e87591b35fbf05a360ae712aef902e029e860a483deafa5a1727d251a372b0c69535ea5aa84a79134be3907140c0bada6eacb01aeffd0388a594ef6139e895f280eb200b29b3fd27c0eb6fa1ac5cfac05afd330a0bcf545e3e3648f621b32839a0141f102526a951ac75a33fabd521dbccf78eef69a49a0766c2dbd99658054405eca48c024a596c8e68a201150d103126a95382d6dda6e1079228ed066275c0a0a5adaf844266befb6f35b9610afafdcf9e34aab2280c3fb426b314094d19195216a674f736fbbd59625bfa89c5ec72b3423b92905a3caab749c9595e1c2088910fcf5019823108a9867a16a8a355edadc1e3618e1f4442b78b80398f76d2313dedf60df51d5b4d21fac4e3477dd471cdcd9639db3ecdf56129b87e4d5edbb0f1925188a7f198522f92fd7b30841091ff025a44ec62116f435b201d7562612c0c5224c34ca158f4aeadc6cfc768fcdc21c9908677cfcc509cae80fcff9b4182c41194287d959a8cb1d45ec4932240c79102ef607424addd678fca2ba1f0bc49564cb717386261a7aa142f5567960c2356cf6f8d8cd090b987d9f1250c71d17f01d31e08a50cc5a000d6c7da9ef4a5eb88e777c2629a91128f45bf53d19912bb3ee42e0f7caf54de15b1ef24868ee09b3cb513f6099bd4023f37177f273bc6d8a7f7a0c5e9670cec8f5bd15c7af71fd2cbadc6cf61e02d71ff5ac7692e6d9aebbec095554dbc276e3fe89c69f93de6910f35f1001e48e90fdc98f383c947a09ef2c529ee65e4f1cfb63d21d0b6c74757fe7d895f15cb275d3857957aabc9f1e319cf378ae3088a78abf6e63e077ab9517c9a09883f88ddd642007e0e4aed7e9ef4145346dc7130b793a493ae302e67e2fb6d40e256692ec92515d8a3137cac9db909eafd3f47c91e198a0dbe1bc3cced2889b092daf8be9a443d4a62c46ce55feb4a45f5fcbf16c2ab1631c2c387d4120fd2a5ce450057c1c5058750791f4e02cff1b349d930ef98c70bdee9fa266350629d2f0622919826ced89c3d0ee612cbc3d74f65a3de68660ebe0fb747c21922dbfbe0b6403e86cb1224e1b97c88d5bb9f82a4236ef489f959f45e1ca40640ff45380b8afdaea52155d2dc12d266a59eec8c0d8a9cf83183e9bcbfc803067c129c28d0829927bc0ff875e4ab71ec6b94a96a451cd7555431f28f3acef262d6ed7c6aba454484e3a5dc748743f37b4d1ea1cb10e7b59fca33e13e73a6ad8d04b472c32ce2c6701a5342db468d4f19e80025db3caad9c5aea29efac1fcbb0e9011a32078a60ba22f2c2874af4795c6e2b1b2fb27886f255903a1729d02370b537b2d3083bdc2ba5910ff81738a4744b23f9ac8f56080f17aa8bd3b05219a5d831fdc71d4e770e8c3f0a39e8a2f673469ac0719da90cdd59e455a14a5bc643b3c0416bc929cd784dbf35fe064718f4f1129c6e2733e7db84f000bbb479b9a7636db1455e0f061f2b16a3251ebd1fba8a27f33d3d1461909695f6a8fc2ce97592b71b5d50564634e2e1ac8cfc1fd2120dd86d8f4115a5e478c6aacbc2db78546e4d9c47944dddb36b59e773fc1359df8f1b5a90a9e7e3b8da25c8a373a00ac9d147a816d86f264eb7461d28ce1ef503fb6b068d772942c301c0617793531dc641f9406c9f53d2c83f9ac7cb4e3df8398e1f5c56e1273d69c2efe957b53d894dbdcb5220c8fd10572c1b1e9ec8b49c911bec6c012588eed5ff0816c64d3ed05c095ce9a4555803ea9e5d29f2fd820461b97fa5389147547390e17cd42c122156b796a260169cd0be0e2d950fe46270099b2afd6385c8ff69e955e9a164ec85f1cfc8a8611c7e5e73436c779ecd0706c4f54e4f9f6fcf955492b0f2951a9d87fb19b7f806b8714db2c4e8795787940cc1dea27adc8b879e1eebd9e6869548aac12172fe532a814baa7bce19b0d56d54e2bacecea86837ff48f4c4e3a174e51a001b080fee0ba45cc756cb77b79fe46a0b02848a9e93d96e0b6a93285527544a47682f66ef0ed01aed886417bbce8a9e80b42ed34f7698322941022625a0999545304e0a1a7b0a257f8951f11efcf33ccdeffebc53d8a4b1563198ab480aa06bcf426b4a9c02ec286a724bc67672c87374527011838b6d9e14b069659154e2e1696f9f51d570f6c7f23f65f49d8071f6a884cbb940e00c2fddcd454b6580f590278ce08716bbf80cd68d3edf415c27adaf3db40af8ddceb385e57ba276278450599085e58e03b8099a78cbfa8a563982088d0bd9c426fc3c5ed99cd4f3962e51c8ca333488d68220fbe1e27d78be92097e757c5b60f72d66f68df9d1d52fc980522c527b9b4fed1a73150778f784283bbd04701201fe7422edb569d8be54b78311e6d177b6933ae4591ac5cf090c0eed24778d61d121ac0cdbdc2a4acc08b1c38d042330f7cbdb1bf888f033bec40a19c59b52b9936c1d5d960ecab1074e8630d069eb3730122fa951fd68fd1b1d9f31c5257764c83e58290b119643eed195e01bbbbf4e1aa96e10cf27719d91dac3584fce855d61f114079c9a2a9301b242943de14cb3b22abbf16bfb3185f8bd05243ea0f0634ecaede92d8696d9b9c2f5c3bd8ffb81a4ff8b985cba25380f5e4ef2f34741f064727d6e85cbb33929713f0bb36f94d3e7190227c6e8bc497aeb150922a07058b2f7acf3e35eba8853849f11576c6a1adbbbb97b27473dbed23f22660dbc84e43007e2e25c148e97c3fa5f8bd7e62d4ff2e3d09fb0d2bdb8b2895b71543395e449a9f969794ccf2179cb41d53db018ab36980da184b1112846186bef238ea2195e9810f34f1e1fce6a0b7cb7b137a40fc30be12402897153baab362788a3511086c7386715c5a5d945920e909bfa5b419c25ff8d3ad77765440d9fc62a763f06f385fdfc4c4864704e77ac91d11920e03658b15574437a2fb1e4f20ef96dd48bc86e21ffa2558b882c301e7c1f97749f1d171cf8dd11c3b7a4e5942e280488355eef446ed636a63fc6c164b5e90f7f2c4a6add4a7988506f6cdd916291a0bef2835e405a43c93c882d3cc8025cbec84e0669e7f858bff5698662eea98bf9aec0fa88c911ebe8efd3aebda6da9d8694773861104d80032c6be196115aec163bf9c0f1b13c7654481846625889a674276ce3bc8ed2f0cf7238b4bbbdc7d5141e64377affa975ebb1688f283ba479c4fa71306728b10e7975da2ed07ca2e5ce33139fbc71c182ac737f253d99d655b065de74531b3001029c6615d3f7a1129ff8ce50f678693ea02c7238252d219b1645d0b09a29f0272548a21d8df47548efc63646a21f07df4843314d5360c9f233749baa924c3ad38c72a7936a3ffecc6e56a03308240487171496bc0141a31c33cad57732131ace3ad1e0bc02770873dd3657e55d4e361a3dc5c8c67145a239505c91a708c792404873eb44a6b99b79db79dac4f5c17257be1f8dabe9348e75e5fa012660a9d7b8eeb054ae138f4499dd2fc63dd631eac1c5a77a53c8a1d318bf455368d5f970f7e78e7b2bcadee7387a5f822d5231670da1a0c19c4bbe8e6e6128a5e8f451f0f7def00aa6d88e5919c90f17808457404f563d3e08608fb2200af05634b2c675f99a1747277d254aea5d75452929c0dffdfe93a7ce041fb3cb0a1864ffc137e3b93a00a1c6a1660ec1b76db650187404e4a14249a89718aa4d3ae05e76126336a10a14d47e6f33c274b4d3138510c73cd3d426ee4e6b2b249b5cda797256f37c0a63a718bf590d195d922dacb24f480128ecd03ff664494feeeb02c27a3dedbe4fe8b6b24b29fd8a2b63a110ac282fda931db11c810539901e509967ad1f219b3246fec387f2f5bfe24998976dcadff62f1a47c87d324a4dd735e6065f14b8e325c72c3614e92ccdd67dd86716a05c7fe5e40f94791c9cfe00d16485b34b59bce808b159d464d5eca4880ac666950c1de527fff4a1d32d64292a890d3f09c771785b09775195b80374a4107dbdc93324ebc280b3abf662459119ecf0fb3a00e11163f90571557aad5fea7a69f4628df1c2a81f64c1be3bc453ca78f6b211d6c2d3f6bcf4950639df01d7cf1df22555079f593c4e205ba066b7198a118a07e3ec73a00fb920736f76046208cfae84040ae6bf2e93966179ad3dfde564d4f7284378241db70665fc64ff54f4391edd4db196df60b92120710ef23740c9e1e30ae855d8a12d97bfa48cd058eafc8975ede75f62e1681eeaaf9b1b8ed40fc3021099ac9990a759cc8632033a5bdef088e175a28aa1ab9fb364d9487ae0e00164a077a4c70a9315406d2a16f5b951c74b2d25b279ecea6cec5c5a889139c527e1847e7a61a313fb3c4e191c9f9f1e5e51d0cda3241d68be306e1e7fc7daf8f0271eb0ef682b01c904f7d43f3738a7772ad1744ec1585c924ff5e9adf196e812d6904e31657a7658472cdf74618a2f1b83266360a45f135f684ef219f236143ea03cd5019615b8811ae9009e3d9065e52f8450ee55b405eaf1a45eaa3d02df93783b5ef062d8fb446408d7d41177c5c5a5e97fed3183f40ad65427494bfbd98b2104e809cc76ef70eccadd3ecde82c5538045568951195d608109550eb007c6ac4aacc01014fb3e4aebdc35d4403411ff95e17a46cb8b505766fccc8bfe27276398466ae99cddffb65c2069d770dababfd1d6d49a8ee42fbf42bce1a2b26a54857b37e2b4309b1d255cd3f0d09065d40f4d958f38f311863388feae59b732c70e4f4803ebb3f20c2bff3cc9f55961f21bebdf9809314ba7573d4236d2e4c96afdd8676fcb454f4b416d7626bbef5bf7195330a9e0ee12fbe9d489d1344b4cdcd607c01e90d27bed78c3725387d63f8bce859a4318a8dcc44b7ecd9cb24f8568036e0f99f0485468c6b1dad62574e105a076f9eb0e68de925eee43d039f87ba10e38fa91f6ff7ffa1d18d91456255b0bd30c48bcf29712c5b661fed2ae38759cd7e8ec91ff2f7316b27e8c8b95b3d4d42c88426efc351419994a490efe6862e0d3a2c9e59d99cb3db692c09cf17c6dc24d1d27e40a0e147581cf3c6344e82bb7cfc67a269c586ad0a1749977f7bc43de49da8921b19fb1db26704bd74283a45335aa0f1f778b7eb6650f8f4b675c4c70047dbabd642a558006e27759b7e527f996ff33ab3e36128b7de32d034070de09282203f8e34cf4ff54fab08ce32969ad0b84541a330c22b2811f7d68fd54b983c4ddb6949b1560d1056796bb3222cd5c086effb2e9b19d89dc68270d3a1c6d2fa92d28c3b02f37cd5e189e3f4d43e5124f8973c384b2aee573a61c104edb5b04150881197c31a5f6fd27d6edad49caf0f01c5be8908db60e9c674ce0ad47a096173dbfe526c4308a3599ea66e91228437305c5175bf2008b211dba55fa29086a5b22b8b7b3ebfbc584085b45a0872cbc5499c835b18c1ba06da81a60fad45c1ea9c3617ac4e073a2c856d32d1ad8c4fae82e00c87925a0d4391625c2f21261c04e64a8ef8b78d0c5f9e60651c4377ac36f3cb59353d1c7bbd6be1f1a85e87fb9fe7f9aa269e1f8e80bd90a09e9848aa03471033ec0b03f34d080f5501d93816eddf9597b180fa22bac8986c371da76739df30fdec4535e87d8143ebb9e2ea8192180c695124f51553a1d492ab9db7e7a81baf98bef7d6008aed5287e8efead4244c154d21efb5360cdf0af0ab3f0aebe3746a6f41051eb570ae536eb95970b23e642f8241c8be2f6739dd2b1818a0abfadac71086a13ac6e6f1992cf6c12d565e50f8dcfd49be40fce02bffc7eaa61a408d7acb570d8d2e8646dd2276b910da5236012643a8ccf80fb1dcf429034cbe21afa80d14421ab6df27d7199327f79c11a7de4cf60c940fd0e4c0d5740a784d6e5296741a7e02d0a76c085edf17911f6fa6105f20533e789795adbf0395d1fe7b5e0846e22aa79b0595fed775265565a9e68250866a73f128fa978cbfb6cafdecebc5f4e7d2dc17cf744f850c9fd4ded71247ec3588ae5b8a9962b57425af90f6efc9e9fbc310e9ca23952b4e637963639f474c0402900f5f48699328d13a7e3861cd761eeb1145ffc46b81c4654d0ffda7c136b9cbf7fb54a99d6039e20c66b7db2d9f229376690dcbe10ae835afa062c63d0773f7fac9241e1de45a9731baff82d020360694a3ae122a8f39e01584e35bc0f8d50791564e5cc7704ed9f43ff00578d76e09704db196a2ed2cec2d4cf9e33aee843d3ba685559bd50f7bd5977efba741e5f55c33fef6caac88b671d1e7bb2e2dd5b85f3664f850d06cd165d9e9fb799010cb6ccd0db093b56c0ef7204fd2b8b23fea0664ce9489b0ba0851a7897aadabc6ed9b9fc9fe66857210b9a838a87c59bae17cfc41467d29d7b3665d4277401854c5c0c75962659004c583dd2e42f289beb55974ab6b0b1010c3b981e8dd70dbbce8f6237673ec0a2e6b7b6c0412c6c22ff63a804b7952791b3fd670a45bf44bb08aa040b6838167f8e77ea94a82f8675273a7f4db0a692574088143037180ac7b5a623382fea53e6fd5a55de1b2348f340373630a9358b5f7c9fbb10e47b25b911f7c28744898008fc01d80681e47f77cfec667f880aca5a843260c568f9142a93284291cd79e73493b0ab49b86605e037d534b372a1d548f3d9cb1e6d0597bc55055f409547cae09636c51e3101d71c73418567d726c6212c5e99d66e67d6f16fd733b9a77896e6e1755936f6fb83f237d6ba4a856a4d7add38c2af3a571fce3068b2452cf2aa30466baf63853412d7e4622bc9be8082edeb9131b56d04b66455502c3e89dd858ee84150f2b429215e818a82129b60304b30198bdf73812854f42c8f083b22bb5a13709f204b436dcfc193fb9fa36cb3b01a36dfb7de7e37f41ce40e8383269fe8ff9479c2c46c917d70a25812de430b1b3d05266fcc538c0d979a355624167c93e300d0a7cf69a4c6bd5721ae3153df83e67be29edecd53cc5f90091b5612e284fd37325ddac9ea9c1d0a52863e3593135296215be63b9b69751c0bb670fd4894aa0f9f7965b4e0134c86917977a3138e75a9f1e6f24ddd10d082e962ddffba62e5c78fc9938ee279623d6c3376f91ae5412040c2caf1b5a5ca3ae3daeb5dd138b10dbf149e7a747a55411b4ce201e658437cbc8b970913ba08583e184a29653fc4d8887a9c0425e2fc0a8b5c468e475a0588bfc8022b839749caaee86b833bf820027b99199d9d9880be95c1aad83721382694b61c6f9ddfb60bf9dfe997fd07e8b93a0361c97d5f42bd444618192e1e28045aa5129d047d0bfd04d2952e1831e1fce33bf74644e78cee106835f8ce767733228baf1b27d632644d9fc45e3b470d6a8b42ffecb6056e45fccc69ddd1a997dd1fec09a6fc7a2922531cbd33105471e3b5910ce0bb5a3d405d1a53c4c778ca11be5cecfa6105a64d78b7e9387150f5b56ba4c21e8c8749b3ec99e654887f70ff4123e87d262b4687904195e32946662d8733bcd23dd9e7b7116cb062bcbeaf0d087c6bd766c8208c35b3e3f14ce1467b6af634c5d781bdc9474b5d55b69ccd1ca9b667fa6f3b6ebd330d5137b1085bf968caa29ab058dafbabff4f1a32f877537b82e649be26c410e55df045ba9958b31d688c82237e725a2613d6977868b40f3281639b7d71b3e28d003a4060bafa58f6ba1db0cb4629ba39df1677ed6335d06e4bfc80770b602f991109bb958a6a2cd853d4bab13cb15097dcdd1ba37c9dcd6e7332b0d3c4314c72d9afd782f985e17f341ccaecef712c8aebd418073dedd55b7ef30006494ce2674b070b4587af714e4dcd8d0f9886a943246dbb30f3d1b1ae45befca2ddffcabef4fca710759de0fbfb133faa6cfab69cf970d942131fe338d05ffefda60daed64ab51953aaff6e7267097690a996198532bc15172898711499aa2cfb26d3c79657585b1a708f2218c919180828fdd01153d80bf502bb64883782747328de1c68b696b9f6ddac3111d4b8f3bf56f0ebb0dfa6cc9e9d4af5d4883e44313933dd2061595621b3c9abc41b01f6fd3de7cd0ce7a6748d56d4b96ed554a7e42657b6d0a0dc2eb3749a03ed355223e9389710ce96b97cfc12c3d557ae79cfe09aebb2e914547960b0b4c943cd17da050ad0c7caa7886c53ffe1e334d6d383abc390a90fb732147b796211b48e85c41b5e0d7ff0fa70bb11802dec4213f39de1f09583471ec0b52c42762291f43dcfd0b722809692dfd0b4f726dc3f6dfad12f3dbea92c753553eb544fe27d4acf72b191b60f5349c8921da5149bf1213de4913a5f05cb45c83ef06dd1ca5f17a10e9b9d394bf0229da2ec6a5a1158776777b308fe7442f690c618bfbd692a1f47d3b3c39b7a405990da5ef31eca10dca3268ef56d69a9fe7b1b21d8ef5246e46acd2ca60f5d1c982b86383bf5a8011f3173f370f4a23dd9d641734e4b11f90746780a811ee145825ec90abb6330e3ce5c5174056c9445235e1cc59d8c3b3bfc8f54db070d8e3f5e2abeebdcdb955002d7aae7246b78c6db9d82078fecc00d94e48e338697d811c9fed26119ece802fe8296894dd2d1eae36eb1cc9b7bf7622a84733f170e3fdfc3be886741f4b00361da3cfe7e5c2eb3b71fb21ed05d6f2fab2c30586523964aeccd38974e26ab1418756cf30887ee228f580cd7d3b14ab5e2473f0598d8058a3e33752774cf3b78ea5fa8c7427922e7b4aa9713184e3ed726dfceb65a3d63414f75042467eddde7a5b778b7f5d2f730debe9b09fbbcd0e2fe515293aff914e8a7059d1ddfd632dafd12f2341314ee919c6464ae889e996fd7a44e75a97b49c73b7b1c0360ce7c2f5506491e96790397f7c5adadd771a7e8f42804b285ff4f4fbd8c9e39890f63f2edc32bbe0437f751dc837049be70d3d2e6b0f0c0f6dfc25e2dca4d4f52eddc2ebdddf9e37492022441f9160ec1baa148cdcfa784e159019ee100b589597f94c6b06a8f3db2638c24418d539e18ccb6b49d85421a844e8efaba589596d4a7ba311d9d8b2334f94ca6d64ca4bad223633f0c4383b2da3e9793addc255749398dc33c2bcb6e705e9e656039aaed45aa84207b915cf559672d02fcd6e75421a43ce7c11101a489758f326123d23db9e7555a48a26b747376314bd81aaca0e14a80a0c2f15534655adc59898be0e6dd61fee0fd5067470ab98a4e6f39d50e0093687f627c388c49c44e2444c4eb5895338a1b262f813a8057584ff214b67ffa3e57452f73526eafb049d99b37490432206061a3c42f92bf05d68f26148ee4828a452d539b6ed3b79b5cb0cdb1a2f46d2ef73cb972348ee3fc923562809c3a212b835bba4b745b88f8ecd9cd83500cf5810a393b24497bdc801ecbee6cb7496af799de9b085cb00ed5289e3e80cd5c2b339047cf21c48d01a259093760dd7a83fe4a5c9db3005824d65ab5fcef0a347db1ba29a8b032185353e471e1da89e4ce58831d0007751bfcf8eca7f03fd10439ac9bfdcd4724e0230ecf9458a4fe0ff5d25bf30a7544c07c57efa83245e5f60b2ca31a521cafa13edbe93c13bdc3e055570390ec077acd57625e11827f8fe8a7da96a42cd93964523a9f477f79a988497a681e4bf98906b06284350f2541698cc6d1738bc637d67d9a0a097d5a2aad50fb2e90c1ebd00aefbf87748ae960d6d2b511572a92bb5429f70cc7fa820020b1984c2b61b00b52229cdafcd086c0215f27f47e050274028fc7724500213eb4b6437adc34a0b6fe4d0f905e260ede01c1d3416a5987fb98cfcad48395dd2b1d9f3a33a1c2579558c7c1818b2eafd649686ca7848e7c0e6798e47769467399634228b362a65d4102f886031d9402ced03407c1fbb868fa59ba36453397b5180a7107b640ad887550eb05d9cebcfdb9ba9e1f306762327eded960b90415ad251aa0d95e6763f6bf0a04fdbf074e35a56c3df85fa35d69c3954ba450c388c5bb91f26c98ddffe8e5a12ab8ab988b23206906df8357da25ab72da2cfa6d075d5cc9198efe4a086d158fd81b3f4641be1ef0ba07b1834ea46337998a02afc4d57c34b6f099904d04451c937d2381372b7ff52c69c207908c0374dc4b5b2b68aed717447255b10a382c068a0e52eba3900c1217f2702e3748c722b9e0dda03f309ce0be77a8c90cfe2ae2c4f5c8bc5bf1ea992df0161cab8615b918dfb118db4fb9debe9336b34778599386f9bee79621bcb566390803aac4952a5c1f3cbbff075cc9ee6c3d1ec4deb91895a5bec08275736ae4fc32ec5987ba2f4b675bb3c2c554810a5fe35686421a980ab07b2e54ea04b3f5a632023646c8ff0999e893c48c118b74e169bcb094037254bebcf3f09d8512722f480780c5363dc9bca8465b333f3588d785329c14f1f9be9c8194808acbaa94cbe71375019d02b4cbed721d63d323df34ac62c07bcbde9e503b6a4a2a0b307fb59922401aecf0c70f1902a9675a24929823d90128d0f57b34a6d9a46e0b1b5caa06a86c020894480d5960af8e64419e24bf7251d3e082978128885f3de9d951d029ee12a3a536a6ebc15a7a33b8b172f28cbad49da14f057858423885777353156a2a04b2123a44833526ef0d3b4a6b6e397ff27eb4a623b1d84b4844267ef673a81ec2e7958892b4d440db50341560a193360d830f39bd9d03d82fea5856f84957462dcb4d3b0aad34c0f7e07cd3b2fc896d9cd4b076a70949e4a8c6abbe01de4c7295e57ef5cd6ee4028d2a6ee3f57969ef82c7a1ffcb8ad1160973978cd507273556c11e2b36e7bfe392d813c8b9a18bc0d9317c8d3b425bc77fa67318f7062b974498f8d6de4703919f0d39ec8c4d925dfee77e535504b2bcf617c578b25c0cb0a42658293c77b4de7ddf5bc42a6fd77df7fe313d6355ec4dd98c038c566250464e074f5aab9f5385572bfdf9ed2d0e7b7a06accfcd9835ec6954b1b5eda4d501eb0da48160f3b9fd7b056d9c7509e0cba92194ce0dbbac405b639d34767a7bf881c8458cc135f0cfafba90450ab199ddd4856101edabab50757d9f045d69262fba0d5f6be913095673631afeaa2477a78787a82e87a3d79a5c2d401a2c3ab1d6140192dd21c00d5ee6b7a97e31ecb733cacb3dacf093f6dd2809b3c1f95699ffc783913c9a5a69fcb50a0f82469dfaff656feaa9441b31f4321c39688b058b0a79dff54834d5302b76b7325594ec5976e7ff9a6f90e4a3cf14ebf4d0b2244e798c825e3536d3947e7f71cf64f7a2d766211071bc6f89f58bdb51e6d906f485ac946bcb5770508d312334628b11fc0e72e47660e9142fc24f268ee20aa8fac36742b2eb257aa442fd5bf12d34a4fe3c48961094d99fdf4ebcd0e3c08d8af6b34f606a4b3b74608aeaf9fb4c70358222b1e3d485872eefe61c845b568734f1696a71d581be3d33a7725ffd87d02e5d5675cd55db50e63b5390fa2f9dc99b2ecfd3f8478868517517f6008053ff7c35092d88859266dd9960ead5c537f21b56c5d81d14828f2b57747822f8e793e02314808159ae645660818818ffa19e30a1fb1f4b32424067a3d1874d63ba5205e407df67250b9d62c42388e2c817152f01113b2bd4fde19b83cf8e26624bd92949e0500359bf106c89993f09117cda5273850ec018a74cff28da41fc5c84712968dd7bc0bf84e627e7e5a41d94710fc58c6964a83ffa4ca792518c8a34d1b4bbf39e3df946faccc43f689e6c746567b1a915e1dd1ace2c2a0ce9c75d969e062193739e761ba82e98677f1b74d30421a3c51b166311019596b7936c28f2363cdbc28a99f5d70cd223285cabbed1b065bcda956e397ac8772e4adea4e6e8e9c9bbb0d4767bf09a846b831a43bd4d2f9dd7ccf9c763766a68509eda29713d25eeda3083cd548fb4b1f2495a2b5bcfd029fbdc5bc17c19ef485ad27220f788e28af86a72d7dd651edac52bbbae06e309197ad4d60391ac06878718f8598b6d8e4dbb051b6e20aa107e7224c26a0cdf51a98786a0913514b81d72251b4acd749cad3823fda98bb73212a6471df1758dd089e191435a3d385d40a4cbd8adb5c307e79a5be97359344867b336afce6ae5b9b448496e9d5b9b3b67c6a783a325640cba5a6fb25e2d4e684cf713b4ea4b45310d453f919efa48d3c581084559cf23de97fd6cde0ddaa9d29a582276eebfcf51932660e52dd9a07696132de70db6d654a46e3653f38b487fcb9f015a4990302e4adb8b5024fa2429bf384387e89e0f7165c1a66363aca00700bb344ae616583dddcef1df583c2c2c873ae6e5ea66a86d56ed288417050cb67577c1a16376311213a7d034ab724db8db7d0b4a334c587a9608e2ecc07323067c024f7af2c2d122adcc21e3a19f3614f6434bb74a4622caf56d9c93bd226e54f877cdf67fb074bd5ced9ba21a2f6e02c34f75d9b6ba692afc26a7a984a626179cf1df548a39979d2a6a59876eeaf7bb0474fa7b23fafd692e9a91c1a909cea6073fd5d508fff2702831266a568038cd44afd050434bb7ca71a3c3bc19578694c5835b4b7f9f3771ba90705744f9efa002577854bb3a4c061014c1422a1040f18eb06b25412604084db8fd07b36d3946eb0cb08c0972ec46369f8af74ff4130ba71520f19f82789ccb8c60255113759b71faa7ed7b0aa31914ea8b197f978ab1619eccbf647047a8c9b2ad2434155928e7d3b149c7cced440bc8cc645efb25f0780049dcfb59b72c442a6b0abe97e7dc8d3dee3a57367947f5052ad4bdb6e502eea832fe2569140c85497505d13f36433ff00914ae973a340d5e48e32d870f7fa1c82042cd52871576b4a427bf5d4d5be47d776b4e88920fe19187ba018e0ab5b2f29451e9adacd79919055c3eb3a9a4b5b1f80c0b7572b8566365daf22ff58621e8c9664645b660e1328662db2fe1129a7954d7823fda1fe153f3417d94d8da706ac647a3f7ce9480b5e36acbcac07d88dcf93b8e9868abc6e7662d7bc71dda5fe171a7857eaa2e26d3c43b8acf48a8cc02b72775924c7febc2381ee06b4aca51154a8792b7c9793c2e2310f3dc486b0a8030ee3e343a06f6b763c597835b0bcf13825177073b3cf5b42e33d5ffa6a3d229093abfb87d839e8056120378007ef6e0d8a89ee4c9f5f53374405dfcd3363468f6d16d7ceb33c2729a8d04c933770256d267da6f8c7ff4d464e0be1a810e1bb803c510b853cd73ee467854f66aa915812c9114e2a4cdd8d09ac8331902c3adb520226815c45f7e80c6011cae7783ceee72969c4d9262d7542cfa846ccebfa3f0447862387e463ff84a14881aec8ac3ade41dc3bb53ce34c5a593a6cc0f109216b99a8f4b98c570745d7e60d51a781350ce7942eea3d678bd60c88625164c27a8227b7087a2a762834d1c4219c962d114a0f21aea2c602c0e9e50009800352b1f5784910b8b',
        salt = '5b6d93caa52a03622e4e9baf3f504a9f',
        labelError = 'Bad password!',
        isRememberEnabled = false,
        rememberDurationInDays = 0; // 0 means forever

    // constants
    const rememberPassphraseKey = 'staticrypt_passphrase',
        rememberExpirationKey = 'staticrypt_expiration';

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param  hashedPassphrase
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassphrase) {
        const result = await decode(encryptedMsg, hashedPassphrase, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        document.write(plainHTML);
        document.close();
        return true;
    }

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        localStorage.removeItem(rememberPassphraseKey);
        localStorage.removeItem(rememberExpirationKey);
    }

    /**
     * Clear storage if we are logging out
     *
     * @returns  - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        if (!isRememberEnabled) {
            return false;
        }

        // show the remember me checkbox
        document.getElementById('staticrypt-remember-label').classList.remove('hidden');

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassphrase = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassphrase) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPassphraseQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPassphraseFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassphrase = hashedPassphraseFragment || hashedPassphraseQuery;

        if (hashedPassphrase) {
            return decryptAndReplaceHtml(hashedPassphrase);
        }

        return false;
    }

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        let hasDecrypted = await decryptOnLoadFromUrl();

        if (!hasDecrypted) {
            hasDecrypted = await decryptOnLoadFromRememberMe();
        }

        // if we didn't decrypt anything, show the password prompt. Otherwise the content has already been replaced, no
        // need to do anything
        if (!hasDecrypted) {
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const passphrase = document.getElementById('staticrypt-password').value,
            shouldRememberPassphrase = document.getElementById('staticrypt-remember').checked;

        // decrypt and replace the whole page
        const hashedPassphrase = await cryptoEngine.hashPassphrase(passphrase, salt);
        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

        if (isDecryptionSuccessful) {
            // remember the hashedPassphrase and set its expiration if necessary
            if (isRememberEnabled && shouldRememberPassphrase) {
                window.localStorage.setItem(rememberPassphraseKey, hashedPassphrase);

                // set the expiration if the duration isn't 0 (meaning no expiration)
                if (rememberDurationInDays > 0) {
                    window.localStorage.setItem(
                        rememberExpirationKey,
                        (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                    );
                }
            }
        } else {
            alert(labelError);
        }
    });
</script>
</body>
</html>
