<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #4CAF50;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #43A047;
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #76b852; /* fallback for old browsers */
            background: -webkit-linear-gradient(right, #76b852, #8DC26F);
            background: -moz-linear-gradient(right, #76b852, #8DC26F);
            background: -o-linear-gradient(right, #76b852, #8DC26F);
            background: linear-gradient(to left, #76b852, #8DC26F);
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>




<script>
    // do not remove this comment, it is used to detect the version of the script
    // STATICRYPT_VERSION: async

    const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 *
 * Mirrors the API of CryptoJS.enc.Hex
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassphrase) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassphrase
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassphrase) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassphrase(passphrase, salt) {
    // we hash the passphrase in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassphrase = await hashLegacyRound(passphrase, salt);

    hashedPassphrase = await hashSecondRound(hashedPassphrase, salt);

    return hashThirdRound(hashedPassphrase, salt);
}
exports.hashPassphrase = hashPassphrase;

/**
 * This hashes the passphrase with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(passphrase, salt) {
    return pbkdf2(passphrase, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(passphrase, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(passphrase),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassphrase, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
    const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassphrase = await cryptoEngine.hashPassphrase(password, salt);


    const encrypted = await cryptoEngine.encrypt(msg, hashedPassphrase);
    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassphrase, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassphrase
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassphrase
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassphrase,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassphrase = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassphrase, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassphrase = originalPassphrase || hashedPassphrase;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassphrase = await cryptoEngine.hashThirdRound(originalPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassphrase = await cryptoEngine.hashSecondRound(originalPassphrase, salt);
        updatedHashedPassphrase = await cryptoEngine.hashThirdRound(updatedHashedPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassphrase),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
    const decode = codec.init(cryptoEngine).decode;

    // variables to be filled when generating the file
    const encryptedMsg = '8399b03ff19b7ac4e13e3cf83a2a26bb2dcf1d3ca1a1000bcff8d7c8302376ef6c451989443a9223ba803ab66dce097401ac154015fe18e5674bb1a69cfad855f5a8c60331b0c1367a85feb9c6eb4f13fa953be735dab18c046e641434e80a6c3c08bda03aa4efa65e93325d3855de59b36d8cb04560120fa3eba1717abe80b5468de481153ec7e04c409dbac0e9faf21a628008e6c74dc6eee93752843bc9675692306de4df9775d1dfaf280016644b6a93fe2df10a0c1eb0e616ec5892dad7c4f4739468113dcfacec68844d62a4743419f5ad2ba77e3083a775678c6d3c8f71236f7c036d8ae841c9d41e6d682c29fbe967d5078bd7d9ba448e45e5ba372a17bbaf02d2b51d542332d54af55d60e03f46ff1c3b4951c93d55cadaefa138a4f69e99602ade1cfe32cc2cbff40742a6bbc9670a1972cfbb0cd54ab5b949530b44380b8cb7d4adb96d84709efe871f8dd00caeb344e6e8f9754a76335aca1306ef352eb470d1973d64799863827c6a7d17a0258ee419855247e152f51ee8c113e7de1e26144e33dff0c501847a3a364a2bd61a99b8ea6c2a6005d764483c7e15a648ad1e26f50e80766c7e63aeb55c5af9294177c2253699d3afe4d568bc3ca888e087dc520b445b63bddc029283e0b9bfd044f15ba3d5c058b2bd985dbb50407105d83c3d8c7cada9ee64540c549d81731ad1d4f9ec1bbd0adc1b68e36b3e47f3f799e2d095eeac0a2a41cf3d13b64a927129b05d1f5319a4fd2853168b0fc60e7440b6cced741ebb70a0f74e2534c64624e1f4f41b78d035afb1c9c3edfa5403039a79b41c992ac99d1252cc81eb28adecf099f26778cab8ed3290d060e8312a1f7e7be2ce9cad2a0b2ddaf8b7b03ee7844de5f2ae78349dfaa83efc1eee30d8ebc17c3a976938550c1acc2fc6fb4241a1a0039b79e9b0ff04dab308acc957f19554f73c5f877ad7a7fec2a43865fc722c0215397eebca52d2849688b01f8eb1ef607cf3ea584ee5141f20f4c7aca4fa23d45885369868b5b6a54a2dfa2f151c8256dfd5f8c339c7a0df0134e11be9afeb6e59891132ff409a4b44cba1144520d21796dfac71402fe83c0195bffe8528d0ea2cc34b480ba6f89e9111cf6ef246043b169c903d40ddf2b37801ef99e80d996f15571abec72cc5c158d053a10af7de34b2fa6c7bbb03c97647c9c52b6655f4838f57a0c4bf90daab5f635dcf02b74336c265a9e8f01133d2af345bc264d78c281325603dbb704d2d172a0a6ce53488405ffdbee8b46c9bf417aff29a23aa6ea22be47dbcaf9dee4ba8cd1f9e3168b3ca05952de0eac6cd931854772de58a392fcca5a0cacb4edb955ba118f71e4bf0a2a6bd150d3ff560624f39ab0f769ee7fa40e394389fa52f844955b68d1f9400101d4a09ccf2ffb176b879bca8f56088ee6ce99fbe2d407bfabe88efa524fbb9fb78ec002d577bb25aef47f676988bf2e07b52c1b032c9a084b3610f5406e9d369c57f118aa61673770c95c32f7da5c602ba551f354a6cd350cc974ff84fcd150cd2494bea81bddfbe6629d7676b87a0395387ee292574ed0dc799243cb100c5c1fcf53304acb9ecacaee73f6d1c608713e11c13c33a91a60f2723c192df086d129d5d8e4678fd33caa476f7e600e3945c8d83765577b50201347bff9adc2e5d917e303e15aff14e6ea757333b2451828b350bc34f1126fd7efec387f28b960e9795c817e484f43fcf2408432f25bb037e25c088286fa1f2fe027b0594e9679a6fb7a698f4236d3fb867e3c178a0ed4cf01aea38b6ee6fb1edcd88718c2b12fc88f0d15f6959a889aee45e6486c8b2d263316c75561fbd3714b2d76b07e6cb736cdb28bf6e725f2cd5e3547db9fc9430234dbf7ea9c05af1ac3c0d71288ba9e3af50fff3f20cf911d07b10ebae9e32049348a03df6e775c1d5147d310b58f2ce7940daad89423834e5c9d6210fd790ec8d81f03c61cddbc33c7bca39ce36861771a588e2979fea26efa1fab5601385358aff84fb2bf819e46442535801d55a630dab77deb144d5bd59e8f4a6690649b344b7df8ded851132da13f709c731223b004c7ec1abb5626bfd6d62589f4ee8026cddc52626ecfd05614eae2d46ab10ebfc7fa40009c5edb5892e147ae47e016f2decf04fb9b463f9617ac974e9f555816a4f891c855e114e847528f4b382d612d40f9c45947efa29faf7af68aba4644bfe06fea2c44abd3bc99ee677774c251060510e8d1f5bbe04af1498b47e6ebcb420477f948d6c383c2b2343095a8e05b9a06ab85185b2e4931629e45ec5af0254cb987ec3851838973c181c17a8f8d19f9fe59ef08160db654d5358ed1eb653d802f54281fba496f1d3884a076cbb412fa9747c851bade276efad3b9e7144e814fa07e61d3ad4ca9dba442817481a485be8538c74313c4717b88433d91766d7656e3eb8e033ad1b105a67f1af947400b50cd3b0dac68f10d03ccfbba5e6ff9057ee3dfedc98dab6130713fdd22f54856f3021e552eda53a5731e3ead9fd6243b390ee0f32d315f7932a8aeeb834aa47f5ec75a2bd218a72bf6b4862000d73a78c636a3a9e1c7209429bb83ce3787786508a9b5f76d5bbab21e6539ed8c395cfc35524001a6e108d4f4726b6456769c5d657424772936ac5bc2d65bade00d872feb7426d7b4aa9a28d69bb40f78d97121a0e57ad72f3a60b6e7758e3c7b4556366d95ab8442fcc006239f1cb6d7a6c814ce13c2878c40077a855feb79b496ceb284460137b43c6cb8cf7fd218eb74c5ca7d3685de875b976efa7d07878497bffb004b014b61b325c455eacaa6badb3ab4de0edfc4d55a0297c10767f788238fcdbd32fe396c7ac987fed415e1775e9b1eabd52ebbea29895606ba21b265bc609028751ec1ce61a58bacbc1853a176df274f289a8196c621ccc9d0490e0c8e736e945346126ba437be615eebf7e849108666c81fb77eb585a3572f447225c4114b48df6802a6a4d159dc570ccdd01077d8a553091ab143a293254e2630bea9d41ce597096befe7a28973ed623c18860e992680d2123fb827a254c7f855b9b1caf2406ea775313751d5431efb7d451af2c379124b3a4a1bc5a7700406e91f1847f3efea79ee302caf1bda7e9302b4bc3b4a7ce67ebcc0c35f0e5200f44c8cfbae36f91d25671b983274cf597459021dcfc3f6567117f63560bedab63e15e3a216b608e583695469e6ad11341a1f0e17b7801c3e421afba3584c590b3c75ddbf1d1a42d5406f0d03b0ee6e01ca5d319a75df103c24f444c5e83533934d8cc346f6e3569cad1f451e85c70474609e0466d3b285f508a1aa446e88fc3f20407ae4914e8192d9135a296244cbdb444fc24dad2c14e6b18ff0aa230ad90ba072a4f46b4ad5018c9ca9620f0f8ecb7f0e0c010fd1c8efd5144424961339356fb0a5ed7e30023b45cc794cef9eafb03f254bdef1176f02bb4dc54961bc420f8acaf32464abef10122d08097932aa1bcb0e2d1ee157231e2654f2c191ecb2ade6a824b95224eeda3a9f2e9d83b7afe89932ebb85e518d1337cb471d80165330523e301b3b8aa648f7655943c244225c9aaaecdd77ff858c13c0d9e05ecfd9a014a7658bb0bf9fa4f85617051ef0a2c82b8b422e2882aaae6b7ed70b2f84ead7decdcd15110f26b609ab00eec2ac9fbb1e6f063ee1af886751a324a7be400c67087353a2e669bfdc999d908ff2d50e7d6aeedd303731198d81c865969552f188ce2b38110d6d7cb6ea1e811f684c8860cdb42755d7f7cf89affb5dee4d59288ebcebf3e2595085233677f5c991eeab9e9692856727c42b1556921089782f12d5c61a28454cb2aac780ae98bf8bfbded7b1ae3efd85e12510ce2fc70c0c1c40c39ce5d28da994e1572191b321f85639d59e27bc22654c3e39bfa1ffba86b41fb2d6ddf0f09e8da7d466aa0d35713ec653a716d44007577657ed6ad0af4dedaa2a5a1dcf06fe47622f3c6f04bc46ea055b0325817fe232915a0ed90e84f550aa047dd3984ea4f65ac09daa34d1d6d2e4b9bf4716faa053060a50bb0f8822785d5f79547b0197777ad511ee672ac7b5657771b8fdd5829e1fd096f358efc189cc8ddf47a69e19a09a06f29b60763a315f636563a4befb4b965e4d2e74a5064fa592fe5a0c75a922c19695b04813948ace7a0de8104e36d43a6b9bc6efd65fa508715dca86f4b32b6ac83717e46f634b48ef8d9ddea3f8ba48a93f7b0ac46400d8073e5be24c0f33556d6be96a92acf0cdcb40b67af1fd635d692ba4312a83064b497b4f68b434d01c8527b7d725cb7bab512a17e9dc89b9cf1085c1610a669052659556ef5ffe88272d4ddbba0dd078997f982440849ed44d98b56742b220f5fda5901a39b148374fdf07061fcc93efc34b0cf19282a773f0e52fc92cb55741d96905328ff2e617351b33dfd7964876b4fc965ba0f76e5ed06601ca4e030e4d4fd17dc5893df3a78f1e1d4535ce00b36b80f6305a838ae03e25e4f0575bb0bebc396aadad6cbe2b3c2502201e049d675ef4cd3c027935922e1dbd92c1a276c3962c337065e4f37b35f9ffe21f05aa57c8a79c4918fab14f303c253b7874ca3fd372ce187845641ff7e8c763e825ffe79387ce2170df77f2e1f6b99549f6ed8d232040c75f807973f30210822021fdf81d036de39bfe5207ad64b8e503198774be760ad3a17f96c43e468189e1864a6720f9d8a28f53dc28e48c84ac38fca88ef47ebfc945184f1f5801fbdc60852d6b70ab44a1fbdcd71c4610a755147c628903c3851f7bf67c842ee8a407083928eb422fed7a9ca1681d4f1ef9c25aa2ed4ae90a697d07c75ebcf9fe61ebd8d3361d59d40fca690e9d46e777658ddb19c4f83547e0a4b60dfda40df19b5754ad5a83cc203b8821f0a0087f31864cdea549522df4b0d9732b0456c7e2f39156fe4c0d3c0ef122a09c5c99810ac3c10f2796a89c894d65b741461d1b6085ef62100168d7d84921ab645788d77783af01853eafee1c31e3a8b04c78a8224c92bce6611a19147dd8ceef2cdbdbdc2ed7a3dc8bb3407c8fcaa9c68c5bc7a920ec1a82ac72c0f020b7408133d5ac472bb24eb5dff195527807157e9955fd2cd89643ac1d10740164e5533bb370342a95ab5b28915922b12171df6766e88756ff0a5c5ac2d97d94b8c4aaec30f94355ed4511b5c5c84091ebf0330c0456fd3b67f9df0b60ebdc7196a1a0517211af68c0eeeb551b9d1daed3b81216cec6049377e733a1c02e769de71b153f8bd678028c9e0e4d8520de48db98346b0ccde4c291623eb31d9bc3cc6ea0b018f2350e101463178f396bf9d6361a1c83678cb4d1614a62e372417d486472e847b38397c2e57ea96774c92ed60fce3da1ddc2606b70c5ea3a5aa52ae7c92d06179eeb5334ec0e571d0acd7b3b7910416e6cd0b9021302a6e824106c339e7a2cfb0da5bbfcd787029de4be8a16f582698b8b91a7f257a2bfc8e25c86243e2c5aa671895c8c0693f19689ed30119695aba668ac67547950f7af39250988fb126a9416df360cec716ce27066902df5dcd0dfb8c89ba994615ca0ad2ce80ee394d1d7acba554e532f9469d08160f9a5f5db769cb095b0e6ea6d93369f945e477771d57830ecee4a4d9fad1aa769742bd5cb8c4fcf4eec713e6ef502cd65beeffddf246736f5bddf6920f2a113762c086d0a461c9973ebdee0aac5480275c63dfd23221d83986d993337c6fbe8ddd34222d8ae85567979a983be8ac58552a8d4fec680ae6117dc7e8a3bbdd28a81705dc169f61ba300487724409a7ace8af3b7144f549d1ee036ea436de1bcaa6b96827088be5188793c6b4480807593346a094f1c30e2430ae46f3951fdc2796051b8c1dd3c787a8e5004238351ac8b87974c326d31d3cbe6eea0c02251936d9c71946df925f9d7b42691e2ef886f0fd9b668e499f6d0b22cea950f344f8d09f7fe9b426d3987bd14b6cb8b4ee384cad3fc47eddd3581e08a2f4a2986159d87a06d87ca51d67de807b0b21267147cbf4045696eed7a630f6d39d58b2e51af462176e92618b8c037355da59e212cd2c19f28b34057f1c6c705d942cf5a7f4c7766fd7d61d6d959b2a902943ee136df93bc556fd4ac7a7406beef9840990b7c0b6bd4d1ed652bea9d3d311ce0da9eee4f7bb4695ede6984cbda53dbe20e21a48964784013802a285456ebce79e96d969c5d156dbb35984a6f71ede302dba907a2953531bf7d9e9d1dcd2d6fc20e0ef8ad40f0578c3d02ab51645d87a941e7072af5886c2caa3cf39ed923f97d62a4f50a79b4816fa53ef5ea0ca40ffc784dba82a62a933a3a7a1e5aab7b9fb5558307526e099a823c55600fb327b4abc3fcb85e16b65f907fc0d8328369823c190b93f63e4348be062b31019f8429700ffe3197c76dcb19340cb582a752ff528d820e6f592810f755016751a3e023389e4a0f4b709acf35525db5160bde73482d86d996733a74fe1a6562f4ce809ddf12c53a302260abf6cb209a840ffb9cf3859084f3b35268beb99fa29b83f821c6889c6039b425da58fa3af1f7ae38a6d2b4051c611241fd10f86d0ac677af3ddf6e013eaf5bc427fd9c97333a608650ee66050db2389779e392663b9500ab58da373b13ec8075d2aee56e4f3cd9d2a92d5714c05b98bb8a685bba06e587ef0664ea13ada2eb7fa08e69c92885334e5dfe6f49ba49ef0d2df8e4e9935d55ceb8f832670dc4e19d9cc3772e4c4f4877065e5c83080239cd2e7e21201f5859dd0a06de25537fe6364ff6b026c7c77b4a91568e745a666b3b268435a549616369ad8e9f7fa5e45de4e2943de96f63a5a791a6c7c62b72cd01deb5a06057d62f74b6ef766b048dff079601f45ab8f63304b602de9b864f868f4f088153dbacc7c391759a71dc50f898979cdeb4c0b9ee6f7ad230f2c5c50653d6e655c74c6cb68aa03c6ee05a25969154f71dd9843574f6d7cc46430e1414edfb1460550c818fe45cc7ef26a18dbd36bd89f3a78876eb7b2f3f8f6af191efa32285cd4637a48a0d576ab742bd9aad24a3ce1aefc2c152e70c1c86f8b470f9bd7d081d82d9ff4573aa3c33d3b156dcdabd274c46b94553071dd0938f03954d842c76efb7c8db9ee77016069d45baee48a6f57756e230e96526a6b66a51eb3c2f461a1f604f3a1c18c478b42c52961e6977655d23d3e22298eab840a5f95e423d643746b288db76c43d0ffc4decbcc2ae5094688242a1f5824322e0dfe57b82345cd0c34a1c159ede6aba580881b3cbb80e5be22d5cb463a5960384fcc48470262f8a0112525a2d1aec555e64a2188e23a9080b4038b48c8aa832c07853b07f08457903c40e8e7963ea93729346560426a78cfe7337a1da3bbd088c20ec10db3c8beae8a03690a94a225930ea0b71213644d217f3a72cf4befc28b023eebf61bbb6dca9ecbcf152d14c44791e0b0fb348efaefecd4b54640c70b9ecd5ad08c5ddac08e86083ac246328f06a3481dfa078b568c1943c132f0c91658c21d7f62eb1893a3a20b30731bcecec35808131e8fc37624edfb68d9acccc0ca4aab1bfacd79973fe3a49858c0f1aef1c3da8e15eae0f901b268817957d6f2c69dc67401349c41e0081fa4196756242340fffc0ab1c73cef624512a19888e91a01de24c6e2bf3de7354f695b32cf5ed48912d8602b72ab4e6bc74a7e267532ac6115e3d88b060f063a76a1bd3ed11b903c8aa46d1ce1b81438469eaebf83e9346b765ccce74bedc90ab15eaaae5f520b8e379e1a809e374ff57033f6b6c1ecac058327b3bb6b636e048d37b81ce4474e23c8d54cffb4f5c5d77e482f12606c6c588b7aad70454a1b2ce9558d317196cd9512ff6431a57bb841af69e07eb040a281ec32198332acfce647546f0745d039dd9303a4ab3ccde1ab627b479a1e32231b6b3b114529e40889f726a69e7c071cd724da7d4e15471feee1b68573882ada7fc34f80cab7888c9107e8e8f0324099a658e3dd5f30db1ce25d9848eb5c65598098a7ebca8d0600553a08fb84baed278393f3bef9f73045aa6b31385177faecb7987acdc98d5dc94963349d88844d0867da213238d96a2ae784fe48ec5df6e55ea8c7dde6c9fa29f76180329c3c1fbdb8f8575757a829340f03eb8c7bb4368add25a0e8fe9561ac733acf47fff41877490249188baf2e60e097e579454f7e5c6efa6cb6643481c719b7ef8146f17d3127fc0b50c57b218669b860a77f1e60145df26f41840d4baf695dd89f5614d0ea304ac5fceab2359ff518ef2fb8dfaa1e45df3443b199e7c594a7a824114d3a8321da32b1ab9599fea0ff246623960228dc86b2898ad2020a56b863e191d043ad2ae1846ee56cdaa8152655b068bc45028d05d113ce1f4e6f73010775c529997b718c43f43853826636c1fc9334180a759d6341bd4d817577f147e310a1616d1edcef0effcfff6c7c33700b9de2b416f1ad7a19eede3d79a693304c98db83868bd1cfd0c9d42a248558cb8368be7324d619f7ec7ae67090a25b368a4616d8c35720c689fd32e4cdef6bb41d4b4c8f65a9e167373b6726fd119191450d2b8781c9280483f7b3e011a0d3c8c22a16cac442887d6625f292899715daa595e2b3517e555ab912d03f5536ac58826e84dedde6b75d1b1ed7f32f3669b1bd5e1c8296a7304b132e9bc9abdccad764cfebb586c7a0a6789ce47c31175d4d92cc42de409ce6f022fb3187f34ab7992b33ac6bd802f6e67e53f96ab5e4302946399f4f236681223b63ae7d989fa0ee494e4262c05b963e263b0533c6d3b02b6e4a0502b0552f652d46d70875a01e5c4f4aa5b0a583bce8084fa5a2f07bc942a0de8ff6d86ec778e89824583c263d3e7352c3041bced22521239457afb90e105ffe11b74d59fec93b6035e3603bc9f3a292db3dc121cba38eec586836b42606241d87ef80f70996cc58b69634e48f47dd27660ce9bd779b4e509de0905aaf87033020c99f95f1ac66111aa54c0cc98594208d309fd27136e72a653561060c55811dd47001bf20627168ed8521270d269877b844b4edb8a7c5419fe2991e3375e38a066a6e1c8531c2c1ffd9ab4464c1dea0cebf2510b260971d14dc20ba164b54c0ad663130b40617d2d5ff32a124c240b070290527a7041a15624ddf625df45764682d7e23379a9ccbb4430f1592d8fa6387fea227ca248650eec31c6c7cf64248a81d82acdd5d79b235f6179b721d7a38ce157acc95081ebeb21ff8d8f236fc995ae62c0f313cd37d12f9b266a8b86986588d2b18d3700be1f2e85bb2bbda7a16cdea92c69c073d57afa9460dd49d03eecdc45f1f222cb44b08fd09064d111be45c3d1789e335e9c3c17980c372d677e2d8c8d7bd164a543309513e5ab14a4747f93a30b3ff5b226683ba50e5666996d959dd25969a660868eac7a496c7e7b59fc4f1767019d924e044639570c94fb25ac32f5a1ffd5bd5ef4bc54355d5296caec9498c30d43d7888007522c5d03f47cd5a3b428b84b2e50ca6a4ed31478ae922a2f6875344aa26745a01b05aa1bd0dc9a97355e404ae2df045abb03c7662bc17caa7c99859fdc271874a06b20698a719072532079d94ee72a0165a4b472ed0947a8e87d1b086b12c69564fb4367553f302836b9b85fd37453e3e890fd6e5f69814cd10e2dad6d0591f7198b070e4518df8b921e7a9711c843614111150df00f2f7618cd18dbb9ba22a25b01285cd08dce3fa394be6e4f157b1bbd54624dec0ac515d137c3812414da3c45735a8786b74f18effdaf45db39a4af48b9ddef8f68c6265528458f857f41b8ce2f502fd14a59496d0f91fa9f213ffb638b8f680736d9147e70519611733651c6630a58a7eb4d4c668d81feaf308143d0862557c709122e2d0d5e72f89d89d13121c58e0f3d67426ba05993cda47ba7a90662b0d8e8373bcbe8f0a7b1fb3f35614e609a2fe08be8f773c6f4502f0bf9e87607507e5c11ff4f2046f658d067805619b1c4dd7a00c667addfbfae133f003923e05b20fb146b96dba90abcc0340996f28e2dd44e41458b84eecdd89d5c48e76353492203a89e9b649fbff1079c80046f5c51c854b23d2de0355dcb9b5bcad07c87629a2eee123210676e0c60570a1aa2fde549eddb1ac17a9f6792e4f14d5c27532f48b7cb2a58e05d55ad19721429a9cd1165e53609edddecaed21d7f72ee8d4986ebd17cd152c223a7650af91b1f581ec2dd0af49621bffcace86257e8fad85040fd0e1f64c6fe820cc0f5c51db2d279797bb5e8885e3e6b41a2470f0c58813ed841eba94126d8ee9f81014380c92673e894d696da687b916953e57e0436bebd05c3b8a473d70c02c28d35191db002e6c6b68e6f2aa36998f67d4f0a1f0975bc382b81c184f76a0b56604aa185db42abcb3c1db3b66a1d003f24068b0118920b05518797e7ac1ce0ac4fdb4c3661a814ac84bc128cdc08ee7f87d0441154344f47d2f8fff37703c9ca2710ce2fea5af73e98ac564f01d2f2106cb6a3b250fc0077748a5de07d1ce4894e89713880ab017a1b6ac038191e0a2a23a66464780694d813194b69c74359636c561e756165a2e71dcbd7bd70712c94a6ca7f61c82ec6114621f2c6c86b589193460d3bde28b172cddff438932df586bef5fa61650037f951f12f87cfb449c2c73a6bbd998b2cb0da7b863dcca2cff79ce16c95e1f5b6f5c3862c9caf53e7da3448e31888520238fe6c8461ef4283ac0a5b202d80aad87c752f3cc94a530016521aa04dd9c261f29399022bba1d2e4e4f668e74d777114cc3f90e1832ce54afcd72e6211de84efec0a0844c46b1e4fdada2e7af1f5b63ddde14297b0ceca5b4a026552bd82e029d3e147e5bdf80828adebdd380c28934bf4dcd35f010972aafa8e6adf32f6e93f0991fe48bacda3782bee263699c14899a6daeb9027d1d6e0f608e752ec6c3c98738679113068f21bf51762d7d8b4a174a235c5382131d64f6ed3305edbb3e40a1d6d01ad0bd9ce497911b47551605e5e7024738de9eedc70064d02c96935b06e3e40212edfc9c683daa0cd55548f194e69ccbac7b2641406e88a6d1f9669293884a719a26ae67c9b49ad1d2abea464966f66a17e187db59f7264f05bee16690e83b1fa9bc04bc345c862410654565674d39e39a0870189aa46c06ce54de0ea95953e59ed0063f3d71994d76a6b403fc8f7338e63d4fb919a43c385b9c9a50f96a410b38f7f1460ea4419e147d2c295ef2829c6fe791ce746a63f4eb016b3dd49a708a9ceb72f3df10a65be3c4f80c6d72d6e631bf73e4f2810e5db27c6506089a1678fbde7b0dd03ec72fa8b1d6e7c34713710c03b85fda98205755020665d14474cc0466dac120354e0f05f9dc44b879d1270777bd8e942e9f57bab918da62cfdcc4850e955aaed15be854747c0e28ee6ac214f3b38f83a7e9f9dfc586c0dc20d50fd142457b7960ca31f13657ef3ac33987db54be8193634b704a366c18457c552c5bc0162ab6ef6390089b65291d5b8dc26194a8a913d56f723abb316665da33feacf2c743079efdbdb0c6474ccf325d47a0862bc9f939a73f98a93a8319c0ec7fd391dda75c64f71259c542494151c631afaaf1d17d42eba9f856c0968675f4d0fe2c143a0549ae969ac7e2ffc737c4559cc86474057c1b81fddbf04f97ec03964c3753f4d097ad56bc8796aee143dd19405e8c53f51769e89bbe25dac722c04d35487ddb8cdcb21d526fee32f9fe49d7cec479ba464f4b418d1f6e9b2e866f6bff966684c245b4ae5b6b59dbe895f97a86fee80aef9ee8fa3ce82a65a50ad93dc824540a1326413382299ad32b42cd5417d3bb163eabc55836146d3dfc26122d115a6da65234eed7b528e780f5dc51bc369cc9c087d7a6b784a9ba5a0d7bbd1fc2e3fb1bb9f3d6f62fae7bd7c3578baa4b75f3551dfe8ad17435f4c26f3a405b10809a2baad78f62a24b497940dab0ff48d1d460560e4b52f8aa2e49b1a275acf93cb12d22f68729a847691355901e6397779773aa024cdfeecf908ec907de086c1c81ce3d1b05df350c5f9a06e06ea112758cde1a537796426101f37774fd3c2ef6c1c769713a187e054071f3a6ac1255eba6d47b72ebff9da2dfa6d87406e0cad51d040bf1360f27e5d0e12b2d071154df23f8311b428ddd21236b0b0ae77dfb4e728d6280c2ddbd5fa796936c55cba888d84387bb8732fe9d4d3a14567660fea7fcd79483b7d6cffc7fcdfa433d934fffe839bc2a84fe85f67b385376a4fe35a6d27fb4fe48c27fcb21955d9ec655da1235b6db793488b301dae084e30fabb5e1b96c5fb17625daff6cecb20f508ea5ef7ebb61a644ccfe1bb920952a9d03cbfba1e5dd6f00a3d0c935d7ca98d61020a40c4f57b7320a07140af5a6c4adde2b695c26f12d794032c39893e7f2460f2ae94b957b50197b911c904f9c90250142a2dc9ca7b22fe895543f5e9a8efedd1ba0c541c226a223d608726357e927e7da6e25370f7b4e131f282bd1cffe6fbbabc283ad94a491eb80c8692f980f616aab8f6ffb6acbfda86b67483c1fe4d2dc2f67431b42ddf4ce830a9622db40af3661443b2f142074d41321e3553cf25f4dd7ccbed8120f9f8e3f77182dfd94707b6afa90720988db38b790681d79d054cd4fee3f8a296cb65fd29bfe3eecd989855108f1dac43f15dabb83031495f514a4a7ba81ccc8a285612fc36158f81aa054712de0f24249f1b9b2c6b10d864a9a127940daf49d3a3182ff0fe611acc9ffefc454d6f8c5145675bb7805de3c821601eda935d628ed5a245c60ab959ebd4a920fbb18b5c526b6a20efce55c1797453f2c6f9e828d438a3a7a0c4f516742e97ebe7610f893e977b5cfebd35f52c6aa6a75ee86e3664c05ec420f71a604673425f210a342d53723a2eac411b6f63ed10c17905eb3a06847161cd0f3f6ff4f4fc60b7500c97f4b75b63559b91037482889da75ec0dafa3bf8b4aa1dfc842e18c032896024d0f5267ae5c1c958877f3b79fb9ade5aebe16c424c1274039f86baa1bf214911486cd4307b36e03225ced74ed17df91fc6440e9dba23d68d7d8c1df4443852d9063e69b55d01c6e9b226776d1d07c37ba6ee604d928bb84ffeed695797541e7bfde51e0d44931b8f049b7534464414fecb63249d8fb466c99a8360e0ee06c9c954bfb28b132b1b75743e575e6b62780a16b648eaba5826d89e95286a7527b4391b782b66764d6a83bf71f48c0e7f99d7ee30a5bf5d0d0820eb1f0139a73b7ffa7448028a534969ea6dff2722d0f881dd7f94cb3f19aa27258881c57fdf51bb2b3b07f34f8082db34f9aac0318442bcd29c35ce5b07564f4f86a4e0e7361013707f12d184e323599141fd98cf2b8cb92d20f9fdc1b6f762e174cbadbea7a39db44ca21eb7d8ee3fbfbeb063daa2ea58460663e277def0870e1f0f27727a2a485f332449303ff84dc839eb18ea1b80582369c8e53ce03d02ce048d83fba9071c5e31936dd396e0055651be1389bd35ee6624b402177b6aeab5d01fa808e49d92151ac3b18d1fdc4ef5c4e2cb830c7329de968eceeafb0e6da5fa4bcf6f0ee396b951eea88529f27e7bc77d0739566c40aaf1b014f58348fa5c3c1bad0fdae2057174f73ad5f994ee98d4ea89741e1f0c0b50ae5c7407873850900303446ada24ba95ad8d8c98c29d241245f8d7f9517671c08b3477006a14f6a22148e4db051f56726d6c7696b1e479a326fe43094d81bdac9a8d648af92d5b123223fd190a81dc7e03c9458ea3c8a57d8b12d90e9959aad66c0861f232f111fd9ee5e4f97efc62d604ded66cd87e3d3c7d4eec4c47c027a726251c1b44aeb264fd25a2ec28049ce412f10612db8de5f7d8205b4d673d2e071d200e81a5298e7dd0278ab1229c374813bec330da721ddbee7aa63fda6814aa3f294ed0ee562b0a9688504619c13387d3c9906f051f5d6bffb4bda1d9241e98615ad780ffd1df30f3c0d78004c9d5143cd836639cdc987b3fc37774599a06aefc5ba16f4219966538f9a05c7da6238d64dddd140cbb4df49a31ae63f0c456d10aa2d0b3344287c0f2c3100a5ac489598a84dd7722094b50d315cc44c8c828059126eb0835d7456b797ed8213cf7c2388d452eb35b7baf5ee6fdf9f12cf23206183581763e4622f58ef7a016db4533bfe32f0b3081535f00058a84848ddf665ec5707c6e6da5ab84853c94a2292460db60ab15732e37eaee3110fed82b7947df8bbe7f51ae145277f51c0c8a4aa48aa12a94da2a9ccf5bb62ff1b89d7f5d38d0306550533cd5c3217039d24cf88bacf2c3385a4efb316877de6caa01c39f7f46bba438d87872ed838e80d1c3cb03394fa616c4dd22091bb91ebebcfd9a17c0f6b010c990ec92b46573799992c371e60a3f395ea228fc1177c256359a6fea6925f262a4eaa66785218a280b7d80b5301e87c0d2d8670278ab39124768435ba167003ef6e52a9e0bd5c257412401f5b72a99495a564a05f6f7ef2dcb2ace3df46a2fde4b0b858a3303d0f9c26f363b4663aa2cdd331f95a305274b7d4282fb5436dc470cb3c8e905d507296fbb8967faad3e0836b87bc9d2a5cbdef72f209877b6991f82d7b22b20821e3d1ea7ccba51bb77e658aa25445b02065f2153242850c49c6b89bef021c68e360eae2930770bca973614301fa2f529013939ae832a86913f21a740e3bb2969606ace906989ad13d1bf70ee5064fbe455c13b4188f94423006113c412244f690273c86ebaa73cf8d6512b9efcba318ab5eec1fb9bd667719c399f5d97c6ced6aee40b1eb18f144c72c22ddc5f042c2fd9aeda654599f8952d77f7ccc5eeefe1e308f67b162546185cc57f401086d3c960061034155c8575baf38dc858b7130bda2ee0d90b65b4a10760b1dcbb5d252600780a08cca239c4bd61b402126314428c9a51bc828670556d4ecaa4d43de48f102f75ca2b949d84cc9cce13eda2ceeabb0369a8dc51e2457455aa5f6fc2c451861bd0e16fe14839ed5298ec4b00cbf4917e287215791bcc2b2df1920b0df7fdcbf59b4256c7ff0db66ad198c45b4eb937704ea37a113316321025f39539c676099d919abb4463c909cf6a0fbac95950626aa204760ffdca03983867fe35c511aaf74a0983315e3be82586e16d30162a355bde6315369a03b1a3cb70f0911fedf6b0263df9228c1aac16a28cd586c02fba13d871b196cd50567033a3d7708520b1ab1f22c1b13d03fe9fa0503131c7851ac6220ef9d675a357e1f91ab6ebbd029e13',
        salt = 'bd326e2eb11e8141937fbf216b060c8f',
        labelError = 'Bad password!',
        isRememberEnabled = false,
        rememberDurationInDays = 0; // 0 means forever

    // constants
    const rememberPassphraseKey = 'staticrypt_passphrase',
        rememberExpirationKey = 'staticrypt_expiration';

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param  hashedPassphrase
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassphrase) {
        const result = await decode(encryptedMsg, hashedPassphrase, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        document.write(plainHTML);
        document.close();
        return true;
    }

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        localStorage.removeItem(rememberPassphraseKey);
        localStorage.removeItem(rememberExpirationKey);
    }

    /**
     * Clear storage if we are logging out
     *
     * @returns  - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        if (!isRememberEnabled) {
            return false;
        }

        // show the remember me checkbox
        document.getElementById('staticrypt-remember-label').classList.remove('hidden');

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassphrase = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassphrase) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPassphraseQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPassphraseFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassphrase = hashedPassphraseFragment || hashedPassphraseQuery;

        if (hashedPassphrase) {
            return decryptAndReplaceHtml(hashedPassphrase);
        }

        return false;
    }

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        let hasDecrypted = await decryptOnLoadFromUrl();

        if (!hasDecrypted) {
            hasDecrypted = await decryptOnLoadFromRememberMe();
        }

        // if we didn't decrypt anything, show the password prompt. Otherwise the content has already been replaced, no
        // need to do anything
        if (!hasDecrypted) {
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const passphrase = document.getElementById('staticrypt-password').value,
            shouldRememberPassphrase = document.getElementById('staticrypt-remember').checked;

        // decrypt and replace the whole page
        const hashedPassphrase = await cryptoEngine.hashPassphrase(passphrase, salt);
        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

        if (isDecryptionSuccessful) {
            // remember the hashedPassphrase and set its expiration if necessary
            if (isRememberEnabled && shouldRememberPassphrase) {
                window.localStorage.setItem(rememberPassphraseKey, hashedPassphrase);

                // set the expiration if the duration isn't 0 (meaning no expiration)
                if (rememberDurationInDays > 0) {
                    window.localStorage.setItem(
                        rememberExpirationKey,
                        (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                    );
                }
            }
        } else {
            alert(labelError);
        }
    });
</script>
</body>
</html>
