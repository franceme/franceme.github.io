<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #4CAF50;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #43A047;
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #76b852; /* fallback for old browsers */
            background: -webkit-linear-gradient(right, #76b852, #8DC26F);
            background: -moz-linear-gradient(right, #76b852, #8DC26F);
            background: -o-linear-gradient(right, #76b852, #8DC26F);
            background: linear-gradient(to left, #76b852, #8DC26F);
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>




<script>
    // do not remove this comment, it is used to detect the version of the script
    // STATICRYPT_VERSION: async

    const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 *
 * Mirrors the API of CryptoJS.enc.Hex
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassphrase) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassphrase
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassphrase) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassphrase(passphrase, salt) {
    // we hash the passphrase in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassphrase = await hashLegacyRound(passphrase, salt);

    hashedPassphrase = await hashSecondRound(hashedPassphrase, salt);

    return hashThirdRound(hashedPassphrase, salt);
}
exports.hashPassphrase = hashPassphrase;

/**
 * This hashes the passphrase with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(passphrase, salt) {
    return pbkdf2(passphrase, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(passphrase, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(passphrase),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassphrase, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
    const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassphrase = await cryptoEngine.hashPassphrase(password, salt);


    const encrypted = await cryptoEngine.encrypt(msg, hashedPassphrase);
    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassphrase, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassphrase
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassphrase
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassphrase,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassphrase = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassphrase, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassphrase = originalPassphrase || hashedPassphrase;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassphrase = await cryptoEngine.hashThirdRound(originalPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassphrase = await cryptoEngine.hashSecondRound(originalPassphrase, salt);
        updatedHashedPassphrase = await cryptoEngine.hashThirdRound(updatedHashedPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassphrase),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
    const decode = codec.init(cryptoEngine).decode;

    // variables to be filled when generating the file
    const encryptedMsg = '63c57f6a87aa5498d2cc3be0ed14b242fb976e216e46aedad0cf3343c998364e6c7be5fc3acc86d99f79d7fdcedd287e5a9646cbe198eae0183ba38106d88a7589c8b592ac35bbc340da1b8d2256c557d3be8e0b0a5f91f90d8f0672ed6dcc1a75e21f07e9de54c4a86dcfba91279bdbc3df29f6d30b56daa8223677d3086ea6c0089c411d31e2efbc3883ec56567f412d190218af9831c404c63d12e453fbec9ca0f7f0229f9d76ee0edd1bb048a8b9f0baa79e2ca96e8ce57786a80e1d9a4b481cee67d6e4255d39429535fa62826ed14524cfe647388192841f5b3f555a4666387febb885de8bf3d365dba6bffd012535393e8774390fd7dab495ea21d0964cc21ab8d26695169d96570cea1580e685c8edbcb2cf0a9b4206e180bc974ff358dbd1c9c1c31d4ea7a47a072ef32e6d9a30dc0f1d501bc00af60af546fb8318ad5eb78ebc15a7339b4976a2da81fbba327210c694b9066da82fceeb031ef8da91c4153813d0a657c000563d2de233a6f5fb13054d37c93496df8786d37a0e9a3bc5da4a35e9aba9d1d2b61fd84e3bbca3b04f382302e39be4bdfd5c13fe11c98f0bc68ecbe335f15f576c075588bd44741280ce424fc3d900dcccd0bd9086d7665b10c7c3ef30d298fc7378007657e3d70f32a4e349e18ef8ca0fabbbb33ebee76b016d5f5d93f0ee2c4a04c49b318c5cdd9d694388fa8f1b081ccdfea23f03ae9514d0344b30ee92d1f3b4c6fd41ded5bd38d82c59052e1b93b5e690dc4860bde6c8688de6527ad5357e75caafc4f29728208dc8c063e574c053861d4c51d851a210e365f5b3aebc052506b445d5712e2a96c17995842f966ad96a4e9fd50c5b1cb2fe648959d5d2efaa901762b991f8a7ae687fc646b4eb5a0ade1cb5d86807917678cb49cf78e25d7817591d27abe16799057d7a78cf22927c65a1221a9197067787a6f76f41fe0c1c9e151d0d79ffe98912d12c7afbb0d081f604461a0a122575251d44a0d6fffea1521b313d148e6e6c91c0e883890977948156f68e80a42eefde23d0ce3922c5a6d851d7b30350bfbe3f81eb86438d0637bf90aab80566d86b0d618eb08956959e98a91d5cdaab946c60697e3b598b2de8edc11aeeda4243d9bbfb6f2841b53b9f25e5c5225c64cc41a8df3034e87b41e1882b84d07eedec0a98277bac8f633b2c110d7c965f5eba3ef3333a92e6f5d89164436baa89cf1968ee7759fde124924eec70b240f3cefa541d845de1c2bc52b44ac60ed94a1924973a987d5efa50fc824c7f7fda76db22d3b39e5eb6037c40e19d5d61d7a457ba033223d284a26bf2ade85dc4f7496273f64b9aa502cf7ec972c53d831a1c809fb546430b4b312bc543632e3967956d892426aa47f64a2bd7c5b2ebebb48741ac51439014ff2adf10f05ff54e541dffec9a6c4ae42c1b38f1854f788b692bc82eef1ed8c57c3b23a51d1bf695882ce222cbe9707b8b3439424cddf8db700611e21389ff8d1042d62b27fd12c4291fb197240025f06d62e6bd761e254e726bb7785d0199cf5e778e58a5c215d2a5477f5d444a031fa7b0efcce685eb1cec241c343e86a6e9a628f17eb3b82af4cd464e56d50d89ca08361e1abb26982a58feff654110f1056fe1004b2982ba3e47073e981a70c417efcbea22d680237d39e9fb0de46dcf14bc1bfbce54bc1c437606dcc83a1795f0c7a5534bafc4c8fde4bfdbdaaca050e087f203c92d1b0317309325c70e242d31a20b4330436b25b502eec412ddc8669b9bdc440e1df88dbd89fd9f07d6f9b13bd9be30d167d2c578bf86e5aaff607a7de03be30ab0bd0d4500c8acfe4648f096e94fc034dad5e8d222d5854a08a72018f11d6b3d86ccbf1510620e9625144de5520f7a5f4142f6194eca183d46c0fb16409bae763145c05aafd71cf0eaea66b9e9db5730149f8253169555506a0af89cfc5ade699ab7abc7a978de9d245e7cfbcf4b25c829bbf7005499736a382a59f09d4aa2b0ad981f5d8df902289c854de47f5f805b5b9d1dad8d03ddc963ecf9de921c490465f3a78809ebf27de1e54f863cdf8505345c1b513dca9ac7ac0a3fde1265c0f5485c9382c2de5b31ca146207e6950495789bebea81c995a04ca4b128e80b9b7e5cd570f87b4ef9c71e42bae70c4f75c545d8245c98941998f97efda6551deaf47c8dbbb0265b4722837a1e40af38539fa09e2860cd15e996841c9925ce8a75459fb15388ab19885daac566a6ef4f7e11e4bd429fc1c5b46790b3fc8da79bb2ad8886d2161ece66b020dda90c2f65a394f5542f1cce64f8d77d388c6414ca2a5ca7de33d5e5d7b05329aab4b2a45b6be6b9032e8e0dd9678ef5f3563c80a7e90ca174515bc2de9c6ced2f72e16e1255415b03ce51274ce5a6342e3da89bc0478857662b95e22d4f66010786a323ba8992085363b650e12daed34f77e4a7f491f43e4a10a5d4c823859f99deba665986cbd1fecd02087428eb86b534a15d6c8a79e9463b42077d8f24c9d1b1e78290918753b8a10433b21b9bb201afcdfe7a1ec285543711dd9679626481e4540b1d86f85553094a84cba4706a7798c8bfb2771ad633fa852989fb2b33b5020fab14f7323e32e3fbfd38a982c6481aea5b1db7eb6c3c00a3356772a57b55425e5153033826d4d6b4c6a3d81b4dfa58042a80294a3747567c8e8746108fd107af95ab07abd8ffdfee096bbaeedb749cb53864a220e2a46556bf3ba712ce1b8447591ca42a5a7bc558961a2305bc4f91d8b050e813dafa60d68b30124ff7642d99be3bafa45c997bee9887dfbbdf25746140afc75167974580f1bebc4e8d5217edc2cd18658c2516faadacd84507194e71c7879809f73c7d7f588711a66e4e5989efadc088adc051451d3924a07114a6be89fdb93dd80a398b533d0bd46001e28194710121c5dc75d207fc41d5cf94fa6fe4f97cb93a30bd98e15312ac571c180b9651184f9613b78b578dbdbda389a15815ccc6f666b052922490d0b128b61b6e9b097faa82b90522b732be88c1e94d4811d114df519b0b8c5252326cab999873b85cd2fbb915cd7d87a2e34c9dc74251667114b2a251e717eba4465d8110010ba0a8b9cbc7e30735864cf8b31c65239b29d84783027d45eb02e7735b39db8266a357db880191d41b290d8cca186a2e1aa1f0deb30e6489fd0ff64a852d0d99333439d87631b3775b37f936dbee9d78cf65f8f8d5b73a774424067aefa53f06da7b360c93a15f439d747e5c43e81cb0a7c81633273633af06e59ff7c8fff1a6fbc71fca7cb4967ba2621e365135b95651c6d3ee183419127699143ad653219321473b4a50535443de51ee5a108403f4616780f35921db388d3c0b6e75259f3299a51fcec7dc156227ee624737c7065f6d1bc44e38d367960143f3212bd859b450d090e6c3c65f3b0ce0cb9282908d9119eac933ab0a2108bccc01569b025b5e5a2008c1ebace00a99eaa1397cee7d2c258ec4b013f7588cb97f1afbbc92355449267b7cf9f4227c4fdd44ecb826b6123e993bc41be64c649bdf11129880814aff344692054979d27b12e6791947a424ee39e4b78f3c481159d1b9510cab48c986aac6836ad42ff72aa60547e420aeb819e6a35e39920b38a98aee6328c1885b4d20299b549fbd2d6739bf31a6cf805bb6f20ef48884c09b8953b1b613ec8c516206e7dd5d335abee4c09c7eb98d35a43be87fb558fc375108418962f09557ffdb63b80dd4ab129d3d82967d1b3cfc76c3ebcab819f80a4fdde2755680de4603885a5a9c6e6569ca2ba989753b70dac90636eb71c2367f6e53268283775dc4229b536fd38ef9648c45bb2fff553a13e790620428c33a1fc121a64630f5c3b080e7d75a9696982879eced158dc04e215efc31da87289d62cc79a6371b5b737a6f408ad129bcf7ee9c630e9f7c0f1bc1aa921aeee13c2616c27a40409092240a31880850af1ca363fc040ce806390e699fb11e79d8116f31dc30177333b0e17bdad7c4a6f050cb20beef8f3eab025f84ab115a63047e88cb7ef4ba16ddba3e482cc056a6ee479a308a2657dc5143c0dcd3fdaa07e4574f134f3b3e7b8c6facbe2b3b177e205274b1f0033baf7f6c9b6099e8107542352e34372f4e17a289b5aade09768b5ff4463661ec53a22ee8fc60207cf2c36e21cb6e559308643a6022e99d7853270ab2762f1a90086abf1a9e103f562dfeca9f32d394b195c235accb771bee483e6de89dd7a8dbca31706b676beba7bf4f0536fd2e36ad772ab14b18f365f3ac25cb167d65a26e6eacf2b420fc93657474bca4cc6355b9498721e4f8acb4383f5aae22e4507cb1d7b6d525f1332e7c20e05ec9fa2eeeed5b4c76ccce03fbe339d1d497e2659fa3b622b48128716ecd911b26ec0dc60332f4f80216151fd0b3e1114bf52340b5f9f6f6de023080d2e1b4e793b1d86974fcb6a59c53a7f1e7981067e231d7ec5f12a67d8b21d05e86d9df72e8ad80c94d0957e6afc86d9c0fff1f303a4f1b6a9fa61cd02f94d19bd96ec15326c926d5cea7bc7ecec7ec7e9b79a74ca2da7bffba108bca2643de083198420b3fcc45da8f42c1b9048d490156a89d58013975de572659178abe19b7206fe1101963d0c9837792b614375105c70e4f2508b5893a39b7cf818f8e40b3ec4af48413d79cb6c7bf0b0acdec237d83a031cb0171b537ca5e3540804cd4052d23de76710af515d12dd8702dba0bd3cfed4895732a3086b1ce02eaf7115e236fe669bd14a18cd4d2c2021b96109d5d11ed2079aeaebe059c0f9d38d4ae654f7c410c4e50b3d2daed0d99c683635ee1fc9a32fba9ba74d8e79fa4a1d3d4052a690323500547b2b8db2123c7b7344c07a7d5317942f957867de3182b2de64250d74d2fdda1dda047d801ea097d7030abbf0e2a7096b6aee5894654ee4e6081e5fe7997a38cc15323563f34cd7c058a7174cdec76db378d22f377f3d544b86a7922add9761dda3b9f734a940054f47b75dad50fd48dfaec92510ee4aff9eeb358108ade7352ed3571d4c55ff98a70e76806e6a00dbf6aaf04af39551b36238ba08f7af7361fda7fd9c9744e5def187e1408ca9c3b834f0d0b60ee56617a94a7bd3010ef443a5dab66e07d42b27fbccb46ac8896817235ea6d30f71a3786b89d524ff00596363b354bc8b05afcff5caf027347baa16b8942020d2cbef13dda55c35775019b9102da8ea4860d83e73c847c14a97f0f470e135d459a43180590432927431e21e5442d778d813e1f3cdbe0911e6a2db5909f6dbfcd13cf88d606af1650893106cae151ab4b9af81823f532b6959e631eedc7e5b01fd3cca98ba74d51ce2d8f024a69a5cf4082aae20ced433e0805dc00bc139f62020c0b0547e36b335cc6c2951552e4437a9aead6faf8f8923cfd60933ad6d61a099a4ab88d31a85378b4b2cde10e3177f2bd170f2d81a8900fb649b25de451344b54dc1eba0f93bbed0dfe46245d1e974fadd5a9d04922838f49455d8f96317cde3eda3ec67b9473907e5d0e342f706ab358c2e241113ec7451ab190744d3a53941018c11c2982dbbe46ddd79e66bb03f6b85200eaf7b791cb06e540d38dbe921e38ec3bf7917b6283c99573de162b302b75329dc8989249fd5683e34173512546a0a1b6bd2e2cdb50a547594598f2b7afe51a795b73ef301b1f30efa93b583257309434e9cae2dd0c7bca27adca66a851bd95da0b1e563a28705488f0d18ebf629abe8c939fad4d574aef20fb8c6c9c2093efa1174a2812a3a93df61591bc15108c214961946fd6e27172691b15a415fb31196f42153252d9b090d966d99a047d812d920a7b109fffe85d47279e10aaee853eb22156695d4dcc81f2cbc1478cf495fdecb3d69691c5704ba6a405cc5c3fd9102f62fdc05809fab2fdd2363905c5685d812fbdc09330be7da76ef8d5d51de1b17931465b3cefd61d5fe3b14ec61f0d3067d8b8d6e2ab83ec95af539c00089eda0ad817142b425552bebea19ee5f60078c6bcf8fdfedd29a39e172865ff2ebd9eff131d53c2956e72712684cb380ecb1dfa14927e14e315c9d1c395ff588e957ba082e5c7f07e6266230721b7333c9d85d4eedb4c1952c9699686aa597da82338e6c8d40f781ad6552aaf0025df8b161e0918c9273baef05026185ab18f0f0e0ea7d35100435d3447208deb5f951569e8c62e3eea2e64dd093e2d34780f35eddf39b39e0d03f02f917eddfb5bd6694be3692b6fe6c55bb5e6525b1a4cf46f304f0d383c6470d22c6cfa5e408f18977037bd195c211a4bcce011f61a26b57e0302b38e3f3c5b3ef3ceb2f0b88eed065cd4fa766f5fea208e89c5790e2b4a68d7762647f1ac1b5e77c5200a2a435277bc4509b8f8dabaaf2cb91e2f8af6d9fd9d75ba7ee15c2875ebafe250f3f62c1b952c34424c614f88a973b40f4c7ed02fcea271382dad1cbd19dbcd62e3773d2ddbfc282c0e2256a4990aa2c27099784b7bca809255402d2cf91f329c7da269a40c6e31a694f8f12a14398db0fba073a4fa15ff3935f70b494c9f04a5db9e2b36e32279255167d6c0525d8f1e7ee10494e5f7f9aa611d33507fa9afbac102f9771124f4db2802534d6651aa0674bdd03db9839374e8143bb9c36ebc01bfa9796c00491c833a8011d4a09a041c10e3bb62c6ed03b5a7174d089fe13fd880ae63e30137bd02c9ffef614f52b54ea4e065dff0a441a7fa847dfc49f8ec168e5a91dcd6c546293748008ee1449cb0f8d709c99b3a931fc8266d57a9f12446f3d4430b71c108c5b369b6195bf2d5b7188ccb2346f56bccc661d122d009cbceb759601cd8b95c033da81c2f5f845151ae03ba8e39b88026029fa81d2d094db3092e92ba73724f65f144f09266ae0364fa6e1f000214f5ea0fbc170f0894dae0a6460f2fea7a561236ef1e82038c805b74401c4806e054d543cbd9af6ba786aae7f24d868da6a919642459d59924aa40c3b21af1586d84fde09ac71e08f68729fab2b59b944b47be1b1afe6a4c9130de13ec7b0a690b29613158c639966ac7ad2fcf82f8220a692af7ad21771107c781710e80517d2a5a5c25cb85dc2f6573bcf614b9dd3e0aeaff4ac116b52a9b5a1a6a3df207ee794b8b1a613a4e985a911ce55acf50e9202a64fb8da9be239df0db1a970ddef3150edb2f64af10478240410251c6dec36947ca86e2fe2fa12131c86a7a30140818796d86a1c8e141c5c83c3f9c16bf00ae148ca1b2ada55a2623968af3a6be1dbd7729d06192ecfba90fccd6134d54898da0beff79b8cf416fb1d2175ec9359d53d00a8eed717517b1b8bcef34487cb67d6acf16338c2c14671fc5922859d604b1edfb3a6267c3495a164dcfe8f925e19c014f56079c6f85ebcdd4eac1db38449731cc4f11c4ca7c9bffc7733a8d1d454836234678c9fa3b2f65234a0944be16cc39f99199b3b50310d842393402799a206fd076017fe019feacc5ea9a8f9af1814e074c1b6389f5b7fb16a6a733e74201847cba9fa5008c5e39b701f5e7b798447dd472bb953c8073215b066d13d3eb3e3f9c22aa1dbf2f92986165855457669bc948d68c713da4c8cf2e7f870e06d17bce4e5236d03996962abe216043dc8dc8d1b25e8c745f3e53db8e08ba3526c293634d0b8e7554ddec562beeb2fb544259da753098e31efe0cd78c03e4d78153028f2e0e425a5b8c7a9e3f81780f1a8cc57dae39046ed2e0ddf2e4ec8c98363aa1b0091d9e4645d966b3df0655157625556091c675e04c78549df5ef22c7e90f077b5d2e12598b8cc61dfd246b51c33baf823a96e644cac26d0189a442e865dd4ee2877eb08b7efe26117396ed65c759c18ef149ef0c587ab124e5eb32c857aeb2b7b33fd9fde1bc67bcd06cf0845f715bc8130dfb064b75f77660d778ba34f78d91daddbff0f86a11e52f07e2a490770ef9a9c393d59591ff6718efca3f7c6182517193843907803a9e908499c3e1aca45810e63fd486c4562d3069c74702504a69a6d617bb429227355804f1ef57620303e115dd56350180f0208efa687813b81e53a1c8fe36b26a2e80551374dae29f29bf877bb0335b63538d9b316322bc4254c2b7b570aa7b47fad0b8c9d05c87fa85b65fe697bb668f40d4af0b1a2852522a051c12f9ada4344441b401116283ff0a06a3eddd24147f284919288613cf91e2e645885e2e3b19ce9d9c992eb3e6328542a6200165cd6aca2f53b8239a0c496008f22a93b3e7198b4780a9967839109c6115d7916562468bb249ed30ffd0832431be6c09dccc6e3e5721d56e7211078e1833d6b3252b1d5e8035c3c20eddbc7cecb224bd7316f874359a963efe66a361b12f9b6b8e2526014e310042572c7a364b135b3be2f54707dbd0aaa75f793f063ca34d6d460e041fab1d9f3282094621316f14e2c7a74dd1e7e5da3ac4ab882fd0d2deb5ca6e7a8286914bbb7818c8cefab0f2ff7d8933c02ce8c5fae7ffdc7ccc82331f97690d2608fb9cdee0d6d12f61edc6c7f805123d2a0288090a5dc71a7c17cf500987c70ab27568455c7e3bc0088dffac10690914afb17d7322432c2a1203aa3ebb381ca25aa64a7143fa4e94a3f10c1fa670849e87db759915d42699172062dbd57250497ac58df9aa030f087e4a77d10f81e083e543e4765db88b666c4ccd7a4ce1ea614df5e6b0977951666c7962adbfc769458fd0f03b02ddcd9e29f3468ec5278e41a9c1f3d2dee71bc79a879bbef2e2cf81a62e610a89d42925d56b86a9014cd57870f31826066403ad935639c20729ef8a1f62e7f6d77065316f63a8e10b6d2a5ab6dd420f6e89d28373d0fa9ba60e35b2d45caeeb176d52e025ee550a78462b48cb5c015c3b48f87403b56d3040d3f6bc18620f2e724154b4efafab85431b864dfecc9d3afcc158eb58d6b049d3ecf226d9ab0df17dde0903f6e4f786b9b2c5ba9e894b7c18a2599e1095299f38bd5f709e6b5167034b6a0f5f3aaf99d8ae0ef443b74f6c9c7421ace7ccab610cdac0e4f572d10a50bf22603a5f7267a4864615240dc9376ac93f3adf72d39d40993c1279115faa78e1872db05ae24d1a53e844a30934da207ba897a8bc8f9a06ed80181bc59af63e1d6412e61d51220688233a0a343f17052f4fbb8debdb218d0655ae89fe2047a07009f89e2b563b7a231722fb86bd2cfb33aa59f516d31f5705433f9fdfe3eca34bdfc3b11161499135ae1a5e6a6fa937ca87771c96dc026a587a1dc36eb54f57320ef13f18944567610ab6801ac984a797494b608e6cdcde43fdd8b273ebf77dd2ddb9bc3c233e3b38aac8f9a8a6feecb4628817855a968cc176df8d6cf2567deb394fc099b56714e0393ac259617f0503242dd0c5dbc32503e0ac2201e3a14a68eeacbfc74a7bde54c992a677c1b676258f917e5401b2137e88cf884136a08ee4e2441fcbd44a1e4e751e40862345fab2daef8180699ef32933da0cec16053ddabd053f36ea9320bdd8c799eeb5fe7121e33a3e987b8e5e2abc593262758c30e70ff9a4c7d55a2e0cbaa689da9594163e1a3335c43e8d990274190e7d78f66ee8600c2e522f928efa40cc6a2d659ef0ae8d18e5d3cd1f203abcd9a0676e999b45b90edc7706ddd6b8e97405267f73e4715817bbdbb25e096d67df0690f51c6b7c0433b95e08295548cbd5929184bcf7d34d433e153c615b655782322a2be6f62a90185a1e0081e469c2bb04db4a744d3e19b8fb40383c2a5f3f3793f4514bbba219f6e851635ed0fc090c6d2f3cb6ebe6c59daea970fd080ad1324c8f5fb9829260fb049c0d774ab17496f2c7f205f6c9fb4a8b41b0df676bcdfcc28925d5d950db323d9ceadd41b455a92d13590fbcd2b9a47b755846b3108c46352aa335596e8a8cae40089c6a08a30eb922fa702e8ce2e36e1595918b400b1956aaf13f514b0ed86adcfec4927e89189156cb05f3605289a1c1fbfb473789d4f840d922d0e28020404d32624e2dbb64bd65c78952caece2dc8f8dfeb02876963a70911c5a1bcc5ee38126c7b47d34d120caf9d66253dbb3e320e3330e6e1db2bea5f684fa95c292f0ef2aeac6f49f52e8e6621fd5605346f304871bb24d0ba7ea40c31fdaf4256446d1ab07d3e87a1f3e8868b24f49317cf26a3c6d85cb96f761e26e20463aaafcec91de37d72b478e26f103cdbc5c21a2c908bbef4c92d5d65868638f01464917330b3ab3fb0a681f69462db315eb56dcc6a91acbc99e96fbf5993a5dee40fc9348a29427339ee5fcb1cd18157ef06135d3e0f4be67d8c845124af80954216252330b9089464665f6b18127de914a224e1f8bf14d1dcdd56d5743ace1df97bfdbd7c91246c63ea503f0484c44188331e7f0bc0443e67a31068ffa2509494aafe36844c86cb15620a2e0fdab0a1bb0f04581c9d893ffdbdfbe44ab0475a8bce5776e925dd8aacfe918a1c4601c65606aafd01a0f97d7dfe3e2826cbd08bff3e86ca354b97e6feb81b948bcb256df92fcf9dd9e5c549d5f7d14eb7b00eb3e3fbecb09a7f5580d25cfea6d3252481fae26fee1b8cd4badeebf1a3ea1417bf2f1d3ca6505079e3087aa2ed54c032958fcd5ba8e5f513ca4776aab6fcd742fcb981f6757aeb3d9a96781e9296138d051ed4b910265e5e579804cad807fca4208abd4bc5dc4a3987fe1af7a46c272a7ed1b6ecc6accd208dd89c0463a656c7d8a2584a02414b6eabccd3f28cddd1af72038ac911f592f8eb6f6df7cb07513777a7944e3e240c059f343fed0c7da62d613c010c0ca627b83d844023961b4e176647c2ca1728a230bb63006716fd96f50b08a619fb912bccf406ab98ca78dfe335f6f4e3889b271cf362ded68019c363e738fdb0631950d6da79c1c766868e2d2936bd6ff018c6f9442c6be17538f71e93011dd3c271c74282e1dda4eaa8ed8197207ee6ad8ce4d2d47b28c2aff3b6a96089ecfadacaabd81d70fa21f502b180b06b39984e4c39e7e3cbb2002abfa3ee86e9f23947ae1e786fc2c38938bff8f6678fa711551bafa9e38eca578a4f1d37310911acc9d284414cf10c7f7eff66ab81c1dc80c4ad97aaaf8dcbef5a8027b109f92df53581e762e93e5264ad78277b25b844f3fd2f3875665a4f25b50f33d96528fc48c54a6a18ac2705e16be2a109c699d316a0dc846881d1c54a3d26985c80b65f7e2844ba903a22be8cd65a4b7cc76aeea7086513399a51a1203ac31425e258899d9eb981dc7ed85b34d6c38db3c99f60b876de7d3ac049013d91cf6d67ef671a4d8046f6678c1898a4e37cea928c087137f13afb7b43e6b0e88dba334fb536885fab4e74074a9042c102e6528280a356bdea53f330cec397be10b73e850c3c5ee2969c051e145358b553877a49637099cc6a47e75602471c1c41674ccc8e0984877fa9f5633c95c7f0125cf082d7755ab57d81fb81e5f51b20180a154216b23612972ff2baea356b01d2957c9570450aedc47bdc10e87d1ad48de6c49030fb708edcdb61ae2c23fe1021aabbb5a93abb0a153cb2b3eea56d37df7ad74a705972edd9c54913d3eeb089150b88e377eb93317a7c675794a32d0ee07105dd672afac0c6b50fa12938f55ae7266122b8e97e5d6618016b5a9487288bfef81d07a32aae25e8c09b32b09d1f148df203b5ea1aec856a7207a3ed0ef24f4a199bf0c8b174d2bd71fa44557fa4bbf961d1c058506915cbbe5b1067742350cae32baac1a63a690b817b8e02c4c42610ecdfe9b5e1082b8ad6cb8caefa9746f7fc39a0088d6b1dbb21de92c1782f50f5328f8a2eaab3d60a86a86d682035ac6715b9622734dd948700cc1caaa1b0c8c1bb2b739088734d3cbcf408649f81dae143a0f7a6aedddfef8830ae32e2dbbcd49b0b59e1c36f8be474f49568b178b41443ba323babc689ec28658cfc53a2c3a7057322fcf08d49037a3705688498765672b834c729da1ac27fa242704bf9d8411df45fc024633f625575a4cb8b63337e0286b0d160da69059c1bf73eb86b70ef46ddd5c95e265ba6db5b85db6cd70a05bcd61a9e749a18f9c4b9c7c6d6af140a031e98b41a646c0f3ae5adbfe085cc27643389c22d3e1decb3a8009a6ab54e8164ef05f00dcb3d16ba0d4baf17428d0dfdc5d8af1844f611eea209d1c910bce3ec44e7352aea9339a82f211db4e7605cbd6a01b6a1be98e8225bc2c483df5e9b8824a02cf35c5896346e7fb28a5b2c0eb44eb426136adb759358f498e4ee34e0f864df833f8988b6f54aea742e77b7f059542b1276cfc60b61e3f724f6834bc1f304525105a4924bae167f0c58678107faa9c03bdf258927d30755aa4c3d654f2145bc70ef0d49ac2c0a75f7cfdefee7b8bf646ab59d1a58766fe897021fcae4b2ca91e14184482894bdc2d267b48f2c0a863b422704728e38274321902c151f91549ea442a62b479761d88273295249b35c86c650e8b5538c23d7f5436a16fc0c48dac71b73026e18869ef2705defea8f58989b2f411f13db5246f84ec4eb7e3f6ce56fd9ba944dcef8640da488c70e309c4432c7176c0e335bdfeb92ade51f54a603240aff1b198a081c2f076eac559733566990444f38d9ea8cb46a4c17c229481cf89fb5c9ee1b8ce2f6e92596d94985b30654198606dff5e1b1397d5ddfe3d66825923f0be62f815e2a2ac82fe6ded09372efeba0a662b808a52bda52c2d52c4603e0d1a3d927fa7fc70d9f15d0db0c1f9c56c1f177afe3873fa7acddf119df117f9b8258a0c5bfb77fd2a72cb75b478b8dff95bd97a3c07d63c0c81af30e8a41f8da3fa7458336f37539b077ccec48d57f35f6a76dcb5d3e37721cbec36f5f5d74eff163a1a397f76b1bc888efc3010daa13292b1b9705c172dccf3435bdac78a8036fba78e8deccbce2f92a6756976d9daa1f77886af9d96fab58551f80d5665464ddd47fe8d02c817cf27b412376830e6aabdad21a2948f5afb1a0ae06e8bb22f6ddf710d34b8ebc9acc8b842c0f0336f346698267fb9b3007bfe1b433e3104da5bb82037bbf92854baf6ec5393b75988e88abd2e74aa5bf7f9520a551bc7287f829bc2a42e11ded04c77c3b31a1bcd5c6050fa3865cc4bdea0bc766ec1f77577f5b8413b66b169cbf657d5d512919f55d1ee68ef117e913895130b5a8d10afd5cc77517a47ce1d68ea661451f1df880e22f76b808ced9b92d172145ec0e22a5f3494aa97eff0b6a2aa53509ddb8832202e4ef42a20ec4d9bba7bba8e68b1c13db0b9e114dac96a6d561e21785bab7b184e2752d56d41df6cd4df43e17dda4087953d1cfa3c16c95f40943f53ae7da540bd626933b27f7bc4b044347e373a68fc71aa7bce1436ec8677e748ed09d4ff49505b2c5fc7bd2b92bec9c0d20a44798a11445a6a47633c73b2ba61c53f38fb762f656d4aa36a3e9e0a16abaa6899ba2ef8aa78d691384aa68797056ae836d03922d6022feb73a3911ec925143d912322ab76e51d483edef33525c9cca5ddef884086f4ca9894bbebf87d2436c2efb6c03cc8d6d0e6077448ebab13d8c56cf601b73f37631a5efaba3f59ed5511c3ac2099f5d94fef5e6e078d16f8eb7132d08361bb781b53fcf9c8a3ea1d865388ec2cb3be6fc4d3bddb1d597c8f84ef3af173038b15219b66e7217407dfea5079c2d82a0388132bfa3e39cb3b9a0d29c9519171fa29287f1d155eaa1bba05b683d9edd30ecd96335dcbfae2034cf50e27737a1c92cb68056e2858fc2797ef5a14a1a135ce58fb95f5ed17b78fa9df168fa9a4515df1cf0e458bc78f114a27fd9d8a9ff11f47ea5d5a0966dab5d26cc346575c978cbfa0fba85012ca3fda06c62c4fa37641989223ac3e213d17117dae3b586d6fd3331b90d624d14912403238db647df937b3a7e9e1d5cb3170654e15ab5c3b282ee421113928e5a91ed5553005fed952b3c5f259c221a6a981e43f707492ec09c2590c28c03ef8334828797b438ef30be96456546ecba167e4ae87abb446a15776d751c1bce6b087da5b708fcec4c196c2a08e6b7b0d77b9403e489a46c79a2a876c700a0c00e00c60e3ed5b531a7a33e9af50ea884ce43737cc3f1bee6a4a8150daab113195a0680610deec7ab4e2bad9d41712694139987bdde7fdf267557a1a45e078c0c73a5acb52ddd113b8f40297c47294df5c435f9877ae3cff963a1079a650e51af3a0c0404cad37d3a15dae7888dad38bf2214f8d7b4b55ba2dd5cb83a2f7f20a24bcc0859c8cae909719ac5c31c6f233437c7863ff7a7ec7953efaf0cd63d13321b96353e75abf6cb9810d47f46fa939cedca9233b685330ea53e7d87efdc3da96dc74133556461e56c26101f77b72450d8114bf860f91e75cb08aa12309b612506a3984bd05dd08ed4244cf1f3ff056f792d7aea20d2d6c3fb256c6d1119edf8ee017dda3468a62bcf4c8cbe6cd21ab96aaf69ff0b56cebd5f021829a261eef9aaafb70d2cbd280e861544ed871f5513e1b6ff866a9f850af4b3f7b02de2cd0677f89a23ea05b26c573065e1141b3cc914e2db72871712a73faae433b8e020ef92e342c06d2099521290d1accaa8a6ef52a43281a99e24b24d2bd8c26d281ddb85de505d8ad6b1c1139a616483d4fa0c90dd97a19a44d9dab157e05e37328339807656235a6fdb97a21b1d45177ee05b941c0aacf9265ef5971aec11c4877fef0ceef2a7480d0b97042d504083c4087afd21c65f36570f677c765cd118900e3ca203213ea0e4a55d88a99b76616fa2e3f5934d8d295debfada47de5a3f398c1cd3046c076ed0162c5e681298e8946d67dce58bf34fb9f221f14e5b2c21baa00e4e0a8d7059a8f748aa54b3d4043605ccc3e8d39ac671680dcca84c39eae01cb64b7b6fc8cc1b29b4f4abecf430b9c38c5738c8553691a88648759751a18186b540d8a9070db943c6ec0599bd01f09473786c5560453efbdd5dda960903c2f4d150d08fea5dbc2644b0321ade7013dcb10b42a986879266cb1f265db983c29a5dcab527b72536f4bd64a30b440ce497a185dadff89fe0c7ebe2b72ff55050eb79b584f11f9ea98fc0d6d8b0d2c9024115517924595eca740c6bbded94e2e11bf361076e020169a22f96c5044bee0e322b22dcd6703fc22c031765fdfeb90f4a131e5e321dfb8ca951c073831c96ce440991253cc0832580d067d82fa56e6404e855db86433dcff8450a77b801661a88d271a02f9f2657b31ba16f578f1ac5ddb0c2d331a612bc1345629aec43546d7946cfd3c946e7745c788cb89d11b2ad7b0bec0baf007db8b0cd058d017',
        salt = 'cda90df069fb92bd5bcdd91eacb7007a',
        labelError = 'Bad password!',
        isRememberEnabled = false,
        rememberDurationInDays = 0; // 0 means forever

    // constants
    const rememberPassphraseKey = 'staticrypt_passphrase',
        rememberExpirationKey = 'staticrypt_expiration';

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param  hashedPassphrase
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassphrase) {
        const result = await decode(encryptedMsg, hashedPassphrase, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        document.write(plainHTML);
        document.close();
        return true;
    }

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        localStorage.removeItem(rememberPassphraseKey);
        localStorage.removeItem(rememberExpirationKey);
    }

    /**
     * Clear storage if we are logging out
     *
     * @returns  - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        if (!isRememberEnabled) {
            return false;
        }

        // show the remember me checkbox
        document.getElementById('staticrypt-remember-label').classList.remove('hidden');

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassphrase = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassphrase) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPassphraseQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPassphraseFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassphrase = hashedPassphraseFragment || hashedPassphraseQuery;

        if (hashedPassphrase) {
            return decryptAndReplaceHtml(hashedPassphrase);
        }

        return false;
    }

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        let hasDecrypted = await decryptOnLoadFromUrl();

        if (!hasDecrypted) {
            hasDecrypted = await decryptOnLoadFromRememberMe();
        }

        // if we didn't decrypt anything, show the password prompt. Otherwise the content has already been replaced, no
        // need to do anything
        if (!hasDecrypted) {
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const passphrase = document.getElementById('staticrypt-password').value,
            shouldRememberPassphrase = document.getElementById('staticrypt-remember').checked;

        // decrypt and replace the whole page
        const hashedPassphrase = await cryptoEngine.hashPassphrase(passphrase, salt);
        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

        if (isDecryptionSuccessful) {
            // remember the hashedPassphrase and set its expiration if necessary
            if (isRememberEnabled && shouldRememberPassphrase) {
                window.localStorage.setItem(rememberPassphraseKey, hashedPassphrase);

                // set the expiration if the duration isn't 0 (meaning no expiration)
                if (rememberDurationInDays > 0) {
                    window.localStorage.setItem(
                        rememberExpirationKey,
                        (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                    );
                }
            }
        } else {
            alert(labelError);
        }
    });
</script>
</body>
</html>
