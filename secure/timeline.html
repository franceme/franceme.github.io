<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #4CAF50;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #43A047;
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #76b852; /* fallback for old browsers */
            background: -webkit-linear-gradient(right, #76b852, #8DC26F);
            background: -moz-linear-gradient(right, #76b852, #8DC26F);
            background: -o-linear-gradient(right, #76b852, #8DC26F);
            background: linear-gradient(to left, #76b852, #8DC26F);
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>




<script>
    // do not remove this comment, it is used to detect the version of the script
    // STATICRYPT_VERSION: async

    const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 *
 * Mirrors the API of CryptoJS.enc.Hex
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassphrase) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassphrase
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassphrase) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassphrase(passphrase, salt) {
    // we hash the passphrase in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassphrase = await hashLegacyRound(passphrase, salt);

    hashedPassphrase = await hashSecondRound(hashedPassphrase, salt);

    return hashThirdRound(hashedPassphrase, salt);
}
exports.hashPassphrase = hashPassphrase;

/**
 * This hashes the passphrase with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(passphrase, salt) {
    return pbkdf2(passphrase, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(passphrase, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(passphrase),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassphrase, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
    const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassphrase = await cryptoEngine.hashPassphrase(password, salt);


    const encrypted = await cryptoEngine.encrypt(msg, hashedPassphrase);
    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassphrase, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassphrase
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassphrase
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassphrase,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassphrase = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassphrase, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassphrase = originalPassphrase || hashedPassphrase;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassphrase = await cryptoEngine.hashThirdRound(originalPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassphrase = await cryptoEngine.hashSecondRound(originalPassphrase, salt);
        updatedHashedPassphrase = await cryptoEngine.hashThirdRound(updatedHashedPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassphrase),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
    const decode = codec.init(cryptoEngine).decode;

    // variables to be filled when generating the file
    const encryptedMsg = '6015a11aed600a7a7dc1a311dd5901de39c15086539c0ab93fcc29cf7027e45aa7546e1e0026371398293556f558479590d026f7f4777309fc556a1b369e47b94e5a8e670c1ae90ce0c871796339623646a8c217cfa656ffc904203033999adc7d56406f715695f0c206a29e0911a58dc58fd7c77e6c011aa2f95cc5706cd218e0b99f31cef7a4902a6af873267746a9c184355997f1e4dadc630918d4993f080c5ef4cfe1006943aaeadbf54c1ac33495fadfeb870666b13bfbc9c695d57ac0b7b26d075769228ec63dfbf46bbd09947ef6aa19fb593ddfe59ff6e450713203c9aece7df28748763ef1ac83320679399316f919b83c1059cee6be5237d1fb103b284bb4af53415860d2eda4ce5aa644a251dd8aa2f192c70265c4214bb65d1965a65095dd783d08180fda85d4e36837039e612071efe1e3d528eb1c5082b051e4684c75222be0eb1b94d190f88fa646d639ab0e1f760eb973fd53be403c1195a35d81c97fc488116e0fbf433ad9f0e3e4342dd3642aaee9a201ce4623c55ba9362402e49b2df4a5754a85b6ca0a50f4c0489890ad02c3c167ece67933edb670bb19424b1b278d8a9270395f2807040f07c742f6f059f4e20cb2cf6b30e079603bc0eb9b65f6458e94fff393e0e5a850b130213cfe9d93d12f707eb63de34d66ad32983a3a56b349881e6c942ac278ec33b4f8204123e7c12a8d1a9babcf7d2304be46a9eb762618f90436f0eac40bb2997f0f59f886f55a5f1f6789315086efd967ebc0aa459c6aa90853e140c5ff5c9bb5c80d6b80def4dcd30631115cb8b1d485b712548dfdfbc9f02c62708f36236aa4d0719255e243545401e24c050c32c75c7bc5edb66bccbc6b6eba8d476d0fe879509d5f132c572dfc4466d575cb8e159f57c2eb38a2b4498ec5de1fb294d871d2975a32bbebeef784d1e246906540a0f97112f2c798d5b48b0f094eb881b1dd2c1d7fc41ac31807ae18daf248d26c29516b6843c15393d48caefd5eef6e5fb4c529d57d338fd9b1d12a05aaefe1165e891947a6c1e8d9a52b3d6dc18663ba5cb47c89ca7cd1130f4f3a1c1e79a877692c52ed00f1fb680c5804ad560001d3b37b281329f207cfa7ab86d84fc11bf1664ac5deba5a81149c3bba072af220a716e2cd22dac56707f59e07cffffbd25b87b6faba310b6c5fa10b4435aca51eb308c6c0fd5d84ff646e8a8df4bfcf51a1d11aad2329b8e6df0c2e04879346dc0ec816607f94c5eb1eee7380a6816bf57813e88a391592e3ae2dfe584de1e33aa6ce929ee30b978a72e32ff390dbd66ec23d0466d74b219b1bdd77b83ecb97b78450e3c8718fdc539c56ec458812e801b20900044864a8e1a50f0a43a2126c9f1fee50104bf6910fa5685077c93cf8c6aa5f9adb7bb0514563544a1670af362ccc886335253be5b0c961773e65c443245cb77690e58d0fa5c6200f1ebe529788c89c3fbfe97c01f770c2ff1e6c120083f01a3ce61a165a3628ebbcd818eb08c38d8c53edb9898b4ad5dd20fadd0a14238fdd18c078977bc070bf7c8c17fa1c915c673a9128c0668a31d7423f9b909b0877ef1691c0de50096e1db766ca78789dc36b4c6180c13498caef8dc8140c2ee5561ef93a6e836ee4a9af2b9d5e68c4d66f8faaaa44a765e1a33c4d80333782574c6f3ad93668ab65ecfa802cb0aef6b2ac54703776dc04823582d8060d5b3e342050b4da369d235e1dca14c24d6e3bf70e17b937e2279b9fde091e66f03cf804dd3eb655ac4ff1c4df3258a8356f975e77dbe1e6d4fd8de1f73e35c2e9a83f0bd7df44980f0cf6c2c912a575c42d16ebba39f500426eb3f5e55c08f6c06ecf932e2bc87cfc77bfd3671f6dbe65db0df817c7f172803098cf65826ec51ebf41e03d0e3acf3f9fc7b880c4fa7775d62a167f03be1a10f871ea047ae6d391cd700ffe90dea28f877811cf8d8b5ffb91392db533f45c5976202c3da59c010702fa1edc1af464a40db38a04a3fb9cd073a1f0126a209fdc48df18c167d44a8c3aa9a73a7a74c36a288b6659f95bccdf60e1b2ca12930f02b0fdadecd6fd007a008c8d295bfcb11328aa8720d128bc4cbeacb9a9a72860e48a74a88df0a33148b381801da7b342bc68b360f83461975debc3f1529981af42bf02e50f531a53ee15be81867843b02cdf7973d0db66383f42d3a13803b1c62da1c8d8cf55f43d2e8fb5e346e7b8de45d86245c65a4a456878bb0785bdeb1bbe1714f249898960aef6434d8cd6007a6320f462b8aa3f95e9a54278632f2807b58a69d60a457650c585b35d03c5dbc3dee8546f9c5f7b857bc41e4d658dc55a45a1f6f67e529941fc8a36fff04ff5ea85afb86f32cc96dfe7fbbfd13ae57d4be71ea47a0ac2b94419bf2da3ca7f09c909abd51068a7954e2f1739c64a1fb140c68c860cca94f5440c612225b4c13eb95cf3969ec8a373a359a3a5fc25ea373be3802a9f09bd7dfa58cff848fe78a602a8074dac3f7fdf8e622d238af9aec63b568e7d8d25e780fdd9c225301f5fd4d9f574f223648f4c73b199ce79eabe96d1b3a5641c169063e6e39a6c84696acee08c9086f8e8cc2942baa548f391a1da5f81bdc4dbda46a8021755da53e4d62c9e767e17331e47ecb8b7a84781fc7351b2ebe34433bac5e6e2340faeb78eb3552f213c8d1219b0bced50ebe42097f14b8de9ab2762a2c43972e02fbfaf2f99ffeb0f5cd7c1907d65a45d29d858a55b9c5efb7fe58d483c9b44a6585a23d7f2c058be652138562ccb46a05ea3488937ee5cd89e87fbfcc17ab76e94acdbdeab133bebd7fd7ea1f86d7ce5172ccc76c6c6ae4e11358286273f559f1d8c95c4cdb8734fd9afbaa8a9cf80c4470d0edae93e56081107ac6c49608d9208d8373cd443d1ff4153c22446386a3b03679ee0d4f94938a644eada52e2c3b584ac1f7d1a8de1628213a08f00eafcf0e20e13f353b1e7b7a42de52d3abf6a024a6a3e851a95dc29e3e742ba96e247432809a29140d356ad5c8b133f74e365714b654d8d5846b95b5f0bc805ba519f5467dc14f4387b72f1a45c0e8d65eb159152219b7cb2d152382fee77d685d5d3ab157e89d22a76429e2fe5f138551c620e426ec03cd03999e78541bb49959f303824e5a5984f7aeb4803bce9a1ee576181e24d5d69440e10a12d9b2505244080dccc234812a2c7fae94b434811f21081b8e7a49c254433b2ed2ba6b3f2088096e450463fd8c35cecb18d09b5df9d82f9f2379aa34a107c37c33954a8781d0a6d60bc2f5c9d7766bddc978368ee426fcf0da662415fef8ab7bf3365c0c38aefc57692f5761d0acd6d32e4db779f6d2198392e1052c8565b21d0680cf68ddfabee041b1975ee7b1d67af919940b028850bc23b1cf1e6c1301da572df74e2e55d488a54bd39fba2ed2166b7e041bf3a4c7c769e31b88535894b29a768604fa95cc58749aae29c8a0cf1282d03f4c0247950f2a8c0b9f798fd68206e50ff9fe0591819ffae8a8f5fb0c339567b11231b21ced8c0141375257fca177e61047c913ff21b938a7486c3f0c728e0cc99ba248460446d0bbd8b29f871391201a919bb61ebbbe4608e92661b3b76a980a2c0a6ac544b1da2c7718725b32470f93644cd05783a4ac50c1db959828d471cf867396cc01efb282e17a32f45a716dfdd7328a9d441cad5e523937ab83f589d3d5a5ca47cfd49f3a436d6a33da946400486ca7fd94c5bf28a53be1905cab04466a1341fe02f4b596e99ee62c81708f29bb67dd3e351c1604e6bde4813b5f0f751ea85e67cc5fa576e8c445f9125cd67e1c06fd948c523a1723c774940439a7081169162c634c2faf2669762721030ec7e7a32f0fa92f253c93c510db598a8e2354dfd85ba10d98070ba945fd65c536a99f8646182383c7e107b7161a747a0a1ca55aabf88ea73d792c96b89bb1c96ad8ec53e1c0b2f107df846061c4a49ac66e98a4373920f6730a6421a41d63d8d5ac4e6007693b6825886d01113a9e8b8125d930fd6cc27594e088146857963cac8fbbee2ac36afe8a0cf7280987ddf79b9b48bba2d9addc13f8f1bc3d0b2f835c07e00ebb097deb90bd59a73793560c251dc3ea35243c9cc13499940d7d1684931acc4bddc67728f0f62df9c3f3c9f7bb0d082f379ee4d21fa752490c7ff66a0d867e1413c454ea595b3cbf507983f24bbd0d707c389905fcd93e56135fa8132f29e8a66c322cec03ed3eafcd369dc4713097639a0946c1ac1193d169ae7cbb52620c31967ec431ce508daf60d622962b77d25ab8d4996f739a20a4ee561201e73e19605e048f5c759ad475aedc55cee9988268b5906770e34c37172cc5705168d3684ee464072f6dcf6c2a8b2b38b7e571b6495478d52f9341f02e4ae02e1e31e01a3b0d6e1b7caaaeadf8f39691dde767641f5608a01ffb64c8dfe276e67287584b6af989527a14d7a05198a4555006a1a57ca2d1a114fec69d09a821ddc9a4102c2e589e1282d2a311f5eb960635df2814ec9332fc754df189a5304d3becb349d078f92d8a2caf66a24b2c681da8da3534db5f2dcb6965e49710b015102b4470465fef0dd728dd865680d20dd47c05a1127210c1ba2f0b21f0f4d8742a1f7f1f5bd42506c76907243fd60b34dce3c1434dd138b04c2da10736cc945967e827546370468b03ae36766e608bdf712812364d80b79a31101a2140d99eb60a6db2603c66a5cac7056e56ee902fee7a807ef2437d1154f1f679ae864c62ea67eac08f0ae2e753bca59dcf595a3f61a9eff95119e2ff6804d002c19027ebcf8c2c26edb62bc5e2cbca3c6f92df229f716cde4a2fee921effcb231be03e808b0e054342745d32809dfe91589daf90b78ec644ff82b84c8ef646d22fad73515ea981e07fa882378eeb9380d39a32571253c63e73f6d3bbab435b8abc5279e53cbe98963f9e629b2f35be144e8ec7b5808260a8d3ec2a648ba0b7e9061dde9d0672ccb4a7213725c35b8c90dfd757fa74d9dfd09e0c681571223bda6cc00f2abef4a431880ad72348ef8bfa67474f79d4de73d3c61c514f5795df2dca96c2233ef92227298fb18a2423c335ceb3f1a196ba18075b2c2a6af2300f938e4e2aaeb4a2a65f2ea62dff74de0b6bad9864172115deee526dd616046794de699d5f9224023375975c2309aa5c4271c3bd6d767b2cef46441c77b5880febe5ebfb28ec897cb0d0bb828e2321dbf5acd7041fe73651ee3db99628f4763eedf2013853e387d6d46ff00685bbf44a77c31bf6be7093fc7c5c52213ced790481534a787aca7279dcf65c2530c8f73f7e1a1179df2cc6f17d2e8f62e0067c15444afb0ad5534aca54a3958885ce8c2c9401b9222575a11787c989ede3eec08f2decad080200e69150c1d0d7227813c26fcb36cd010cacdf564b4e92150da1ccab3097e55c33e88da1f35d9764ce656f9ba5e19ca284b2747c88a3e73255cda8855173b2ec0efc6280ebe2ba66662a01359526fe4ca228cda5a474b2cac4a38fe9979d4918fba4278fbb8d98ea7f0e003b9ca8b4bde5516e7ce63516e91d537f2cd9e5938466d9f4e5a4fd7d79025e404d57d4102ebc2c4375007edaeed977a34a2313b7e43e48afadbd1a71f3888bb196e9d89deec6ac90315f9ea94182a251f9bb1a1fbdd226efe0a20094c08f42b600e703ee55df6f0febac8704e90b92a68dcd6c2a2c031fef78762a85634824d7a7c705279baf7d18bda6aff98ab2ef31b22fee2c2d765de8da991a1d5700123eaf5a6259ed911a29ddc5047dd4bcf9215638b18766db2c05e563638c4e04dd184fbc6871528592417e931b3b1138fc90eb9e0ae0c732735365bcecdb55b9a92c1d7edfeb2e456ca143a51b715ee016c139d8c09abd6cee475b5a1406626da9dd2f2ba782f5a1b05f4b3c0e668e786144031fe01f9d7c94adbebf9b5bc6d835a4408812bf03d236d734a5b3b393e031e36a4c4e5de39ffabb593a978ea7a5513aea162b6b15d5f41c18461c7b4066bf0253cfe19eb982fb05e6c207e17a4bd9437f30f4592398b01bec97d40e8407805c404351fee81051f3591d9bf9d295411f610d9db265876564f1d270c7e2be4bcb87155c652a9ebea1bb9a9531b8a191f3e3aa5a3d763cbf8d22c790b61e943fc5c878a8544a28cf804d0a721d7b4aaea58c18612ccaee0f60e14b9d96d2f07a4ecd667421ef2634a9ec3fa9931b02b96978cf6738f81d5112f59409ca8800d417a8b5d9d3dda4035be267f829f39122e2793fc8ac9054f165c3e89d686efa492adb5431037b19063dcd50162033653102bc0f6b4b18226ca33e7b23c49b098fa220e2500b4b55b38380e4d2e59c04bc270c65699a1206c45ca2275811e1e92d851497ce0b79ea0446915ba5b29dd5aab2329a024541863df9af354da83a160efa6edc086e9f5c4a344ce89c232cb9670dba754f462247781b861a470b93dca8046ab8216c0e9299e7c29a8f8141a74b194e67841ddbae3a3372abd5c9e4f219cbbb98dc43d3c34954ac5bda0893c9f9a8723e5b177e00de24a4179f4bc1530c75a2ca8a7d9177fa6039f988ca5254eab4fd27f5186115cb14dc2d6a1c558d5c72efc3da3d0b4e316f1382211e941d46d66437295d93cff5253222905b4f2847a45ba09d1387aa830787ade3c6646af83ea2e1599c921a9e62006c5655a60937cc12dc56fec098b5959ffff9a0dcac57f98935323e7ce9f4f98b5decae6e8b28a478e01e43f47bbe29314f0ee116a5b2ead058700e4aa05bfb02afe328ce93062995e5c0145262f16d45b90e67aa2f15a3d3806293d8c60b1eac259dc3263bce5cfa48262b6b3d91b70958f7c1fe3cb7874b11c3cec7b44efe5246280c103aeb3f958e7a6d73001010697f32d4994b5d8b527e2e00ab9520a5392fb09a8e9e739a6ccb14d6c134700772ef6dca8b0bb86d91ec63565e08be42ef8d306c5a3e7ffeb02b4a27a5820d9f558000c5f303341e4a51be831100918e6576ab1e4b0155a5db639f04fc7998673758864e728add8d7f60ecfe6559d247a76931de72f7e5bca433923ac98ee6bcbba0d8338e3a42b965ed05135895ead1fae953be92daf973cd2258d732449b5fc98228eceefdefe593fd0def86fcef7f791a8b8268ee75e32270d3a7877b0906f85da062edd14902db4c6e8f1dd31aefce762f145e77ab66c4d7db240b68727ec11ac1ddf8c5fb8051e8f0c0b69379955dd0030a627fca12037016d97463373e033c5246daf2753951787d6d0b195d4b3aa2346a9e52e40f0f79de606fb7ca67697ae29c5a7473c8555dba3275dd8772bd5b9125c3d745734b74d138653e0d4c8498ddedf506a7f2cc4325a9c745e61a73cbd554e7deb37f4dea46e9d9ddfe4dcac21fd2240fac0a67916e896dbbae1b774d0e9f98503358e452bdf350bb8e8e58d1d2c7a8f14aa66fc8dad8c9230e267ebd48bbdded2d31d0c092f31570ceb3dad5dc55f21ea9c72136818e5784c8f5dca2362e6a5a53857f89bbb0913f5e1682be5476474aca8b5f829724e83b1dda173ee37c1ada20fc0015f8d42b4efe839cd8a100811da3f300b7cf89d01fcd38d2e7d12e465e9ccde9a5fe1e8667681412f4f01eab1da6fcd30e72eb6b83b3a6470818e8d67252cac602a949441af5caf070cd1554d88c45b58c2b02091a1ef040e4b851b3b0d7dc0cbb64334afbb77e07bc272ca4df801c70a96188bbce33eb2cda0413aed1da8ddb1b9d71672538e74b88743ef013a70ef67de6c915e7bb291de178e727e1269b6875f9dd4bbb69af816355157c273c45f4c5f372649bf76d1df533b68eb2d002baee976e82903e05fcf1caca68509c0cff4e60d11fd3f4ab4e2516ec9a7aac07a9e54f4057be0e2eb1bf14cc3d4f92db6e1102c831616ad9cea679915fbf73369fda0c932b1a2bd69d5fb305a73c42ea7b4d1284cf3214bd6265bce074f7e86fcab6d9f91c3c12c618c300554274b8836acfe1d7f0c05c986a59585147a7a7949712fd6d572a61ff46bc114d3ee51ed80afa019c565c615e8259b5b3fe91268d3982e1d070f04fa34d938d128b01e21fc48010d98585f6c497beaabcb1461fa1cd8b85ded7a87742b0614b3d8d5951b2e5b94b9d35037b3a7fb5a9cf06aeff4dd891cf8405ba522cf5118e31e3b2b6c884bc03fa9cebd8fac24025b54c088a418b051e5f339eb6fa68afe9a5ce052dad0ce5b2a90452305a91802734739c9a83db2fe7aec5f7eaef1e5ad48b6244af71e62aac4fda6802ed71a974d1fa85a322b0383deb64f1ffeaa6ea99eca04466cbf1125cde97c96593d8e6a0114785d01a69505bc07966c27dc1deb9a1ba4447d5f9f44d3ca6e388ba6aa12d09086704f91b2f8a283cc529402e14bcf6007ca21708c9d2656560c6b56aef44ecf29cf24c18a9c5092e3322b8c1993d0f1223ed958e379a04c3ae360eeaad4e8630c027d7c7a20e28269d6b2e3141a8fd9e475466380f3167e5f8e25b5ffadcf04200ac9e69bccc4d50e36f24506231789d2cce450dc3232765dc87540ff8088511703348f9259b2f2ca2bdf59f6a9a933ef637070fdc94b28b03121dbe9ab073a638d8ed1f7cd914b0dddacdf134a38bfefd5752bb025e346c78ff3164b8a5a5fe373a633ba367ca160a88023512583838f6ae3e1b26ae606ba348065ef41100bdf725b168ea8c39cdc88b4d59cc6047a7bc87ee916042cbbba45a6364364a856e2d946a4c3eb410df28f80f826ff355608c972356ae6dd4c9a92ddd14fba6d81579a2c42e9cccfab8d1ca95cd781431d6c513d1524b6a02bb777a75e6134fdd646afe6ef62eaf974a6ecd1370fe066390e690a6b19d2d043d2f93b13628b641be6d72a1c001444c646387d7f7bfa559b025ab066d023e1df648fed3e3f1d77aa212f70c9344e9c7d3162da315d79ab3844cb1a1ed05d9f8587e46fb3dfa18926eadaa02e1f89a38d361489c5f22e8263f66f75cb94db649edbf7f139001c6d5ce825786763367c13d24b1e298f745b43624cd749b6c4bd2e0711228c445a1ba0ba00240a9324c767bba0646d84fc49edfeb7678be9a4acddd0d6d5db1d1f88d11c01ce2c6ce95af3c7c139a5df6f0a9977c4c0811d2df91ae4478005d5bcf750f88398da0febdfd93463e186e74d263983dac64063381ecfc8eec8e48986d6c75a50546f2144bc587a6c196baae2264320302ad0d1c815be83e5db76b0e4006ef515c10f88b78aca02bd5cf832c337b6fbc1754627ea0e4ec959dc6f8f1c9f7925182c0bd1d6a3bb67b4dbd370a48a8ed797e98d359414beb6ec9c34ee850b9891504d660ba31c9b0de90b0aa0323862c5ce41dbb8c02c24f0b1897e370f44207b8b6cd06454bbdc22691d12887c58071bcd1491715310c66376b2d6c8c5fb510ecd7d93662d3f3768167798d5a4f1b4ae95371fe97a918503469437058939864fec9be20ff59a7df70e62bc8da283ebb5a7b9a7a4fc43de0ad0b1b3010baf49b7f2b141bd6e6ba8789ba0df84e7124b4aa97be7f9545c51de686e9a5e769b08f52c68dcf7a90964fed2f3d6f6c5c1d884cff8eb1dd20d60295cfdbe57e5241ff21ca2886dfefe2020d2edd4eec746aca49e3a0f2ba5c8b0a01ba22fcf7ba8d3f5fe4a89e70c327ba0f4650d70aa7ff1e3d90089751ed6585b50dc98e229a594e3c2533dcd03e94a7cf6efe350b2be02ddc9880523421523eb30b3694644bb042ccdeefbe3db4bb70b8e0ed599e34869d6073c17970a8865df4e9a5548dd60f4b124d98f753d4553be6ec7ff43f4a71ccc4cc57c9fc915b5a47e9797e09ee3583d23e2ef2613e308c98a37118090df709b0abaf39c3b1664fd7cf30760cd2b0dd6593641698153139a22bfd402f4d00020d4f91fcc3903eb822580f4ce60256aabe6cd7ade5b7450ae3caef1e369dc666e93c530346786bf22ca8f4ceba73d21a7cc02a0cd8f99a5f6a5e17b3831ea1516da58f960bc5e9fd5afb0c71da03e4beadbea8342d5f46a1bf1ba4c07945a53386f769fe40ae0fd7d19faa2865f123c9d822ca1f5dbc08cb9ab06ef1a34bacac13a76954a336110c125a7867a80d9719389ea1baa65254dba22ac08dbee11848725828d7531f96964cc4f76d44c23631d2ec4753984586d1de87d9608660291f8e6cf2bb859bceb1b00d1fcceb7da57091b2be986ff6e5a097846dffe24b953d57db3d58c5697361e1d99ae6415e3b7431e26de9bea0e940439a8bae80591e444242c56b30c04e4d236e320fd0251521401254a8052e96fc6e525cfb9d8a1395a36a955345d54da4cda316fc2d87140fddf16e62adcb8a7b94cad448704fbd81b26ae916e555aa0e0fbc30baffc82ecc379122b8d0c58f5072c13b1535044a7fc8574a44561983b73111020d8f679a514cdd861915f99a4e0731a8b915cf2355e85c068e66643bb05aa9618e32f890c499c0e7cf559fc727d45c28711071dc6110b20d622268e632162d0eaca39b1de027f9e74fd14d1f564bf043ed624dc685bcb75b7ce9e26235c452afd1bd7c0c773e9e7af127183c591acbec02defdca35ded73bf541b7e945cacacae609a77992b908ff23a7bc418c3d55a3ca155352965bc030af6d167c1ce4d8c30943d05230a3f24665052fb33248288266f95ab09c1cd5bb897f2e2ffa4659e1497a0ff77fbc27c071b5db2b56b53d43ea10489b1dd1e805458ded7fd83eaa8b393db1c7db26a1372628ad38fc170f8539777a0d515f4577f29552d4a8ddc1966bf3d98b0287ed0cfbb317226f3d026c8e9d418111d9774b408320f1dd2bb682933a341ff787dc4c450c4c0d0b42f44e2b93f155947c85f4c6182a60d932633a5971df80664ca7c8fd4313ea318be87c74f06014069dbf692ac922e405c0a2926ebe544810d92e1c450233f3bccf43aa099e62f1c728850a5931daf3abe627bdb7a313d3cfd03847c75adcf676984078c6fb8838c55290ed19a3ae00c425dfdf2468763301efadf86d95693c19238a0fd8e6d90fb2631e835bd460e2cb64235a89ef09da418f874bf2626e3fa156538b63a08f7f84fd3d2e91b267e3bd5b3eda95d00ddef5d6b0c8c51c4ae9e19f46f451d559d8888701fd7f66186840e2610f94af98d2d6bbb25aaaaa08dde4cb0772b426a2dc8c79f2c15363a6f920f4582564dd1f7ac1b56edbf47b297eab88218f5d8026197caae35fc13b551d81671619d1784e46a2f0909e62173cd7e8cde914a32f1e142dcc752169967462069983abab7025be603c83448006e37a15b1cbbabc5ffb5d6ad7b77cfa7a340c1a5395b782e55d4fc4efec8c8dc0eed37168659958cd5baa028453e5647916509d27a007587f31ce30198fc9f2bcf3031de03339c14678a7727d7d9199969b4ad8f3b3179570758fd6375d6e880f28f60b5e1e3538b4ea527a16f65bb3841d5d2e1e93b0b55c142f839e97bcb1eabc0b477a22c1c31807b1bc9a9a64fd764b007f64cbd66f4f7a226e0eea532a5f7e9164a48800b67da997fa9ca9a5c2600205d3ad85abcb769c6ec95b6867206ea06b37b61e2d74a5f9fc602a51a9fb03609f047d0011eec5ed96dbe5ab3adcd80b28655a68a2cd55e84dd19b85497b6ae8adaf7c9696c566bc43dbc264f6b582fafcb54590f11957b6f3a69e437c068efbad70ef7909e9f9104eadfa8a33f7d1b6005d119286c75b64ab542d57ef8146633173b1b6b7a520faf2b8a410a8a7e28584d2c2a6de614c0f0266945132e6067051a9c6b820c9354205a8fe00f9282faab09fa49b13c6f5a3409d6af0a4d60b6d2ef64fb0e708a16e0db829716f054ebb7a974455693b0e0416429ddc3c681c9202968de024166a1a24708e803c72a643c0566647e25d9be4cce830b5a6c0148af595148eb8492cd5617565e1bd29d46167b6166d9cbc2a5aded5cb12ce7b2da8bde439c5e9ce3e7bed5b3bd04e75a389c8d946d768a1347e31a8767f0c0e2125b10368352515622671f78fe51b9d8af5613908cabf2bc34e618e3c96be15a6fe428c62237a75258c7fcc077dc68ee50c42f26429c775131d370346897b0e0ec15693650813eecb3d6d7b4023edc74b3ce706a3267f3c2bf29f77831edeb0d6635bd160b7703cfa6943ef5d228c62f7e0633aae616fcd9fcb9fe88b922e2c1b21b11ae4db050dbc09d52347833b8426a3c84d90ba351da2f647e974ed46ad2b0898eb41d6179d9e96a37d351a945d2f32e1588412e007eafe704055b91b95e56eeed10aef1a5291d2509f0e726e0bcf66949cb0e0b8779a4d034b642e8e7aec2b2ed895e86f8cf44bd6053ecf3960c55389edcca3186abb3bfebfe4300f3d11d5b5ac25cb32f535893cd77a405889a198b15abea0a946373b22b9f1b2dab97fdf3f956591717341127ef0aa7fe1b736f1351d34a9758c946de18cb765e2eaad67d53fa32bc7c5897673a182430ce5daffd982a68dcadd256d16adb73948b0144ac40aef8996fab06271dced685af4443fc041cf5f3503c058083d34e92ff0b728b85d89fa2999c3042429d4155103436296484c3e8084900d4b099e2eab0fc55dbc08f23ff45f4a45e2456e5195c8657017d24e1b09caa0df38f9faa82eadd5a30ac68d100312e594ea9b7c327cf9a1ac43f1ef62dcde829e47b6c618a6d48622113337253421a63fba583c9de05674d7ecdc9c0f180f2834008393cf3e236e117585b17c6e7595d795f27d3f3d05cf1878e12f73cac3c71b07ad36f03dfd8a20c4db16ebacdcd301b971491d350ba37fc6e6cb316ce52f95a8a339c8f9d08b23b03c0fc1eac8a63a191b0bb4d089ef88590020863b23843b277b4d6025bffad9f09e7fa7473dabecd322584e136755407713a9d9a4fa243031e007e3498580a8a5e3163717930d84d0bff27d9af60ffa6b88b8237d3188327d99fcb8848f48abb65fe1b909ed1bc098a1e30bbbddbb1eda6be02565db63118beeb2e2e7890b3cea082ab8652a95a49d62e4c899d231aad0719f0a7921e06502d6774fe6d04c2b501c7f94e05ed3704c024265d9eb0346413103e5f37b1a51fd4f476b54377dc69de5c449d34e7ad149b1a2de3a45117caa3e45bf40a80143b71412a7b3bb7fcf56641ffb21f68bb18a0286f960cc1cd8129c413acc062a13b53d5bcd0699808b7a972b33c921e6756f373b35e61ec25a820a994e3a89a4281e12f937a90db6fb1d5e9c94eca7f45de8fc46b2464be13dd3d260125edb0852cf226e7f08210d995240544628d09b32faf33c3204b319c61b0b84b7d18aaf70b666f1bf41c3e430e4f808ebab12e4744dece84efd4b0342b49851456e207a104d49a5ada44880db992db8f0e253245b0bc92b10d48d2dc4af4371fa383173e7730070ed29f1d7ad1a07f835eafe2859410b228944f528403f721c8d536433d6133bf385408c21dc76302307c98cad61917bcf2b8b86c62517098635c371e069065835025a2a7f428a1f81c8bcee61987bf0b66e727609f2e40a1744285e9b9adad1f630f97a6869489ad8e63e349876c6e55edcaa1d493e01b343d7f9274ee95ad17899980e9a0aa663d385e90d02391d9475635099c7ee0745164659bba03e1817ccd383b0441b8b3f3fc0a8f19d331a6f451d06ec7ab0732d0fa90e4116aeee24b3b49c94ae8a38d14c1fc1c1d3fdfc858cb0f1143f4ac9f0512d8b3fee14571458bf932672a6e3c0b0d9270954534ccf1aa83adff83a26855b470f80daa87c841018318f857edd4c77f85acafa2f56140cc823ed1b78b72939d4e757475c8dce70fbfb91dfc346d2691eec600a5f163c3e427c45dea0adc6750d808637c6a093d107d6a45f4969414d768790595c30b6103b57417058b936381f5f5a74ea388c8276cc3e352d6d39bf3dfa417395e8133f5ca39c74a0c26a527714cd82c53ee1d104a4b624c494c20fdbb8acdd758c55b0e682302ec0bf7a8dd843935bc5cc5be0bc23c96368da4c4b6e1932b472971696afc51f40a850715dc02e054ddaa7f4acc3dd342c919c842584a2bca0d4ffe531247816bca829c45f3c57a78310045170ea09d06a5998ebbde9565495f8d433a1952050b843c2fb9df225bda41f832f5dd7f9dca2df6c30275e836dfe1bc7e7384de0193ba88910ac0881606239bfe97ccf6ec2b3102da3d724ec847d620fb2cd951ee7a4033ceeb1c151f2c2479e194c5effe726694bbdf8950d54d6e00af7660bda043042dacb6180e5d538d76694e19aa991b38ef1f20e09887264f68c472193d51a93de06e598bc62834b42d8291d13e00abbc527ed5ed4f48daf022b300c63849f82fa05af7c60c169e219af8a8b815d18b501cd7701daadb4f6514c96cc209d1029c0a02c68fb8f8a64801790c2074e1b99f43e614a6847e859199e48a174c0ee190da8b3ca63bb07771f947e4267c4570e7eb3d4de4977be65bfccff255414309c0f1e1d94658a2dcd59ca2cfe6d95321927b7549b7ce76ad04c51c9c2d86df516886c052f787bb8320f7d8d68e0a56d6c69deb78eb86674bbd8086fe9bf61d531080c0672a9486370aa2a5d01cef3e7dd45e7bac385389dc90faf0342a881f83490a37cd941b12c844952e277326047810b46080b9e4be196aa4fc923eeee14f0c8def2ce9a788cff150cbf08a939151109e8db532f549a2c37ca0bcc732f5b25560d04ee63730efded81e7daef72555e1a15f48bc74f6c01f995d9616cb089f90399aee94712125349d1dea26c64efdfad445a130c5bcfe888fbe0b98b178e6d180f0680ad0e237d3500c26465edec60c0318b04815b6ac5c633f66ffb04ab58afd66d52ffa877748426d036844f36235bd08567839759392f84b479f6154bff1df105bc8ee8d601e01b1f4c75dda8ddd0bf64d77d333838eef98fac013154c2477f4e8c39141862f18b5e40a419ef0955afe51ca961e10fb2c9a899c6bab5da15d1cd31ad76178c64938e52044834d6b5cfceb15a23f64c67e0c81cac7645327cb8078a1c154d91f91fa0b791d0a33236a5db6c6410cae79cbd8f345019dcd651ae73fc6c70e036276bd865bcc739b33c932c0c20e4c9ece6a79c5164dbc3d0eb75fab5207d0f4fa50fffd4592eb1a3e2f3eab05969562f24fe63f86b4552ee51a28141c281773a60d66bf62f17e8b385a882dc38dcb1169a484273db79ca2569a6c104268226bb53ef3be1ba59b902a6670d3124ad7b5c3f34b0206f3ca5e511d6c441e4c9b31aab756f09fd4c0c355b93cc4fced555684facaf8216c4cdd64a470af4e0d351b029c98f41cb2151c10602a',
        salt = 'a2141b0a47af772d3db633bd6f3cb23a',
        labelError = 'Bad password!',
        isRememberEnabled = false,
        rememberDurationInDays = 0; // 0 means forever

    // constants
    const rememberPassphraseKey = 'staticrypt_passphrase',
        rememberExpirationKey = 'staticrypt_expiration';

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param  hashedPassphrase
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassphrase) {
        const result = await decode(encryptedMsg, hashedPassphrase, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        document.write(plainHTML);
        document.close();
        return true;
    }

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        localStorage.removeItem(rememberPassphraseKey);
        localStorage.removeItem(rememberExpirationKey);
    }

    /**
     * Clear storage if we are logging out
     *
     * @returns  - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        if (!isRememberEnabled) {
            return false;
        }

        // show the remember me checkbox
        document.getElementById('staticrypt-remember-label').classList.remove('hidden');

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassphrase = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassphrase) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPassphraseQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPassphraseFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassphrase = hashedPassphraseFragment || hashedPassphraseQuery;

        if (hashedPassphrase) {
            return decryptAndReplaceHtml(hashedPassphrase);
        }

        return false;
    }

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        let hasDecrypted = await decryptOnLoadFromUrl();

        if (!hasDecrypted) {
            hasDecrypted = await decryptOnLoadFromRememberMe();
        }

        // if we didn't decrypt anything, show the password prompt. Otherwise the content has already been replaced, no
        // need to do anything
        if (!hasDecrypted) {
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const passphrase = document.getElementById('staticrypt-password').value,
            shouldRememberPassphrase = document.getElementById('staticrypt-remember').checked;

        // decrypt and replace the whole page
        const hashedPassphrase = await cryptoEngine.hashPassphrase(passphrase, salt);
        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

        if (isDecryptionSuccessful) {
            // remember the hashedPassphrase and set its expiration if necessary
            if (isRememberEnabled && shouldRememberPassphrase) {
                window.localStorage.setItem(rememberPassphraseKey, hashedPassphrase);

                // set the expiration if the duration isn't 0 (meaning no expiration)
                if (rememberDurationInDays > 0) {
                    window.localStorage.setItem(
                        rememberExpirationKey,
                        (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                    );
                }
            }
        } else {
            alert(labelError);
        }
    });
</script>
</body>
</html>
