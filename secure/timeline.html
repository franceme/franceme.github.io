<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #4CAF50;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #43A047;
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #76b852; /* fallback for old browsers */
            background: -webkit-linear-gradient(right, #76b852, #8DC26F);
            background: -moz-linear-gradient(right, #76b852, #8DC26F);
            background: -o-linear-gradient(right, #76b852, #8DC26F);
            background: linear-gradient(to left, #76b852, #8DC26F);
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>




<script>
    // do not remove this comment, it is used to detect the version of the script
    // STATICRYPT_VERSION: async

    const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 *
 * Mirrors the API of CryptoJS.enc.Hex
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassphrase) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassphrase
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassphrase) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassphrase(passphrase, salt) {
    // we hash the passphrase in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassphrase = await hashLegacyRound(passphrase, salt);

    hashedPassphrase = await hashSecondRound(hashedPassphrase, salt);

    return hashThirdRound(hashedPassphrase, salt);
}
exports.hashPassphrase = hashPassphrase;

/**
 * This hashes the passphrase with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(passphrase, salt) {
    return pbkdf2(passphrase, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(passphrase, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(passphrase),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassphrase, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
    const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassphrase = await cryptoEngine.hashPassphrase(password, salt);


    const encrypted = await cryptoEngine.encrypt(msg, hashedPassphrase);
    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassphrase, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassphrase
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassphrase
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassphrase,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassphrase = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassphrase, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassphrase = originalPassphrase || hashedPassphrase;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassphrase = await cryptoEngine.hashThirdRound(originalPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassphrase = await cryptoEngine.hashSecondRound(originalPassphrase, salt);
        updatedHashedPassphrase = await cryptoEngine.hashThirdRound(updatedHashedPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassphrase),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
    const decode = codec.init(cryptoEngine).decode;

    // variables to be filled when generating the file
    const encryptedMsg = '659787011c8562de432b954706d1a3c97111c5cdc1160379fd00c5ab95484439d25b0b85012c60cb07cb4204d043e2cb8b5dc5c9e8253ab6abbd4fae5b3b5b05528419109f3211718bbd5a782bc2959d0271d231bfdffd50755c612ce5c729bb5d3ebb0951ec6aa6ff1dfd5251896a80d63117e586b3c128165dad90ebfb48d1cacf88fe980a21691a3c33ca84d82a03cfa82b44f99221981c5e48f863d7c4721d3464a38748c324f3ec5cbdb158c77890cce90f489c9f9814a1b2e260d8ffa1740e80c3005e8cec5a157f56380ac67594539132d50a23c2e01fb5ba0119aeda278a87e9b44b11988e786118ed7a239b04707365dcaae17e6b881236f9259ba647a790807228f73bcd372b7059122056bc66152c7c88e66ed8e1bc48c266b1f7b8f33b3578d96a054e2e3832a0204711fd91c874afb5f53f702524df9e19e04914e0c38c563b27d52a3aa0899d0975f27a3d5d4ad0eb71ee49886b879eb779a0b35a563ba90be4a9c4407a4b1aa8f2e5e4532ac7a0772b05bccea91ddc45293e607fcb94875fa5a4f9ce57515186b52c61af4c49e8e9b810e1f7c83f3d74a8e150116d5fc276dcfeb2ab48f7c8060ef957da43c8b31a6c5bdf7594698cc67f9283dc6cbc6058fa2597903aa8934a30107d05ccf4d1f5c04cdd8b5a6a1b73df6782a24ce2438f8630c63557fe3b41db89bf2f67285d3362fb9ce58eb24053075dcecc9136ae207736798ca57acbcaed55334ad91448b97e2e41c67bb895278ce175f3a8bd33622b4301d73c43500c682afcfa0ba69b4c404f7f2704248a96aed31ab130af3d9d99ad9312b68986347f3d468c1fecd09dc5bcfcfba9617e84002ac1854244e063d7b83dcc397bf17946cd7019205191a1c8578516e75eae1cf1969374e5bd37c5c43c60ee1c6694ca1e85fccca6ab7170debdb6134d6202408d4cd566897e5bbc4e23cbdcd50e45b2e153823e306422f20a4be54128c5e84363a7bdbfbdc65f841451ca966af46cce1bd551d332205b523f39c0b0ee9c33eeb47d5fdce58bea7792317e705689344ebfb92df9555adf74104c0b7440ac76e43f886311c5545ef1f8617f838852022d919e4294825b0eb4131c31a75e04403b645f17847ddf3688227b004e59c0c5f3d7b4b57c8792e3010452950328b2e9b429b6d612c0813f7e93ef908ac9accb4029147a779019ed5b95c53aeef9095b7820353644cd9f6f9e2278bb1e30f8a705101d88b557e85156d62a60987aab2c06d592037060c4929a93a0dc343328b2db0e22ab32b69e299fa89c83ace483ffa37185f80d7432c71e2d2d7c41157507c4319d4a4d6bec1fdf83ac33ab9299a1b791cbac472355075c792c26f1a297045e002e68fc11e613caa444c75e7ebd0131d8bc7b0289d0fc7def06d027d827dea1cf52f290cb812fbe979d261beb6e1a7c3d1dfd8cbb69bbb240d83d52d1c40fd9fec2f05be465ac870b4b94ee3abf5c23327e93c19d63f45b7b2c333ba1fba0762710df5316a92113e0e297b13693bf4ae715f5fed746f32d28e70eb1188e3fe381b166cf271d7ee5476c87a22efc9d4c5dc9c791a6f0adfaf924fc0b86170883ecb432ab86847ba13b3e67e541dca31ba6ab067b4d0c417cb320d8453b5e7ffabe98f2ff960e0cb0041a7b0ad0c85c3de01c5c471eb2b2744e21a9422f7d29251eb666d67c4e92afde2de2dad2b4c8c17960e529e2243044f22472c60aa0338a04b42ee5059ada3d76f66b697b31643fc0f11adb452e554486f9c531643638b367bc744711e4102aa3766550e3ebeafd035306fe764ecbdf3a8324374162a8924b74cee3c718516ebfbf873df72e1c06c5d67921ec577afb426f6e26f28a40bc17ac280f56f76fd9a9c3f6e8c80013161d5ca0109190cf069feb66fdb2e7cfa298a8e5f2f0a63b386ad49faa2ebe375559dde91c73e246e6c07c32ed719defa4fab518823477ec68c54940fb82c33cbdb39e405a2f61bd3bb82cd6f05a534943cf76e740838c1de9590a0ba76a7dd317bf4cd37ee5ab5bd878f3cad98e5aa47404a46a6f28aa5bbf2ec8e7063270d5ea0b0c418982712f407c878518dc379d16b0a32e17299de842ddeef5865d5a0a6020ba4336903c4bf1d13f3b2edb549eefc850902dc3438ac106dabb69ae31e782d3b31e71fb0272fe2028b1cfc1ff03e49e55f6246468d1895a657e1fa760d90bc73f579a734522f2dc0b69c2f6f5d6d01c82b244d58853da6b597340f020b4c88c381a5230512b6c9b170b3ae557eddefbc0ced410269f4410ee2c1adb92a3221ee445c66dbd28950e4b65c289f8cbcadb451bf4e1367f36ea4084ac4e5d6b5220a821f7eca915874503409cef53518a86265ff753958ac01fc3e9f682e071d228864e7eb2fcc4f01d3c11a236ecc4d54c08a51db0f1d1eeadfdd1c08470e16f806dc7ae8b79900135aaaad4819c166461dc5da0935dad648e808be86e7fb6c816dcc62d539c61ae1d77a6a8550c24a3ece8b049f8235443c34ea517a19977911a341c7e5aa449839c51291b60b13822161eb970ae1b3e072f0a6d34f82b17a5c52180431609283f7328a040cb1c0f24427f804e05ca77317583e5c4a5b139ff5154516c30c618837469f123debeeef0c7f02c4113955f7f603f0639914472d2d612f477db9cdc27f115bc5e4fe6bab2161d106c11cb03702546d9d52720af17b772c8f22be1c0639631eb65f8fd456e3fee177d754cdb06d13685a318081a926fdfae3e9b4593d1eeff35351c34456bdeb96c052dd31b64f0aba9e3b7ba1e10cfb982a9c9709613d0230312aeca56da8ec688eada48183e62a705e726fc2d6a0a79ae69d672e495dbb94e6d7ef5f7c37183dbafa961cf57722b8b4ac3671378820276055e63aa8195ce0c488910b8a579433c863a15064fb202e3c426aadf86e92736833d5547e112f09b6b8fcfd22c86263adaa237f74c4c7b7cbdd0c504ee74a8a8b8afa492a757d3c6cb879e280234981abbe880a47644fdd345d670a35165e038490a760030fa0ac437f9e0bd2ad21bde5ad8ec437ba2a5b04bdc3148343b54f28ebb1ed2b431202be1dad26fc7c6a81be4e03a69a598031352d06024d0ea11496447f9015fb2c7bc29298292a80e24c8b4aaaf9c0197c04373589a4c846d8cd5a086996132184ad2d7fa176f80df115a0af3fb8bb708b7a08608828918b647791b09436fc9313b389b16e82a4e4962b646aee528cf8cd1c126ca3a28c11cd58154a615ebcdc1e674695129e3a4c24052c77878f7fc75887f288d49d290c94f6964aeabfdc35c07f26915f9b7ae8d9fc70512f1a0fc5ef7de6d48ce7a7f0a76ecbc2a8fb23a41159095f84f503151384991ada46af078bcf0ab9a93264a4344870b944a1fefd1c5bf24d402a6abd942cd863ddeed4eed51c53d15b3e344563b60cc4937301d8e5362a16d7ecc3c39d155855f805f5dd4e48abbf6bc1f05c3302ea26c5ddcde2b70df52e6d4e8729a22643f3bd9563350bbcf842cbe614e4895ebd886f74bc5861f9b7a6b1024335167d573cc81fa23da1273b1af903768919a3f64a0e41e6c59fb531566f6c403716353ff08a2541106c0002c1cf3dfa22b477b1689e0cde9c9c9d6b83a1c8f9c8d53ac3f98bf982b85e0e4b07f828a806cfb752fe124aebfd548ceec401fd465022ced8142ba08662f196ef9a6b42de3d00bd42ed26ccf6b57b9da1e7e95753aa91a56dc297a4921485f8fe13d7fafa4360cec4886e8273ee5f842015218e52eda5e19bb4e09daaf4f817ace8a8121930e9dda3a32f472368b2792d6000bbc3b8dc1487b2024db4fd2375a2bf78acb7ecf771ae3569673a8421fa432643fac4fcdf5182593c1331489bee56c97ae5d0bb55a39db3cfdbd7438afa1c0658ba371b57b001340cedca68a1e12d45f7ae0661ff609d471394dd53fef5cc173d2f738aceed246ef76b112609f0046567951de004139b7096ef572c4d95d76820611bc46c9844fd6f03d4e59a087c2824652fdbe6b5ff64ef7bf74571f24195695bdcd2434f80bfbf868d67f74123426ac4166701d2fd005cf57ff56c72cca9b9fa8d3bb8c2a1d6d9a7bfcd2c45461734a15ad4551208229d5a65e462c2a555fac63ef2678557f30f943f444c59eaf80734e252e4904762d83fbb7e3d26e9151d90c0357779ca824e2accf17385f7675cf149e329cd28cc053522f99df81e3c2bb96c3d20de7f3b2b889641d7b7e223861a1034af4ad5186f82cb55684279d231e773e81d59b9812dee7442912f590389f2f9077be377cc617623ce8d95cdf9f700bba176c0a08c8acd8d623d63e865cecf37aae68f6fd3e2b68d03b8eb881a10a0b3412ff1aa265351df337dfa67c53d16f62892e3daa38c280435e245790ff0b72e980695d8d47b4a736371f29f157f8190e09d631a385a68f831938b3d384b3e060de13426b16b5126f529646cc5e3804ecb29fbe9580a9aa9e54bc05981a30e9cd6be8f99c628ddb76982c173008acd209a4bf6d4fe66da7f7132a97cc3a4a94a1af08a5bfb5766538f4e462231bf2f0820f34f7439b2da63b814a4624d3dc4872b2aad6c725528efac9c821875feb2ffe9f83415a14b3c8f8b6088540080cd176d4f56100219c9c368335a22de3a55b0e0a0aa66d14aa1a2895c6c4f2eb843a016f246cd5a7bd3ea0bb0ec3f7586876dfb71ebacf0829a10eda9c1194e3e3c17efe0287dd186a2b7c692c26cb9a21c926fe027c1107173380e0da25fcc95b864e9dd2e906380be6dc04709c67a1f85568f960702dddf00262dd8fa0a6a9c9aeb5d72970a2c8372db015638a9389a38ebbc40c18385e89bb9e6dac3dff9acae3a08ee2eb2f59bca7c89e797fb234eceafc45813e29d819b75f4268fbdd77192bbfcf0379f86a4ac5d1d2f08486ec7851fdde04055b42028ccedfe7e3ad08014e4bebfcb37b8c8092f081f663f3a21e49c4508541aca654d6db76253b085e97f0ff2ec4448444a85d1008ccc5bbb9c97065c8ef4ea322c9f19fd0542273631f39ea91bda5f033d7bc7195105a755390f677e37450a8a7fc5d08bae93c7ce3bb65954fd0ccfa56dc43cf519e30603a16a9137e9040667b432bef8b62e21de844ad741acde116e1d70bfcc1cf71faa449cb383b3499dd213beb564deaabd0876458876b0263452f180501a4be89695ec28c84a6c8af732eb6ceedf1ea11bed951477d6fef9b5fe9f85d4c24bd6da17c2b1baf5ad326c78e42710acaa544d2b0be1e8fb36ba0a0f4de46628c0685dd48f6d4cc4edc80cac6eca642ddd570846dabbd04c90322ac03e7c689526d5d3bdcdb50841ba957cfc5a5d6b6acb0310885c7a527f983372acc116d30cd18a38eb83acf29476c423b8831e96e4afba519e6fa170e50c233739114de932ab7bbda2a4ead2abd1b459943a00d563d1f4372ba6475a8437c3f35caecf8b7cf3a429af08c0120e768cf1761266053b3ddfd4eb69ee881a9000fa9aba306c59808588062aacea283e5f3177a813f541a318d0e104422f44d3eebe23dc1c55c1a506e1e3c881f082acefae56f5c69c0198a3a210392237e039d88442841f8de6297e2bbd29e3ac1f69128ea4d362cf4dbcdd45276d6c9e6fe8a3b15b62511386099740d62c3e800a5b5d6d607b4e6de5aa4a166531da4da9e0db472f6ceabc9f7ef38bc21d61065e9818d530cf227489d8e518f124b2f14d807d289472590969d46901f96b3926e14fcd72ab62bcf0292e8f344924581c1d96b308bab80901790d834bd87570e3573877ef9c15c0129bdc4efa91ea29b00c331b97d668e51fdce75b5f599ca6aca9856137a0ca55681e8c79c01fc2e69dd9b9c9460569930595cd74668436606d7e7ffb4af78a1feafd3c6497de4c57c8f704d83134ee3998c0f74225dffa83818d3c5c7dddcdaebd4bcdd4ba37dd434a5fa26d2094061cf00d45a7bfb316262a7a740ed9cd61e1d18de55fd2c4055946e018e04c5ef6e645dd8a999bd1cb058f448c254b8f996c98c8f3399f3047ed2cd6c4137d95eb0a6bcea1363e4f49bde4d74ea73da53bb05a41f88b5bd245dfcf58ec228e769cc1460eae350d595ca03dc1bca67812ca407bef110e9931e0a1d95e44355869193d742e2ea1628991edcdf867086946fe693431b4c438079cccb7afdde32aedda15b7879ff58650468524f46b846ffb00d619757ecb8586ee740facaf87248a0e750dc647839ec7e28de5a7bc175e89b9e6a05b3a841ea35ebdd072829cdb18b3c7db1b4c8f61f7fbdd7be4fc33dcc8a9d30207970dc8caff63ccd7e5e00d03418c1826f7e1c2a8de4928d32dee0e34376b07bc27176d141080d62a79aba1c09465758ab03a24ca49f919c963223e1628b45de61c455616dcd9d7b2bfa82e42957f2438fda401d9e09bbf089f1081b9e66b0b4840d855cbc2ef2fad29c970839678634e98e5fbdca6356b4b5537b31b25d1741633320403f630e0c2bcde0bbd8e2a18970043b7d3e8cfa7aa661c72bc18799e3fc04c50810a0970b3dddd36a671b4a68d7625c4ee1c3ecd5784b583b0e3020cd157a876036dc7d835cb98f3cafbd24182c522edb22213182f49147f361e43fc26865264c6187ab8114dd74e521cd7c5ce8ad4abc996c8167db92477df9a7cef825469d9779e7733e1e3496668c92dc2c009783443b5159c72b92521bf8cbde66b85cab16677b14ad60ec76d5451d5924fd541ec3e8958a438cc22874e2a625fc40d5efcea35072cce7d8f13170350465e7947fef22bad50503d8ef62cfd616e5cf8d7ac1cebbbd337806b19d207d4a50dd05c30dfb6992c457c6fc2d550d520124d22d12671f3bff2565f03fb6794cb53eaaa89d6578e0f4fd961c65c434165174fe2152d778847a258300491e3f94094581c83d4f5940ae2cccc9201393ef818556434e3b8a50b295f0b731f5516d1488cbd188c9b9c4dddada8c21eadf5b4334ec5877f6890d8f0b610c1d439d837d784f1149b996c4c388c9f1ea45681ca4abb09ccf95cf3a2a954880e67bd6befb14ded95f1dffbfab04d689b3dd288ae81ab6714b91453f315806f6aa1d1c6ef315ab8ad045a3a17ea3e54eddff2e0b12efaab3d9dfc1bb710b2d02ecfc2a4f7e3e012b24f0daf699cfd681ccdd6b28ad1d3a3f367ebc3b09886c83f21244d45eb50b0f39fe7bfd00b7e5b6e0b679d40de04a68153c2783df6096dee0d5cd093aefa04e4c13b02a7691ee52880275204aed04d5b423274d14f5ad2703cdd9ce0966a00071331cde7e4cd40b291855a14c5672f0fcfbcc525431a7a1f590929cb247cd709ac708b6b519827c61118dbc2169c8b18e3b448daae3e6a56061b4c58a78c7534d99f6a145685db62724fd1355972256b43e15962e6db89f0d75a063fd7d2808e0a1105d7330176434e336056295e5977388dd2d3e261229b00a7cc5b2036bfa68660f8b839fe7ffadb32c4d3828fa34c33535479d0c85921d93469c45092e5ef84d43fc5fbe6ceffca2281386608f50d88c0e954e8281ce04d8eecd84d9c0a6a34e24843e0595b8463f35f6b9e9fb314f1fb57b79c69cdc363e81c1de23bdede1552f73bf2665bf870e15db6b584701ebcf7b56a2adb46d5b5d39a6afd7a8ef61e9fcbb63d1ed41daaf17eefed26677324e59b6e01518a546d235f6c30b94ca0fe3c9092e7a6e92c98b8744cfb3caa90bc995d56fbc24b0b80d7911671ee8837b380c048d28144a47e1da6b2f4206b7e0c198c13dddbf8d3113bbbbce6b19759b1b082fbc1f9be5e08b0d73c9b19eda0e7ab2edb68009e2ab90c121c38ab9db7019747133d879219db488792f9675a0f02f82576acfdb697c2778bacfd00f82835dc28e6f42734e3bc0fab677e1956175e7d4cf74bd6963f0c2f3bc5850fd748bca1429637fce07ebb54f7a28eeb5d45454ec62d633752fd2864feec459a396076b7a959842f891f8618249f74391423820d6e6419551a0bf78c81a561a2540ea049607a58f1b9245dc3b08967a6cb65ee576ea5cd584294850781e4375f9d436e86967c51cae8df2d2df29c9bbbf521a997e9aa30137c8f5c367165892a092a8c5c50ab8329a53f2d74e32ad83e15f948663570f3b690c9a3b67d3d7ead153e61bddcec29e78b74c3cf4d38777f9257b7cf1944fc39b7a2c718880e6bc8931ce1a31ded571bdb2fc5bc0623a9257b8ad43f7514ae6b3a9c23425653e61ca269a330d2117557f2211a4096a472707fe35ed74042407fe257d2a3f2d186870a4ad1183c0ab29df5a23affba42d79023b3f995e689707008735a15c833b33ff782d08c3378d19d8af0efaf45d84f9fbc5d269fe1ce263de3e7f0f26dd690cd843932fc5645a8afb102caa7fe47921d22818b6a9c5639650ea5ab4d3d3bb07c01c7f17a6cfbd85bd83269f1e2cffccc290281c2908407955958f059474bfdd9578387772b80c2cc059a5e606285e6534c5df13c93a0fa4ef99a620a45a943fbb6dcfc9b0a1e22c755f873977ce63f688f472114718953d6614cce2223d99fca6a6d8c7cd29e54a3fb433994f40f05a667d3827a5ef27b7c8a68cbe102c0ca98e92f50e6245ff29aacd9f5a8bde032ee82e91e60c0cff6c472cf0322d80bbfb0113b11a5cc484032ca272382f36d70a409d90f4666e84d032af5512eee9b790d5d3fb0b2642e252ad08e957abf6365b663b997aa511a86f01210f940c12e250d1f3a7a11860de69f8eb1535f5988f654f691d36370402f7fbd5484e2efc40354b94ad5429e34f0d8e2e82d43ca781ff754a0c82b1987e7cd0f6f5dfd9af5a9a32e83ddc549366671b415a3120d5b40cb8550c46135ce2872689188d9d75476e9d22b592cfbaef7e29f1ad40249d2496ee4d95c431835a7c20d632a256a26d1e339a29e0ab9c556b4c71ce3ffae235f689453ae91a1043c94e20e8a5e73717d7efce7a09fec53ac60a9c373eabd471f8c1b88fa4563877d4ae9b871958de1e1f75ad46459dba1b532df2f2860f741cca45c0410ec969a5736d6bb075a62410ad645e0ee5e29e7d55585cdf99a8373efcdb4ea2c7a0c10a52a2c1193ea525b233c8d9ec591cac16b344364688fdc349f943147e561abaf37db7853e5664cc5b253cae2acb4991a61cfbe313ce9b7f8d4dcdbb9ec9b8a3fc75790e8f625b044309d3bf7f202b1ff86aa1ae60e087714ac0132c096917ee1b4e73eb53e572a3b67c27e14d25a4b914ee400698a56788ab182a8c8667754c27237b046c2cdf28a6d1b57cce2c14a84607c178daeda40730e635772bc8ff1ac6b80b94c14dd50fd167405c4e48a8858dc0f51286f6a623b5fa9439feecebcac10c51ce10fe2d8ba9d003e756527dbf1d7dac92fe6fb1ee0546df457bc3e0c85a327f111bebdf8782d7985e3858a6f5702f548d48552f5b6cf5489bc78c26d1eb06df7c825ccb26838a53e94a6853890fdef7429ae5d90240d8391f21a6330836f67292a725ab284cf72910a1f61d77079c9ed0892528510373692e5892cfc62a5e47c8ebc86b62563a32189abceaabf9fba0cf50d93a5946f45b1dfc756d29df009fd029b8173e967e1fd91c846757851239547436035f83b1c423bfdc8c96b1737d4da44614e90fb08eaaa695305bdbb7120da5f7e33ed957c47e8e2fc9f34a3ebb15606ee029790320cacc1de05e1c01d5bc83a3240e219ed486ea112a716162cf33f89be590148559fc95132e8bb2ba7958261b91c2bc57688a07ab958963e81d64f5a6c1468c76194d037a506334ff1d5271c9fd8f025f855f64d0798cc263a4c900e44d21bc733a1439e46a2a357ed41ea576d372c87bd7ee0289e93d85da4b703c3a80ae1775014ea90d8abc32800226565076aa69903d7e687b26cf57ebf2b333c7a62a413a51c9fe80763ac038a1e283df2bb70555c13cb60c47932e967e7f40eb873de6f08dd3f6db592d352d0df338d96994fe16ec5d5eddea390044919f2c1a7a1b765e8b14b13f5a24f4d884040774a48ee342744381b8284f219c262ca068cfef917276a70fce5f39969877e92d8b3bde1ddfb2b92dd6beebe7c5ec77fcc1a5af8c2928fbb627a03141d74b9e5af6e32b274bd9ac7ab79a2710c6c5641ad711b6cee711930763e7ed7a345f522b3d49996bf16301d359d47e1bcf39484a15f9430fce127f35c438a8af5ede77a81a7bf79db40c0e36bbe4ae6bb0e1a9084943dd2a1f13fd12fb195f459391d562ae5afa8d969170c60de484ca69f121fbd26f3848fcd57bca1a616d79b45526736554970b982254c10cfb97ee52da91c1b4a5e6063d4149a2da1bfd785895b437e2b6a6aad3a1d055346c41d6b4280f2bb964eb488762bbe2ceb6524fedf22b6c6380d3f657deb47334b656dde7027f18c6914723cb3ae357026cf9d5d35c92e492012398cfd6a0a6d90445d902f2d557853fcebf05009441ac182a459dd48116910745e0f8f7170d99fb8549c570bc90abce25ac3177cca1265acf488b928fb693f34b316ca527ef0afb3ce995f7804943d1654ec2feeb9180ae927aa2d491e6fa6dc2ae0754f6a0031c61533f5f68230138124c73daa1157f14cabd21b5c572cde943d68664e0a288dd3a48c571be33609c02f078995c3eb6cb8072ac6153363dcae626e170828807bb60a672a710a1fd7a1eb6f9170d388b18bfbbf23dffa62c61e9d7832dc5168e04003a9b8fb3f16d3f67169234e0e0968e79718ac905c0daf7891d19e8f88c53626ac15e2346c8581d9e3df97dbfb04b3aa3846b7ec59898f68d09416d14e7edf86ad429a8365d455983066cd5ba43f929de8e8721d0eb863c63414150ba966475ef466a9f1377a430512c78339272e026d587f961919bd1ea5135afa7d4b8cbfc1e2148913db758f5e457de2daa55db5f7a40c3526b83086839215d10f043a12cc2e144ab67d37a7615e4994b81e53db1f2d0d790e9c77549efe89ac19a5725672e7d95f796cae80382f69309d6783705082b997a07ebe6ab04b480c1321abd96da91e0f74771c263e2245c228f36e4176f0ce8e1318fed105b974d801a64309cb7e695d3f6dc0e489442ecb3b50ed78367fca9d227e06b1a01cb04a67d1076cfebb582f99f61b6459176fbba5daf57c31055d1d3dedaede756f138a67cf7953b69da23805b6090f77d06920efc43a233a36344c44cff8066941be21826bb805e21e1fe846b92f00566456bfcd086d59b9fc45aecd73bc88d8f1488b8dd6f3879182ff0575987ec7d716d0ae6bfd0581041a518ed6ba3edd7b414e1a734f0ca3e95c1d8482f52b5b290bf958b5cf70c1d22ef67d9415d5c6edf2fe9d17c1d24503fc9f277acfd50cdfaf73209d56dcb8c688b03315135f64b1e6b0a04237ffcb5c5279fde86b96373673a2bde58dbf91b3020b9eb9a3f28e4fa0b82442967d06ec5c3e2824ba6ca5d7314883eda825270e3d57743fad80cd8c60ecff2d32863ecfcb3fd12d52b42dbe86ce1f9a05d8f32981255049be553eba0c71755b830a4a7d4bd10666126d0383ec43ebdedef6cbad05838ea228c9b90efe072dd785a85b53beb6302696ee74326e114fcff61324bdfbe8eaf3e084d1dd32545085a52c475bbd2581cb9d9b076427f1883be8ad9a9d3c25dd2b6acb49242fe74a054d541d6cb2fd1dd125d7830c352f24c70144bfdb86204e5257a05b864a5006ccdaa15a9356b3f213df9d7bf74db90e62b1a1b557c9055785362b273609f19fb3aafe0af994ca7b80f481dfd498b836fecd7e232440cb8caa77c3ffd1022512939e13f6bb9aacfcfe2d39a91a93b04ae777bc1025a8de7c5bbfa1242277d32e7e832f07554c441283828646dd90f600b217c04c3cf76b1370da1633b86216923532193e90313e207ec5a7436386a9b05b0a48d0277731a288e846a01ff02c8e4475cb2c4f959e2d2661399f4a8b31c7649ae44ad171b3875eb8498dbd26e9cb289961d9c449682e69d4f5b8155f15dd6f3f6c9251011babd9eaf9c0df3254df402670cb38c91f560f94a19904ebb99e771e9d416668ef82f292cba3f3a390b07e715a9ab4704c5d153519e8594539b782ee8b99476a88b1eb9907072c2c4a7b2c04d730707e260afa3038cf1c7510983cc55a11e464f52470a248a423d7c7b25418099f65baac62d773c6405958acb27824c13464ca521f69394615386ea3482e2bce57421a84a29156e45b0099c75a71b502f9967b1054f7c86dd203d7d791c0f5843d176e0613e727746d7a077e5c25cb4ca3aafd183416412c3089238bbacd758d44d0fbe990d1a9b444ea37aa56f2be9e34cff0660c232d94607c98fd2a62c524b87b3b1baddb3655f04137224ed8fd4a1f09b67f3c7b80f6636d4f2c2cb73d36a5107ea0cc01cb632c8aa03cc7fbc4c43cb6f5f9a6d2f27aef18225ffabfa17b6ddde2b2d42e94ed217b31cc68a4fdf19ffd87f2233796b22d0e71d859e7b3a565d3662b361804fef2d3a6a25f7bdde7cfc5a3c8bc3c508763067fd3bc3e238136b9706e32c19a363c907f64dd753cfc8ec1efc0043ef2e38fcdf39878e9d625157670faa9d8c73f3e3a8e2664039adf76a22b99ccaf22773efb1e6a2ddc5cafc3688ab0ed9b4e996fbe9fa3a63bd1c70ab11fbb367ff83a5adc226bf2b945199fb4b3db68b7fe080cf91730f401af2da738813a4e778623e065473aa3f47ed9b92f8f692c7317cb1b092c5d8a53364d6f78f6e263f1b60d094c15e6240af6ab96a888f8e3f732f65a13bdbf79a21429b8907454f36be8cfe09d16201e59cc67cf7548d4365e564140ab959cf748feba21524a520284687a1597ef65e2ad6f82a2aebf9a1ec113df19c0e3b83ab761c5e405376c014e589c75537cefe922918d22d9f40828cd43beaa9fea45f061ea1e9bdc32067cc8273733eed8d4ba055f77bfd1ca8ee981e2b9e4db3946ebf1a36cac631d3648a4558ea49bfec53d34950eb11f41f8118ed59fde675a201e0c99fa12c9e4f7c311879f2a0a8eaa88480004ee8ab210f1237d8acbd695baf605648ad8152e71fdbe1c3c29e48d6e6be6b7a8e7d07635f8ace450fe0e6bc4c20d291add8e4e1b9baf52179c1c8b0dca0afc234c25a1a397d436287049c4dc870e88eb8f48c8706a45da7d9b8b72036714a927e6fb0d01a169e58976f734a3804323eef80dddfd5bd1c83b85b8973e54587686e9e40d978223384b523a8443dccbc038dab38c380b02c01104d63d12c56110f86eebcd105f25b7604aecf73bcd56b015426be4c81b895f5535fe289e1612ad2aeb6730ee1d1c2909637971de74212594da7ea50fa33d0b141a81809c86f52149d7a32d9d9d0142195604a88e060910bf6d1ff8986e798ef19deb9bf4ee88bd71b1afa01ef723b22de86a413f391f159e7d69ba35b79a38351af025ae03ea45fb7b939ade6ed09914024ff2a8f9374f6ff7dfd1559664cbb1bf3f578fba8deb273086563a9da499295e225a3f49fb770acd769faafb1a5eff9368f9a52f5eca480c7ad00890e228137870d3dc3bfd766ef811481ba3fbe0c4abdfc1d696ea2a615f9987215f4261d3e81c5b1c33126bc7878a643c58f4814a77c482bcc94eb51dfb48e3da91cf0aa423317461153673600e64a6d588155589a0e8ba4f7e64df3eb34e4f77109f1049fdcd6b66cfebe2e1f5585d698705adeb377a54224c90ef38b258c623a4576a2d432a1f1f2b07c2c253c6b7a636e58d27004faddc319aa80d644787b92d2fa2f57dad5818f7864b0b20124ee11dfd1e25e6ac5bb543626384bb2be995e2af6d7bd0b68150a24d0f936850031d98694a3aabb7dfba73346895c9676715b782bb1e048636cc817584f34effd638e99e5d3a12a28fa2e7947f0cbcbeb776e9b0faba381af1b0bf4e848ea71985ab32e57f4b8e57b8690fd68874939622067f31292c2a25ed079b79272d5b442cdadac3deb19abf1cdd8fc9ca7d68ab7a5f073f01bb4c5c5368582cc7f665b9ec0b2a5e94fdbd232296e57ef3026b6f3e9e0b3ac323923a299507814f5e197b35a2d7ac83d968214f9cc1215fbe98e85a77df51ac8efbc4f116c9d647313043579c86e7edad8436db747308776115b2921e51c684c381bdd72df2e35073fc7b5fce36987fdd45e7ae3a8435114d4276bbb7fa2172528a9d48435cdea19d81a9001cdeed527072b31475a021d60e637c7919048eeb3b5cedbabf638fb7dd6ba9286fa113a280e2ba41da34b9576cd183ec93ed1ee5768e5e9391dda2cd0873be9ff20f98ff83ca1fdbe180d0df8e44f3b1a552261b038890c404bec97f12133aa45a54d07848287686bc404988f911a4ed8f7cf927dd9a9d193754df75d9f62386bbfaabd1e652264601d93e1ed8c09b4373d31f3d1a5f850ff1dec1f4d1cfead8766240f29d59ed14c5ff04e81545bfc2271d0c7223fb5c1f623473894018233fb03420ca7448b3b12868e916904ea2d595650a6578cde0a74a88c8968ad7593263ccd18f025e331a1c3dcda21c1f5de3d4b4446603cac10cc89eb3e7b347019dd82b7a8aaa89d6ed08c5480d33fdb5f704bf5ac239a3d764e122c1eeb97cded57a4954ad45ca50aa397bff249b97f0b6223b59647bc4f6921eb3ce17f957b81515e796574df92fceae16596652bf7ad2c0b306fe2e1a0a1543b87e585503bcb41e20c98544c0a0b89f574eee6aa16fc7d27c382f3e125413ef91d64f8b3de17e7d535bba7b9753b630f67a341bbbf6c778b06f9eabc190e643a1b4a769d95150f9245311ca785c7bbd6ee9e857a3a608a24ba8f588bdae15c9324c43456eeadaf73998992978852aba363fd5e70f80c0a57e7ddc75bfb0538a9c9272517f0173db70fef2fabb7363a95d1a1364ddd7e25724a4cbff0d58dd57c234ecbe87e10266eef485186c25f5dc5d6b3e244fce90c7ec8eade06e902ed500022c6737a9e4b95f0bbcde56a994abe1a39ff418114d77058a49c3ac3fa6c6938c8e07b57f6442bde7a16ecd22c64e5917b2de151e89b7601585e4970cfe077ab5912ad06c9ca837a8bb45d71f8116f9a5b1bc8b150e390dcdfdb8c96f935ccacfb691be8b4d334684baa1f3444f561d791b035bb20f44e7b39137ec30ebbe84c496a94b38a40cc45b77f8b35e7dd69a8a34c985635fc07f1a623a890885e9fe79d43d7ee00d418a7e1178480b86d6c6f905a4aa681beb41c7cecc6d34d65ab21561521ace87763935a29476b2722c54ef69b888c0186ee80e8638e7140d9c9c31e469f96e0561a8c',
        salt = '9d8ec42d2e5eacb04e6d86abd17e86c6',
        labelError = 'Bad password!',
        isRememberEnabled = false,
        rememberDurationInDays = 0; // 0 means forever

    // constants
    const rememberPassphraseKey = 'staticrypt_passphrase',
        rememberExpirationKey = 'staticrypt_expiration';

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param  hashedPassphrase
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassphrase) {
        const result = await decode(encryptedMsg, hashedPassphrase, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        document.write(plainHTML);
        document.close();
        return true;
    }

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        localStorage.removeItem(rememberPassphraseKey);
        localStorage.removeItem(rememberExpirationKey);
    }

    /**
     * Clear storage if we are logging out
     *
     * @returns  - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        if (!isRememberEnabled) {
            return false;
        }

        // show the remember me checkbox
        document.getElementById('staticrypt-remember-label').classList.remove('hidden');

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassphrase = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassphrase) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPassphraseQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPassphraseFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassphrase = hashedPassphraseFragment || hashedPassphraseQuery;

        if (hashedPassphrase) {
            return decryptAndReplaceHtml(hashedPassphrase);
        }

        return false;
    }

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        let hasDecrypted = await decryptOnLoadFromUrl();

        if (!hasDecrypted) {
            hasDecrypted = await decryptOnLoadFromRememberMe();
        }

        // if we didn't decrypt anything, show the password prompt. Otherwise the content has already been replaced, no
        // need to do anything
        if (!hasDecrypted) {
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const passphrase = document.getElementById('staticrypt-password').value,
            shouldRememberPassphrase = document.getElementById('staticrypt-remember').checked;

        // decrypt and replace the whole page
        const hashedPassphrase = await cryptoEngine.hashPassphrase(passphrase, salt);
        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

        if (isDecryptionSuccessful) {
            // remember the hashedPassphrase and set its expiration if necessary
            if (isRememberEnabled && shouldRememberPassphrase) {
                window.localStorage.setItem(rememberPassphraseKey, hashedPassphrase);

                // set the expiration if the duration isn't 0 (meaning no expiration)
                if (rememberDurationInDays > 0) {
                    window.localStorage.setItem(
                        rememberExpirationKey,
                        (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                    );
                }
            }
        } else {
            alert(labelError);
        }
    });
</script>
</body>
</html>
