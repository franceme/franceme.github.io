<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #4CAF50;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #43A047;
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #76b852; /* fallback for old browsers */
            background: -webkit-linear-gradient(right, #76b852, #8DC26F);
            background: -moz-linear-gradient(right, #76b852, #8DC26F);
            background: -o-linear-gradient(right, #76b852, #8DC26F);
            background: linear-gradient(to left, #76b852, #8DC26F);
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>




<script>
    // do not remove this comment, it is used to detect the version of the script
    // STATICRYPT_VERSION: async

    const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 *
 * Mirrors the API of CryptoJS.enc.Hex
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassphrase) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassphrase
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassphrase) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassphrase(passphrase, salt) {
    // we hash the passphrase in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassphrase = await hashLegacyRound(passphrase, salt);

    hashedPassphrase = await hashSecondRound(hashedPassphrase, salt);

    return hashThirdRound(hashedPassphrase, salt);
}
exports.hashPassphrase = hashPassphrase;

/**
 * This hashes the passphrase with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(passphrase, salt) {
    return pbkdf2(passphrase, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(passphrase, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(passphrase),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassphrase, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
    const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassphrase = await cryptoEngine.hashPassphrase(password, salt);


    const encrypted = await cryptoEngine.encrypt(msg, hashedPassphrase);
    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassphrase, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassphrase
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassphrase
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassphrase,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassphrase = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassphrase, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassphrase = originalPassphrase || hashedPassphrase;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassphrase = await cryptoEngine.hashThirdRound(originalPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassphrase = await cryptoEngine.hashSecondRound(originalPassphrase, salt);
        updatedHashedPassphrase = await cryptoEngine.hashThirdRound(updatedHashedPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassphrase),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
    const decode = codec.init(cryptoEngine).decode;

    // variables to be filled when generating the file
    const encryptedMsg = '58bc03a318024054a4a4dcdd2f497585a417dd021ecc744790032f17a0dafbfd1451004b69634e9169269976ee6fb1a3cb9bf6905d6238ab13d79abe003bbf98c14951012663451f290714a1f8d49c2f20e2fa969e1e514105082b83932ded2fddc75535f79198aae5fe42e3fd5fefb10b3f47a478e660a6a3578212b642a2c5c3af9ebd8d356a68ca6a3cb14784b37f126a9a7bdd3234e513e27294181e5595aa33a3fb580238467b464d9b3ef934574d23eb7d273a39d37cbba4357c6943d1381e5ba9f0e501382810b0550e75d51563f2d55752bd78d5b572305ec4144656a86bc85063af48e7505021f1c77596a519b432f39873a737c94a6bf7929fbba6ed5384836627dd61bd0bbcab84882e20c8ff9aac02fda175882edfed80dae408276ad43ad77545c2a94a6d40e89b5f5abbc291c231ce2f299a04e430c29eb7bcca32d28a822b3ed9c9c063a5f679bb295b92a7c1c0ceb65a0a1649a2b4a422280f42b31ef00374d57d1dc98ce37c840619e3bc79689d836f168bd15e9ffc5fc7c9a33dfcb8f65a0f9885df021becfb3ee5764f1c33c0da8133433cc4fdd48cf770c68226ad7f027e439f348efe547febe3af93f4ba20a0d17d7f013d962bd1bc131753153192ca4cec11bd7be723c426a2bc3488817458bbc53afd916b04ddbf784f84a250464ed7ec9e82ae40f6eb3a5808199b4b5b0b3334ae231531c695df47af0ce600f2a6469907e2e01347ec8c412000259e302c9054945a631595c974ed1d5d11ef16fb315494a7d1f50d7a5a83a1d634d2afe1fe5871d63f3625764a03db292e5795485e16bdfdb73b26280d01220956c2772a7df361a85ff29fd6b7ef39fa07c550c5c7644a8df605cb820192552b3a86e344cb8d3f1af7385588ec97c954501cb7426173bc519a82a824345ca9040865655bb4e3f4b78632c264f6d8b473903094ccb97df2b15f87d9d6c60e9dfb904c291dece1ae3d617e9c40fc16e9f0564f52cbd598854133bb6a9c2205d38ff4e564eff647ed620c3270aa2b393a2a44a7b46d8908d9807fea47258f9d40bf16b02cd7f342efd9912d4e4e170c986e652fb926360c33e270eab0318d528ab5285964388f5628ff47a1f968d049e92a6f77d8c16e5d3bfb28237fed2ac28269d93f0259417cadc0aa0d07a7e54b9ca4b73e5db35930c5a5597085c9687c7e5799e506fdecab5658622b40410fbc4cd4924aac2ed7472325ad08ff3f3047d02b87e7dbe23d054ed826f7c3525a6dc3e40d0fe20ba2062c24c0f38967dc5bfe366416e220d3ba252df85a95e091df44b1be026105e83e97ccac8c764c74d3d7ba658322b3d6b5349c9ae14e56b5ce65a729228e9b718b2ebb09f92ca03e4fb270f0213ef1a0cbecf8fa6527a08c54a2dcef6790c580e84aa7c9463d5c45368e3cb498552e728f79a8c21f9cfd383ba7f86d36ea23a9d2fc528ae98abd650fc660cbd121125830177ad5e234fbb782573d3200e130d8f29d12c40cd64a18692efa6110bdb4b9ee9d3815dc5ce1e824517bd950002347de110f8979cc883bd836147f72eb4aa0f33c23c37a514382898195a5a66d218e2d08a3846fc180ca5db39647f2a5ba5121b83d45d8e3d03d7745bd5b3cde495a3a154b8f0e0a3a11711fe418f842dbe28798a2c3d81e63db172c68af30dbc532b8e3618700655136f34bbf671d37aed21569ada206e87a89342e8d5f2b25699745d518a1f7fe7057e1763bdcfd19940c39b0bd1c1383cf77950fca4e59b0803b65c4a8987fafb853d29d0a664811e92a830c1c28da663612f3f6918bfccc1d627fdbd009e211e9abf0455ceb74d85d40d9b00fe56a5461a028dfd351781731717193cb099570bfce4f7b4cc2233f98ec866e55df36b5d2ec98695577eba03f355af7c4029dfc4ede933f591120ce0755b97a008e7e189e23479350e63a28e34804013da06dc6888f8c36f6db2904327c0b1d0f82a51b45bc66388cd3c6b7334433620bb8bff746eeafd068feb8a007f59aef314e3b3b1fa10784ae3fedce157d3b63a41d8c3c6539995e6e62750e37f14d6fdf652b7de363737efdd1f3c512279c6bbd86fc6be659dd2b7da68f38428b9d690411572738367b410c1e6505e1478c61e1cbf7c2bb8737845e0a765035eef41ccd1b6ca44a7167d1f307dccb2cceeae11230d0284a44480ea584bdb28e7a320ea54f936d9b8f5fbabb62dfac230b370a8773c8c5f607ba54cae1802ab32801ae90844f7ecdca93a8548815b5b7c9bfd45cba024f79daa326857024e8b98620f4ae23e8532a081a7b4d7e43d861d516a7e82821d37181f67df9ff170779ecb9e7eee005f9b9a5628adc279be3417a1e6ebd2cc8fa2b28bceb214ae670885edf2c7f0c1c6a6592a1db6b4bf12a83a24393e2f2266cfa5b6cb2b64cc90325aec54d950a3bf034838bce6f05f9e773a609d680fb1f75a26a131b08261034fdf8560fdc195293dad567f2c5bcb0986905f5f52b7c910f6ea8c66e6b25e0ba1dbde0bce6ce68873472814ef8b781665645aeb7d7bde1cfb47abfa59c30b4a2af3e50125b630ea38161fa41fb767b0a93cbcf53a25855ac1f4b1de9d2cab81b1402b72151716bb78e95d5ff582aafc4853a18abccd9d3c56d5e947122783d499967c5e9f1a2493d4895ab1f0abb5ee486f3edb55dc90911285111b0f93e5952c7b9dd66e1907e1f341ed7781b21fe06d90935bfe16a55c505fc7677e0f3fac9a883768d49aa0e9453bbc7c007d25cfb01f768f70cb5fe5fa363098b49e7a53274276b19d5c45ca3328430edfbdd857d130b14fcfc630929b55898761c539dc0129ea719881154c67bbb6a8b5f512e881e28de143acf1016c9f04313183ce1d9572fb8802169263fe5b0f1106cf057f085c8008060f40dd6184ac9dced04b44c9e156aba18148e3ca11e1086b1734983a8c0b5de933eaeb6681dec1441d5a3a69b66ca920ff8f7674ca7f63a3ed6618eff332243ffa00146690a2764bd0711ef2e5cd0c61f75b8e801a20789769d93e3fbc77bfc12f61053a1adfa1314efda06ab353a9823bea432b871772ea34e69ced53ab12ac37a0a1682f83b27e90c74cd514fc58164d490f9e161f9c27c098b170644a63f9afcbca28d8e624e59ea90d90747d7fac27d215c56f5ec33199341a64c0c9ed450717dc4a8907c8f3c4d1f5008cc28a43661bea51a51f97263b988ae7232204bb1da63f626833791cce1758afefff29c8083a85c73fa39265249a08d7e3579c48c442cc97b800638898d41977395560847dc4f19c1d6f29dfa605ef05c2f2ae09906cdd554dfa9b1024cc854b3c85c1aa05a0e64ac37b7c3a0e0e50b3c3312cb67ef0aa023082f4503530b66a8ec4f3e44be0c1abdc52275d10efb70dfad26b93f0e0853fb1baf3274c19e5c8febcc57da6aeb329beaba217f6b99c0331947b101f833c6cfae81e5394660864ffb55ad3c1ecf1a6a61724023cb9838c5f9678952d5412ab5ec1e0eacc75365e7910e0cab307f4e598e786c6531e94f63ff6c4461c0be31c730ad7f62d2bf78d9fab3e9fdbc73c4fb3b2870d1f5471fae6e919d0963bdfcd750635c28b7ac3bcc1eabd35d8f4f7ede2e1fad052f2e2a12dbbf38f05756ab1d1a43c0d100dd1cb9013c6a96dbe94a80fc4bf4d278f59d96da22c355e2648d7b5f5bbeea1eb6c1516609f6afe7cb0c84a3cc0d7e53b4cbc1279cf0c64ce7a62573c4f60c6e52cb39670c1b0552d778c2c88cf98c74aecc8e6fc1f003c8dffecf61a925ece3e4f4929fee381f684fd277caefc57c6bc61d0aca116cd00231a91dfbe16ef3760520ee5074c87ebce9ff70e496c68d42f734531005bedb581f2d9676a2280d4b2928ef9f6dab9e5371017a02a20375d74320ffda5d5b7078be399ffbc54541d6685f7b538f4f96c83fa359b43f22af1fcd3793cc55106ceb506a90cc0e76bba0efb9070adb3c98084d9ae0b3df8447396891dc03dfd1d6d8d920b5bfed2ae997adbd4a51aac4667829dfdb397e903be6da4515235e0a18398a62ef84e8367cca629608eebe852f027b2ae73ecfb4ca28eb806bb03f4cd26f6167c788ea8de862531c56b81e653a94d64ba135ad3e8ba329e4557b3a2f169694418e34868b23edea9fd9f1ee9eed993e1082a914fab8ee5b42c54244c174a1466cf366c6a03b7b43e64ef99cf572831f980b747bcb22d29a840cf6b2aa9e837410ea495eec692641fd97f994fd800207d77dc4cc10a6ab5ac4ddb102d6f88c8870bba7c8a482eae51be4210b3a01935695245de9cefc6e7c970b9d0f9daa0c9bfc67aacca768b219abdf26c262046ef2d045bdebefa4881abee2a47268b38ced49b157cc505ef7228a5e09baaa9e776527b41b2ac5741db5751ea97b5b10c56379dffe7e20044a3e75e5d088967e74db5e7f0df95841dbeec3dc15d151091af361bfe4f08b6b4502e266c558e19b4de264b13adfa7fc5c4ceaa9a4834bc60ecdb8a95b4b62c74c723a3f1c489b793efd7e62ba85f4cc6e89b202a68173351f938e68f8b1f6ff7d7462ead446cda284c80022351acaa529c82753f70beb4cc6a9e96204c39aa477acecce292c285d930e86b3c0682e10baa5ba64c5297fd3da2df7a61cec15954c56606491b77aca06a5e626d50997045b4faa91bc2b1603933978c8357def537bdeb490387a3668148d7a560eceb7f90fb71beeb862ff81240ce9d9fcab70c9f93e3e5b9f5c0e7584acd668670df9c54f0ad7738ff193498760c2cdea9821526fd4959d5af9005d586a2106edf26cb2fe3cea2eeff8b4db33ebf5e95e11a9469cc257eacaf8fe048075af02f1e89d7c8cd87b9a7620845f1322b91fbc9f1b198487460fbecef5896aab4ac32d053e9e03d14cff5f0c89efdd77f626a053e026f38dcd7fb13e3a01111cb078be3400a75ed307f31e4891eed38cd908ed74090173dd27fbd275210cfa7f070b8d28a564243a0bddff8a4fb189f49d914eec104a1399966f11bd9a01ecdfc498e0184c36e612f3b5183d1232c13d85c3ef024485866021b8f6049ee5e59943eca7f69015000fe6efc01edfb2afc3a734a389781bec55318835017890871b3f04456e7cba0ecd658932d9a507adbaff048e6cd3c852ed32f44b39a83d25b4d4d0904306f2f4564179327f6142bcdbb2303be7b2ca1d91b7315cdcbe67556b400a239d424a2ee0f18fee8adea6bf5842a145e4189cff59e69f8e671e7e445cfedee4d319eec9191790293f862cb995fd75174179a8e55146cd42f4bc0cdb7f9c3874d88dec11547b4e44382f48889b89a70937ca0d1e58da4a7f84dbafc75c17194b6664f3c44c63fb89d1ea9a8387e8b2a67bea64623cdeb17056271a45f35ebe93f72c7e2c36f4d382c7d989018ab922f1cf215d3b2b40b41cea902bcea9c81a080892b729fd0a5638f96574c80ab25450ca2191f1bc94de4bec4f91c7de2703c1136a2a48107ad541e0195c5808e8efe9f0491dfd81aa0b42df1288d346facf3e78e73631580eb24aa8cec625a50fe288e14f16fd7ebff497e5521c4497de08c5e4a32b0d59c0f236f3f896edfc6dde39b36a6bd1dff09431c7e3f5e9c6b081c64342eb0f2ed122c2232bb287a0814c0cc0029cce22c4e1f228706bb38d9b34f09f6312a9d29baf69f0fe54ef4a38cd3777bd48f2316303d56bd57ce8c37271208dbe050738140385cf8cfdb1200c5ef4ddb02f83af9d597bd8a5eba03e651638ff63d04fed51ce7a8b35a1a31016c3a55d8b558f855beb2ed82ac9ac200105ff31b316ab134e53c2ef38f9c09601b5c980c6e84be6a70c8ae6b876bc2f3c56e88baf513c61e577d46753f3e72623453e90729dbefa611821efb028171a17f7be330b33d43ce76a46feffb7a65b5685407d6cd9481ea7bc30288000f6e1858930f05d0985ebdbbcfa939523d332f315ca7da33264fcccfbdcf5d40be024872a8fced263924324ae873acad49eaec1b313fa5e8141a59bbd3661240bb816e8eb800aae8e19684518e2358a77e8e3bd464b6e7f07267f6171c0d78f5bdde78f832e65e3b661a4784b71fcf06c4069cc38a9355c981283709b02dc71d3c18f037f3451a7cce09d727a8c2f80f401adddf103484355414e22310f3c3d74607871e23c2ffb7f2671e4429c6b4a506470b852632d6346e6c1c68e07624cd024297701acb4054dfaec6d466f8990de3953a58c767b00b50f5fe0f9503a704eda797f10ac17af1334120fae69499bcdaff1266affbd05e6bbd46b6d019ab5244fbdf33e5adc2996a9915ab011ca66221603bdc2af08cf579124348864f25c5bc9926f5d0293357c3b06899b20040766f4c73718e6259548448d044f4bfee78c4262d198c5f44c1c87066bec80ea4beff0ea99ac2d503bbb6aa80678575c41c937f8c6fb477465c1e9aa04487fef7608633c9322cf4260d14feb8fbb399c4a060986568b9c09b945d2f91ed88712c4e4c4d077f2bee6005e9ce8fb9157140a893ed32f86ef9d9c889ff915400e232db0b1be8d9ae2ed733d730dd4e0e2176e18f4cda3c98ffbf9b0f2f745a55c9af56f83932a26d2c95a22108c75b8016e354e4a11cde07419090cabe3beec580a0f2031f814eb2478dbbfd2a8d2db3264f85b3f20504ed0d0a004d6eccc03263ce9ede6dbc1d8641d373c2e6faec07b45521cb05aebfa1c1c3d5342733d518287336545601630af3562fa0b120b287cff47c2304cfa6cb580db927fe7791f7fa13cc58fc4d5adc1bccda4c683250624e1931efa2677daeef9524990ef9fe6cd50f7dd20b19adda490e7b35ca20ecc15c64b7e7582d5495073e00e20ac5f2dabcfe238ae0ae99ffdb872aabaca67f8a017b7b2e6ad361e80db787b00dcd2c39034d79dc0a8490e4899e866991ee392397511247bdf7e7c965317178c4a06790b188201cbcecd6ca57f534494b99eba2b7189d3187f73f918af4c6563acd3b9a10eb8d9daba4278e6b155f637cf8df3de07e30d5c9c1f3c4f04e78b11e8422b20fc9dd6f7580af80c22e5e1a028c55ad44034501054807037fcd1f5def0010d93f80e88a2701ed2c6e9d5792712c06c79a6dae4a56a4ef945743808dc9495759ac939e13586acaf7abe84ff1074266528f6ba81ed6dee4b03983122f2c91fd71a58e687810d0ba83608189305f11a749e9a6ff08d48bcdd9dfcace3ad06407856532b88e72dc2d47ad7ea7e642c4c0d080e83269c02d8251dc960f10603be2ea5e39e6540746d92dcb608e3dd2d267ad733fbf8c657a8c82c81bca945e69f7b8cf6ebae236dd3331307cb82f2f9c7321eaf23eef855a107e934c03445c521d1c8fc36a137d8c0505c24f2f686e0ba1168c9810fd8846270a5d6bbd0d08fa39abcd675430a66a45e3468514c0ba0a780da9bfb86756bbfffb73fed11590ec606a2bed7834c85853ce275f0a932962ff73cedb9c2e01e4fbb1a68232270ad0a55f314655b9f7e091af9ac480a409ce72106bf866e9491dc0f29d9feb1d28b74dd7cbc41efe71d779f0ecde8a5845c425085e228e93fad6a007ddefcadad609456012d5a9cf73700ec7945681889593f0d93ddc070bb909b064422c88e22242360d082a6fe31cba75f7c8aafa9d9ae8d0ae41457932c01082514a480f9c44df2a08f9ccf2d76f925ae601e9da7008a4fc87074ddff1b88ef5812395c0a00283464d08ec9d9d075c29c3354efbe7d0fd4c40f96e0629353f58eed5ca04e55de056780d3126f7bbb8dbda0b6e78913f6ed685a6c95cd4d726e1804f1274d90cccf716af195abe574c8e41141762718bc97c15eaf1f91304100cf12eb0c71fadfa2961bc353958f16af88c51bbcc9a780435910e19d71d097543dc4',
        salt = 'b1fe441acf8a0c37bb46dd5c6f672819',
        labelError = 'Bad password!',
        isRememberEnabled = false,
        rememberDurationInDays = 0; // 0 means forever

    // constants
    const rememberPassphraseKey = 'staticrypt_passphrase',
        rememberExpirationKey = 'staticrypt_expiration';

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param  hashedPassphrase
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassphrase) {
        const result = await decode(encryptedMsg, hashedPassphrase, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        document.write(plainHTML);
        document.close();
        return true;
    }

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        localStorage.removeItem(rememberPassphraseKey);
        localStorage.removeItem(rememberExpirationKey);
    }

    /**
     * Clear storage if we are logging out
     *
     * @returns  - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        if (!isRememberEnabled) {
            return false;
        }

        // show the remember me checkbox
        document.getElementById('staticrypt-remember-label').classList.remove('hidden');

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassphrase = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassphrase) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPassphraseQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPassphraseFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassphrase = hashedPassphraseFragment || hashedPassphraseQuery;

        if (hashedPassphrase) {
            return decryptAndReplaceHtml(hashedPassphrase);
        }

        return false;
    }

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        let hasDecrypted = await decryptOnLoadFromUrl();

        if (!hasDecrypted) {
            hasDecrypted = await decryptOnLoadFromRememberMe();
        }

        // if we didn't decrypt anything, show the password prompt. Otherwise the content has already been replaced, no
        // need to do anything
        if (!hasDecrypted) {
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const passphrase = document.getElementById('staticrypt-password').value,
            shouldRememberPassphrase = document.getElementById('staticrypt-remember').checked;

        // decrypt and replace the whole page
        const hashedPassphrase = await cryptoEngine.hashPassphrase(passphrase, salt);
        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

        if (isDecryptionSuccessful) {
            // remember the hashedPassphrase and set its expiration if necessary
            if (isRememberEnabled && shouldRememberPassphrase) {
                window.localStorage.setItem(rememberPassphraseKey, hashedPassphrase);

                // set the expiration if the duration isn't 0 (meaning no expiration)
                if (rememberDurationInDays > 0) {
                    window.localStorage.setItem(
                        rememberExpirationKey,
                        (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                    );
                }
            }
        } else {
            alert(labelError);
        }
    });
</script>
</body>
</html>
