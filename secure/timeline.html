<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #4CAF50;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #43A047;
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #76b852; /* fallback for old browsers */
            background: -webkit-linear-gradient(right, #76b852, #8DC26F);
            background: -moz-linear-gradient(right, #76b852, #8DC26F);
            background: -o-linear-gradient(right, #76b852, #8DC26F);
            background: linear-gradient(to left, #76b852, #8DC26F);
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>




<script>
    // do not remove this comment, it is used to detect the version of the script
    // STATICRYPT_VERSION: async

    const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 *
 * Mirrors the API of CryptoJS.enc.Hex
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassphrase) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassphrase
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassphrase) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassphrase(passphrase, salt) {
    // we hash the passphrase in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassphrase = await hashLegacyRound(passphrase, salt);

    hashedPassphrase = await hashSecondRound(hashedPassphrase, salt);

    return hashThirdRound(hashedPassphrase, salt);
}
exports.hashPassphrase = hashPassphrase;

/**
 * This hashes the passphrase with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(passphrase, salt) {
    return pbkdf2(passphrase, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(passphrase, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(passphrase),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassphrase, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
    const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassphrase = await cryptoEngine.hashPassphrase(password, salt);


    const encrypted = await cryptoEngine.encrypt(msg, hashedPassphrase);
    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassphrase, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassphrase
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassphrase
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassphrase,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassphrase = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassphrase, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassphrase = originalPassphrase || hashedPassphrase;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassphrase = await cryptoEngine.hashThirdRound(originalPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassphrase = await cryptoEngine.hashSecondRound(originalPassphrase, salt);
        updatedHashedPassphrase = await cryptoEngine.hashThirdRound(updatedHashedPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassphrase),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
    const decode = codec.init(cryptoEngine).decode;

    // variables to be filled when generating the file
    const encryptedMsg = '439a9f2e22a964534df9573c442f33312f9723ef4f627b225f105d69a37efb321ee8120aebf2d0acb73ebeb51e793599f9593a0b57d398cb6ea7d374d617f5c7f4786fdc0eecadd26434a049243036918b33bd63e00e894da45e8f1c5c4cdb7e69575b22c59b93bc6e739aeaee20d4008b1e0055ceb7cec205e47c829c3bcc484f0b4aecfdb39330cfc81f7c6c2b4416e0a88730e6e2686cebf91d845601acf78838abfc18b7731e99013f50c8af16766357543e454b45d139498007fa4d86f7ac6546a586b124aa6b0483227c6e97b4a611b263324cbabb215bc531aeb5062b585e7b598d79f0b375fff2d8e279505646eabebc63c310283b5451cbb052a1ca1eaa8d12d7c22b8ad02edf52a98a4ade5fca2da014f00b585c3c623ceea76dd021c9c094be1a992b5f2066bd1ac1cbc6f215110486aa9eabcfec1a74b2e0111b46a0ddc7ed1f1d4a8a27af725e175aa36f2834deeaba3efb0c12d84c1d7f955d46bad2dfa8e26ba327cc99249b21fa3f08cd3ee4d18e540395da2ca1a4a9beab763f402db060a1eef0694f81974caf3c15ec28d80a1f417517d09f1e861ee9df8a63f95927f394701dc6fe160a3906f8fb44bcaa114f18c5dabb63fafb5fe3ca2227f3c40e02297a0689d8e1b22cf4bc8a020178fae05133913647f039e9f6c5646bf846cf39e200ae3b1e20de641837405fe23da5dfad2f8584d264955ef957b9fc27e7b157e650a98d1b5f88cf555b3e1f6bfcc0392c87643e3554e44e06c81858658a3f9e02cf499253632e42b03eb860ea19424e03da3b9dbc2e9be77494b866c991bee28f92822d280a92293cb4bcd97057cd8b5cbea663b04fe487e7cf9abf63b7c525aa62c50cfd36301ad2fc557e9794428674b51f46fdeaf08add837ad607d50c565fb90de691181624259cc45edbdf47d996ef92b0152f3add44631072a48883a439c0a02301590c575303cf0066dfbf8585da792143678fd64d1c5d66f0c3ef22095cf00e91654aaad708b2d4c2877400c48c457809cc043b922575a296f02b5ca028badf48e11a088e0685c7a216e4ceadd262cdb3400d8209935ab1d9370c11ade2155f9a1181a6f6712429cb952d3570d77c8b81e464b60311b05778046628e3b77b6ea160e30254edb17c53d12c58b8d061a2fc4fc1915bd78fbfd7065bc721f87c2089d1099a79ab14abec9c1e1f15bb1197bfd2089ab0fd6c77591478e2fe9309f2e83c90fcd40f3a963be4e26e9dc485729387db79615acc94a9fc1f55f80c8287a9462dcd0fc13222eb35f6e933089d220efa41f11830eb781abdc28e92d80de657add1a29fd3f98e114c31821ec7b6b045b6fd0a34552686b444b1ce9862ceda11077ae7244accaec7194d96e2f848bacd064c8a3750907b9094bf78066f251922e2bd6d26686f3e0824b95d555e93cfdcc02a28f9d7b2031b1f2b24e33490b3309d8c975dd0ad89c0b3ddbf38cce3af7a2d2de87950a542108b8be29117df14582f43f9a5b54665dd9a4cebc3465eccea42e1b39727aa7a3d297fccb5f77b7b9152ab2663171fd5fa0f3a3e9bc86c8df9990c9927189ad50262395332905952739b68ea71a79290b7104eb9fc70d2b451c3aba09e6f83396be8176376246ad2d7e7b155485da1322ceb94974d91c0eece331b2691b5d7e97f6b4ce9ef8dd027d45d75d6144eb391eef7a0c7f2b92ef827f02208d67ace959ee6a319200117542c6756a33cede49e3ed8d358a682960f08b2304052d268a17273bf0dfc75b282d106bd1939d146a28ba8afe3df7f70ffd8b52e945d97c08a332e7fe94d95e6c04d47b48112375554e1ff46b31b4978e5fa02083d33c9a5d31dedc83dcbc593aebd49a07087d4b17509e313bb8821bb917f7a6f884e652235af2ac00c57d8105fbb5ddcf00e2269338383f506b8f4f5b3b3429968432d971599a55ac65a40ffafabe07506c7e797b79a60f9379a3ff7ba56aec02ac90dcec8db6d7e1ae08853531d13b2961db7e70a1884b436b86f50909c52a50082b88eec83b07ffeac163b07a6834475bd8fb8bbc1f203642514ec84b2e1f4de4bc0415757e026493f487709f3c79acab16d6cf63cdb169ec0588d54f4177265eaae24ad9f8196bc24ebba9e7138c58d5b12bb3efd68b7b8d71778eb0f121e188d02ff7381e5213d7622cdb52de22ec89684f6b9c282a47267a21b134e08697eace2b9ef18b78e4878679853c7c09d6a4db9527abbd85996547953acbce33a35111383756ce7b54dba80c632ce52788b46be7442234c6704f56402948e79dbea9ef53e39bd1d5b836d250c0751e5d56389928cdc35372c930367a14fb767f603822977377c263771b826d1cb5f76301e84e81a242f5507b5c2f316c5b6a7a1b21810916031a54fc157861d317f60f522065f45100685ceba765289755990296a6e2da6637d7bbec5a19651a7586bbaf974e85bcaf063d741d367511956ca8f8a5cb807b65f0b11640ba2f0c4ddebf44aa2c9a63b4e9a650b9c57d6ad1bbcb72b6d3339ff1d79cc79aa76e01e800c4b02eec9d10ffc0c1e46e0f0b782c08a59dd5c8efb901479e73cfed4b39951d954fc9dac39f6887c93288f7184c4ef8931ae55057d5962f6b361a458296f33916d23b1ff56c99b3b1e5ad66efb9f7f3ac0c7a476a3da4ab1be34dfe0cb87ae719831864faf554905cd6b60e708ab4ee66ce75856e6fa57f98c4339ac3cdfdc181fb53703ef9ae6d7b072c720392c11e3c1bc5c1a435dc93b1e0cbf2892d18038c648d38b58bde03d06e7c1bad51b4b088f8a15ef3d1efbf61ec520293884eec6af1158733758ca4d48d5cdf3c9c8d2b34ad87cd610ff629a13141bdd33403e5da23ffb9aaf469b240f5dffe5906f4a870ecd708b90dac8d7192abb35bdbba9e2c094a51c9fbbf549526a9f281d00d453ad197e4e4cc4ae497db6ca7bce6a6fa3cdb6ee2c459876d379f8a11c0bde39666561312a2c775663c6b7be38439546d918e64885855e14a65fe50a781c1470233a5217c6977e5a9027736d64a41e5abf111c537829bf761cbc7e5fe74e82eaa14ca32fc415bbd1cf4baf797524bd80fa5aa4212c17febded5d229902320df9d991ffc25ce1fcae108632406e2a58bcbcb1599c2ab6604634931f08179b6a5edbe5f3ef7531115dc8077ca63bdcd1daac82dce4a253c558e9211c54b7cfc2d45d392618b64738525b0e9c34739c91ac1be860d3cd129de2aa6e1a845016840e2acd1a68aba3bac79f17539fa88150d866fab83f5ccf667b667af7406572cbbf16c4a4c7c728daac2ba90be7d9a25b78bf806cb0235fe749458cbc7e64267c4e50b6054cb714eecaf016f81c8518fd9315c7cf6c387407c12243dc18e5d1adc952d5a5a9ec52f5e348cf81ca546e8b3f2662c325d1d89b0c769ed2ea9c0647277eb566140ed4d2dfe6bd3c397b486e7e7a986c78ba050c365e3527f741f530ac0ad5229fded9420547d2c603581cf30d1dedb31c7bf3715169a1d939b76597e2c8eda2b469046e873f7b35267a7953a0b6c282e7d72a2e57204cd2a5a2f632075950504d3d0648fdf7bd493b3ccde9e1afe85884ebb4d9bb78ca9624544aad75a772ea886cd8b97a5816e173120399e388ce918770c6250057a39f667011a9e75455cdac1c17b265ba61efc831092fc3664d3d759ee07c80c7f125344a5a81d1b063870e8993bcbaac9027305b3dd24a2a3762a1bbab5eeedafaf5d533ae9723f5841e24b0e664c0b586ab1b813f738d37bd6fb5a5c314653ec7118fa6f4828c7103f53c3273c7a08ba3b84999fdd8e4cc9f64c9dda3b4d3b68f4c5d0fad605c748b87a670d195ae98bc3419a48b4bfe5d505b98fd65fd6d77c3d70c1da7e99f0504418486124650df78387bad0090c7cfa98c6cf8de3c08bf2348a9ccb3b3bb642493eb2f1d52b92149e55124f094fcb89ee62ef017807895ff8580b4419976b0bb646ccc13746c7d17318d8e50f8147713448c9d7eeba8a06acef902773df495adbcef976b7b4d69e4a1f71884905cdecb18d07d55203accf19b1ca5388dc012a8bb6c2adf79b02ee8655d5fcee9db9cbc3f2b42db63513521cffd29c695b122b3efd695e951bab747b2936d01cdcc7b98a7fdfe2b3aca8ea52f24f30f3857e026087dfee60aa09a34dba4f7c4c4d08a5a27396313e648c8e4655b0f8be1c3a77206b1ec89a9888a8ef0f500670dcc3d387f9cf63a3dfaecd0b453d56e34d97cfba678a995acc8fcc58991e0c0bf1518034fbd48133bce4f40de8953f972da20e38df9a2aa8d27144c4c9f7c096ce0238e98a89ca4d85135abc99a2795c31eced3f518bd870dd80b7e6cc7d8401bc01c2b4ec9a30cab4a10675473defebd91281a6620cae2ad9bebf351c7cad58ae22e4df1bc41f9418d6e425ca8561aba8f3e07a2ade69e3f7ffcc355227d5f5d6f8ed5a5314dafdbe41e7f58db8b2988bf0b4e29b316b8e0933f7a897567df879e4956866bfbf2e1a305894877d8c0d529ca1b25d1378d4ad979ffeac8a914df36abd2278e0ebd81a7c6a5e72fdcd84c9e423abc6b3816c52edff74b1454e3e6453b62b27155fb8267165e4c60ace36d0761def66fbab997b9946124e7834b98c39d7193ffd7698976d51b0384dd431a5c1458299a5a9f5e8df133e7e4508445fa8ad6acc1b6576a0d05ef4fbe0ec57fe9a7caea76cf29a392bc3b5110e43aadc9d94ddeea1c50238c2d2712024181de9a44b8def9db3e7cc30e1208d9fc2dbe2654a434fc03d11a02a71c4af919526a4490cfdc9526a672d5229aed2350bca0820ca4f3dcfd2dff4f8690f875344f385501fb749238323c20fa7442964f771c20eee5bf91cd274491b513b26669fb41f4aa322df863a798c691ac39f938cfcfb291e7d5a65b6a470ebcd379081873efd3dcd06bf23c7fb2a27dabe704c977226a8a88d882f7e911fe94f27e77ccfec72329622e78f44015eb91e93bfea46d7e3163bc0b77d02b25bf8f59d37ea1cd293a7149c2b6bc8fddef44fce80fb34e7c6dc0b62328719129ed23307601c3aa9702d83bc221f43e30bb51cf051e558c9921a783b7e802791643aa61ec74d0b130f27e451509ef34ead30b11de18fa5cb15f65a57a02d8132ae3e83986ee1a5d8028db3f8f32af3e9d6fca2075e7324a805469d7f98e54ea7ebad111ca9aea5ad7c4764387435737f546d884d6332b4884d1def0c80433bd351e37f05060fdeaa89bc133825c832404be53bc3d274818dfe57a795d0dbff29cda9afac2a4ce617be9a204268c5ff5992010a6de4a52e3d782c8922f30701e9837002579e1c75cc99b4bfba2c7952de20cdde2da4a13ee166e057a9805d41209c1f70bbdca40c482a77b4321e2ca8077784fafc23262b23012cffe44d87dfd3baeef6678b53cd680b932c6ab05f2707b037571e201867106b8e3f3f64cd0108a542bd728fb42e7d38fc6ea558e442a96e8cf6522581fa4bfad881e2f6fc6aa3570c973125e9c1c0c5803046eb24ff9aef4e60828a4a0051ed191f0129356b508384f1bc54039d753ab7aaed99661b0710cce6c7f48492e9a6d32c38f835ee744d643c8d9badf8067ca814b8f702f16d9bd4ede6fa3521fbc284366c1ef44536ca61ee979b3a88f594855371b0f1b81fdc70ecaf9c59db317dc2f2ebac6753f30b57feeaeae21bf3ac883ab27868c73a13200e827df22661637f4ac3625367a2129c24d8b8517024ddfc267d3d3bad49ef3d1eb55eb64fc7834522a1fb606feb436d144348a045805c230d89feeffd7a0f0ef62674492fad5904e7a06f378a837cfe60aecb89218a19e2fb2ba73272e60a7c3e4f624a5c78705ca10512a1807aa3a3b4f90ddc0870c0c4ebc86bc15494cc589fb37cd839176b3d785f852a170ab9fdac9f071b17319fb9fc1ecc3dbbc68bb803c5bc839d8ab96bedf0126c148438484b98a8ab259c287e84f52e14467ad83547ade9cbc052a56ea27658aeb5f2364e81937ab1facda2b1204fa1a96fa7f314bebf603543fec312b304d47446d1469f979649b84b3cdb14ee6e03343606e1a6e4a7b7af8fbf0b2e2060e03e2c5611dab1cfa9b37396e8e82197c77931ff6b71b140ea8c05369b573945d5466bd30aed49a21ca1a98c3c6faf6695cf4a955d1d7dcd5ed76b42531a46ca4643875e769e2086cb56d0e74fff08b104af5468eda7fbcf6857c894f8b9fd04274fca3549942de319bf423a946af6667bfce199d169b7678bbf59ef88b4fc1fbfe226b7952c11791c3de0a0df098e1ace71791980334c718de8eb8fdcc355abf63996287752ed9eaa8e3bd7080b0ced22e497ce02fa501cc3f2b7bbbe619637c357bf5f29b951435578f9afa06c6ea2c015aab0e199631301dc99fb3ac9a4bb8b4820f7d93848254a269a333960dda94e58d3b4036a4e98821e201e74a8c8b2abc9d7c998abbd8609f62eb6c4242ba3abecca1667e689b55cf1bd10d82295816da1985069b31eb9783e4666211e08d5a57b1c1303ee4e6e6c1a22a4e9bf9ae654f95ba7d8e05427972e8587b668743dcf5d8255b1396cc6952aa031b643142cf0673a5bb803f79b093123c938477e7e30315111979f66f970a2a170c8f8d92ed16bcd8c4403bdfbf5298760692c24d730bb890ac9a92113e383d807e158556277d4d25582d7f5389982c84c2d754667d7fe819e0cc857541a7cd3001a366a24cce05baf6bda7a810b8f6363cc4fb0c73d76418f7a5191b6ed44d560d80359f6bf9877a5d167cb16ca258ad45babb4ff0d53971f8925b68c7e7652e20b14848f339d2a0a4d35511d8e70378ef26131a405d9527b7ef0e1d81ea7dbbace824efcb9d3119a76da19b41e856f4a034d871f4a363c7e9222a1fb6478922e2aac5b414adf8913d261b69efdc356ef726517733143783afe518c818320f2ed230df548a0b1c6594b17a0edbd0179dda2c9f6035c83ed6ca852810e4298a8682325350d1a634325d64b68301ed1c5b971b267baa7bbdb8e62f1f3a8f2c1e928c695871338fd27911a81aba51ba1df160ae389bb41cc643638ba8c9eff192d2ae97106b99841cdc21d3049d3bcec1fe3c70036d88c754db04fbc0233559355cb741176c647c599ec95275b1796e42e98c1caa9ed12d3c289d75b9b883a01883eaae78c1df61a0984f7c6b58ecce004feb43b8a3192527aa6619fff0c48ae2b3028441518809a0c8d7d4770ef16a46c2aa17bb2eb8b5674fb39a82d3132c20cb67a4eb96be4b2015e67ecac59f0dbed4bcb934bd6a566546d9aa9fb65ceb27a7839f8eb4d66185709245b307554d3eb1e02d6280026cb7fa53ed9cc5cfad39b38d0871acf4bdf440327074fcfb9998e6e361f7bcb3610d3e63d18bc85d1c764c58da3b6c91eda54a759c61d8c2c6a6ab9d6f123b686b5adf8e12f95cd7dfefa183997c19b508d2a7387b59f1973ae585948ae486cab4c863fb5a0c1b9cbae43f4051c1a902d54f7caed3db02753781d24cc3a10d8578edc6ebe755402bd67b89a9e39670807e9af4ed241e7f339cf9b767a208231d1a85e0301eff9c079021dee25af36ffdc0eadde2a186e883fa00dc117bda1d3e85880ea8e19b69fd520f39db8548e51efdd2b118c6f4f27f4c15a9e3823cbd0b9ae0c324d2cbf2ab9d38ec6862ab29c19151f1faff515ac3a3ea1661efd04a9a82d1e55c6886fca5d1e185058b93017594f16007950a0455c47ecdad511f011ed77a0a7c0c292b2874c97051d8cf6f805fcd1c16576851575116ca88791492e4cf4304f1214c289b9c832f32fff8683e292a98a06c4fb90e5bf279c78c560fb1b8baa122d1f016cfad730e2f6ed0ac9c1edbeb735cd1a9589e74ed85cc443ab0293ade5c6e0ef607c0292dbe0d139a02789eb8c25b9cce7a3b06cfd65b3d19fbf2ba30d877622a4a2850218d164d292e7eba8c941751c2e81b182fe6e22fe4d60d1353e31eafd060c2c1a46826f1c805567085965f0de3ef6d1f41523c48a61f13a96d10793e0545be36726144bc782293563d28cd2cfadfb5e890ca77013afad8ef67be7cce8a6fb95454f6570fcf5d1e0e07068483207c8e2485a70b6fc3fe8b2f811219dcf016f18e22d18e4f3a25d6222dbb34dd2f7ea8b8124a1f6104a4328897df3f6ae39dc07e01c1fccba5ff3173d1eb996eea18490f63705dd29d73ecba322bdb0f295a56b7d03b4a4f58dd52d0b4cefb4814aa019c2a0cc297d9cbe957dbb9f4ae8703eb83b83f46d9c544cadd1a9f2e12e83c8acf2f5f8e1f3c2dfb3f28f62abd309a7e8e1254360291c17c7cf20454871dc0b48b7dfc4f97bb645dba0869fe3a274e48a2aa4771cbc1b6bd38c46b8cae2a7fbff872b34ab7877f7ae9cc8aab3d0fdf3c857a98ec9794875f6afeda1873e2442679c1742c6280107442bebe408bbff73508871751c92a11268069005f518163b4588558fb0f97bd06f0ef370c19cdb1dd62b404748a382d782d6286557eeb6a954e68fb9dee9909a6a859b5b81f37fb7e9b55402cfe477c73c3b0fcab694e7d6d97a8d85592c6ad2327fe1d9d6159f2f651d269aed80ff1a3cbbcc57329e64df68c8494ed59f03d8b20fbb2b4caaa9bc602a11457cc8b7f6576d61afabb5adeadb388694a6f74a77786d30173e9bb474c4a913818f761f2c557a8768ef6dfce99f1d0adef4dc08705db30ed7eb2bbe9b7287010cd9de9c085047ab8cad6a5691776bb83ce1a36f2841f60c6a9a52f0ede66d6254509c531d7a38d1bd58c508ee0d3750216c2187e4f9d1c34ddb57b5ece7dbcea97c4ef6e78c07f794448df40c45cf136d691ac9d657e5696c2b9ba3254f3137a53401af5d5aef4d6d1d9ed9a1e2cc5da93ef9f30af8a39d34b58bb17f253ff8f6f72f98e7de9f0eec58fee7e942e4cb39376370efddffec2f6556a31df517b0c1fad332c49234a67436cf35af2a46d637938fda5f06e0285a2bc8d59e1657cc69195fdfa624b8ffa1938d79d98de23ec4ee1e81fabffb723f0e64f3d22c722a369b121e863bfc6899baf015838630e06d63333da0e1146d9f54b6a8480613f7f4e90dd64118b840b2470ed224a77e388754f902bf467d32a6a42c11e84a248a738743c993fdbd45cd651fbe05bb37d9fd37cf2b164c20519ffc5410d2e6772a0c4e8d0d7ccb920f61674dafa56ceacdf350558955383845b753db7d24a713a18953213dc2045db102d35bc798896d3dd0b155e18e3f8f89952c3c1c9cfa40814be8d1b38187f97db211e8961ce392f187f2c372c27625cde361e9190bc46e5a4203cfdfa5c4de7b5535c7ad6c12c58818bb36a351aefeb651419b9ddce676187781dbcaeb47475fd29197c9e1bda4b2ea279b6adf7801b5a0f5374965d451ce687d95490de346efb58f0d6637c4f1bf9f7859fba024e17262218cf43cd4c908605c929839fd2b060a783deedddcd7d1e04f225c2a0e30639d1c9e735ad9a6c5460799105926c97af363d6040931fe29e6bbbc51dc5556851b3d206cc87b9ef49a4a01c04e73ea6637b1343c19834dd7d7ba39eda049e3bd4a3da783b49cbf24931fe62b54b141fd51994d203bedd370339ceac496e317369168743a0cda2e97eda8278babf473e2175d048b71194c9a329634d873de7a3f5441a8f20674f52c097bddb6dbc1d25d44eefd437078b118e501d8ccfc6efff539848ce3a2cad9a232005e985d017bc84f0458250842e408a52e34a407fac5b3983d6e701d2ceaa364b23853b49d73f7c17d0b7c84fd05ee0727d84b86c03bcd13229a3d6c5ef3b83f8305ceab37d6a390eed8780ee20e55d2d68c4b16c20db479b7818528f9c35f61fd2fac672fa6b31d2efe71ee747216fcf1d166eccc49d87a22c0275c3e7cb8a54f872855ff4b7bd6daf06c6851856063a0b71ef0e00d9746fbdac2fc842ce4d5fd2ca0dc68ad088d7f0335838b0c9401a4dae393770479af392fdd72b19d8661dc3e0bc9434fc24e9dc02122f9c77819fb28ea5208c10fd7c07cf0abb590f817c8041094af6e1464537e0a8336a60abc4fe5923b97a0d00ea3a34196b874ae68a7130dbbf7f7c1d27e15872103f98b8cad78432eed2bcb9bec41aa3621517eee8c21888093e666c5e090c0d9d64914ffcc4e78f4f6ae61ff19e07de6316c6ef66fbeeada94af4b59116b032a4a8081832ba79b4b9b039423c01f6d429b8b71737ea04a5fd261cb2c052332d19bbc7c693c17f6ff2b23a967b24b8be663cf30fe09fe595fa86b06a1115d4362dfd35031e21b5e99731aca0c49b9051ada42faa2d9cee2c9baabc8946c6a968042a0d14fedfef69695fc1da5ddd4f9cae85e1ab545c6c9163535f6642f3cbbb3df3fc99f18403b1ec78f74e749dd0c60f1e5a99fb30888e3067ecc59142e23dfa76aad34b132a6c3a4408ea6182b150790555ffeb11217c1147295aa87ce48cb540c6d46636ea408955b2221c8dffcf65be981b5cc7bac974af3c5c1a39cf45fb148f9eaace9e706422749933c55bd16276548a4f2d37c3df579cc8e7b0596d46ce3c955e186ba70157fca0f4ade976bcc2dd8711648d12db872ea113a138d0c825339040fb2fa9d36ddd3bea71b2dfe91407364cb26be11db67548cc4803ea754cd42299131a7baa9db5284f926092a7e45aceee9d3748d674840c119c8125c2c5eac92d042e212de1b0533ce24201c2471652b0938108e34a38c924de7287fbfc88d8aaacd8f2762e15d3241d4d033c5ee4f343b147b61c7f24c25a460d43ca0656fe812fde7b5c299d4e3295a47ae57b1a3b366a5691100837ad92cbda15f83a1f019a74b453f56006b464de41e70fd5b5cdb7556523c5b2176d3f9dbe99a7efb5203e2417cbdb0ab5a71c0c570d94a623ebd67ae079d828ae9c96efe2b29604230c265ab5ff7837243e7c29539e0987e1138baf92be3744aa3b2875644d0091aa8b1d16bc17861303d751ec06cf4717caade31a79c0615004f3910d6501de9a95908c991feac854c9c69ccce9e47e70b0b9519e1c1e784b4b32dff44e8ceb4f9bd8b46e670d93e6bafb7c3087d17433bb448843dbbb156aef047aee0e32af84154e7b6710500e83acf9fb04c109073bf7e90a17d46a73c1fbcf7ec226d34099972a3c4715fda12f515e30ad70753c9447e743d9e737f8a7e2c4a47f0436b1e73c91393f6e9afc6a657ed58854403d47525774cdd9a834c64b0f509e22d22ad21922ed04486147642da3f78f0b813330d39b77abcfee2faf19b011275a02a47534710ba173001c3a9ee738eb1a1de15d677e12b29e5f0f0158f6ca96b9c79a059b57e63732a2909158b446951939c5cb05f7cea18b89784530af93d96c013f668095967666a704691aaca8fbb8a3863bdaa2f0f2b03d2af5cded8107a74b36234ee7f0a5cb06ba03e9529fb21e85ce70596e2c3e3c11adc301425e533573dee0b9605246ee3cce5b7dc24b8439cb778cc65d4976c56e348533f3ba41186abd486002e24676c27d46c559e1430d52d42444358948c14c8433b2998e43e4025d58b26f15e124f9d7647088ffb740887b06f27ae1b8c1ec0503f5f65d2abc402e3563f4910f682e14b24ad3f690ffc253dd73332a31fd7d0f37f173d7af16d210abf977f84535cd69793c65647a6a6cdeaafc6a57147ffac2c1a7a2fca02e4cde87818d77fed3895fe17f694ade3e83661c172cf5e1a7975c6b7729f9aacd0bf35dc9decf7d2fb67ef37fa147190dc05bcfee02fc0c46e939cfc3d50ba898357201846cc5569c259083d87caecbb154952b427dd2b743916fd05bad822acb6ac75b1f9701c8e2cb2dc8707da2677b81bedaff861f3e3643bfd243426118330aa07a1053e805551b8baceea8e1943de9c3a64871b89ba70ad80905fa79c863200021569b6e5c00829b845dd892a585c045721db752d68257a55a1ca9293ac6583250dc8ae796782c27c9a2a2732f14ff1f7535923305716709008d0c17f3ddc274cacc6011e82227891b3716818e288cf1fe827fb29dd786fbe3545cd22a12392678686e77ca382968a118d05ed5222ec347e8b289746f05507db3280bc2b5e885708cd3b55a43a68816462be745b84344b307a104715d84bf34835038deb862f3a419ca2dff3538ab3426a5570a805f901d7e2f7c075b282fb7a96272ad523486097c2f095401786f464a53abf9b1649bab1b2ebb4a1bf6deba6547bdb6310fbc142b6499f84b55b8922f683d4ae367f8f0ce58776d5a5aecefdda71d54c4003c05baaa686e6875b1408acbb4e3b16fa1f2f36918b6e019c52366d6e332f4d43bbeec632e9331348fd12698fa733f4e74e9096964efb9e745e98e5bf2cb247cd85ce8c4ff569835fa54d6a07bd382a048ad34fcfbd91f1b56c4bce8bdb279250d7dbf6bf5bdda86113c2d6b5d1a1abc2eebc1081d171ab5453dd7dc4d21b0349ef2a89c43daadd5835a4416c7404073a89d30ed28e9ffd7565a99e52b9217e0c9195dde2a49ff17349f4720c6e7a9dbd0a1636c6f360a32782755f48b33e38f20a0088b00bd16e5a482a9ce59bfd4ed1386c5ac4c8466d378cff7a02bce2a26f332783701b1198b436f2aa52f4b89d87d1ca7184207fb08f7f0c66d1b98eaea5c1ea2608ff18ab93bd989b901e2705ee63ef435da5e1375488522a966d1974881e4fd68d479f8c3370a4a41a8e8872a56e05426b21998da4fb906e05bd5f997fa357760962201c7afca6f6977b77494fd931a5a126b64b1583313eae7d5e8bae3e95f35b52e3fcdd67385e35dd2a01757038595ac59dea09dd70f4c34b54695c68bff0556f647be031a6eb3840ec21ad7c4d2d89405142fa350980cd4d17409e8ebd653f6f3fa4f42ccd3924d30de538c2f73c376cf131b41ec513d7af7c582f6581e3860678cf4b91110523cc63ec6cd7359ac0ac27834730ea812d06cc7712214dd479682f0dee98c9533ffe25a23078c6e4566e0e1d296da5cfd8eca76892e5174c4c0aebb98cf6a97c608c4ac21b6d2102b4f565642cda016a13d735bd8eeadc18f460bceceb103e79595b64e171e17f24471d537efbd48f8c0335da38d317a76ec5aec1dde6697c58ed85a565c2c8513050a3b77385fad1367aa585736465efb8a10387f183805d2acdcd1254087c33c3af5d379882f352964892a6d273a4c4c505d14a479037a14f569615683badf085591cf87eefa67ac804f33dabe04d7ce32b1de0ee88806313b3e15a0ad0630d67cd414fbadef9f3689619f15500c78496d26dc68b9a821b8518e2e36f04fa27a32eeb568ca0caccdfe46f676b4c21e1cd72b97b8654a465c4dd21130d309c3cbd7cb710d960b0e8ee8ffac260cbdb807deefba3d83813e37872528e774670defdbd030a0b2e29204870a9c8bdd843612c470588fa9cadf',
        salt = '2caa6fd3bedf06859a3173616392d621',
        labelError = 'Bad password!',
        isRememberEnabled = false,
        rememberDurationInDays = 0; // 0 means forever

    // constants
    const rememberPassphraseKey = 'staticrypt_passphrase',
        rememberExpirationKey = 'staticrypt_expiration';

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param  hashedPassphrase
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassphrase) {
        const result = await decode(encryptedMsg, hashedPassphrase, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        document.write(plainHTML);
        document.close();
        return true;
    }

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        localStorage.removeItem(rememberPassphraseKey);
        localStorage.removeItem(rememberExpirationKey);
    }

    /**
     * Clear storage if we are logging out
     *
     * @returns  - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        if (!isRememberEnabled) {
            return false;
        }

        // show the remember me checkbox
        document.getElementById('staticrypt-remember-label').classList.remove('hidden');

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassphrase = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassphrase) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPassphraseQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPassphraseFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassphrase = hashedPassphraseFragment || hashedPassphraseQuery;

        if (hashedPassphrase) {
            return decryptAndReplaceHtml(hashedPassphrase);
        }

        return false;
    }

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        let hasDecrypted = await decryptOnLoadFromUrl();

        if (!hasDecrypted) {
            hasDecrypted = await decryptOnLoadFromRememberMe();
        }

        // if we didn't decrypt anything, show the password prompt. Otherwise the content has already been replaced, no
        // need to do anything
        if (!hasDecrypted) {
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const passphrase = document.getElementById('staticrypt-password').value,
            shouldRememberPassphrase = document.getElementById('staticrypt-remember').checked;

        // decrypt and replace the whole page
        const hashedPassphrase = await cryptoEngine.hashPassphrase(passphrase, salt);
        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

        if (isDecryptionSuccessful) {
            // remember the hashedPassphrase and set its expiration if necessary
            if (isRememberEnabled && shouldRememberPassphrase) {
                window.localStorage.setItem(rememberPassphraseKey, hashedPassphrase);

                // set the expiration if the duration isn't 0 (meaning no expiration)
                if (rememberDurationInDays > 0) {
                    window.localStorage.setItem(
                        rememberExpirationKey,
                        (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                    );
                }
            }
        } else {
            alert(labelError);
        }
    });
</script>
</body>
</html>
