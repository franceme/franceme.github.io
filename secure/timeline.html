<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #4CAF50;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #43A047;
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #76b852; /* fallback for old browsers */
            background: -webkit-linear-gradient(right, #76b852, #8DC26F);
            background: -moz-linear-gradient(right, #76b852, #8DC26F);
            background: -o-linear-gradient(right, #76b852, #8DC26F);
            background: linear-gradient(to left, #76b852, #8DC26F);
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>




<script>
    // do not remove this comment, it is used to detect the version of the script
    // STATICRYPT_VERSION: async

    const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 *
 * Mirrors the API of CryptoJS.enc.Hex
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassphrase) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassphrase
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassphrase) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassphrase(passphrase, salt) {
    // we hash the passphrase in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassphrase = await hashLegacyRound(passphrase, salt);

    hashedPassphrase = await hashSecondRound(hashedPassphrase, salt);

    return hashThirdRound(hashedPassphrase, salt);
}
exports.hashPassphrase = hashPassphrase;

/**
 * This hashes the passphrase with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(passphrase, salt) {
    return pbkdf2(passphrase, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(passphrase, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(passphrase),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassphrase, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
    const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassphrase = await cryptoEngine.hashPassphrase(password, salt);


    const encrypted = await cryptoEngine.encrypt(msg, hashedPassphrase);
    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassphrase, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassphrase
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassphrase
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassphrase,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassphrase = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassphrase, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassphrase = originalPassphrase || hashedPassphrase;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassphrase = await cryptoEngine.hashThirdRound(originalPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassphrase = await cryptoEngine.hashSecondRound(originalPassphrase, salt);
        updatedHashedPassphrase = await cryptoEngine.hashThirdRound(updatedHashedPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassphrase),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
    const decode = codec.init(cryptoEngine).decode;

    // variables to be filled when generating the file
    const encryptedMsg = 'c13eee3764b0267a3fa6f9012d3d438c8048d3ed0a441025f48dfa090395e23ba439b64f36a2d65613f5b7c6a025b22324d36dfa5162de2139c02b9ae3981ef463aba16160aa5210bea47f0f4217a7beba24e53c2e0bd25f1164009fd36bf7f44c1e09ce6166e7c197664082eeab19f2c6dba92f89fcf77ea866705a241b9f4e13055f44526bfcfe2c5041706d4a44941b69a47905e9ba42fd7d6e0ee7db3a67c1dfb50bf1967ec60976845c9c1c8e88a0bc2c3cc877135922c52d302d5ba0948642ff662aafb8eefbec6a12d8a012a12721a986abf316e941cff9c042912f9a8fc3a9302bc0c903a41f2ad5c48e40beaa2d6b5796d4bbe5ae662d17981f53da4de150eae0a0e734e445af2286b11a50b26a7debba72fea9fd073ae8bb57ea07eed1dc1e05d11054f4838bddd597e2b8406b9cb865a906b8d900ac417bd2d9d66b87f5ec221b8d68cd1b049ce1f147b53b215d08db6468cc39e18c13aececd4f2df8730c2c7e59446430d40d34205b2986e5cf54b9e0ed8a5f53c790c477e5d0b2355417b8a535630b9df9922ef2d43e02ee43922aa805ad226c65b73d4b42e5a834c59fe3f024519afd5064aa144ec0b6be92dbb5e1f9a425bbf1f62a4ee0a5fc1761df96f53e25ac8be262dafb693ab64bc7a4df863425e1f1f86c7c0f3fc7e1481e75645d4a051848d0f0ed4f68e12849e8106d817d6367723b1574bedf006b28ce41008d5f242758ca4e481467596b0a694967c5c364e427a6ae738db47fa24ceaf88e04623510f12d4c3407367ed5cc12a29045e5a92e9cdb8c230a8ca47768b770b90c3c1f68a52701bfc0a62010c5f1b11ee7a60da7e33bc46d6ce7a8aa078f6d9721c9322eced80e3580ec3b0eb6d7172db7ae54a7944983d0712e500af834c8b0831cad7a348d68f2c02092248f88de6cde0dceee1b7912c2deddc1db5ce246e8fccc0d9bfad09dd79e60bdf11c25ef595c8961f5343b90d1669db3e813cd7a3f1d5995144f38559f726423371409e29bd7ec8864b64131c5c997f3466151b9af80c7fa901998da21f7696099b7042d695e77fc66958bae74861d7d9bd0ab7d8e8abec617ec80e81154fcb91ed488eff1522af9d92893a2bcadb54300edab47868d2f4282479a0bc1f350702defb434286d6815eb68bb9c5e962f5d39c2e8106691b7ee3ab1100ece691b894a44db202a07079a3a498d845c70b347203bd8ec638a0291731c62d4948c571541a5af4d857f1d757491df551de4f479bd78b7bc5d63d8672ab1bcd856868b04ac1c33fc19a8dfe5cc9fd60484ac7bb406f21acc9c8b70bd529c0979fe7fe942903a03f9315cea563f362eeae5e9d5f881ebaa15c09fd2d937e518e2a4fb9dc6a94f5596274476dcb1678b2e9c95df19ae20b9f2b2843a62e062d87ecf38efcec032bac7253fb6eddb94eda31d748912f56808fc19db7645ac3397576a543b1c6288de6144539f891f2009ca00f3ea5f7bdd9cd9cebe841bab4fc4de8f27b26825ec70bef985d792eb621bb0e5761ad23911198cec545ecbdc89fb2eee4766e58e5a208a54de657926fa645ca221904828b2f9646d917bde08aaf61f7a4f0cab35a09905cb74d000e97788befb60d82045f206fe14cbdcec944ee28de9152f6f1619a62d713d325c310cd9d9fc7ac9ef5c942d6cc890f3d7cb78b4730173d5b4dc337b873055b532ce03ee25506e656f2c840da9c4b31b826037302eb1cf894a1f049bd07b90e6410ee993e3529d86679573f22e34a7881e996ddf03e862b8960fdc46e7351aa4375b0d48a7afb8f7db24809406b885a1ba2ee0988b071641d6d5d764d2da9a562e635d0d991d47d24560f1e129bb2d9ba6098ae4100078c939a3af1cc76b70fdbdffeb9d243780a31780ec93a43f5f5e8f2cc026b2552cfd9cdc2aa519590033b074bea0786fe3b361102d72c2a8392a83798bb19341f6d7bb548cb399360eb549679fe80b18d7e0d403f11d63dff30dc1a0330148355a6d74691f3f9d7ed4422784d8ce24f02445988bf0e697a8946268cf3c2c6faf243e30d449084c9e66570c9a33a94d805468915e86014bd9a866c3b5e59be0bbdb9458e8acf3c736b799c127e039e3ade0784bcdaea34051dec9b6adba5aa6efdb14cbac27b558a3153c66142c5e5256f418ef1bf344f252aa6174567a2e084b641562feae90de9220bd76f02663051f09860a366396b8af1dc840d612987aa14f1cfba2a321b96bfaf31ca1cd4b6e8d745a4c375f86b66602e4855e0eee590f3402356dfd230f94d007509f5f5b63136710f443bbe8da8a9e93fb81bdd6e74bf63a479d21acd2299fe78ff7d782954b99973aac6aa8c48c8e63e3d1d469430683cf26e1a85b676de5e5b38ae86919366f02c75bdce683d269a5db346c0ec9b95a02dc36f3891088d1117abf1b8e053dec8bbc6facf90e3dd81a36da31d289eddae854d40e126fa943da2fac43633d1e1245ee74aecc54df1ac68b65a40ecb03501a90419116b45c51a7937b50e7846b74c7aae6e5d5f58c73f335f0788743e50a7de2eea282fb9e0c4c4d02d7e24c8a389eea2272f4deeb3261868fb16c7c80f5bbf633e6c8916b011284853e5258674eac4c0c28ab756d3a1400cba8a2a6a8b70bb82493259d820a4cafeb784d1a69c9bf41c4402c99c371172ab912ef1903685ac5c919ab0a3fcacddc1c93331a0423b583f4acafadcc85be1daa4ea3dd40191b41de72efb7526ead1fa15533f36e56f32d8c214c1c60bec596778bb0a2516db58444ee2ce21bdbd68614bd2ff641a80a3948c36adaa32e66744fe2a32f61c9379a0ed40a5a994e24b5cf323af71d7c39d5104e5c2c4bcc6ee5252c8233eb80278f087a61b90d1660957aa0be8eefc3e5f1b89fa9eadf1a0ac50c0ff295f9dbd8dca72c6c67d6e09880bb656d786ac026cf1727712ea4c7e8ad02079ae4772f304538c689fea41acf15f3557dd62297c4d1ebed9726783838b4adb2e3d30816dce7bbfb24fb48361b510a2e35da455329f9348834086e6551600ddad9f11da93211537043da8c97223f4ae20e6d925b00840f47b9460d1d2e242b951dc6e8596cf6f2bf5920179e5b700794c0f6ec53f824293484bba601ed520ce1d9920e474568a1757952d0a20a6afcbf6dae32fdc055f2ba2dea7c41b9666ba9cbd5dfe52fab6885e575d733753629fbd9c20a3bc7cbca3c3b6403112a8f943d56d44adacfbba260c119bceccc856cfdb98bc92c4b77205581a9e38963ba808eb36be26e01551c12a658a0615e7987cc4a374d31d8e8916d2a19870c492ab78c94e5f179a36f65ff92d752515629b95e333254212fc4768e000127624fb0f063d251446a139eeb298314c059a7f00a5f381bfc53e30659599e4e6bcd0f50e6558bb302c112cefea1eb25096113d3eccda525875ba5377b7c18b5fc565819d6bc22ad5caea70692a9d617d41250b704a5837e61b0e584054a2d81f0b84fa79fc8bd8d4277e5c1cc04a2819ee1a1300c6b1651e115cf18f7ade1770ed44aeb40ea43449cbe7d53ff6d0b00e77bfe3a227208dab405f80e1b7826f2944eb950fab8d2c505f9ed33e065e2a1e2f6d6b7f0d90405336898a91472ca0506b48384e34a897f3055e800b2f9c11e854158425772a57de9afecc0dff873582aff7d10f57873dd9435b0c7e92f67adb0de1c9f17df8c00957c26d94af66764361e0e3a1c74a7a680f2643eb7e3e9e05dc11d2184e6e0e59420d976e44cc4ebd39111c621ab6dbef682a60c221f1202db7471aaabff75e578dd4b8bd18e1110e5222bbdc7450d1db0632802bc7648bf08032d4a2cf94c6480887593673252d6896d89762262f3f67f381f26a44fa91c52b30478ec40cfbd2e49fc16d537523b8573a82d2e4f934fd0979cb3cfbb1ec1793efafeb4723b0f324181f8c5890c7cecd6759ff4681c3263137beb396b6b8831a66bfde68cd33b8c85a0b38fe45f10be8d6c8a9e1550e4e8e8177c6008b944fc7593c741d1ff66d8a702e5acaf4bc093b6e766312b03258b7181cc3e069f56c3d6e8114721d2a335c3f4a942f88c627db2d411c5ea7d4c49b2896ed2bb27f8c2a339da8c75df29fb8dd477fc8a5d3607398f48043737f461e7bcbc4ac1ebd5530908e61d9b2d4bb0f3be5556588cedcef887b559f9e22aa8b98d46f36d98b6688e9765fc3419f3d992dafae6b4b378a43c00044e5b036353f2aa8f6326f3bb83fbf02edc4a58e2794c338b4ff9e07eff62c95fcc31fd604f0115a856399e60920099bd6e50975cfc7ea64bb73d4338fd11b007d8381afd7e52ed4cd9bddac0e58edcb37ae53a92e290bf7b5703652c1cdf582810703149243062109eed2bb6588b258a8ea6814e90b2af7d8383a8ae0d56d9735432b43ad72b67210f763627b38d999de5b492e252ea5b8aa64db078b9df6150c4617c1e471ee94a67bcefb7c86fdd4d519020627320425e9240fb79d5619a553bc2b835f966e0ddc5f182efdd69a097a81ca9e5b16023b842b475350017eb7e36d3cfbbd82c8b044b0369a8b0d5d93267dea258df37e7825f94d60e6f7b7002b61c52115fc218a803a4034561a2b1469a127a4f9844f9a1e4bd8fb1f90f147728b868ac06381cf918f95f10cb5c80baa30c0c09a30d84ca7023b822d8598bd1eb94fcb893699b01714c5bd1408752cf6e57fcbc9591a5d3ff9857da3ca1bea5fca463205079056f6cc3b672bec8b26804dace77c8a7b53d687361b5869caa821510e6a8a8bfb29bc1f42d211089a40464a92c7ed29ae22fb0c3c07d4f19be82c6e3e1ab4d0d85aee58d7a819fcd4d4bfb484cbebe4ca0586d87ec43d75354a09fb9d5ea6d1fdc2352c68f09b1c2b1c41db86baa586f6f806b50e9ecc0d320df5246bbb6e6365684b77c82698aea9dfb77a258dadfd1cf2a629230db9f56a0bea25655fe6a79a7d9a98080560dc18b2c22364f7d0bb347131efdf04c4348e55bd5d7e1601d67625942bc8f65e369db761ff6167843da8cf9944e412974977c40ecf468d4e081eee12ed4c27fabd2646b673bb17c7656d9921e3cdaf8d7b348371b933208d9501d0ba11979f98721df622014132899aace110c72ea952c42b54c858b4339e68b8b79739ecd173c41215edceb82bcda93011704e404a3471bd2bdcc41859982457930d8cadc25ae3bbb4e8639f1cf8cb7b0d21c7c3ddf72c868bcb783711946a30e5daec77ad8ee6358bae95e22cbb5461f15f45d9269e78509c749b04671f6692b54e97bd6a589f29661705dfe75f165eaed56cc4173ccf883810861129304b70c3af0afc1705752d2c50712d096e731da9962565f9acc92ed46417f231557b9628fcf894fdcea7249ab215d365c2d98d12708b2bdb63a2994fb4b79e50ee69f7cdb6716d2fd302c76fe2be98eedfb945689c77d686b9eef6942b3a6cf2fc20fcc137f01c3c9eb55a95889c243f27d25865bfafe426e69075f3661ece6e217e6c31c8a50d707821612d08e3745ac2cb3f3fad1659e23b1d4ad08e110bda09e5789e382c1d21f1d52539456a4f2430fa74f4d79b1f25c5bb16c4192b54752a971f2fd4a6a71fccc71e9cbfe0c17be817e8e604680a175d228327c3bae13e57e663486ea8f1ce0982e4335aeb5c83d089ab050adcc8ecf1b72734b5726cfb650d5062835cd4632824bd95a9bcb5678bd6bd0b856ab0d106c62497e3cec14446cad2360d18810592fc7e417cf149b3a06b1228369257b19e74e85158898dace3468879417cf12cb3f7cf18ed513adc3a34d0804f5c321926f578b8432ecca16eea0667f3ff5b08df0c180b20188af82d2c1bdaac06b044d14e4111fe91434103e0143c634cc4960462d065f35732af0895d2d01d8a4161dbc8d6e6c5f63ee6fa0b540248e07c909baadcab69d0e51abee7772378fe4466e8af5610f4bbd4f2ab0d3930542eb17d9e0fb8a0488016f7f2cb6795d7d855286e1841b23abb1cb99b395620b023f06a4acf1da75f92752db20476cbd536e45a0574e565030b1180c38f9baede23a61bc9808d3ca4d85b3480090aebfdd6661b123c3f091a428b3bde0bd902dbadacecf9273d2ec33763b4258ae582168a6fa414c2e11525b89cb8dc5c0b0d19caf7f977c2260e31168eb34b4b8242d25cfe65108c680cdb18c0cf4dfe01a86dd2a5c48866ef0c33c3ab3831ba361049c328ffa2358137f136c4085da594acd25873d39c34afd7fcf9beb20e9f503e82100b4c7d55af442f2ad6996e43dd8d25195104b9832e2d2482ea7373f01314182b8e8fe0372754db630670356db01e86e3b9fa61e73ff41f4c46aa04c3e49a47dd7ee775e92a6ca823f3433f5ea52e5301f3fa778b85b1054772c4fd9ecb594bfe9f3aac4b571a52a24d6cdd289437ab88cf0964c2c6198a7fd709ae95cf02e4858770a20fa3e518b87bac6e1b1b4ac2472a178c0c3962bfb5d104a223250481d0a544864e4e7f433bea5adc2ba4b43ce6fc34df643e2b0af4f992d726f81430dc1958a3cdd6515eb94b59eae4c735f10f750d406af65eec756311b3de68cc1268b82bd5923ef90e8035d2b84d97022e3cd5bd5e035d435f4154a74cda617ddac367684dc584aabe64a2a864afd5b30de5ec495b5161fe4ceaa0998916f853be44dcb897e2e9bfed2cecaf06763be74c85efe2a6795dcded8ce75b92893e5f280f030eb424c77b180fec0a08160084f80dac3e0e578e93a277cfe6cabf90da7bf1c8f237e52ffa40c79b065b19e7f4c2c32e0fa8fc040f9fe30bccbb9fc240a94c061825139f07c25ebb97d1355b97504c5f85b6d318bc2cb869a2055dfbc3ae916d59977347352d8c1f7e640d54a87c8dfe51e622ed50526be91b1ba3261b6844d0eccfcdcb948da233c13af78adf72fbe6013d0a45b8966b1ca660cffd93303cec047de65debc620207e9fa68c59d344d6ec6873fe7c729ab2fdfd20162dadf7dd89f75866cf5160df3698b441fd399e5eef9c1ccec12a2c70d6195ea897d140abc4a730368ef849f86744a7955910a748740127a64a390794bdeb5dff359652d9ca69e917dd47ca26292005207fbdd7bf268b632705bf3a9451b5357c7e3291ba3aa203f9f195077bac76bcdb54f917c438097dd12cf05afebf4ef94c12fbb3ab3577a4a1d3b67228f9c6a707d3d8e652475963fc625fcc947fc2a5d13c327d56b1cd2024ef7cbc415e45649fa5dde3c885bef0d8a1237856254fb458f76483e9b06cc762e8440c43709c6e1cb7814ba0eb33e09fdd3d995165cdd348b7c9dbe7e1e1fe2563fe5e6e6a33bd698de15a047dacd97daacd6f814220a1701949e3414acba44757ac9ce0b852bbc8d58150d3a2be3cab4ee799870fe7bdcd09991064be6f4908e263feb490617f08e5bd98ee01840f2df282267007083c8820bc627046b9d8910be50257eac92be451c89673bafa6c4fb676f5d6d2f0419057d4c537aeb5f94f613cfa32054985d4bae0e11971f54ab4d91e0c8ad9697b76bff26fcbf79ff50c0446b5264cafe68ee8d7f6e458e0d96bbfa63019db79cec14b6e6be5a3dabf01bc7e7930afa0ea3ed4e15ce7c049a44b698bd17b8758348d567b99560056a75ff3b4f334715858045c5d1df63456c559ec4f3c4bdeeaa57c51dda2a431ee190d37f5c8075f107f281a9c3a2d45aae7bfcff8ea72eade32a7e29edf38f2699ef1175ff3b8e35b00bbdf292a20c45002958173ebb31cdc0e80003b05c2057449ebdaf354bb1bbbc64953e571d70034e68a013c9b86c5f50d6861aac1bc3d7267a25773ef428d5e10bae7cea24cc186345e96510fe30d21251563a08b8e6679d4c73b225e880bda6209f02ee94a9cccba9c5082020e983c832b74c887f7c2da61245cb98a62885f23626119fa64248ccd68a0f1c80b637e743dfd59920cd1c908cbd0f14ecdcda520291e6e6a132dbf842394ab8cb21e3e00c589d78e693e14df7eac7a36e6327d712d76c637da203943c5579b41ad026351a9ddb6b6d22e8693e622a951dd39628417161a18cbaf83f14b9839a2ae9044b754ed7c9970b6088cb097f5480f1c5f3bf99772b66ba7a0a086f47db2e87f770c3c4cae2ad7508bbcfbbaba2936aa99a2dda5e79c5fba328d3ee8a5ac9da989af5c83af068b473c3b52147f0fd7e4046f5557c2dcb63d6709e77811321cffa4450abc1c8d7b37c67e97dd63caabb18b81a428bd5c0afbed1bce113c1fa8b7cb501a3ba6fcd0b07ce74fdbe936d78cde29cf3c43efcf6cfc9bd5911a3530a1de073dce157fdfc30344f307336ad7bbfea4fb00e0f32a552abf791db4e1caf5f77087efc74b5d127e3dd11150d190857b9700f4c8d6bd3d9ad7af36a3a89b0105b8c82d7a8012b53c45c4d71ffd4fbabea6d3c9508f14217cbb0f44e195be247922311bd7379174ee3ccf238e11a022a27fa92e961ef124deb92feca1c966bc7566ffb122ce55220a2dcee1b2d514d67726079a9000625f7fc3ca3a7c3d494176a5dd01071f63b2ede83d8ccb3a162e298d917cbb78815c13ad9f1b5156a8f1b9a2a81dce376baca447355e543e2ec191f7d7d0c75403814187059a3f31cbbf47d3306afabf4b09b526825fc9cfa7942bcede786bbd53ac87351a1f9453455fdf0738d227fedf2c601cb134d23fab44eb590c9520be9aea7f31145538630d8ff10913721d93c430458d4fcb5e3d9f1c2a204c810e7203748036d4baeadaebc9d38f707fba0e66e071d99747bcef8520ff9e0a74081e61575188ec2c009b47d4f94f5c6a1e1f4a6dc6ae4d68dfce0d35c8ae3c4e106c5557e790eed207648fc7715af7cf18a63de816b6da8ef6ba7ec5b8ef80a731713b88e04d53fc708f24600ad3d02418564590aee149fcd99cdd2b712116b81c2b93abe4a038c26d3af5316b2c9d0ae558d7447fa5ddd6c2fdf905ff162b4a71187c0034c5708d2b56f12585707b61ee428c90256f32ca6164555cf094341243c69823ac88fa40b8620e09389b00a41d91b9e82fc3cc7effe9159df4161341fb96d99e159c9413547abe2d78edaae3f1084bc168dc677b4cf4926fb5495b9b9f9e81bc1ac63b063e3c97e8acc984b41065f3d50449ec233ac9a3047dc57e3188217a7c694665a7da76785a54b308f40457054ebea51f543d20a02b8092240eb6fb97d32bf499a8daacb3272c576b00ebe5c5816c9d4b9b78997ba0fdf48b2e979cbe36e984f9698d3e802b4c420a53f9af3cc76e5324dc7747cea642b9d05a00d11a25313524be781e2b0a416d23ecdd397882327115b1fe29f560858e1e923cbbd5e52cfd048c3640db55a7b61ea75a091f873fda51ce1c09f6cd9a43183e8bfbaeabbcb147eeddd4c5ea7c06a4b2a026651dfb41eb4d380c48222217e19210da053a2a482cf8427693149405cea743d6f8d16f7cb735e1f90cdf581888d44d99392fd9f9e63a7036aeb669530cc4165f391964295b51d41dff57ef5a484880571260a30db0f4266aed367e623e966cfedaff73cf02630499d235fde583b6c3ce8ede6f9719d737d1887bec8e33ef8838d189934b209655590ed1c770e8dbdb7fb64c82826bfce61faf90d893816a2fedad3853d7ea2b4de4febace9dcef1b2c8ed9988a8444636b1f8d5f59373605fce4b00f2166a6913bcaad0061e6eccde3594758b27668b16a555ce7113787d48d1376205c047c873f2a7ce66a2d8bd0b8b63648e4fe531160962ac22c3272832560e81fff8ecf6c301c5cca57b34c8b84d532a183df776ac0426da031acac35f9e8fc15b1946131869e85b9c793366f0168f26955f69e64d668dffccb9a8ff9074c3049b2109b7182e0e026ce2a09462480b47496b2ed54290b7a06280e5abe5cfe3ec61cf7465d59a5bbe8c9dabc41d4605138c87d0e9ffd637dc3e1cc40f049ad2c38250ebdd831eae54821382dbdf8c95d31857e83a9c229a244d5156490ffc5c9394d646eff871ab08ab26ada1f583351078ea2f4d5aea175875c8c46e5a36cff3e8d2f37938cc60699751f2f79bb83bc77552edc7db059e13585e3b8733236c01a5b9c52629ade571652880002436bacd55aeb2d3903198868e5c6140c7323b7382e6d7bf7ab34c7d635922dccb4b19b133b1c927af9bf13c71ffe063069e4ecd88efd5bc062394c8e7d6d0d57d416d72343b07fba2612c32dafbe0e2983c4f3b1f910f4bf3d78a8147f502b5c80644cea84cf8d199d97b9150074605eb0cc8fd630071f280c2a2c43b9bdf41772a0d876b0e2a629f389ec1200983863566593097af61eec3f0d02473511e49b428cb6f1d07c5b7d004d12a97515473ae9890a981b1c089989cb01c1ea197483601e87c7a7f5217c5bc9f63fe6c706e9e93861add95ace940d33c1b5d5622018d51330e3742d7462637e3fafa7d34734ba8009879b4d8147898804be52f8b3b6a779527251deb347a4aa45eecec1e4d833517b72549081c0b49ab5432f4798283e47f814dfd667bf8845d1b7d1710e91e77e2925a384ebf537cdad1dec0246eb50ea1957b353a41a1ae773a3d46246a1ff6ccb1d3296a5443deb38f48bee3eb1389bd6b5efe12499b2a01669da940f8ef592a7df683c92ee26429a0fac6e74c9a979edbbfc3bc98a291c2aba363c51f1c2456dd6a43e7b39a3f3c944fbcb9eaa62bfee78731145fbbd4eeac280629af55b6750b66061a5557c631f468c642fd8813ac0fe14d16fa1649092fd3a2d6d4736360d01d386b03baf403fe24ab8bf6d70641bfd0c877f511e06595c025124626386131f9e84b14867957e43e8725e7e2d1d42c28798b7b98581b599f9c0ea4db49cb77fa0130628d5545943fe7ced6913d67c17fa96ba3ac44444c8a9d35631c0cfc203bb392906c67b8b2ff0155c2bc29e7d1c954125fedfeb7d3f88fdf6ebb1aff0f57d81f135ccbb84c5e4011576fc0a7440932f5fa570384b23ce242f42f08cc6cfcff47f6accd4d96c8e62f7ad074111ebe19654a2bf1884000e37df146ff397530abdb3a8602244bc6d314a04340735693dc0aadc8050ff0f0c60ef0954beaaf2b1715c2b968ffae8441dc136118e552eb36349f575793ebed764228a98235083808eac99aa30c79a4157c194d5ec2f5e305857b369638a1b4cfbdeca7f0864b812be1642e274b2440ad433c4a819fc359e763ad244bc50bde7726c01ed94e8fb4fe4428c7f23ff67ce80f86e65cafb67905f245d380e5d572596c6a790d0e6619556ce1a61bb79f4174617987fdc703d5061366347a0bb9490934aa50c91808096534e83326c8ab9c66435782626fea8197d36aa1b31544465e4aa9ffe2acc5e58fc95217a1bd16b131acfecbe417bd77cada569c7a80dbec97901987637ae2d4f7b7ab0dca1b112ff27cfb77978a5e6b8bbcc8fcad7162da06a9f8df043e096ee3e2523f5caa7bf97c5031204cd0235fc487d41519f1a7f7753075a4a32b8013cf668cc12fe31667bb353bbe672d5dba0a58f94b19e6e119b5d9a518283b5f98908a6f2eeb51ac027e3f1b859fca5c2488294e24d74107d69377d3ae94daa12c3717867f6d65f1e4c8e3ecddc54ce0f10ca37266129ac65e2c822792664cb1021a295b4dcbf2e96b9e5b9dc7158b638425457596c09e9c036a96abd591449663bdc77a83171804f0ec29ba86e517f781606d8326a1fbcc9a5d56799b7cdcc30df048a51eabf2b1b8bef4e08a1bdfdc23a6eeac59b36e5ec94fb026b235deca0d0166fd86453bed59186d455bdced05f84183caea811133618b285d24379454fd19adb7c2376bbbc7e329e845d3c00e6938847aba96ca0ed0cc5b4a8f7ea043589416251f17e0fc1a4f93399ffd55cff8f83af452c50d9dc05720f60c8b3b381447bf402c1c0ca39956846276cb91d33892374e7c23f6eb9d9ef0b471e5d59c24b855eec3ebd1c0242061c4408201fa99b1c4e07fdee26f4b0fde7ae5ae888ecff9af9b694712c927e975f998586d031d676bddf5fc1d02fe97f0e72793c36ee5aeba094af331d5ed0a8678db7a45dd2b989d60ab78d2f326606a2549c96dea53dcc8b55718422fc90ac51be14b24837ac1a208092825f62630e3295aa8cd14dfff934107999328693805a3703bf96f707f3dca63b58a035241d7152727b9d204a72901ffe789f9c6f3aad1f3a8106424b57c5af06891e7ef0cc7c2aefca3ebbbc6de333439c6c5fe0ef04b196e8d6200b7abfe66d929c540362a5ce0c2e599804a92d1b1df8037f5f50fb778a8f5cd9a1bad13a3992aa69bee14f9a3474eaead64f047851dc9c96f846630fbb7ae9036590b2aa6836e5c575fc8dc7a26bdd9028158ab72ac76fac0867a848b17903c2c4972bcc18029a1d6e17fb8ac8f649e16db04dce46d96f59569da24582a67bf552b83402ba3942bf58e0cea33237d8cafd144312d2a58cb1bae91673288a7985d4d808cdd8ab3e21a9dd24eee69a783e5cda19ad8b05283883a59cbcd41a867cbb3d3ae6f4115d6efe58b9817713ad87b0abe664565fdc5ae0d84b8d1c5c4be1cefec365c8aa8838e9e76a27560e82922dbbdf493520762161f387d7786f6f47b321986bf4ae6fbc60537116b33e5a654bb7e36e8450b87027fcb9cd2e3cb5db6d88adcb8bc051db68fcef7023a54c1d5236a194ec111f0a04c1399c1d70d5eb0a4d6077b5cdc3d4baa8bf405bd7a93d20a793dbba174d01cd5e2a585c65217b77e219fc86af76d0365ea3e1695923978be36a90516353f3862d4de034dd4705ec9e09c3229649954d8d630f0af0618b4fffbe9fe548e4331b8e108729ff2146a7d087df58733327a2038595f2d759e4bbaf8e09651def52c045bbecf6bc50ebbf8711395f4ad28b9af806e8b2080f528f3e97b66db5b0d9280fe57d0b4132d57a9d77ae5427fde984f01b689674a63375f279a45bbe0e590e2b7bc0ca7449d9f14f2c788a91325549c633ee08484087bc279e79720d37a546d7399153b54f09d4f58864d0445c3bcde33d684440c757602d9f3de0f3f189f14e78fcaca345e54d5ce84dcf2ddb7bafae9ae107487238950b7ca2cf75973f616ff8762920be905e1530aa535685d7963108eeb5d417dc1005cfd0d6aa1c02a1e3db146f8276bd9eb3a04647db5f976fae3b76c565b7dfeab7ff149e2cd75dc453dccd2a24f3d00850b967bd4f13327337bd9445e9ac6db273f4a053151d17755710d355d0e3fe00a44f7e347612278163e1853f5a60fd3e64d63399a464a6f16b18b197ceb7f8f7c58ca7e47cd9f8275f98778799d0578f7514416f8bf31a37fdc82f651286d9d466e996544041c3c9862436dd508470b0dbd5daa9618b8d0b6665c152366a67999a96823b3f499d635ee266028e25f45e005624c3b05573b69249f9c001d1041cd7739e0c608075c4033c14226da26a120570b0a5212be1950cfcc1b49644897e7337c8c8cf84354cc703166ec8066caa4ae7cc2ccfa6849e68559ad61ed2091f546f5b6b3593cf6ab5156c4616f02f55570ca3baa2e02b38a9024f3f956abc6ce5fa98067b0b458247295c78a7f1141028de636110e2cad34fd8984f671946d844344645d41fc1afc816a234b24388bda2e81246c3f077fcc4a57f0d485e1130035f4d4902cd48cbab2f408b1106707883d75cc5f691fbb1a76f894da281cdb500acba035eb8887a521dcc76d732f7ba570c346197b40e2f834852447c81374ba730ca61855cc5fcda66ce973521fc53a69e383197c111f0a4f2ca2ee1b0a5448994c38cf4866b05bd2f4f49f360cbcf5eddb3db78a8737f43fc89c838530d2fb9d3d04674e091b52309fecbd979bc89fa8daa406cb3700d7f1d1826e4fe7a73d07fc09a1fe6a164fc3cca2e69d7f45609946cac330e55d30bd02921b0cdd35d6f3df5e2ac091858d43ca33d80f59d2af9754d4903f8ced98635c0bf561db83a93ca51652b0246affeaa6d8f58808d24bb42682688083d89dadf93a1e9e80c9990627e6aa103d5ee18b216b8744657b2cfffe2789845549587c9663feeb566f1641a10da286a3c4fe03765292ff17d8b0e5fb05922011e3370e8627138f24e16167aff4ecc12fb9975bb15a694f7ceb8946bf939ea486747bdc3367a35c8b6fca6cb9056d3b99ca8386f4324504a9d74d685ff90618c8ef70dc8dc4599b5eaa57272532604d6dca998c0b90c2fc1d7ab9e1175b81f621800779b6bba6b7e0cb21b4cd8a22dc8ddf85196c417817e6f7a3dba2482826726f3a49173d2f12e161adbb5fd3a535a3a81a3d2a6918be235c39d003df2a9e79f41e9d93b082fb5daec5637e812d32d9786838c98870fb2915d7dbf8cb6dc946ee7dd47cb766287d73677075c8ec1972acb954cb1dc307df3133c61b11c6009846e1e4a5389fd3cf31c582a007e637cbb59e3f4dc41229aec7a6665c6bd55f0a9abd7695a3aacc5ada9edf7a8310fd868619d079147046fe514fcf3e7a55ae550f552c6ac93a704479f8f9b2c2ed9a6ed6de3dd8ab8afdefeac83bf90beee2fcb717c0c62b13e4d728bd22b951dd06e6ff99aed3d5bf0615907d4d7dcf6386397672325cf6d32c514fda484e3ce7053fe1a149806fdf2b71135690fb14719833fae6c67a53a9f1ff271fd38428b6847674a086189c21d618cb112bfd606775d78bba2d3c202a4eb47c5516d9b13796f63dc203907a7049c13fbb95c089c871accadbe8b21da0440c688412ee9d24d1d0039fd3611abfcb41660d3fb27d0bd17c4910389acfbfb409b34e9284563395459296e38895665ae3df2f1266fe9cc3730a1b751aa3dc8c17f4a49f44982a71de7b35ae65af4516ba405543889a7ca3af241a4345ccbf6b24e38d5c00ab09ddac1953b9aaf40a34780fa1dca555be53b4df0e43feac6ece34df08c4d0ae80dfc50941a4539e6b6361d2283dc6e5825920cad550f8b3f9a323b1b5c43b7b4949499fd9d4b43a129dc83f286143784d6eaf9910a5329da4825ae7a12911952b75af5c62243051515f58f95dc58653cb10cf95e18ad35dcf958f8a84f7512f8aa1269d5eb9a0d65836a100d71b6c3149304fcb618570e3a14f542d2cf8668a6f9dc670e801775813c82fe6af715f17651dab57b6cf68c06398507af4f7ac9d56b1d503cadb0569bf18c3dd0e705606e12bd1f6c756d98e56f179d333fc919774432945c802c659b33d84ba2480fc3ae75fb1d06ecc3e06018a5751c1b881b99dd046998383487cbe808b92e80a112bb88b3d58ac98aed7aae02b3492ae5738bcc7f21e873b593b91fe1330067f1516b6d1048da75964c',
        salt = '977ecc74d3797ae592fca9643daf795c',
        labelError = 'Bad password!',
        isRememberEnabled = false,
        rememberDurationInDays = 0; // 0 means forever

    // constants
    const rememberPassphraseKey = 'staticrypt_passphrase',
        rememberExpirationKey = 'staticrypt_expiration';

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param  hashedPassphrase
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassphrase) {
        const result = await decode(encryptedMsg, hashedPassphrase, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        document.write(plainHTML);
        document.close();
        return true;
    }

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        localStorage.removeItem(rememberPassphraseKey);
        localStorage.removeItem(rememberExpirationKey);
    }

    /**
     * Clear storage if we are logging out
     *
     * @returns  - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        if (!isRememberEnabled) {
            return false;
        }

        // show the remember me checkbox
        document.getElementById('staticrypt-remember-label').classList.remove('hidden');

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassphrase = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassphrase) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPassphraseQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPassphraseFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassphrase = hashedPassphraseFragment || hashedPassphraseQuery;

        if (hashedPassphrase) {
            return decryptAndReplaceHtml(hashedPassphrase);
        }

        return false;
    }

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        let hasDecrypted = await decryptOnLoadFromUrl();

        if (!hasDecrypted) {
            hasDecrypted = await decryptOnLoadFromRememberMe();
        }

        // if we didn't decrypt anything, show the password prompt. Otherwise the content has already been replaced, no
        // need to do anything
        if (!hasDecrypted) {
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const passphrase = document.getElementById('staticrypt-password').value,
            shouldRememberPassphrase = document.getElementById('staticrypt-remember').checked;

        // decrypt and replace the whole page
        const hashedPassphrase = await cryptoEngine.hashPassphrase(passphrase, salt);
        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

        if (isDecryptionSuccessful) {
            // remember the hashedPassphrase and set its expiration if necessary
            if (isRememberEnabled && shouldRememberPassphrase) {
                window.localStorage.setItem(rememberPassphraseKey, hashedPassphrase);

                // set the expiration if the duration isn't 0 (meaning no expiration)
                if (rememberDurationInDays > 0) {
                    window.localStorage.setItem(
                        rememberExpirationKey,
                        (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                    );
                }
            }
        } else {
            alert(labelError);
        }
    });
</script>
</body>
</html>
