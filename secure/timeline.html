<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #4CAF50;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #43A047;
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #76b852; /* fallback for old browsers */
            background: -webkit-linear-gradient(right, #76b852, #8DC26F);
            background: -moz-linear-gradient(right, #76b852, #8DC26F);
            background: -o-linear-gradient(right, #76b852, #8DC26F);
            background: linear-gradient(to left, #76b852, #8DC26F);
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>




<script>
    // do not remove this comment, it is used to detect the version of the script
    // STATICRYPT_VERSION: async

    const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 *
 * Mirrors the API of CryptoJS.enc.Hex
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassphrase) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassphrase
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassphrase) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassphrase(passphrase, salt) {
    // we hash the passphrase in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassphrase = await hashLegacyRound(passphrase, salt);

    hashedPassphrase = await hashSecondRound(hashedPassphrase, salt);

    return hashThirdRound(hashedPassphrase, salt);
}
exports.hashPassphrase = hashPassphrase;

/**
 * This hashes the passphrase with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(passphrase, salt) {
    return pbkdf2(passphrase, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(passphrase, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(passphrase),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassphrase, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
    const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassphrase = await cryptoEngine.hashPassphrase(password, salt);


    const encrypted = await cryptoEngine.encrypt(msg, hashedPassphrase);
    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassphrase, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassphrase
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassphrase
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassphrase,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassphrase = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassphrase, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassphrase = originalPassphrase || hashedPassphrase;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassphrase = await cryptoEngine.hashThirdRound(originalPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassphrase = await cryptoEngine.hashSecondRound(originalPassphrase, salt);
        updatedHashedPassphrase = await cryptoEngine.hashThirdRound(updatedHashedPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassphrase),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
    const decode = codec.init(cryptoEngine).decode;

    // variables to be filled when generating the file
    const encryptedMsg = '0ee622e36fb1503912aa5a78f08bc5aa37313508594e788836eaa4ce3e1f26f0bfc4d039292d1219f3da9cb7d7110be91f56886a96d80f35f1e8a44a73962290c9a62fc81403eabc9aad9c6ebbf2fb833471f9c25f06661bb07e2af6f2f6c9d546ecde71daaae097d6bf18d9d3d60b0fe6d8538993c3bf55776c6b78dc081b7d2b3a919811c39f4e976c289190fb6bafa81d9ba97e8c56e428e23c5bf18331e906ce7bf6d9f10fb78884ad74b11095f5ae561a7bd86b0b0f76d43d209cd8541a5c8f298cf250351b9babe198dfb608c20dcddfff7b9163a86e0ad47e05386bb50dada8c1b15a7e8b087b0853da072894eb72741c0f30bc869c780e18290fb40530b3d105e507c8d705f90a6dfb649a502d51a57d95db0c9c26b90d3d60d78370986203b331c7b44a30875a14a4bfde0d6b1c64687726b773d88dfe63a8e90f6c63e3566b2fb14a448c869805f49af50bc4cf97eff43f59177bd3139d48d18535a2b7580264c33ab0d96eb53473f82cce878a3377a2ed97e0725d84204c9fb174b0fd199ec629de75b788ed8f43dfb74758351600524d63b47a5901d92a3780b168f7f13cb4efb341051e64155094c47e71b80a5bd88f3b571d328bdabe8432b8f4c35d01f38e0a0ef366c6a6e3a7501d250c5f009852623c591e1e6f33b4c2eb536e8ace1de1f6fbe40c68971662fbe97acbae9436c3bd4036d56c7f4c9bd410155f5930a92e1ce539b85d7dadb2e72ed78bfcf827e4e5221c88f1d5f9d6217702822fbdbb4c93df8ee6747a142e840ef9d99108da7cbc23fccd605f9494035ec1613e5051a105ba171811574c0d491fb8991dac320b2d2e0ca6c64c7ede588bb50718ff5c718142cfe5bfaa1cbcd154ae6050747bc1dcfeec289bb9bd44a56225b6d3017b5f179965ccc136193e17596018e5dd5e21ff201b84d94866f7b5a3f978b5deaa2a10cb6c7c5fe70a937e5e64f7716e64c77e94d45bbb63d66c28fb906d41e255621f1c4aee4f42351e398368ca30b7c7f13d5c24a5753692781d0f62e7eb251083de4f0eb9f9baa0470b12716e4b3236d80d612d26cefe85e50e5ac62f43fd059e290752e435b15c8e39acd863fe192674ff93034682cf0e2fa0e55c6f472726f6c16b0ff00d574cc4634802e65c0a9c9a4f48a410b4456b92355c309b8051f6ca11f7a3682b42cead9d4fd8589a7748cb03ae15e9487f92517492fe6cc77d4cf64927f652ba74b29a04e7af2e2c79aaba460da1f1178485d961b3fb20f6ae60622f7a9991613498fc2d7e9beae15d6fd15e96aa0b00a09bd61efc961b9020cf50ebaa7146b4d6f87624a7d2bb4e859f259eb14479a49a9ea21a7905666c941f4cfdc6dde8b93bdf64713a3b4364a28aae0e6d1c3a994730d129d7e9add6cbe757098ed77ccc6d09c85fc4b12b026aeac361c0e9c092f345ca2f01fa4d30f7ea5bc04836edecc963368069f01ac3392735c5a6dbf397fb21fdf05a4a163f22678daa08f8fdfb6e67e3db7e04de68cad98ec928c8212cd7f14c62d45ae7b0ca2df97ade44271bc74f00a9e0a4838aba9aed4563d6d4da28aa627f87e3c5bdf507c83412ce4a5e6a5ad5afd685e79525cd7c221fd60ea8870ed82da2d0489647240f576885896df6644015ddd44e4e2cb39f977b2ee797a23ae5ca53c6d656eac36e3a50663d1ab7f3345dfe37b73b6bcdd398757bd347e98ae66eda43a29c476c0af542ce86d66d457672fe04269e2847093f9f00762053398a6b7691f3d8d99a1915096310a3cfa8484814009084dafae794e7931210fa11edec1461163566b1da33b5da5e9597868604380cbe86e43ce231347853e3377a0a94f1cbbca9cb1b6d9cbd21dec4a92ec790f2f709f4f0a51f1e49051b5996aff3e744cfb4d8488fddcb12c7179194b3f27ff1531589a07d58afc68c564f4201a58003da5d90a6afae2f56372487f3f144bd1f00beb9ad2e4d402d40298563c2194443c6d994b543ab6b0b032d41c3a46f2ef4079d067347b3947e5223ec70571a49f2d78afb082ea1012ceda0a99f3231260ca4712912146775034ffecc62619e9f7fe8e2d8de14dfcc5fc2c739c2248633e7d89031d086d6606ae55f34e9cf66de228a26d67518a5a3cbf7ad8768cb6129f3c517a2644cdde1f6661d3cc591173100e8cb121e732b4f02acfb3ac0609cdf09d558aa061a5083154dff0e7ce51b10eb39943de24d71d886f7d966e5cf8af841f922a54e4beccb674de831175ced4a8c7362efe8eb3ec8819a40c74f0b4f318abf5308913175ec88302d9edbbb3e636e49a664e713c4fa93b05e183075d31695c5aec6559d4296dac1203836a1c5f72755e46502339cc855d9076910f1fce182463039cde473a72da41395011efbca352af56021b6c5c89d8f740b4e9235c8b793e8afa2a7bbac098937c6896f6f3e7d1715ae689a4047e7da0337f91b917e885193b6580b6aafe818145f44c53ac7972c7f3ae12f3698f6b82621c7835786280e1a505b71cee1fca741f5fc73308ec2c821cb6463c74dc0409c80ac9fe7633036b1bb081a81d0fe29b40819d2fc7ba95bff6239d34b47d2d6051d02e984cc87c4e3ce4af2792efebafc9f1a3e54a568f73c82fd13b31b0d7a1e77e9d8732cdc3577645ddc20bc9ffa9bcb83927f57328147db2d2ca148c0b226b9e7f8f008bfea15f68df6bea9b66e26b1387e20695fce086c5696f42f0da8a07edf86d6ce525c8aef69bfbd286f17706aad9c9994b12740203ce960c00fe988172a777b3f744aec397850ed13a6c1aacd326dc6057bf60263d1b23bd9e759342eeb0086741535f27fa40478b89011fbb2ced394f9c8dead8746ebf8f2e7d85c26d92c3b4979aafefe34a1cd2d4f61c3acc610aa8acbce5fde581d61c5c41f850702f95b9b0ca2a4c3cf4f27491a0248895d2dbd4ceabdb2a8d095f120bcb396e0c8afdaae596dc5b8c00a20293f2611273268c605db0ea1d5c67f075346269194515a962f77e9b1c260720fd86f5ffcd10711edc65020d253b9a37887819d2fe141de216054a73dd9a344b7bc6484ff5e4a3274cc594f4635c8d25b204675f2133a96d986935e27ca12629572287887905630365cb45f549a7c98f4f7fbcba61054f455b53a8433e2161c2d50e6b66e815952e23551bb3fcb027a05d6633c3593033f859d04354ee7cb2c1c495cfb967ed40dba8c1c385f8929f6cbbf8ba7a4ae358ed6b50d2abb271a1b2318c7788378f5e3bd127d35fa88221d9934f4b2c9d277c303bb0d97177562f9cd1a8aef17e4b3d937959cff08e1277167d67307650c5c095e6d8cc245bfa78064e3757d075180ade461a0707748ec9547f46427c5b58722f33e5451df93328583038c5086f03fb44d81baeefa3e0c33bb878de9959e7cb47c1992953ff8150a4a4fc3db714c92bb14f45c86519106fdb297c858db80aee37fb9cc1c7b6abf090539be38ed0f8ae997e8ec49988d4943bf6971e0f131dc88ceb75ba904d9f7e372a63fce6552945ab979d3c74982bc4f5edfc02980fa29941d26469af36e1a0eefa47a3acdaad1de0a5494a7d38bea0b2c7fae3cb4129b334c83d4cedc6e6fb530da7eeab18e0414239070b9a7539bfe048386e53035b2e2a0d39c825f887a7263b78436e189603ee3e63b3cfda8ec43663b9fd2de410d265cfdb5fa55aa5db9969fab6fb08379862a08c39ed48d77a79952ad151f779cde6de215d55b425b2a632bfa454a7cced96b45c8ead6ca9c2ab2899d11656a018335a9ee21f058e99da330ca4ceb4029909b7e1eedeb701b81e77a0d2be527531bdcf74177e331caf420a3192ba2704b30c0b3eb6072b8ca4e9d9243776001503ae3209d4404175c9405fa9b961e711f9880e3b2df8862fa06d8ad3093b8fac279b48e7da6c3ecdfcc1639dfdf022e6685575b8c40035404595ea8337977c01cf668e54dfcabf2c2e986e9e8df1da87558f2b14a1021f901a8fed8148d1c0d9871f338514b6afc2ebd2b79ae56cadfcde2d9a80a6591c7547251ea9137a49ddb0e4247123781368918c5ce9bb90c8bdc588c4d0ea46a646e100b798b55ae758255d17200a7c0ac9f1c2b1180320d34475dbc5d2e66d32b1596a860884cc0fdfb7753ac70a6ee81246cda619b4e10b6120a76351eafc96571e90b4aaeffb6e92548ce863064698e224fae51d48933e3ed82d969980b6442a4a931723b27e9132158b4eae3af26a157d6a8db044618746daec8eb752980b2c356f0fd8764c1b9bdad98612a3c15978d3402ebb5cdb984c349b5d9e0426bed52c81c266bd651f6668f6ead2bc27aab77e98b80bd22b1eeae4f9218a8528dde2d487c5e2515e47750da88758591d3499531d1efb27ca8db020caae9cf05b5462b80ec73125338722d00da5f5fc53fd711903727c94cd79545afc170b860c47b6b5ac58e9d08d7fa4696d57574f76ca63dbca1a2596d4e1c31edaef76a318e17464a6c017d472c2a02325068ec6e1c0de485d06b915ec60764924a353b7bbffa8d8d6c31579e90343290ab68cfd11e790532e5e1a81481c3f9d7527c619bc18ec319e0ca43713ac427d5600ac1ee7dbf8182af51ce9c751df172ff6905a8d0df34c09e7e8ca744305cdcfb6ea59f2b2f1dfdb6f3b96e992afcdcb7c0c31cdb32d026a46334d26c6a1f6fff2444b4a8d16bcc5b17550b8eece25966157d452c9ec97cd399b6cccdb035fe431d6c1f948939c218406f236dd2e2a4384d787f7498e0de88efec6260315c7e7e8471b4bf5ce2d3dd318bdcf11ce7a3fb9df3bb558996ee799d48f6f56065c3846e23087daf21eae9718adda9a875b1b19bd67ce87444bb67076efd5341924e549e34d22874b589a21ca2168cd9bf77c7dc5efd304daabaf5c68fd0b235b02fb6725a1c23cde826f26f565c1d3aaa4367aa777a89c441b4bf98570f84f715ac195c06c86fef8cba5b8353fc7c58f9f73b93b42bbaf38d96934e32b8611121c4321ded68c1351e7ead9489166fe74e4d7b18677b958432ec14277ed3e918d1bf4f9ff68eb06f728dbcebf663235a9873bdcfc505c2312fd257499a44ec59e0a535a0d32a03995b95047954a66d205e49cc783bab9f979333644770cf189608ee5f9a61c3ee20417b570dc11e53c9bb328577af629497aa78828ed2361a5a36cbb3caf839c9b04b248f5109d7b0d87e2dfe90d22cc20838d560c520cfa620c28fe964b139a86d13965423fffc504e5b11e07ee02b41fa3f87de7a456b853566be682ad5c294b26f24ebad9370ab068d0aa2b659cf156f98a1e84da21031f7bcd6230387a6bc7e2e1c06053b52b683ee48b719e1f39f271a37bc39d5aef2a66b1decfdc81adf96b8b4d370fb601071976fd5b203eac0299ca14e5519834c07cf46f268fa81bb54f00dc754c6a162a27269843a0c4d2528201b1bfe1076cc885c20fa699dc0577d09220abe52c24e81cd1699d0065fd96446b98ce4b08a59c9d7ee746709d26c43c46eeadab185c7463ba9dd21a1da460d103b8f5d40aaa1d8fa0332e02679bf33dc3da4b06ee06c7307080dbfae4750822741fd481234abcdc96e0f56ac10fa9597323fd2d1ab1b54499f157427b831f09764c03f3e9ce62e612a742d8afcaa6c5a0698c28f870ebcd84dda984ee7ab0f4fc4b0ef67cddcabd9a526c0b11e9672d1fa1acb526cb9fd9f3db85f955e7a8639eaab9559e49b91f37c9f9fb45fada548063aabbebaa8a9ec8ff181c720c0b69976ab509c3567eae3d5882911b4f7f7a9b5d121eddfe1e1f2dc9b34162ac1f1a3de872190b507c4b9d074cc74e8fc858f3c6f0e9f15c5d1f005643bf36862ee7951d214d9cb6f2e79dbee206edf544fe6eff73e2dbb807f83e6c819f17c7de32a0ce982eefc4a219305f08cfc54ab1e63e21abc78d692d68a83f4dfa7e0dd9f161964c38830a03555f9173419a8f33d5cd03b84b73232a1541442d4314db7d4480ee4505ca1c3efb7358ee19f8d62d5882a7b11f038bd8ddb754f3ccacdacc0fe4ede3eab09d0ce39bb846a45d32ce1a29b5327c7ba2aef9e0814f77299b88343533b4a56a41d2af0a20b0fdfa5bd5ef887b5b59c8222812a2e8062477293894224f5acebd639192f377c334d2dee61d10909108d642aa8d82e3ab7b95daebefc2fbd6674e9b9cee1afe0ce9d79cfa7ab44410eb9d4ed95821dae86eb4091850dbe0170f8d6333796a6f1d919c1440b5c0d6026f7ed9c8b8b4ca19a3c074a0ccaad352bed434668242a39c5fff4aaaa032b215f7026fab17a5c3aef39ef45bbaba27be1a238ed6f9ca82f609c41fc3c48d3647dbc28460a1edff9c3e060a166e6357178a94888c3c6c1b42b5676829a84c6d384dcc36b03687543236948e2ac1c2bb69d09638d0f23b534f2affed25d9ea3e9805abcde515bca50d612289915f561fe804b9ab8a8c5aa745c7ad301efca45072783ed2f2d495429daa2a81731931444474cec9010d577aa3c24db72966cff9dbde25c4e5575f8657bbe235aad98d13a3693877054cfa35ab849e430667c8a69664f172fe68e9384944366fb324ce550a0d4ab35db0d3fe43bb362e02c60666f650e16284975d14f69d8e99a77a2fa4b0aab9922992d4b6e7d841e8b32085e4157f6c149d21806167ed4579171d533e23c5797f7d87f7c8ba64cb4b5ef6a09f64e2e10771ae7b8bf4e81b3e6c981e349f63f4935c052f53ed6a82467de38c721f2a1cab41174cb5d60a2a063ba02ac193f6f26c18d45478fa8007df35e9fce94ecc3d5a93a8c736a496e999e0857c871c93f0b2e702951cffddf96b15eb912a77412d38c3054772991c468746827470565f607cebfe7e92c5f567e7504ee05cac69ea4c03dc2c1f237b2996353929f85bdd2c2d9e3df2995981cfceaf80bb9fac69695a6cef45cc788ea5b98641613e9d4a961fcbeb50cab5a8d37db4a76325a70c3c907312b3a74e51b0f088c1dcb63ed8d865a76bf8c55f2c603b3f3c20c468f7211bce568a8a9338421e358c96c90d349c4d02a80040369c5f0ae1ac1000f4e55eff35f3ff1d9e9b2c10cabbe4006589b675cdbc1fc4e4bf2116a5f125dff8af0f464ab27583f6b5a16d8d280e2f185fbe88f7ea579144dcc15e7eda5d3158f184fa8e277c4785fe33ffac8661f145682f9ee42dccfbd653fcc93dcc0315032dc0ddda6a43f75ab8bbe0f50b6d9861ceb593e0cb64f2a3ee98e21a1e946571b7549ca142415749b244ddfcc8120411bd1e7a494c3bac8be73faa2923918b1f66cf5c4c02da08c4cb2aa77c63778feb717d3fde68608fba6bb9f21e55635ed89b3e3e80dc36902154fc0a35a5f0f32e8fa1365614d973ad1389f25496b473e2de3c4f50852bc72ee875421eff065964ff5368ddccbb5d38b1ccd0e3fadf9131b02cce56a27a4675309abea3836022ae0f2095cc37988c9cefbfce73a5afdc1dd188fe881fcd51739abcc77aa7dfc1bc8b49c0ade57ac52cc25b73482835f826dad832fa8ddf202e4a3c4b9b7a8d1350591a375a29de2d4db5d0fc5f26e6f9acce3a77d1232246c79853d3b6ddf222b8b11f795aefee6d6ffafe32f96127436278675b8bb2ca6c5f21a6da463f73ed619138bda3fc2d5aae8d1320cd19c9f99ebadadf1ab95826c3daf485d656d67c32922a05c942d41906194fa05f5787325df97b7b4a06536154ee716676ff2738e5ee58aa526ca4aef249e43704527598e5c201e985cd5da4a7621cc59faca36dd0f854351f2a94bcaae455ec2098921ea0ba33fcb241e7852df993ec7993fe2383ba443c3a6ac88b419545eecee0a4de87e57a47eab26a6daa2f56fe0ba92f0891b6e3effc7ca2114001a1d31419759db183e9768ea372fa06be20278203080ffc2c3b7afdf8c2713aed46ab16dc832e5abd86e66572b782c8b91538afc22e3e678c813af6da4a19192af483411fa61f1ca7e005dcdf8cc9724685b757d48b83c6eebb9fabd30974b302ac3cc881eec33906e6e7478143a40c4929b98091793ea9828898efc7064b0d0912de5e5a66d0511381f3edf018adc607b983fc8b753be64bcebc65f974b5888b34bef576355903709aec7c7ae4ed8b1722c39cb5a876b281d13e3d10dafb30703b92a5f0f2672a0eba7a12b7e939e1cce12d34799e941c9bd680681f905df92e6d455491bd51381b7af813c084d36f9baebd0b150f095d602aa178a8341813a3c3dc6590e472fcf9f1384e7e8167545706ddc15837c1760e5e16abc1fe6bc11e30dea23014a30a1f47d46b4ab150ff2511acf1f05eb242be89e03a8812b6459fbe45c8afc6a8fa054252df293cd598349a201572013d55d79d97d44bfaf09eeec277e887a6398fa6ae56a5aaa2daab098c86a27aae4045e2ba433f071a8def7f36986189776295b2ad48c39eee6e007f3e64a23e033623d3a82b05e40102d0243af71500c063d0a09f4e4da79fad6a8ed62e9e4777decb642e5fc434fc3980cd5646eb8dda8da2bef95185d5708a119f36d058a6474be130f4b7d9265b6ab7dd1389fe6cae0a7e7980f9921f2a5acd181daf58db7822dc253e6e9232f53e7426d1c484db29876dcea832e863378c7487f12c50b9b09cfdb85d912684068f02da038ca754fd1aa38cf6ffa2a56a291111c13a667417a390d9a2b6b85b360775e46e86a8428d7c41d80a2493aeafc8715391ce78bd2926046e75ea104f03569e756f2876bfdb3f741f3519079597a6efcae9b292aea6eb9bf55826a7c463a25b350315ce9e7d45119bf037ff5c739d615c59a73cff789dacb409706d857a536132654e5dcfe409d68aa16458b36f0b8330c2f09ace1eba36595c86c4b8ce850a1c5d690b9ededf833475732bccb919df2a75fb742659a1809787602d57989511739edf4f7b4e078c83227877d4b5d7448a12ce807dbd97142ac08bec21dfef97a5307e12e68fdd22ebd27e4c88b345e57d9043d1a84875f8bccc9e01a1880a381b4dc179a1a640b5fecc096c4da0b9496ca6f7718c07621e96551ab8580a302d8e6290257cf5ab8dcf64a0ed5c353e28dfbe59185ddec256b239998bfee96fabaa3f642047126c85389af3a2eacd89f7a8a35b3fc7cffb03477084a441002bdc2774c36f8f343991b76ac15d90c123e2138852b80fcf84d984c74e96b4a31ec2c475fa4a7668b407b73c00e530290c92256f74fee50e8432884ee86e8556a3745d3f328b1d7eeb5582c8f7a62652069ea0a62d1f9c5c5f4cee2db9e11b61fdbe31ccea71a0c0253919c74be9d7b7c27b365e0c5c2bdf82a75413e599b5d022492be9b471b6ad7156eb544a37eeb1c8f665242d28069e6c4184b3ced8df7f79796c654fef5a0d27430115a36e78ec684abadf754a24de4b3298c7d59f5345c54cf66406b70d68b558e19007d4f009ca7955ab9707d9b65785da9aaa86f831cb86034bfc7de3a18c1ec8cd9fcf9807047cd1520ae41312335d2689c050e3fa1f63261425af08ef4507fa0a58e86f8dcdd4f0c033ca36a472a8b3cf42812d9518f8c3bab884788eae610d9e9ea708e7c794c2841ad2a64f6365e3b47af904647a221189bbd062e90f73c58af5e7dd5d41f60a0033b8b332be64d5cff17772315ecd6a132e86119af47b4b4856e1160420832a7de501f6785791b2f7a14a1ddedeabd7f8fa69e08919e626a6058e6c09966d8287c18c0755d8b3e069baf89e27e4cd8bfd3fa01b9307c708ec4ebaa376aaaeaf680f3b0d25faa4a78e4964be72c4938704257dc5143dbff4dbcf41031f7c135f8afa3afc58f8cffd68184d8a7987e566932d59563b98e8187cfa92f899fa9df7ad298c95910dbca6a60a849a1babde97da773e0948d3186a7b1fffe0827312ceb9f13a97ba808a69947573a3156d2974f3a82270771522809d24345a9ab1933bfe17f85c6c70c54e6ecc09cd26af5dc69df51e391fed4c3c1c996e9a6795b881890e8c9058a4bdc24cd4c264b141af38fafca6f04a0c52e388cbf92529f3ad4b364df9fb33d2003a233d223b4648ab716dd745635358e4d2f24541c1af85266ffb30119f3d2e1a461a04d97474c8aeae5ae30064a4534a42bd1581ff0c625262db8f78ef4302840906b447535e28486705064a95cfb00359f78301adfcbe871490046587c6b2f5208df4bab9aef0766a82a9acbc7d748b6a6d65852f4332eac6339ec25544f3538d87119c4f94734ce4524b092c0a1b4f931325f3ff652e01ef1046606f70e3f03a56c27605e693b19704e35cb553bcd69fefc7538927c33e6df188054256b41fc82f163e09002ee60ad37a996287b4ad41fce524f025cd0a13ceb8d920dad32975f456cb85ccbae51c6d2137f0e3e540080ecabc4f00dcefefe2c62c2ee8156c80246f4e78c90f179a70988504304a2cedc84aa6c18366550e27aff59147c80d143d63d76f917aefe50ab40ad9674cc79439dafdfee4928e84530049e744724e8342d968324c6698f4b6bc89865ea41eeb3cfac0aaf98864434a1f07f189100a10701e61934584f3301136579f62b65e34bb140760d5299edd074bee3fefdceb29e80a9a9e6832986aab3e802023c33dc0912af9b38bbca93ab1fca7271728159987e8f4e650b65c25292bfff6968dbc29b25b8e33cdcfce1ebfd934df4ea9a64e0bd8c834e12e9aaad0ada9c49e69ff9ad5e0aaa902a71a08b7d0f6b7cf027312d8914cbeddcbf27017e571d98c760bb55a0670d37d02b279004a8310d8ea42495bb7b46b8dd75053eb1bcc2728c49ea6ef85b93b1b4be4c597e24c0fc3dacae66160e080790e5d674e4bbfaebb2c232a8153006f13160646714703cbb45bdb07fa6c9bc2dcc3d06bb87ff02274b8a38cf65b4e17dcf4aed3edad001c7592acc40cd7d3e1fd103f1054e11e428bf286b2471bd52175986cbd97e32dcba685bcc6ef94ef79793e7cd5168d36f03bf34e5be86b8a225cbcdd32cddbfe407b720d7c83435045ab243d953ebc738b31f11bd478217ae0d8c76ca4b52889cfb625ca6fe9b59d1b3392cbf0734e216cc3d8061dfa39eb62ba1a29aaabba5a2b4d8bb262735b208d0bf908d514b6b2f9559d3fcda419b84bbe0b0a34a9d2d39c874bab19e05f657c190889c137eb987ca1143e3c065c3075d8c00c66540f13479716d9b5b44e6c4a0a2b501c7c116cfa557935bf360538dad4e2afef8e7eacd5cef9da9081d049d48354e9707e2f08b9ab26b8ad2e15a20b5bdd8819fb30a92a8ece3f083b81eeed3f42ef5525496a525c54f4a54c74dc392822882e1ac42fa05c2afb48c45235072c1688b09396b50a7b1f0190774e37b089e1967f7c7ebda571c85f1a01f0692d6d4f804569a44c9f204b724e9d76e7af8a3344fb530cf607125ff9123fad2d5db1bd620a9bee7f51c9ba2fefb3977d5887bfce8d6e6ae9023fb16fceff545ba539e82882e3451a24fc03f5af900f9cea655af01e8f92157a94675d0965776c3f50f4c559e74fc4be1b598de7bea9006ba469fff050052c6bd482f62b7e8bd1573d7c0f96a7c6909387aeca6d1e3312ec50327892ce815603f177e018296ac6f1c8e1eeb1fafbc8258a0951d6154b67e663a88a791b977fa8d3469f5272f61e308b75bb4e34cf991c715556f45da47c33be84e090fd9a7e3e24d38fc3a86e6facfe1cdf8296b79adaae2eb856fedfb869838f4c2ec9fb36aa17cb1eca9c75b156b5c3bbb89e92272b1d4c53eb559d2b52ffb07dffc2f54c3ddf96a3e6fc5267f07b970d1bbb40ad5cfa92e3af8ac2762b6deaa712da7cbd66a12adadcae0cb06872749a4f2131aae6acd810c9796809c95c65bd3345c29b0cd8dce55726c1b40141cb2230c21672b6c2e4c98b8d647275c8e159d1e5c0841192e0ca0e67f8b1661ef5c35adc75a940a2e51383f07466274303d43bf0e05199aecdfa9a07e4562167564e77f3848adfbf7ef6ccb070f96d2445cb2a91d285ef783a867a03186e47a000b3c61d9a75fdda1d1b58cd8efbf85b611fefe7077738d24bf0c005b13ff47a96365fbfe6f2aca2666b679b589457af6cf0a2dc190523f4d877ec775bf5cd80f4d14de18b065881aced17bf8eb72b361cae97626a015ac12302f14e7eba5229549235d50c3f66543268529742881823ebfea7571cac34eabed51657b31b1e704f6d3edb6053b69dca8a7f5774fa84188a3a68637cb6621ef8778d812f0aa694f73a6dedb66a067f5148fc5c7e3fc62ed6767c07ae69d543b41bf00790cd3163b911507ddf0eed1d9fca49fad0786f9fde4371ed35dae230b7974ad14b764f4e65fa0d71537e3fd329bbadaa4dbea45e11ad7db2107b61ea1553894595181c4de5541021212793075b7ca9b540df930b9fb6fb6440db811e539537770b1bf9fc6cd8e36bb2602e31b3a00cf33b43490604aaed2ca1734e8e1789a341cbe864053a90064d6ccf235f18c535881540e5a059d0d7abfb80058519e30ea04e52004870b7bb66dc69c3eaf99ae6a75c97e94d0cced609e6d352bcc0a889984c0365f71c2a1e93b59639410df8f25cd2fecd4e0fd961280c9fa1889c0163258d29dd830d60f026a463d468a8ecfeb8171d7046a6d90ea6c29e95b473a18149cc5e28ba599f21549a710033af8b8cb390351d780ed58c883eb98ef7fb3f79f6647c974c2a4a13634c8f10475764e6974bb7997f0a552f85d5b998ec14700feb1b92943e2668308f9e74671f37a228dffb288b141c76aaa2cd18792e6573d698c89eebbedd4d6c64a3fd3be561466a8826b876bf368df128f7e4a3512d5ae519b6cd271fd99cb87b1655bdf1ee9adf96d569ceaf254ec89a9a31d392abf7175954d048c29e97d03487fd0650e149fc1a5f60874930c2a25fd1e4df4f4432f47fe02f04c59baaf0e0f249f0566b96de6a04a7093d4fdd33c49837158eea8e11493866ef01088f3e97a70f5a57ac0efb8dc7a822ad686f7cea9047bf30a8af065f8ee49dfee61f48ab4dc6d68baeb62dc0aa6d5dee0efb3885d7f066d72f26529e8e03c504948b6eaf55dc90413a95c5e4f59faf2e93298201164ebbb376bdd3022119248cb5c62741b4d3a6b57513671ba2058da335f3322246a59d5951df2d101519c7b59a9bcc4bf8e0402ca9fb20c785b9c0376159d631e7257370d438763b2f64a1ce42626bffa91bdedaaee865f717fa3226c6ebf2831745a9240adce4b491a88ae524d10e43e25a279976789a0ea224350cb4f7b4d72bfcf68a5afc9130663e27e2a58a0b4d0d4057d4eb27259a77924d97ecd85453979ecd833beaeafb082329db79a1cdf75cf6bb780e28aa7af3db1d9a9e0db94e34338582546ad2fe043506ebc779515299602e538b87b20b5223b1249cd9da3f7225397608605fa37104b5ebe20d415a7b67bdb3cea6ab26a1facb5843869214df85a8dabcbbc988dd70b139627a8abf66dd1f09d3448af058fe9e6ccd3ef21fd7dfca8b91a823307c8918bca74380cdc801aaa9d819f9bb7ffc0972f0150eda48c3fc60a3a9f405c41f6058297a60d05fa6f1ccb5e6b8feaa97aadc53a7f08d83982b381f131b1081d69c2694b256b17d9fa5f6a41cd779fe4fb55574dc0f29f760700575a84e05973491b65be58aa1ee8e00f5ef2b447f4e3b23b5e101544f75ae53bb55e5518b94fde52a4f3083ae36f30ea4cccbbdd64b27e72c29207be947eb5d0f9cda981a16046a438edf92cac9888fed3fd81c5699abd9f9657d90f3e21e25d2ed58f253577a1d2dac0fbc1067a50be6e60c659d5758ea0352a895c0a9a03c7a8988a7b88a0fac6a6cfdc1baf32f7e90e278d1882a23e6489b444d7e07660c7f6ce42df8de09535426edbc9c982f73f23106ebd35d09fffa23242f46300cab4f6a5a0f056133fd097bc20157fd0d24edf45bc3ab7a17a3e422a62d8b77ed1108496f3f982435d413ae5a46d284698dfa82f8279d2584dc15c7892fd31822452d7767360032f212abc095c96e384b4a3d77dcebd3143ec9df0e2ba319385f1e05dba638ac098c4d6183720c224aebf93577e66ff31006b4bc1c221f7904900450ee80f69bb504c75489224919b55aebbc5986aa1b38210c106ab9964967109548273a40efbdbfd7e222cb6c0b47b28c654d18613983ed29cb519aa47fe5ce1a006db76e42bbef01a4cf2d3392e829d4bbb82c4537ed5eda4cc483b190bca1fa8dcbfdae2ac45fe6f5508eb9e8e0bfb323a0731cd813762f0db7266c29495ccac5030392e152dbd5efe99ac8f4deb57930770a26ed342640ec1134a1a2349973e33d1ac6da424b058211428952c67568504abaed138638267622b5aa65c22bb2566a0636d51b6f32143015c5e34d3db047d418ea9d37df02a488725125d56860e9ef54d7847e17c5246b7ede3f1e0e44c866d02516d5afd8b5438de8383748cbb84edd185a383cc60d49b5d749d736cc71a9161a604ba1da9e7bb1dcfe67ce24cba28635f55d4444f621d40200e7710b8068ebb2cac56b7ef68ac2f90500b450e13fc16e188a8a2e44fe852a1de8949206d26c8ff678eda3c4cae4b6f4a3dd3cf0d9a606ff7f18189acf24b7e5777a924ad87cebbefe87fd39f5faab83eac6c07e9ec25d321326333c79b9f7d80ac6d7d1c1c75b567ed5449348fbb2376d45fbaa55593f382984b5221b0c713d287e971e167e59ef08e1f2131629c89829a7b5fd1065327b08f1ef20a012ed9bb43b934ef632f52c573adb201c81c1a29af24199e44fdb4164807f008af8be9ea735573b17ee03efd23bc3bbb078d83513c456b4b5c2119376664fdc63f1bbf544ecc8743cca732871cea85f60b74adeb2f5abbdb70aeef1a8c4e05f0f49ebe8721769a678441ae0a5446c37ba8bc6ceca6f72e25e4b99a338eba1e3511aae4c6720cd12c74bffe856875a7734dd57bb4c57fc543873383f4baba0778d2a3cb389d09f9d32925d4c6c037e878ac42e07a12dfac0d9fe3eb512020cabb1034c74fc50f2c82f1971b6965591bd0dcda5ca7878fb3c45e51c4459dfa88ede764851bfb8fe76f6829447c246dd3602113b59c74063dfdcc36e1a645abe4a2e772af3307da1f6ac1412480bb3775db9a71cc14b9525e401b7f6b551f73928866d0cc8aa9f23a5e79645ba6cfb94229bcb410cfa8b3b787eeb68a28a2988ce30798a69e65872735db8d7fa22e1f8159f6a11a2b88a3786280b6dcf56f53d279baff0841da34b707559a1fffa4660b14cf5d87f62f66158892eabb4e11f3d3a84182da0d624bc8023ccd654d2c8da4c9abe4135099b9b50a3f80ef353366ced9d0f58f',
        salt = '969fd177543b411245a8d02fa84a3748',
        labelError = 'Bad password!',
        isRememberEnabled = false,
        rememberDurationInDays = 0; // 0 means forever

    // constants
    const rememberPassphraseKey = 'staticrypt_passphrase',
        rememberExpirationKey = 'staticrypt_expiration';

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param  hashedPassphrase
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassphrase) {
        const result = await decode(encryptedMsg, hashedPassphrase, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        document.write(plainHTML);
        document.close();
        return true;
    }

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        localStorage.removeItem(rememberPassphraseKey);
        localStorage.removeItem(rememberExpirationKey);
    }

    /**
     * Clear storage if we are logging out
     *
     * @returns  - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        if (!isRememberEnabled) {
            return false;
        }

        // show the remember me checkbox
        document.getElementById('staticrypt-remember-label').classList.remove('hidden');

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassphrase = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassphrase) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPassphraseQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPassphraseFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassphrase = hashedPassphraseFragment || hashedPassphraseQuery;

        if (hashedPassphrase) {
            return decryptAndReplaceHtml(hashedPassphrase);
        }

        return false;
    }

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        let hasDecrypted = await decryptOnLoadFromUrl();

        if (!hasDecrypted) {
            hasDecrypted = await decryptOnLoadFromRememberMe();
        }

        // if we didn't decrypt anything, show the password prompt. Otherwise the content has already been replaced, no
        // need to do anything
        if (!hasDecrypted) {
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const passphrase = document.getElementById('staticrypt-password').value,
            shouldRememberPassphrase = document.getElementById('staticrypt-remember').checked;

        // decrypt and replace the whole page
        const hashedPassphrase = await cryptoEngine.hashPassphrase(passphrase, salt);
        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

        if (isDecryptionSuccessful) {
            // remember the hashedPassphrase and set its expiration if necessary
            if (isRememberEnabled && shouldRememberPassphrase) {
                window.localStorage.setItem(rememberPassphraseKey, hashedPassphrase);

                // set the expiration if the duration isn't 0 (meaning no expiration)
                if (rememberDurationInDays > 0) {
                    window.localStorage.setItem(
                        rememberExpirationKey,
                        (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                    );
                }
            }
        } else {
            alert(labelError);
        }
    });
</script>
</body>
</html>
