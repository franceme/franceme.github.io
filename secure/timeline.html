<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #4CAF50;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #43A047;
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #76b852; /* fallback for old browsers */
            background: -webkit-linear-gradient(right, #76b852, #8DC26F);
            background: -moz-linear-gradient(right, #76b852, #8DC26F);
            background: -o-linear-gradient(right, #76b852, #8DC26F);
            background: linear-gradient(to left, #76b852, #8DC26F);
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>




<script>
    // do not remove this comment, it is used to detect the version of the script
    // STATICRYPT_VERSION: async

    const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 *
 * Mirrors the API of CryptoJS.enc.Hex
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassphrase) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassphrase
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassphrase) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassphrase(passphrase, salt) {
    // we hash the passphrase in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassphrase = await hashLegacyRound(passphrase, salt);

    hashedPassphrase = await hashSecondRound(hashedPassphrase, salt);

    return hashThirdRound(hashedPassphrase, salt);
}
exports.hashPassphrase = hashPassphrase;

/**
 * This hashes the passphrase with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(passphrase, salt) {
    return pbkdf2(passphrase, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(passphrase, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(passphrase),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassphrase, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
    const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassphrase = await cryptoEngine.hashPassphrase(password, salt);


    const encrypted = await cryptoEngine.encrypt(msg, hashedPassphrase);
    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassphrase, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassphrase
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassphrase
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassphrase,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassphrase = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassphrase, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassphrase = originalPassphrase || hashedPassphrase;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassphrase = await cryptoEngine.hashThirdRound(originalPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassphrase = await cryptoEngine.hashSecondRound(originalPassphrase, salt);
        updatedHashedPassphrase = await cryptoEngine.hashThirdRound(updatedHashedPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassphrase),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
    const decode = codec.init(cryptoEngine).decode;

    // variables to be filled when generating the file
    const encryptedMsg = '4620a3fe4b95ff023ad5739751a869bc58f36f540125f5f2638662786a0acd089c7173ad4aacd820abe8efaa3735f4451340aa7c8fa9967af2af2626f31b9280f087d8850486cf1aa8c6680447e61af587b646c54ca330bfe7410a831c9f3ec11f5ea9bb7a667180811a200880052ff679a9d2b48ed585901a395e8d79f1c6212d04226ad0bfd6ecb15aba1b065ab88e018aed105f53a7fd3bafa8e90577acc740dfcc122a8514d29fb0483b0a9fb2f1e4eb12f244cabac1386c1d327d5cb889718c36b5a96d34d57f42eb054c62502c8a1b0494a13c35cda5d139ceb3ff4a6c6b4610fa6e4b23261e7010564c665f6442a78b0d736c755e5a2278c7fb06beeaff1cfdf46b0b2f098d835d4da08d64b6aaacbd28a2cf473889da6a500c7a66ed5f4cc93f0b4ae27dd6dbbb51f1448ba4fac9e9c201aa8364d7ee38bceeb587e86ce7b74b482011f7c7018213cf80bb51f78a8137140b871d6a402a9d9494af621a73926c3db54a2bcd2f7a48b2a7ec433f068cb5fddfba0b92dc2d558f581209ea157d12f46a0235081bd6203779f788283e08ae9db57d9df51d98e3ad314994222643d5e2969cd2e11240ceaa5be99259c6b890e6254e413503947f763006679d48561b0ced8b188e72adc9dbfdf58a8dd822ac642ffb90121824ecf04492a85f2cd7615fdffa8542ee583db08c0bd46b828e97516d56e086360b2513d07980c6f4cdb2f7c57621f5bf2e16f8e04b9fe46a1b389e3a7315dd60011fcd29e4dfa263936aaeb3ad1b80c14c607472956ef9b3610bc813fc799936c381f3e6064599248e13e4e4fdfce1b7edf2def786ff519dad4e3fdf2701337136320840d5ad1bb1cdca422a3cc707cb4fbf2a8a47eb98554601827faedbdda0ea85ca90627bfef6a8b6fd35bb900248b18ff5bdb886d23969f3ff78a63e99dbd01d004eff63dc9423fda3877886d038bce536d5db44f50e60958e46f7a7d929947e2f36f7fbceb3f528f93fda796478f77ee8323b4aade2ecfafdf9d5183a5034ea146548caf35a7edca5c8fe1f428cebd3111cca2c4629c487288f0918b113422f33dcf102c7f8d15ae04df7aaa881901d1c07423022b89c047662e944fe41e6209d5d5227b0023f8687d5e9359d59919277d58e6aa21c6e8cfed38bc55c99abd7e0f73a7bbd4c121ebdf47c15669284fd70e68e697bcf8485f6c81e8b4ae5ac937cc8729191554cb82e694a074989b5a222fb76d656d18eaec7791475b5397178662decf3bb8843221b91e3c371525cb79e7190b64575666f984434d8d06ab309bf13a66afcad4f2550b85baba979a0e56b0b90098302699052890b6bb121566ec06f3ef11bbbcbab864fdce69de4fedc767d5f29c8fd56a955c44b502f63226260286f2ee117592abbcbc1a43f9da6ea4f8d076ffcd10d53909d13ee6b43f14c2e374b75d1336c9e312ce38ece8f5cbb80e0bc5c0a6c6ad90e2403df6e35a1c6e2e800e9f6a63a4f1e80dde4174aa77da642f2619e11ed342483b9a750702d7ae24f55713b792f8df60e9c04c2402d17cbde8a204ae7f17bc6b188452b4043dcb456eda63d9c682451fee3acc9af5193f991cf10d2b6e60d7954ea88a4e54c924ec168e436935d7736d9a81bf6fc9115accee393e3e2d4efcde9eed28c4380d5aba4579f7612624528fcbb76a7e9565ed6df283fcf60e506f56663b4aeef1e8771a100d6f50054c673b48a148c58c1758f0d866f98856a854c12b5c954b66313577d63dab14902db8f36752952430b3ebd26485faa4c025dd49df48a76fa416b9ead09d11986f11e4e5794ca0a8735f7c4d14e6ac0661e37c9c30c2bc3c3d35375fee4894004243b50913df29162d3e0ee6789d478dfc75fba68334239a812dbcd5f89ff283aaebbec63fd58ea88c7536ae0230e90c9f9485665c4d31f1271ddb328ad75cb7594bc3e69b9c8624a05171406bcbbcb2271f4506182030eae690d65d1d48fefc6e54621e018698ca44ef31126c2d523c4aeb9babcef0c146ad329719c26ba01bdd8bb16833019ba799bf58097e14f4e2026c3980e7c020dd46da340e0bc16a944b1869e0e467bbd57d45677b4b6216da20eef50fafc43faf699d2c7c9b617c0e52eee29fe3d0dd150350cd0937ed97dd44f5c3f36c7ec31e8499a0e2636a1195d3e39f9454379e213742928f07c6dedcf54ae3aea7f5de2656a829b0b7954d0b0d5453ba28d20d256a9c45c66f9dc84c7a0109af06e0d99edf02f14732efaefc112f99380f1c95473b4fd989ed86014197591651ff6e6c4086a01f63895dc4668246b250e87e30c49b7f5a3038946eb3aa8d0755bbfe9f649e9364804d9a9640c86423ad87408de695f21a41d8ab69a241d30691cc5a130c17768a882c0a55806c8e6012a0e7704853b3370d1b96c5bb9f4e0fb4f8ef8eac53e250aa537189ba2dd3fcdf276abc6c70d65115b20adfb2258298924a4604982a631b3ebbe9541b41466d14186b51c4183f43f47c6863d52321c88a2512a9f3d5cefa94a36718bab0f9b54738de1a1ae0a388acc3f90ac806b5a71919b82cee98f6e1b571e7cbffc67cd3af9f77be29e384028ce2911380b45090bc1174d542c61d56d952dc4aa60246ac82be02e90137c4fa50440acf0af9282fb5d6737f3030d6e24ed64b8ac7e01d7a5dda0d59a71da50bb4641434ec6dd3fb84dcca5ca3d37f7265a744fec000c9df4309e23eed0d731ce2dd48fa834c52b5e6bafc6725a103d2b654ee1675e1006b4aa31a1393f626a1843265909eb0c67335783d22ed63169ce58c7edd297fe1597b778f855320d4d6e7017e480a9de77ecd79150a0084d0aed3fba60896802886eb716bd4a0fac52103f927da43e9e6a9c95f438c6e9d5bb01df20bedca512a4622fdb69bf875675164c8a3de7b128f01f07d4538b2737f5e3b23bd10353da436ae5bea2554510e6bd31a2a9d25c7d24ba3438bed9ef2f4bbb4503dcccf3b0a5bfdabf26d9b996cde791e004718cbe92466a78bc6ebb64f5435d3082d3e2a7c5ead25db16e94207e979e93c84ab0ec16134e4ce7d95ff41e4eaee4ce72a05c290d39694377f9782f2e6ef2bdabd7f72713f8f22d8bcb8923068a113036e30bef3c37e3b133132b9de2c111e6971d96b58e5158954955ee8f5ca225e175cb113038daffa92ac9c6874d458744667a8be55630b71072fede4741f966b16159f76167e3e7f48a6f8c23a0886d00e088586db7e191b467bc2de4aace7a83b54713ad5ad47c84f18cd9c2f9c2a0482e32173aad12852154a4fe7f3542a9a05e14c4ed20653c8671cd48167ce67bae606def7b39e911fd23055200d6dd6ba3ec869c9c2bf74bf9a748f2c12dbc4b7747cbf4e6b73442ccc35f3ec652c8bcd6c64545122df68f24b9e3932124baebd8b701c168b03677db7f163f63ae24ceaffd5934945c0d4653ac4728881b4ed429797709ce3a30fdb76ff2a1823592026add292d917c5f480ae15d00c659e217fedc932e8f3733849887ce0e249b45f6911ba1b5d63fbdd223fc334b345ddfdc46aed1256cac4931c524db8558a4ccba7be0a333844774ba8693e4f8306c113e17b5f251dfb9f36ff817fb9d9761f82f71dbfe5ca26fe02245f13baceefab4c58a4a49e84f41f96eebacedb551aa7fdeff3cdc4261790a2c03e3b75d7ac75c85a202ef0ad1db296a4993248dee120b4a29e6b6f0ab3f9d3c2b3d7a951ee97e17b7b6bfedca83b63e6a11a34989eb2131fb22ee8c9ad02e85866b11324d1bc17df73dd694a2d0dea14df252e837da332cb85fa4ccce44704cb25cce3f5b835a69ba8f944880dc0df35aa054ccb94d5217e1913ffebcc07948a80fcda3b3aaf0b7077606a8ff70c880fb6a333d41fd3dfedec8a0827267fe8b6f331db5c683da8320a334802570c6474c0a3e80f9c459367aaedc18025a456f881f53adcdb540aedf77c068761f7469915fbb11556dbb6eeab64d985af8769b5c8e1b8f187484baf1b8cd3d3d8d0c1960946c40a3a21a3d40bac488fc32511075b8c5e1d3c8a1a421e8f043441a4e118cff164234fc5b6a837e471bc49c3c66a34fe55b80dae07c7f39d2d7b6e58ac7d480289f6e9f7d589d0b6daffeee9012d26f209998737010cbb60e95fc04bd106f25cd3e783fc7a9b1d40cc4739cd7b6e30d251d11f2ae720e0fdc0547223b383cbc5d3987c8d3b4c6746c4dcb98ada5bf573bd35dd671fd9281b4af8c8ef0957c30e7039db8ef5bba28e515c6cb0979c5ceee367e10a48f974f803814627b8337a726714dccde29c8763b9b4f8fefbd65c321ee6c4d764c7bdfaf7340977961470af897c9ec7edfe53737a69eb37c49ecd8ba75316585d8aa6765b1a2bade32467e751598a8fc3efdacf0ee3bf43a6a8301cdea806bebdc67d2133a48e0714fda14da173a7c2dc357073ae85902c234865bbb377810ca1001d9eec9bc94333feff6de0f3017aa2ab898f9ecbfac1da9ef2fb301ae2d9c4d32ea10d103076e4a83814039da246bbf6fc8d064db772d458740cafe27fd4970ade100bd8782ef9f37ae1aeaf22c8a17cdc54eb235a835728370bdb4b461e72d140aa6104707ba82e39073a2dcf44b63d2b9ca28b13458594a972e28ae244dd50c933084935710349b293cb0380892da488026466cd3355be31cd2edc89d10a4d130f03e4930675a08071abb6185f26cdbe14c530f67c49e3b15374a49d065e73e711ae485449b0c2bb722c522487a57597996b59e2c39abe5d50426e3804bfd1de640d4f9c153279f53c921ec50c028d01ea6a4f4c3e164166979997c8b4a5d9579de6ab52ba8c6b17d31e8ffd51e14f29522bec8aa829c844f19cc38e8c793075a749e55ba532dc897231a5794215ba2155f12ad4eeeb0e2044b925ca527bfc730bb6e4a71a789e885301615a4b88b281aec89fe906f70e8574b36f62c420705026d9264e15292453735440595601098fcf26b49a7c2e1ca790f8f2c72a6ca59eb6844aa6ee1b356282a1693fbb083649090a9e1e749e1ed48df931db58d889ebf097aeec51fc53c1769ca0eebf42332d03cdd521414b14f2b71f4c09f1d279eacfabee419e036e584f3e12e3a33223d8bff1281a9b526a7655a5a9a0adff91f1ca451336899f61d6beb04ec12bb2cccb9485184b51d0768e329814fbbbead658d2d16ebefa558ec5c0a87090af0d0b454514a2168f8bbad0394154c46732036ce9015b7846fd6e0d7e5f52861fd751b557300567dbee6542a6e264591f4b191439e3796901dc3915594c2abf28a947ac060cf62fd28f4951d137a464503d42eac702d16f71dfbcd5860a4d0640725ee7b4b39854829ba5b5eb52d0138e62a24e6ed306f9fd0812ac1820ef1e75652f94fd5517878246b173b4b66e922907925fcc7b8b358dcbf1971a536dd1e596e9350492f147692cf3782cc19761b7f43f98069b473b2d2be271e0970b44a720f0ff3840ce9ee7c3f15188b4d64d06839e82e84e608d6f4c99ec60ade69ca3c6d7b9b415ff46f1632f5b9e6dff57e309093dd7a35ee737a0028ae67bff731132320e0ff84864c11503bafa790fc63069f8c92e40b47603516c2310d2df04db08fc85c7ade568e5b81e6e78288e91ce0d40738e85436b0fba53943f151fb362a3103d1a5a0680375ee5503332b756c1dc68ea614da758064ff5ba325b952ca1dc39fb7ffda4e2ee5bae6c5b19dc8d555bb29184f73907b57a9181bfcf51163616354756dcaad51c6b781818fafc73021b35a4307bc4de81f83459587c667ce57e50a70232b14ed38479dc7326a43578fab42a8d2df8e113d9002e58e4a88e501a6f0c531fdec0a9d39780b4e24a3776bf23c4907df305c5ff8749588215c61b21c1366e45959083aa1829d5f3fb81aa227eb24b1a60240e4bd27e9ceb8dcb4c40f97f31eb92583cdabb47b3d9565f45c81229d538d8a06001683b939625b0b52d078b76cf1048d2bcb8e7327795589b176c8c217e1bf694d2b3a24152a072188e6e025767b7e540e9b659c6269302c3fc646eed6db8638039a74a3442ef9d278494826a8a3e09376e4690ea5f12c8c42d15cdbfaa2f82d956d401791b97364a85b396ba78cc237a943e7cb4b4703ce6030a7b1f304f3fb56dc2019a575624a79c6a26523f53ab552bde61e74ebf010e0a76fbc500cd33a3458bed57a1d39845ae89e743a2bc76f769e4b1d61fd1c65b69ea08c8ac01a189a2368e5416600147f9b6b35ac18e5ee400775bff855f5bdfcf94878b17a212bda364d12d24e6226c0e0d335f1e9362b8decdc935de51c1201b56c1e738abc88a0fdce7210378aaba25218ab6175be8ea38309146dedf47c3da8abde9d69a18890f263ee7cd9ddcf214740995d6a0a8fe19bb253eb3030a7165e2a453bdb98274801c82b1e477720e625b84638918898ece39d53a80987ec6dec313cc7a5ba79e0dc42e867a40fc3680bc8e761c9de8747b108fd024f081af5a8d5daee196d33b56aab00de9d98a2c21033eeff004f6ccc61cf5bdad948ac9ba31a97c38bee2e4e1129a41c048a503d365d02cbcaeb048c7d99238f3cfbc078ecc2b5dde82109aaf64ef2bc237e61de12073d43326f24fa6481993b3387415ec0ade73cd8e76f30df69109147bd46251d76d0752f1ce40ceef11459662db6b0169f6603048ca702f12713ae87613d0c270d8a486513fa02bd4eb9cbeaf5c409ab0742227a4959da272e3ba07dbf658c2877006cc3224a6ecb2f66e2959a97f013b71783c5d02513e8d334ff216e7c9bd7d9fdaacd4a4e0e1ba7eff087567854bff83c2561337af7221a402404c2d92e805a374a1a02c0c1a24fb45e4dfce4b3fe0bb8e3a14fc0fe26a6de2cba6d7719b0e1327d6eea941f2bb0f3356570664dd086c839a0327bb6b4b64d824868da7fc2a22ce39356243ca649b342e9721050c8a1f96a4cad878885ea9ded65a9f8eb65856a7dc163fe25f279f695147d106f8944e2ae1977050a3c1c9de6f1099352ba60e8210c4420aa301d6fa68f58ca203510890ded7f5984075d9c65e9920d9a428e01075b6796d7446ae1dac6be980ddebc45bef647bf83f3b28453ca973e7614e32c20f7f273aaf3cabb8ab5797a4f0f59bc9482ded89374dd1c24c4950729040f3d280623f732570dd58dd54a1503208b772b9d5e0c2d11b15f19911244ed8abffb7578a619c7d4b61869a470a6c2b3cc7a8a4eb6c1bccb333064948d449b3990b6df9b2e448f6e773f6d5eae2586da098ee97095f05b7d0fb258184af2452e13549e3b26cfd6b65cae51317b6b7fe22b60307bea594808c7d2160ace74ec9e2cba3c1d6fa09336f8ac4846fac321940a3396ddabb9333da4b9ac2f2e56ee2a7aa49ec5b9925ea3cd5889457224c494b3eaf22ea85e261abc4e94d6b7c1980352b9aa2baf081deacfaa3434825962b0da21c09536bbfef7c8888d9f3feaf98809df347ea7e3edf779b90c0edeab16e80023b7a520b4b4c6af6a309bcdf4f85a2fd65f3f272d570ae2e74919fa47662831cdec3d6b5f77b0a2290931292e0b7e9509c2929265a1f50e782f45c612043f5190c4ac4715644abe0a6e47c356af3b120d653f8813d5246472a377391107856e216d25d73356ba0454d9b806195ab9261bbc29b535fe4b08a8f45dec75314f6a513e58254ff9d75cb1e6fddb9949383047897b55a398c3aaf5130c9e4d60cf23a39600aaacd7b42114700f451e6c6465191567addb95dee715738a88bd0fc3021b94364cb5ca53f22b0b5ab8e4a816714cf0f17af81870a8ec522fffe18ae21f1d0b63af1a563b2db967ba6f08eae48bca3b46e841478bfd50bfc13dec4e03e968cfc1543f879cd2aa8934448d654118063f7306a186e7f10dbfdeaf27dd03511f639d0b1016421ed138ef85ce820102100185b1903e7550df6e7262590385259045a202abc0fcbcdab2f6d6994ed2fd52a263eea3c2fbc338b1ac6dd8cf089ef75e9290e3a6cf995a1858503b97ad7b0a8ee6a58e4c832c2044f7e2cc71d9b40cca942b43af5882affafc8bc19aa1487b785c1720fa666e4d24e839905964339eb055f62e595e4adba28eca3f86e71c7bd7404f31bd4e4205a21d5cf85a5a544e7fb94b633defe08d039f0588ddd701e7473305968ab386ba97fb0a72a78f993d3525ccfc14028a47a9143e06c1285e47c7202aed41c983411f2170fc0ded61f64867a970f2135217b502d86d9b1278764f5776fcd2e4053af0ddd56956ddb965624576d331929402fc2a4a3004b1de4cab163044de2b770ddbb43be11f874ae0ef5e682657d56bd59b0c90e9a88bcb2630d223c545608caa7c118f88c29834d7f3a61920f993b88c865e7130cc2e159547d9adb88fe2d194c934a6bc6a010871d0d344dfce67de23afaaab7b05869379e400741743cc6276fce53b29ad747881eef5ee0efaed6197e06fce6442c15aecbce0987612b36811b0525f27efcb2c8fdef364c7386ca3af8027c241f04a04c1c22d1b9256fd037199dfda1023425ec997ffeeeedf850c7b635c7c8f153aa6d1efde9a93bae74dfc2b7f5dab3ea0fb48963e3b9f2362f414962b0d792ee5e80f785886098d0f9fa8ff99fe4c23f7f1f36fb8bf4feba0f46680972acffd1b997c5d794e9a63c2fa15c4959efbaf82cc7e7a89e306e738bb6ebb9e91465a87a0095258fac107c4152840182a0ccbecd037b190e526e1451f14ef39fcb89688b7b183874e52cf54e4ed0d5d33b3a301b1374c622e30202cc004800dba2f7aac6c9625449e1fb3282a6cbde96ff91028379b1cc574943c93d5b444de0dfbc196f4339039d5d32b0e75feb5ec3f4ff1d237f83a912d09cb8ca567a9aafffee02997d8543d81b1d9bcba98f9bf6cf3fa003cb1edb557afacb486a36bed4170682ec098730793dcd51369b48dd697111a6b00d0f0e1560bfcbf49b24efb49088c2a2d849a07c66baa0ad74f852bc9cd18b7103cb72e257f3e0d74837a9163100529240b4fde2854d50baf2d4ee8f8c2ddad60408650abd3f73a06a7130cb0b6d16f47073c0abb2b2414c2c2d7da8f10c78e252a30e2087d4dd980b5a3e4b0c9f6dd5c5d7bcc6915d4f3f44c13e54326f26e03a58045b1838916cf949689e43e6fdee0e54205ba1ee48b66b552d12984a85e1bdd431c58508ba934a99727f1200a60f159357efd74c53d7eca73ff5d068a630434dfa465a38829e80a65d65c5c18fe96d577371f5c0a2e22fd4f222c29e47d1078df71ae669dd73047e3e9a0f31b242f85d6906838730411c86ee6ab19f789d17337bfa3c3dc6252a2552b6367cae781a0be7138c4cc57337e1d1ed73228ac7c57d37ef208afeeb3757c55db0b3210a737da41fc5461a894a3bc21631e4b4112c80c8f2721e28c56882ec2c15b146a980ed52f73d1890e9ee8661e1a8967fe0933650a40ace0cedf4f10f8ab4ca6a261f587c63cc91deb169d1ce8f52f7579b1ac9bab05f9204b06bc962869a9507d0e9d69e645acf3b6d00dd4e237ccf20444a53982ebb4b622da56a312b8250f02e20a412471acd45b842c20fcb3e48403f3768fed53bfd25fb5a26270aeec1b7eac1b618151f2b43a33454cd8704efa158534f7400a1147c78f9ebcf7162a0e39a1173d408485edf5ffdf3908dfd198738d80286a9e55288c828598e524023039f20534ab5fffd2380434cfa800258e5f43153beb81996d5657204f186266390c684b83b5f715e4a6b700f2dd560f08949d2dbe7f30042c8e8b4ab4da8e0df7ec22c3fdfb7c789f1f6c37adf3d9e7f195d750771554d5ebd5159c63785ff2d0b27d9a9b9b39ffca6e2fb9e1541eb94943247c758085130b6f0750af6cb8b74b0fb051d4edc58897c0318b654c404a9dfeee5262ee15ed0dfcf7b6ebe3c24f084d7d9429cb1567583ece93b1a96d49be50de636ea65f27b2f6b1b59b11949f4122abb71b5a28eac62cba9112186ba51b1065808b693ae7213071a5e3341e09f447c0b046e119f1a3c9abf531f5fa86ae3ab439562a80fd16033fe21151d7f0f74618fbaa04dc7a2c471c1f0f0f3426f56252921446e69f25e3ee23b753f40c66491e5c12953d1fa6638a46f077f18a6dfd23e49495fcdb97eee965e5d4dcc23efa98e30f301a6e3c8a3bc4d5eebb926901c1216266812e607c549d3e37cafeba2721884685d8a200692d2748ce847e38e54d95073498a83854e3d8176566904439b9c01085847b7f4c951bfc59e410755f1469a9f08c35fa989e6466571a97160618fbb4595d6ef98483c5deb5c329eee42d455a3e5c577210b0f27ad417caf246d98b5299805bb4fe194afbba96fd7e91d861c83c1d79c44559028ca311cb7e5f9d2c6ea212fafa899783744787f6d17e6a61701fae6b3cbf0dc9c2a4c1d1e216a63a10e1c5834449264ff75eac06bd86f6e12b324c941f2a78e8f2f3eff9184da6278ba7cc0c7d7bad1d0eb02a02bfffc52d11cea3aeb8eeb1bc5f8264db76084ff88a186ca8e563b637a5435f9ca4f7e8a137f2eecbc2954f9d912d267bac9a0d5fe2e8a281107577ed0c229aa25398427f8ce5f5b6603203034db6202e6cbae4e8a83f027fcb6d93940e194993ca28fb83d24bdd94fb96cd823e865905125f4455564516b1534d713fd153b7398d898fd282a6d82c14e18333355b33882d797140650564a501e42e7118a94a2ca42fdcf3657ee842306e0ab50286a499096479d66d878609f6df4057b437a3fbdc01b3bddc30ff5b5989ad78d481f6f6c7ade4b6f797eee5081fd95fa9d16f41df4f4f57707abfd4e2ed49bc8c8b6bd275d31213419c7b9a0b9e91f2cea3d218f3af57db21cc6939b07dea51aca3ca69f7958cdea108bcf431fd692214efaa1178d9abeb47a53afb18a983e252f9b6f322f7076077387390f5c97d84c7c20611b34c73ae8e63742a089f1e32511fec089ec8d292f66ce8068f4f87f7d597ecea6e6bb5d642032091f2b246958687b70283c5499839b40747ea6ea885d1bec611efbb2fdd39f0e95e4ea16722aea9f01d2f395920e26ab743c540a55a9028a095b0cdd7dd5cc29661f4c04edc4422c4757560828c1857335572b1d8e8a3d7140f8c363e4c0915919c91c5682ff7b014f7c24ef345c4e41bdb684fc261e4e8bb0dc6246eb44196ae4e703c5346b52dc291add75b39607817c37eea98e14ca021607095c646752c74d5d72ae40d91eb229c5ff76d338c9c4399aea75a7057720286ea8318b03002539885fdca10bbe42efaaf771d96d1adcb40d78c36a0ab70e0e372f2f9e4cb463cc199186b289aca0a4762d320b5a7594885ebf564cf37d41fe9b7079e56f0d181e96ea1f9a34fd8526fa57f6967d518e74ee036ea3ff3f976ba5763f468db487f0e67a9a6995f0ac60a114b21f01044cd1bfb4beed23a7deb29835a8d1075069ff03ce02779cde327eb66530a2f1cc5bdc5e720c9299cb4cc286d4863865ef7f9be944f5c728d1282730ccbea12ca1faf757174ccb0314a78f7012e6d6ac994c2e1d7068204519ca7144937e1d741d2dee0bf329ae8eb696c250292e170093e86420192cbd1874b49a6a036b062a8201c9d085f6cbb701d2045124e06fcd54b05646ab79d488a6227de409d42fe81b97b6a805e60a16152d6dd0335cfab64cc530c6ea5f94aaffb9352fbae255053b026d06907c8eca7ea756d21218250dce8a585fa56af80bc8bb44ee24456d06355dd092a5777a629a845b2f346c425e2e84ac345be782b70cac54187377f3ff2902206a2ef195ef9daf83768dea4f15d72c6fad920429c126a9962b2831589b7435b7616c70194266ee1490024558ea42f787d25f223a0fedd8ee9b9e17e7d8cf8eb2a337af44c8710a9db62b012538dbcd5d2b8bae8454cd48e7d792b87ad598d3538ce64188dd5302ab3dc1f158aa19d3cbdbc888d0c8210f856ee34ca06f846c5a1885bb3e3395c08188e3018b3ad5c2629bfc7b7a4f98e75b1f49fc606adb75be66079d6aa8f97ab97213422f85d4c60f7ecea595d3a045603c8b5d32f7772d026075bda5ab212e75414ec9f024e48f71a476fee7e82c8c9e1858d1f57c5a1a8165beca259424484d3ae3e7615f01c87224a2869cbee673efa3d7a8db969547a7ba37c8a6fef078aa09e4c84c6721f434ca3616373907563acb9acdb8471326c745910e1b5d2416accfdafe8f7def3e348551d4d9020515f94d6d255f7b3ba850b62f4cf390c7c9b3bceee8370f348dbaef06dcd4bdc7feb0462a84db247d50a958ac2d24eaecc7fe1f34f7cb4b4ccb9fae2d8ba44f318e41e5b2520e3bf6a1411f417f912bdb95b7fece7ff78c1875601e893407a3019e0cd51bc5fc9c4317c4d5941b9de72b3f520061f3ed9a710be323a7cdd6ed14914d34f63808d519fa3dec7f1115a590cd38f591b64e1324b13d383a457df16048c13865ea364a8d79e963e6a990f6e739fb79a37ea4e9b3557b554b1e21936f8d685da4a5ca78cbe34436c4acff175336ea20296a3cbcdc008f356882edde82783dcdc1b536e9366b137d67e4f36fbffd5b3da15d3c7a096c360250fda9aafd3483ba96730018723fd4f07a3be36eddf3a3492e663abf5693fb2c1f2cf056d681ea5abc6ed83427aa53734d766cf53d78110a95fc039e679ad1c3edcc5c4ad46c5496305b7a4be673450eeb02837710084764ad292b3a24751edeee97cfa147eda7b3030c22d34bfa29afc6643309a1877e46f170464d7d55d62ffcd01174dd96d67c4cf5e8774636dce3b92cd826084b09230c357183e14a593814edd7dd1f68e3c949bcea157fb323ae2da13f4d1216587f322569af2f4eed783dc8543ea88c53b94dc4817a4709bdf1f8442ad786f5224758a7cc528c6dd501ccc28adcc49b392ba1793b21a84787f59dbf92bd161cf78b848cdabddbabbd9bfe558396479c5889fbf84a9b9181e2b959b9d747d85f67f35b863645d13701f17a5b39c7182a66eeafd0768190e8b2433433f7a7cb720cca5600d196fd0de988c69d57430e2124c6671cb19f88703e7b48c0a8959e915a10b5e631593c5279cdeef389677b24a919b795202792b90f62e643373b3caf6bc78e601712af5c130f1a209589e7ba5168970e9347473ec5105f0f190fdaee4a48026bfa355a9896d66b4b193d793ab777f0b5b2d9bba123fe62c7d304b227d72da2a6ec06d360e01e7621d2b35f3f862374e991339345890dc212637835aedb5a56c85d29bfd52dcbef81ef2effff73a61e9c53269fd196067e7c2e7c9eed327f6c24941beca573431fa45739a9eae3973318ddb437cb3f712df4db95ed810f100d00684e2aee82e70813e221a7dec2ed2d03d17bd5ce5a6c3a0ad3bdb82745e2c2c6c97c3b64956c20be7cc2de3cc4b02686a55e12823696501f3690fc51d0a1d0641d0226f663fb18f3ddcf56d6b1148134abe2dcb6a4d9ea53cc4f17c4f67f322302dd23379224463c3866e0ca88b378a21fa2b84947e92a8fcf657e0898f50c4ba49291bc97bbf90c501e62a78b8cd52155e2e8c85714e904d25395db591aa8e1ca36cd56e7151f24ee649c59e00d5b093a47827f4c26a0ba149dee51a6bfc19cb0f14fb8cc44c2279ee5c12f26f65073ebd08e68b8c25eea1a55f2924d384f82d2c85019d827e99654c6a36d2b7a73ed1d389d0af7fd89e90d0e23988c9703a979896ab2ed8da3998230491091b9d16862231865e78d1ec4fff127c6f946173800f91ddb807025fe2c94a4f812ca28c55772da560e22e727db2a157d5fdb0db80fa6afd6564e069a37b1afebccbb98b25808881002ceb6e54e66fbf5a843582b26a7521e0cc578b57fbc5cf67818f22505741df5bfa66bdfce36e1e20cad31e0e034a6750c10c066f7f89b8ee083f351611da40817bb2b4f88064539b81c7e70fd0d04658edb3ad4292b2815bc915930bacf53f6ae0076d5e0d05f6a12b3c7cc4a18a9cd21fe509b5ac8781b3aff11764ff39b6372ed19daa5a9a073fba9c0e6c1b5de0ae0579a27dd59d3e052428bdd840868ad07da99665e3c62d8ab723a468591244b7785c863469609c4aec5f27c74681cf5deaacf0b586cd10fb84588586d0d9765c44b4f7c12627f15d1aef9c81d22267552542c3f6f865a9358465d273d6932b4022c03ca95ba9176a3f0553dfeec300222051f76a618d4c760d4f2c55d6ee22e316eaa41d626511a9c6cb61f01dd29b71d8342ed0ce499373f0e6e10c11dd04316fbebda9a32272a1ccd1e99ae61b3b06012fbe007d66ff3ccb4264c579006abc2482ed39f02c5864c18a6b96365c4fcb52b343f68da4ee3bb865db9c67ecbcbff044466a1dd03957313fa39441abb06bd39da99225f569b1ea35a3ba31ab4b9f5b45c98ece0eebe50cc2c16083d0778b3dd69abcaa44803f7e91f2135c542455643c0b879d0541a14c55755f7f4e67e816a1b2c4b55568951eb45eea195db85a02ac6e587ca7b20fc5501ee592df9f5a4a151337fe5f1259ece00806f31ce78499524d2243a0ffc4dde828b2deeea0f7723ab92badfa22870101eddaae07e33e4bd5402ef6b1b9182d1a922fe5f7f403a7d572d4b52d1aae596a6a27d1c67145ba01f1568e524d495f1d12cd0d8ba674f7fb047abab662dc0659a5a9a7e82e5698941a28211072de354e96f43c3f1de963445793efffb6ac0e8a35e119d98654b72659dea7d2c04b390d49898f84d7ae6ce80e20d5deb92066eca30345478e278f5d346067bec48734db650478644fa7d8903e5f8a1743c12ae283f39480dee6fd0a686c2c404019223e11f6309b1951654fd9419a3061fdb0267a04afe889103e338cc6137ef710be53f9e9bcf947f51b837ade22422839045d3b12e7f5e9e0d91e79ae94ad04e2afd3a59e10a94da53f5acc55d01e20ecd72432ff48e74d3f4cba802def0590c649ab54704abcbec0fd9c55fc26876db703919825f8b61cc93714b40817e6c10b5763dfb9cb5504708006b36ccc98b44e0b4ecbe9caafd0433abe29069815930467901285de960f792fd7192f45e50e74afa67351e67b24c5e3ad840b9695c28214bbe1b04999695892735382e9f1a4dbf13f76e510fde750064d5396d991538d08167effb8c478d82c479e5255d3f79631bd5aa1c7a61f84818856cc4e2c6c8b832b680e32e0466afcf616d97517d0e77b4eea3922aeb10891ea5016a11952e413398fed566fe316c54e882017e1a47501fd62158e92abcc59d25ee9e110d5ea9116dddcda03ad35f285d59266aebaab75e3237c',
        salt = 'c10bf92b44c5610a9d6361bb6d3ae583',
        labelError = 'Bad password!',
        isRememberEnabled = false,
        rememberDurationInDays = 0; // 0 means forever

    // constants
    const rememberPassphraseKey = 'staticrypt_passphrase',
        rememberExpirationKey = 'staticrypt_expiration';

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param  hashedPassphrase
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassphrase) {
        const result = await decode(encryptedMsg, hashedPassphrase, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        document.write(plainHTML);
        document.close();
        return true;
    }

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        localStorage.removeItem(rememberPassphraseKey);
        localStorage.removeItem(rememberExpirationKey);
    }

    /**
     * Clear storage if we are logging out
     *
     * @returns  - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        if (!isRememberEnabled) {
            return false;
        }

        // show the remember me checkbox
        document.getElementById('staticrypt-remember-label').classList.remove('hidden');

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassphrase = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassphrase) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPassphraseQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPassphraseFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassphrase = hashedPassphraseFragment || hashedPassphraseQuery;

        if (hashedPassphrase) {
            return decryptAndReplaceHtml(hashedPassphrase);
        }

        return false;
    }

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        let hasDecrypted = await decryptOnLoadFromUrl();

        if (!hasDecrypted) {
            hasDecrypted = await decryptOnLoadFromRememberMe();
        }

        // if we didn't decrypt anything, show the password prompt. Otherwise the content has already been replaced, no
        // need to do anything
        if (!hasDecrypted) {
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const passphrase = document.getElementById('staticrypt-password').value,
            shouldRememberPassphrase = document.getElementById('staticrypt-remember').checked;

        // decrypt and replace the whole page
        const hashedPassphrase = await cryptoEngine.hashPassphrase(passphrase, salt);
        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

        if (isDecryptionSuccessful) {
            // remember the hashedPassphrase and set its expiration if necessary
            if (isRememberEnabled && shouldRememberPassphrase) {
                window.localStorage.setItem(rememberPassphraseKey, hashedPassphrase);

                // set the expiration if the duration isn't 0 (meaning no expiration)
                if (rememberDurationInDays > 0) {
                    window.localStorage.setItem(
                        rememberExpirationKey,
                        (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                    );
                }
            }
        } else {
            alert(labelError);
        }
    });
</script>
</body>
</html>
