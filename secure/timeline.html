<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #4CAF50;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #43A047;
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #76b852; /* fallback for old browsers */
            background: -webkit-linear-gradient(right, #76b852, #8DC26F);
            background: -moz-linear-gradient(right, #76b852, #8DC26F);
            background: -o-linear-gradient(right, #76b852, #8DC26F);
            background: linear-gradient(to left, #76b852, #8DC26F);
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>




<script>
    // do not remove this comment, it is used to detect the version of the script
    // STATICRYPT_VERSION: async

    const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 *
 * Mirrors the API of CryptoJS.enc.Hex
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassphrase) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassphrase
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassphrase) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassphrase(passphrase, salt) {
    // we hash the passphrase in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassphrase = await hashLegacyRound(passphrase, salt);

    hashedPassphrase = await hashSecondRound(hashedPassphrase, salt);

    return hashThirdRound(hashedPassphrase, salt);
}
exports.hashPassphrase = hashPassphrase;

/**
 * This hashes the passphrase with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(passphrase, salt) {
    return pbkdf2(passphrase, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(passphrase, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(passphrase),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassphrase, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
    const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassphrase = await cryptoEngine.hashPassphrase(password, salt);


    const encrypted = await cryptoEngine.encrypt(msg, hashedPassphrase);
    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassphrase, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassphrase
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassphrase
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassphrase,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassphrase = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassphrase, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassphrase = originalPassphrase || hashedPassphrase;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassphrase = await cryptoEngine.hashThirdRound(originalPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassphrase = await cryptoEngine.hashSecondRound(originalPassphrase, salt);
        updatedHashedPassphrase = await cryptoEngine.hashThirdRound(updatedHashedPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassphrase),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
    const decode = codec.init(cryptoEngine).decode;

    // variables to be filled when generating the file
    const encryptedMsg = '00e55d1f277019bd44c4d0178bea3cf83f88c22222e7babd6ada012eb029a885b2b40db85e2f0aeb7923c71a5a7178799226e1b6ed2ab4da4626355e0db6c90aa645ef849676d25f21fa93b8350ffd714cf72fd7264140e80815b5582bf0a86f371b9f0495fe7b6fcb1cc2984ceb5b340db50c1f2d86d62ef0d6b9b3d81ffd8f7edde86db8acec173fce672c458e6d242d569fb94138d87cce89d80a98047d2052723346b10302485e503b90b28d8f740acacdf978ec254b1aca52111953c7a29083961b33b3d3f331ec75502a5fd0a0cc0dcd2fdb34afd80a0a3b317e77e25e01ce34665850d2a7a449e71685793410da5525df190fd10de4f1dca0c2a5b58618469886ce1b21aafa054535b705d6d132562a602eb5ddcbc02bffaf5f17d19f54af7f35497341ae7557b4b378087e04961e64d27075a6cbbb0782bbf99d145c5ae42bbc52d7ef076f601089451d547855554aebfdb01f20047fd800bf5c7290bfcaf3443de48a6b01d8c847cec57ec65755f1c13ed9966fed2390a041e7742a166cbc2ccf50923067350b608a191c7b2293a8c56d7b143b376ce20c55cbb95273a735a582937bc8985ec585a10045d0bb3cfc8701be10673f69f00a7999f89b3086fa7f727cb3efdaf74e856b5af3ebecf1d87a3dbe004ec52e2da5a7d966150bce61549e1ac802bcf9b716737ffcb5b4c6ae8b748e5a9d53362ce07b07f7be7ec7cd32c921f28c25abe32f1a2c769e48ec3c1c81d5b234d9fb1d0d6c9c2c7ff7b71b9861de273c16f352ed7673da8c0ee534c98e6545c330ddab8fdb84d0ffd0c365aabf422b272836ffebb79a4a6b8248ebbba27e8902ef2bb03f378ce34bd5ed1e3320821f8ca1c73dde2fadcf730896a9e0e0a64f0c025e6600d350bbc1f46f78f71b763d73c6f5ba82802edfc39312e5a8a958bd733cc236846904b02590300e677f22b71225449f00a67866cc160716387217354bd5880c5c492892db60ad8c643f47c2d44551f3be64def88640b74d17c080735991d75af521a866a8f163a153020b84f906fa27a89b5faa13bdc5178e12d70b256e36a2f56e76e8d27b7e411096d485c64d45dc9665ee108056c72c679f03f75c6e404331a130edda604b1400765729837453b2a448054ce3519c0f3960c0023bf9d4f365e021fe2110de4f2078b7e2ff92ff9e6f80b18a10a08d67c5524c750e513c308e32be583df08d64d12c8dd4062edb6fee58fac1a2edafc5d14ef51755fb9796d1aebc62694d254f5c4b6271e5027af8da657a3f162c00efe7360ff71fc646d12442509de732335debdd02be5c4352e77101849689978ea1f0430a66b410d3635837233741469f8058a104c199fafa0b6038f2032c3f99092fcc4e024373d206560e685aa3aec0e0e49d9a092d1612b25b7f6b565731afa6c9b03adb50201868c3e3c0bcc2b4641dafec2c3c16eb99494e8d4a85295ee064f79498832a0c64d3213ba56ad0254bffdb9fb8f947171b595ee49bed3d9988995fd314e814823cd732e90b34edc0668f96d925b79037da6eda96d01996a44ae0ac5b6fdeb54e496768d94e84444af1f7df4882cee7d7128b16a2b552eb540c8230dd6eb4477297173d226720fa630710c32a27993adab9104c0c23558b13a12440ff363516a6958110d0981478a79e592ae92493e7461be6a5f5e790805f3c5b6d03087a8fdaa9613bec7747967fba0506bb79b72cedb7e9aa7223b6250fe086b7d4ea375ddc7f69a7571b0a815cdde8a41ef75ff81013c8f0ac1a324e3cc08da6a094f49425243306f49216b826b67b881ccb3992a7daba07bf2c685d8844b4c978313dd2588b71e1c53bc6814627782af6056540c0ef0f4b674ca47691b0b644579db92c25c5c53f34ab4f835b0847fd4df0133a578e771b6ebd71b0e5f619459ab43fad53cba8efcd41520a0b58b42ed5e8459031b27a2ba6eaf16ac81645a15fd9201a6200df317d470fe78d9514f6d2892edaf9462836bde25e3b39a3681932ae0568ff133d14e39c2f96acb719bb19604e21d8c6854502583cf8b3712838d9ff5aa4fa3a8681ab87aed9f20c3e649ae16f6d08d3b4955030cfb52ca9be530d797726169ca7956d10a1a0811c24a8579164cca9e5e750a5a957068cf81ad5cbb4ea23e73599800ce06f380b2e9363410e167aa31ad273de0e871a8beb190236a733a4fe80618424259eae4a0437950cbf6c83009ac901c42c7c405a59f14caf4fe704debf0f00886ff2d787850eb0f5c8d78f69abcf18ec831bae17c6f5f84bd14002dec5113774aa86f610f77c7211dd8f3f6a060add16f4fcf6096b1a7f8fb05246eadbb265b30f32b0c6bfdb2a54902ed8e4c3d64f48bcb213d241a2fe9e0fd5fd58db6f288329fab6020516db26630027228ae13307660cfd7a707907894fb5288bd10146a562d6feeedc714606e5cf38d6d9b42896ae258f0eba4ef22221bab49bda8d48667917adebb03eeefc02106527a5a7cdac64670a73e29179ed5f845213ff2a085763bf9b2fa966040fcd8ad9d319a769ec4faa1915c976ae251e67b8bce5f88ddc978dd9b3f506e0bd24bc5a32c69fd365223b7dcca0b24081f40cec287877a066e4ba71f214e387631c42aca8b5f277f6b37a51e91eb5a5d0b15def8cd65133723df131a0fd966f78cfebae52b0b301d6ae885b92b8eeb9cecb89dffc87a4a1cd517683b31651bd09588c27f4c8e3361627439a3d7948be529231cef325c4a7cc99acd67dd2d9ab8c31d7b48ebf8e185c1297e2b88ee929ffdd2bce7794ac9b18210e4c61c080fc422e332835da283cba59c69afd5d1973f03683deee1f80aa9eb51ff99276c951fc4c506b331c16d87725a47c0c30253b1d7ad3a29ebd89f57aa976765ba540dc92ce12babeac4e636b9dcd755254b7c3b3c44bec416637a3d9f7069725e045ba31ac10a55be59784b9f059205888a274cb89ac885ecaef07fe41d1a101e362f72b3d668b31f5b2331a24c0257b38703cc2e097f4d4b1975b78197f801acb641fe2993b18886c97f033f712fcd8036a60136957652b183e59ae812f8d44945db1605aa398983265e4ae0cb0e7eb7b5772dcdf7d8f973171c4ef4279527b0adf3a1f75f000713eb49abe08a9db48a6e8ad1b6ccf41d544fe6f48a6cc4f014100171d87a57bdaa4d214e842727b8cfc37a8794b9e653a39eabd5d857a7b9184a9a4db8f0abed274e656f27876f4f007f33d6bba0d477575e73ec302f17d781c4a251d1f33d1e2ac65d90e2e0d5ee6b488e566c52878d0a1fe1c2d583de7a4a86fd3ae93caaecad2c076377482edb3b74fb2f104d0eb3649d17f66616de4074d72461264b1e467b2f0ce8ebabd97d8199e1ed09373a0b6aa1a6f57d375a1b630a0fe7488db47d6e4e4b27e06b90e32ca214ba4acbc76dba504e09e7f3ec42ca5254695ceb13fba5545d23e9e21b93182a539d07946b3e328186a318e20eb079f8f709d34a7c635996228367f39de7b537f9161dd0c6ce32139f64c86ce181d3e95f96d0d14d28ab4e617b4fa058ccc19391d7a886dcdc610d0835cd247a0a764e4cab43638804d9b64ea79311d7eb9dc297cbd351c49cca404d91c003a052e4685635b98b8800b2c521a0525c7ec70f9dadfc263ae1bd461d72fcf1628d0b178c26dee6c3aaadec0a513b4a1a1b6f5b9a11f2b8474e39bdfb67719bb93f61d1b12ea4de2b87af3f00da08d6b6b1e842dede64a369e8044e0369b98307bcd364a6afd8097ee0e1ba09545225805f20c8c1765393ec4383911b2404cc8f11499a029d65bf8b39c81e07dae7d4c99ddf5a035b5cd58dd9e8622a2109599eeb27757c539276cb484db852b913cabbbb04713ae01386a83ffcaee304262e60d40e61d40a9f59fbd0473c33abdb7542cc52b2d00a6c22071db66d4e8b32fd3037deb47e0b7d3246c2d6fa98835e550a04e2621234a8ced38d48c5266b22e4741fb595f58c20d12a05ec5000828e3b4076601fa2a6623299dea5a9affff39840760a764ecd8857fe263bdd366d7787167ccd8b209939829349b677dd6904d21daadc643c68772d9aac08e5becbad8c4977ad183ed4b0e458b83b13377bc8aeda242f7391859c3364c15dbf1f7b6c773a987ecc8169172d3d2ea16a10cfbf5dc93de9b79bfe32f22cdf3ffc0bad1a3934f27a0736f07ca3765493bd64c8f3a9f8fcd2c1d042ffbf68ea9f11de5a0729a626b30e25a047cabd0a938ae5b23b8b92f8ff80a1219829ef5c7f115030dae05373ca11f87e30f3af1502119c624ca5f1cb40a7752688b1b65fec0989862d705910c0554f28a85dde3eee03e4039f53bb9eafd71453d5999f583d618201b371f4c8f28f0c586fff47af082331ceb2b07e257fc108799417947304cedda06ed499a9320a4dfeeb8c82d6c7fd89bb0f1b19f57d8d24f1805ec2485074638d09176c157e436b6e50913a270a456ab626b4baf18cfa962ca6852085195b8b96262d033f42d5d025217d5164105206d3bc439ac69fea610ca0e91049ec24e07213668d0a9a34283c43037ca2a0d59792167a150111784e8a466844921dab88ab4f72d78d72f9a4da179805f718781d83518267d7c06571c40415776cf4bfe2bf5591a00f5e789008a774569fda2755777a8ae32e69ecc8374a0e4ea4d1b0ffd1d25d8732c95bfabe66af9c8d9b4d7160a556d53362e0028d4a103fbe396e01b8b299709091c1e106021b22dcbca8397b7fe412ba9eecacd7efff23c84993395666ed1c60baf022bec1f32941ee72a8a35a15c1805701688fe8589731e377c49690dc1968fc15dba2f2c61badb2bd4fbf9c231908940497d72f0426e6b6d1d37e577ddb835af166d498f5dbe99d8ba142390ac12f978219e6fd902870e78fa9475b7966c9cfab39c753043e191536ba9d0078d0bc6326ca31316db28fa4b73bb21c30507d2bce29eeda24b2920d09614f7ff7ab87a6b83443481ff7e0c584e9f485df8d3ed0f34ec857d84dd478c390d1a9fdb760c121ed64bb4435cdc1b6b818f1ed7eccaabd0ebbf81ccfd645b520dc9ba997db0d9348db9328793272e1dfe96636f2185e15727e968f2ab95b3b4ada795012f899022056bc6422c784138094151f19ee79c4ee4cbcab51c42603263da79552721c9b967c40804e9d9135d721af572bfadbcdc4fd09754679325a654aca75b3e276310616f33ded21c8a7b5be535633a38216e874d88a89c1b357c0b1779ce86f6650753fb17b2b270a57fc74e9f1ceac563418465bfd28de883eadcfd68752c29a53151e5bf817994ffc1d062c01eb8fec2d951eaf99b23c58d368cf2e9885981ef4d106cfaa441d53f5d5e945ffa9c1874ccec68adb912fc487315801e912662e5e32301a3c888ef6f7ddfbcc33d1bcbffb9586c09a30f27f1d8e01f65763c3557298de617d97aaff77097dcf753e9b78a5eb44ce45bcc20996e38132debee3c19abd2ebae5552cfc663b74aab2cc5e9fbb2d68560465eae1f4b51ce8bc6a10d1596965d15e968ea68c2c80006e072935e05e8a245a0d02f3f83c9007bff11ca990b4ead253ac86ff2f23692acebd93e2b4f87ce3810312e97df2a038511ceb11159104d23b20f65a590b1b145de6cac1d81d7fcae187a547010d0ef25ecb5b054e4c2fac2df0695736aebfe62263e3e8ecc8b9f370c81c871a4122a4bd16a01c1141ebb22b12e1a7e836bf3350ef471b2ce4a14d3abb473f38fe1c36c0c63cc0e533acc7e14a27d46a223dc7ab2727a0e98b7c562945bcdfa3b6c787d52f917b7e956c9f27d4106dc1545a1cfc39fe09c440d7f72d235acab616df664a04f0d0055dedffdf36109dbf13d2c786767dc771db9dfcc61a495e547e517e7c52dd012cfc86f6cbaf073d310859fd920e881a608b60874570c904fbcf111ae7103f68f335213e8e5821484f90aa6e206af35128b5adb161c3b8415966091280443919ae4acc255b0ff9ef20f674a4f3be4aa9bff2c7ad4d2cc21344e3c44498d4b13e401808005abbf69627b50251f9ead4628f56a8ed0b62cc6593f9f5c1e58c68064fc72e15c83fd02cca1f1a2dca0d30904b2fdcc3e78e318c0aaa36642494fac2afff50e8fa75857c851c183da3e357caa43f46e271f0b60b91e7d369eec1bc616a5b388d36253f4ebd3645c42644b676dae6b38d77a472ff8506b5c9b4c53117910635544cbe679838f23e2b77d370f14411f9a0f4095372bf2188836dab5add0894f5e0756c59456f018559d23277300f50a2f31378ef786f503022b42edb84c94b03bd2c81849be1caf03de1f547b359aab875fb7c1ddb9a464c71558798e8a911b5cfa4362c95cd6158c4218a844aa94cdc75abdcf9445a7082a591078398e32aa2e2ebae712db0a1ca671b12e64d686237dd187865d70d1c7419bc970dc7077f52d869d9c74144c6f9453553d0441686cd670e05618afd9a0cac68b52f083fb472400a469d6da225866919a7f71c4a19ae9412a6064292aec8f3137fc8ae6821668eacaaca4f5004cc250a9f230da89763f1e49bd70a6ca81d41f0a12df61039da3bfdc208558898a3c31e125faf31c9d9aa21ae710f93e06bb77c4c37990092090f199f4da95cc2ffb9d0a48f4229deb79fecfd357e05e13d4b3db7d98666c9539a9ee6f705b15faf8a654bf67a28cf8164134d0aa8302771eab0e61635f06000084328b5c3857d270cab9422140b6b64bd9d0e15a15f37059d17c8988d0d055349e0e7c1e3204cca209cd6f6a014d80024cc57e0c21f8bb14bc357bf88ed53dfea8a84e052b06a27541753828f72678232624e7212ab7c1878cda20c3b4af91a3b553f7ec53feddb05ef390b61db5bb95a7e3cf60325aea4c09336f071a4ced88158e7c1427e9dc2a6672847de82388f4cccaca02e8c8e25e14490826fe0b187dad8e2f2ef11c4276846a7341a5db9fe09dbfdcbd1277134d10facc010719a8567b8089f2c50faefba687becbc8ead8d033016ed4afcc1d3e314c2ce0ee2b301f61e49b683bd5bb9ab88212d434011e83159c483a33587b341de978dee0d3821bf527ef65534ea681ac8bae10729233aa6bf585b79d3fee62b798d0934fab4262b3cfaa8eba07b9cfd213b52325bf7b7aa90d15294e14085b37144a8d4ef37bc11ed83e19777367e65dba4c0765f15b7e50ad49becded675c89983461e5aff0a6dad9b633d329ff2fbe9b4cf5b91a20046e1241e4bf7d3836200684c7c3e0b7fa1abd412b30d056b5f12b50f175a27127e384d9ed72cb13921b50db470d0a3ccf1e5a8965178788611c47bd1251261dc2ca030192949374ce34f81fca77e672488c0ff50e60465d2f25c6ffd0bb584060be91d0b3880bf39551ff19adc56af337b366b99ff8b68d89b6c2faa6721adc246c47726c16b3e8b1c5e1ebef153128d8dcf5becf51daca80494dd173d345eb7573bd30d8ea504c4c0f79271f1f89d3e79d3e6760e70d797a8f5a1b0c38cd59c32be3f77beba0a022eeaff6a816e8fa726201e54552a6688959e65530bf15bd37a5b56289de8faeece084f4f1096810c05571909c177e82b8bbad578362bddf1e85b77ecea26a2bad66ef9cbd578fa65af437880fe80ef58c11b0cb1610aa596f8fce14fcc4804734def7af939d33d2a58471c689a368630e0e5433ff8c25f6437a1d558102117b217eb5243c5cf9e8ed4c9e8c3e83669808e98553493a6e82a933baa78ed0d7e3374a41da56c3388be01f9a4d5d664a252a8541a60e54ba63a72e9bcae83e02cd8a992ded954b958050f81f240e949fa01b1cabef4d0d36c0026c2532944b8c6feeb58819e0c0e23d81e3b2ef9ca2a1fa1bd5155d7f4baedb3189c4297b6514b04d96ccda47e33a623dabbe7b70e8e2e31ccecd058af114c6c619c72f0bd22ad2f894e2326fadc9697592b793ce9612c1dfdd7faf589092d61647c98884dfc8e002c178c8270c964de589eda85be992530e31bcd8a53c9311a3a8f0d534ec2a26e687384e77d9cd0bc17f2b50be4c129a533eb73c19e1e837bf635c03db0e89dcee3ea9d92d47adf475b4ac7b8381f0f5ed9cdf714c051c6d2b507f525391e3273f5eb303089dd13d08c1805edc6aa98ac4a1d41e027a04d17005947046ea1fbe3b85317f94e5dba01cd5b1f90fa15b3f297963d8fc6d38409a0e4248165d07d233d4dbdcb60b415915beddeb731ecae59a8b33f9e2b3c86067340de94f4765f8020a28e18faf79d724f7435bc6b4f5d49590b088f58d4b0a8e158918dd39cf286dd18400f011d9abc6a897678090563e48cee6baa4b7225903ec7287e26cc133b00b1cc7293295c409c57cdedc33b32d95565e9c179f472f3b813539826f655b84420910f539ad0396f60590e9c4f0d5b53c3deb8d18741b034e4e9ae63542ee86b62f588606b88bad4852b7c276219bd0737c24dbc5eaffa5a002c4c93eca8c63e76938c5baf8b54eeb24f1bacb0e3589990ce5b243c5c21d4f18d60aef95510dbc01f721afeb18b11b1ab2d437effa45b0dfa41d28396444d33bc04f651979e3fad387c97e82dedd2f410181405ff231442a5530e1a4b9d5302dee6f342197c535167e5326353e832b963e72188860ff50bb2f242d6c82f1aad94b2f179f60f782f5bb195ef5e6ef2e402a6274d72e880f99cdbff68b1d8dc2d7c973683e5fe3d18f0641855de3c56aa06b9eebbfbbfedebdb490727b113c0d054e3f8ca10d3888de874531c8b87eb90ee02db6b302d67cc7f3485de83d9fd9efdfb3a69b6dce8eab3545cc74984f48871c38c01d2b620c027c5d3f18142539b514fc7850bf686517a50ff3df200ba8ee2a538d153211a49ad57c24a6718ca2568cd06154230ec51d215bd79c68f8d8547b72e3486a371856bc1c5ce78e6697c0331bdd80a17b411d87e2586f11bcd207e84c0599ee06b399e50c5b91ef909ac5ddfc067bd0109efd79a0053ec7866ca63cb07a9ae9b0d2ae4f9d42cadf34b446739c184aa2aa8bcae5cf18c596fd0ac0b4615c8f0967e008511953c0be45abd412f966007d4a1a905e23206c6427af723b9c48dae9a97bd344386f005845e1368b4d2932a29627a1e199d4ec50b5a159cde78ef162fbd2f29e16c253f134df4f8da39626977359ba8f932ff59b891031499f4c41c3ed3a12cc7edd1865c2db3ed910ee959cdb06fa81e669433671dca61d2ed21013c2ca58db8a5532a970797df3ee0e456b70edaddea51c66f4527005b5a0fc40cda09244007b7c4ffcbf665e69b51e4c2b53bdb3c0fd69a3be3cb62d90e8da780071416a992208de8de1d05f985dc29bc4cda650f05ee1ad11ed11465c8984f2e932f41a5b24b1d05405a7c7d183e752662fb2e3bb612117806f035fadc3660a1ac0fe7d34ec1545f9dc1a177aaa8c4f1f9614ba2b3c95151f493abd7547e73e943484cd1e2e67fa17d5611c23c33cae98e2318b2e3321e0d4266044ae817eb521ff61359f1dfe3ff922e567496ca7696b93d88aff8f57aa87ab122affb4327344f00c76b5ce04cc8d474ad5276fd972d830bc001ef8eac103f4a5d891916e919e256da7f7a69fd762fe1335040535d0a2bd97ea3a35b6908a7758f39cc4faa67db05cda85b1f19370c99feed66541d83ad253af12dd578c670f18a6d0e18e30b8abd01f30f132adcde8697bc64ce59242531ca06deaea960e88cb96b099fd97d59c92aa5d7549e27d4abb260ecd61c791c392695f8ec0488fc5efdd0691f6ee58979f3eec9fea639baffdd3f40413881ce0717892b2d3b5c7d45a189f0fd6e562f98e5b721f91e43b9f5f964d151187f9f03739b6395d4530355059a62fea111e23debd0fa36587626166bb22123943c1e4b768c5b1a996b1821b6e4c6abbfad5cc7db19aee024f65ffc8c10ad241a1ea105059ad452208e068c0276d39b4e081d0bd2f5a96a70d625f5ac5a74d679a2314cadfaa5f3fa2b4314616df2c75daf7b4dd125036cfa13eb1937dc6ee663eaa1c3c1d8ef3fecbd256ebd013d6525ad50c304064e4a04b749b10e43c4e82159ea0fd417921f8bf6704398b4b8bf02b90449c632d8697885c7e505295c5c782162b6435d8d50173c69461aa7290e6894bb5d8de619296f9c569986bc3c00e7329e879f9a956998abfe49110b08a99d3fc8eccc58e65e0bf10bea572ebdfa23b90cbc85a48f25def48489725b1882bfef65007b40087e0c7ce644b85dcc8b63fa3c2364aabfe9253cadfb97153c2821c59d36f8edc2edcd87e7f27499a9d2f3bd8cdc6c858c8b1488add7c51a68d469e066d02622cb5d0484185085e5c0e5642e3919d8fcbb32d63077d9ce52cb27c0a195033b03fe4082afd293a78454ae7ce5e0550ee3f1f5724c891a43a7d4e235e6d124bf596eaac720a2d119ea3912c5e8ce8b28ffe77f901ce2729aa0e908bee8afbac26febb4a2c41936dea9f61fb7065a440ca591d699af8cec9ecf0318d0fae1265e27edeaedb3b809d0d7aa6695a0626ccada9320cba4fe46f59095f4a5aff9d8ba8c4dc1d82087c7ec3159b8140ebf509e05a9f9f1d3ad7d1d6c1d8e06aa98dbddb094c2f2dfdbff506e9c53313e4c70f03093b1b21e0f35711bb46be4da11c7df74d7abacdfa591580a0a910970bd474e2abf90f6ef7caa219bff49191e99782f16520f5ab77120530a36da448e6267a7c15b790592a159809fdff7296b2c19aad4192d109ae8e873d995d97acf92a886543c602e92b7780f171041c302f1706d7dd7d374ea9bf5a88b273c8aa0a4ad57e05e18d6163411cb6baf6f8b61ad64cd1792497536298db9caa64b9d124ac62d901dccb45cc6ca26c593f4b58fbe909c96b77e1061626ae59023c154765f5c9162d8051379739acf246f7d1695b48fbe0c8daa7a659874a12a69d0ef725630754150f8e5432848d7c45feb84bd89ecaa24ddd681048f8473030eceae12e10df3e24aa5346f933003cfc8c2b1a03af4d169426eedb4d8cb414bbdd84aefa35b60926504a46e8f33ed6605af33380d3c401557d06c0b46e3120ccd7f092c3d27b2c554266e8120f3394bab686a0d350f8059c34647f4f00104d8fd866e4c1fba2a7aaa838ce9074c84bd206f803f67d2e456b8ed10f934af3a5b2766ef145c4b27678605276babc4b90e3d00b57b21c8f1189f0eedd5a215dba4026ff6195e1ceb2863c21a26d5f8220da6a5a2a49cbefa782b7919443edb3b40ba8ea2a5219ab489b8fee44a178f187002f7c0962edf3a8921f570cab9a9594514d9ac3840905630a9c2e37e9be5dfe15190c11d5f8eaef5955cd8c33ee34a3f2cba4968d5b6dacd05bd79316b3c5d1839920815283a5829d242a38e143c0d60c5398884021d283eccebff0ca8e5c7e43c6e3324d84d07814280037ab26ad2855b8edd8201b1b5186eeef90143212a9c899d19ca127a20709dbaadd02bdcad0fa7d6403238ec59e7cc974cdd23e0c06694cd0e4384f33813fbcadad3fd45643ec4ec25427e081428b86279e52441cc028e87394a19ecd93cfad1f08df132415be0591c003b348b3c4e8d753340e886c744963cfd319ef60d5c6b7ca022e8defeffb51af22931f76d3b8c369ef0b0f996db2a4adea5c1d4acecae39aa75092a029cbd53577a6243045049eb4d9fa0fd9d62313c6c41d62c90d43934640d9d75b032e0d02280e86d4e580e166d75a1a92b14ecd32af20e35c54524cbdc69f34c1c7a07f871481071b28fb074bc193d68bcea8a3ab2d2aa926eb07ab3a21254aad4648ffc8d8e3d7e37c39fcd4d3748bb5df7c2274de172db59e5fa237eaf7c8ad43221b9b6ed8529109dea1d2d5ede942a203630d7323f6349f72a59b4ed8640db2f96ccc85eae29179cf8105fa4488d446b5f83acd2b551d2a6e614eaaa38ff55f3417007da557abf16fb6fe7bdc4cff93f93a926a6788bc28045bfd2fc4b1d6966d52499fca2185c65023d15e13948480cf45cfba5887386e453bc251dc5f08ba476841f4357841560ed2a22246773e842e93b554139f9feed362512e1b9498947cbfcde0beb549c00e31a002466e93e12aeb1e49744d42de8b20fa0af8678ea77acf932d6ff863f5a1c21120a5b5df3f76cdf0d7babab52556f707b4031725735d7c0a48f664d1c15dc7f7a5de11dba4790e0c2173958fd4013f77eac6ffdccef3e42e8b0fec3ca125c038fe6e38e17322d4607e34d64ad60a7dfb17c7c65934aa3eaa215268a2e9cf72e8426b1bd92e4a17069097c2222bae365706b0d992ea16591373ce5f1c4aa2683610c1958ce0b85133d3c5e4ad129c5eb6f5858b5326d35c908a9e6bc826384df817fc1218513242a8448ea2932b5997cb1c807db6f5bb1fd14e7ad2a40e534e646a5641d321723ce2835080b948f6984d0f0f96c19a7645590ec02a6b70ed42c36a081b0717e0dc1016ee3eaa820510a26205ce7b56643032aac4c23ff394fce9daedc0aa85fbdff0c68e7d09aa9d7a627ea861f5a7f5476873210ac6029d92f36bda5776be768c677d212e6a12ba61f55fa8f47ea72bc0324b1d480fc0b4564d61a014ea10c3805e33a1fed99d1eb58e11a0117ddc0de0274db836ddd6f10aa18b680e6ad9bdcd4b61e9c596c904c06a730d29dcef14daabf128dd89b836c51646554639a79c7df9cffc8a30bb96ba5395d049982d73b54da77b12902a98162447a1c13ff9a7e89b43f8b178ca32c1763f088e3acd35fe549f22ab516a48e2202dda96d915a3bf6bafd5772b91f07c621e8a7d5026de5de298bfc639431f4240bd1c90462de972564e85b962db794e51bc02f510ac8dbaf486102c550abaac2a9e70251de02aed2d400113ec306e1ef7d625399533b465e78a40c238310cb9d33f7385cf3924c7623984fcaeb2c9e9d9494408248c5f590cf5e81fc8a4438cf447a44cf14a0f1aff6e496b2f158dbf87a3b88c576d49c5e3cfc7424cf18a39a4080cc267f7f852d02b927a10835a095b7d878782c71857ff3f901736fd7e8fa2a94ed3ab1cc3744ba33fa58840946c330997f084c9a15eb1846a57853e8acffc6056e971c18791a0fa90263651c85f454c6515d85b2409f671a07b7d54ecbc16c09551160c5229085da76354d8ebcaacecedf54fcffd7a2eb3485f116b092d52b142135ec3ed5541a3843ab0e5abe211481c7f5745ab1286aad523caede236566ca3f914c159279de3329fb84865d2836fc4d2c1d980c0e6bd054c06dbe816d554611494bb130d357acf2ddc30cbe4f4d548669415f3d45ae2ec50c995656ded8b43dfeae263d38dc4b0d29b67a4bd2075b5f5d1d5460a4d6402b7ce944fd84613f31e965ba5d6a060a3deeb694ace419c3a6d3fa6bdfd589ada71cf32949ef21fc203735019e82a530808f9df32d10d70f193e4edd6a1369ee5f0247a6860c54a2532ac2dfe14141aa8665e2e58cb52b42afb52c0cb5687cbcb42f64bbdf6fe91eeacd93077806282469b074456f8d5f361369c7e0b1d6e6e179fea4ca0f127d21fd1d26a9c64875d95fd3af1424d4a2aa4877aca3c57fbbd1938ea388405184528ec8e796416f19eb37b92b2843bba7b5ff31f5cb32af87b1d43dec91b8e3eaf75747e1eeeca8b85c9b1d2136cd1343e706ae9fd53e7a00db3ac8fe5ab5baf117fdaf5cff699cc923fb385bb2a4801d648029fc13d71f40c7d9c085634d9c70b862e8501b08aaf78e8b4e348630064588bb0717502f0f584cccc466d58d5b25525004a90544b27e4faa0c9c2cf5ea6bead0bd5a03f6ec1491b939ce692350f3cb53dcefdd8804c902003d810aa8ecaf6e905bd20e5a30e8216981b301cf4f183409d58b53c7bf51f793a91a32c7c30bc0c8a9c9dbfd41e6671319a39c0e400f6869e904dca0c316efdc31ae62e6db262fa5da5926e35e673cb8fddf323ed3d2587d7b2fc98160fdc7b6d034223a2b9c834f319134feddbcc6ef63e217afef4b17cf200a82635b073d92060c9babcb1cb3adb4b9508fb76912f187c3f479a484906aafd68c3b7b6d4a2537f5738ab411e47c917f949c202043537ea0397731672e46fb3f2c82ee1dce526b2b958bba4cdeebf8c890cf533199a27d54dece36a7635b593d7a3110b548f57b9b6fb83d41a4a901054105b93579a3f17af12baba3524a24804d8e5fe1efd04e70c43f53bbddff313c6fefa41c4368c4aa55775bf6aa7f86c86557f2ea1046e0ad2b6a81893178f5b5c39be4f515d49d143e98549dcc84db932a42fd847e62c83fbb068b083693ede0c05ae2e4ca80ac7b0884592b564774fe272cf13d8cc9fc18d50b2f23dbe96d81d4668343ec0dabe1aba034b3239e815bea6caee254769619da550ba389a0199a7213398aed2da7711f3e968c50beb0e906fef2d0a4fe3bdc5001f010f2ec711484cc3321f2b1f57e59e20e9937c7a28d68f6af23383b65e742f4124d71298a903764ddbe7e08f03add87c499b34e1d25d1966d0543dd073a5524cefd95b571927164a2404acfc5def934d7bc33eea53fcbcc6102976b98644923e6b99414d1148c0220b6a688f7622b907fa146a796e2097430af637cf32a2e040c4e3dc96033b5f3c89ac414b6a6867b6c47b7c22f7fcc4528267ff51f6eac6703c8905152f5803cf51e023d0dfcc03402ab61c870b6d4732e8a821e4c8e610404ea2baddd49f8aeb1d6935f4a9454141da1be7a9ed5aed6f51212452d63db390a0bf5b4c2e24de22bbffa8b1af8ff9ff1063d6220ab1a548b659668d06b47c2d40fdc2f6f301f052bd4db1bf6ddcc7705e75ace327458dcc18f8a7c6c649ff9b8329e4f3795b2edc2cad02e573f7090efba77a22308d3889cdffb960cf36aac54316378454cd7719a8dd5bfbe4a65786b6d5102e779666642edea0292936c58d43bce9163bd54792fa82bf3729167d6f2cd655332e64b1e295e79a1641c5230994a04bd95d43f64dccc3997f812b167458a3adc57a1206ea69c239068662f3cc99929cdfb3eb49ec49d3e9d390c96e45f40d1ab49dcda2d9c73169e79b7182b6724cf7b6cae4ef94ae256ff595f617f81d3daf8e4272e30dbec6d3f7ac6c55f3486c69135bf912c34c64352e671a01c9219c15b026ac5d01158ee101b17a86a9869f542d758ff701e3681c99f4a4972ec426977b58088977a98c9ee2af631c680709357bfc01c82588966dadd47a5d76a20bd435ff0b32ea663f1b6fa60fd7fbba4df5169bb39104eb089a3232a9f152b53cbe9da86cc240451e4a0c9e8813dce13c2dfe31c2db99753510203b55a4789615efd7c1ceb2ef9482e67405b72e',
        salt = 'c7a1f16646323344b50f72615407116c',
        labelError = 'Bad password!',
        isRememberEnabled = false,
        rememberDurationInDays = 0; // 0 means forever

    // constants
    const rememberPassphraseKey = 'staticrypt_passphrase',
        rememberExpirationKey = 'staticrypt_expiration';

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param  hashedPassphrase
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassphrase) {
        const result = await decode(encryptedMsg, hashedPassphrase, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        document.write(plainHTML);
        document.close();
        return true;
    }

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        localStorage.removeItem(rememberPassphraseKey);
        localStorage.removeItem(rememberExpirationKey);
    }

    /**
     * Clear storage if we are logging out
     *
     * @returns  - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        if (!isRememberEnabled) {
            return false;
        }

        // show the remember me checkbox
        document.getElementById('staticrypt-remember-label').classList.remove('hidden');

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassphrase = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassphrase) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPassphraseQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPassphraseFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassphrase = hashedPassphraseFragment || hashedPassphraseQuery;

        if (hashedPassphrase) {
            return decryptAndReplaceHtml(hashedPassphrase);
        }

        return false;
    }

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        let hasDecrypted = await decryptOnLoadFromUrl();

        if (!hasDecrypted) {
            hasDecrypted = await decryptOnLoadFromRememberMe();
        }

        // if we didn't decrypt anything, show the password prompt. Otherwise the content has already been replaced, no
        // need to do anything
        if (!hasDecrypted) {
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const passphrase = document.getElementById('staticrypt-password').value,
            shouldRememberPassphrase = document.getElementById('staticrypt-remember').checked;

        // decrypt and replace the whole page
        const hashedPassphrase = await cryptoEngine.hashPassphrase(passphrase, salt);
        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

        if (isDecryptionSuccessful) {
            // remember the hashedPassphrase and set its expiration if necessary
            if (isRememberEnabled && shouldRememberPassphrase) {
                window.localStorage.setItem(rememberPassphraseKey, hashedPassphrase);

                // set the expiration if the duration isn't 0 (meaning no expiration)
                if (rememberDurationInDays > 0) {
                    window.localStorage.setItem(
                        rememberExpirationKey,
                        (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                    );
                }
            }
        } else {
            alert(labelError);
        }
    });
</script>
</body>
</html>
