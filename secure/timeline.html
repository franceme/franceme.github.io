<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #4CAF50;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #43A047;
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #76b852; /* fallback for old browsers */
            background: -webkit-linear-gradient(right, #76b852, #8DC26F);
            background: -moz-linear-gradient(right, #76b852, #8DC26F);
            background: -o-linear-gradient(right, #76b852, #8DC26F);
            background: linear-gradient(to left, #76b852, #8DC26F);
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>




<script>
    // do not remove this comment, it is used to detect the version of the script
    // STATICRYPT_VERSION: async

    const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 *
 * Mirrors the API of CryptoJS.enc.Hex
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassphrase) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassphrase
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassphrase) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassphrase(passphrase, salt) {
    // we hash the passphrase in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassphrase = await hashLegacyRound(passphrase, salt);

    hashedPassphrase = await hashSecondRound(hashedPassphrase, salt);

    return hashThirdRound(hashedPassphrase, salt);
}
exports.hashPassphrase = hashPassphrase;

/**
 * This hashes the passphrase with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(passphrase, salt) {
    return pbkdf2(passphrase, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(passphrase, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(passphrase),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassphrase, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
    const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassphrase = await cryptoEngine.hashPassphrase(password, salt);


    const encrypted = await cryptoEngine.encrypt(msg, hashedPassphrase);
    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassphrase, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassphrase
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassphrase
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassphrase,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassphrase = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassphrase, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassphrase = originalPassphrase || hashedPassphrase;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassphrase = await cryptoEngine.hashThirdRound(originalPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassphrase = await cryptoEngine.hashSecondRound(originalPassphrase, salt);
        updatedHashedPassphrase = await cryptoEngine.hashThirdRound(updatedHashedPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassphrase),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
    const decode = codec.init(cryptoEngine).decode;

    // variables to be filled when generating the file
    const encryptedMsg = 'b70662eacb3170b06343e101e48e98ed65ceacc4f0dbd39802666230d9835ceb4ff7dcdbcada46c55177394bcbd6435c689a8cdaa0347184138440c9205e5523aefbc5b501da3257f28e07640565aaef75b91ab5b98053628c6de5a765a0340073d8b1242ad7e2abc0c66f32091ad7ac4cfdeef078fd55d78d02e0e959aac9b0fe7f90eb98e02928a3baa176f7428531c5cd175c64bb151444a83cc306546e3b1dde60854b4a538a3e1699f66c32851151f8fdc205f55d79202e8e12005ea113f83f9b05448074c8796e08c749beab44f330f8f2e9053d97948632a0f19b59f852edbb69eed9e3f234e58abd4c116bdf1566243b9407ca47b34a404c1570464c6260f6c78f15701a886292b9d5e31250056242070cea85834cfc2455a7f2513a841c04410f82d28132137b3eb20f14672a2312bda8e65a07f536e778e610d44a5753bcbc0a8b46b415e9fb9ae5d952885ddbd4a1ee46cb1f19b18f6f6b5950e3d2c578113fcf1f55475f08be335c900ea1184ffe31f0599caeffd44c126e9b31bef66da059b81313e5f58d7076c8a52c37ff0b6ecbdf16d9f3702d98770d615322e736cf7571692b7e2c7974dfd2b07e391c33be548de3b466a72ff02d7516ea7446152ce1368096a29bfdffa70be12a155f90d4cb089a13aedaa3129fdf2b00460e4c686a1d79f3e07900ccc1b2662b23aaac1848fda389d6f7900e93ade37dc9a8d4920f5c694a2a36e69f54b37bd0faf4dbeee064228fb7a834ed91c1099276fca1f12d1fa73551f5835e4316875e800dc5a117cc46da8ea2bd0a3e0eaa1db5b6fd506f175852bb389243add046cb73cd8043ac798f3d4cdd80fb3a9af9120ea6d007cbc37ea4ca52a2c92468933446767b80dddc26422e1611b75f04e176a9d621121cfd4bbd294cd6540fce3d7ccc308f0c691c73d7354bab7c2998a767052a745502482b1326fd716175744d239c7d7f247b68857ae56e1e64ffab8d12022c53a7d6c592e48a8421763fa6eb4ea148fefa988eb30f1ecd61faee8e70143e34e5ead16a9721b164a2144f290808212d05898d4ad59b9ba87b692194e8a5ba37e04168d8130153f25469265685ae262892e82f2e57881820ef7aeb2ba7d6e46bd333169e0f648b17754376b941958bdc59f5ec3dd32bf7aad8c888b726d745ec466733efb2a613498af0861f8ecb5e505e1d178d8bc5926f5dac1749c46316f0e0e76737fce437016f2fcc15db44e8801c36c0d481d9a3b7e63c475086a30c00fa3c00ac355760321cba231d5e4af53fbefd64e057ffe651fd5e3f46b03824cd89960e71d3e9523f8515d0eee7c413a3939f4f9fb1e33eaa9d692b19842b0cbb846c1e09681a48c5f6cdf7a4507a5e7ebfb98a92c565c9a35ef3357dd01abda864e99f1378099978d5b83aaf705c79bf27c57a6e936ccf854528d6bf6a72f1eab86c6aed8d1bf6f877b6ca94a65682dcd911e4fc6cef587b684cf889d9bd8923fc183c65327fb3c12a83142776e855b556e3cfb6314cdb9f5c10cb7fbfe105ecea3b4f8bde803311144b3c0103dc68ab12678bc48242a2f82d0ac855092d292d8b835e0e4f67dface1f23726281f82659fecb5f4f828236a937c48de700970f004d942fd7a0f3e7b109fe9365bd682f75ea61c3852be1dfd274805308b2897f4d51eebb537b38999265998b74bb93e8f0d24c280e5a56145a46084811bf982de263113eee9b58da4ed9917d3e0a6bc668bef0820f8b6ff3c402012d5a1be20fd0d35e31ee85a6609a345bcce4013c1c49af0713b96f340c5ea94708403870126320ce68ca1e3cf1de667561b406e0d62d48e93a575e0e4592a55c150fdf94711e6757ebbe8ad711d982efadec484a4ad69a8663b6dd7e2932ef048700c54a73c1320b5d08e9325ff000f00968ec673dfde32b0987c3bb536699d1bbf423a1a6f25e9923a823fcac54516851f27a8db076fb5a75b292c4a6155035909060c79794c35cddf951627a80c0e55b1b9876e37c087cbf971f4fa5d62c26abd6db96f9a1f1e94d37b87509e121085b8e12eb5189c4455042d0faff7ac64374ea17b83384d83f8450fa12a02011f2e7556e953eb239201267861a07cfb86de18d7316a9d9639eac3d5dc6d6d7443a29136cb0cb972823b99d5c12761b1a58b52e068e174bd2c755255bb7ea62690e1bd7e5e9645d143ba8a90c41f32ede6dc1c8f6cce71640dbfdc12406fbede17d7a3a5ef31b1f55bb1a4628d3b511fea8782ae0027d1add607bf706637bfa350aa186891a2e714771f65843a0244b75518470e9c0afb4296cee805c508a832e0b8151930693918b8fc2a2ef34a2f1a426199077f21c81c6bf4b50d5d864a7b868ff283620c6f1daad5689d5ea72a6996c67494561f9ecc16166a3b5d18de4c458f9407364e1658e666d268e315ae9b1f416a83ce668f5227607bb9da8c5d14f1f16ff8fa7ce9e7741d1ada50fc253c566aa6d7a7bb48dcc12cb5df0fcf83d630a04594055e66d0682353057e978dd24014138eb593d2b1c212b8d3fec118e159c912aa92dac54f6a89c0bc193d6ff86936d0ad08aaf22d82bbf25e1a4b6d3ee8fbd6e9eaa751276c06bc3cfe1d6af7eef589df3fb978a3438a22b916c2f1e5e3d0a64b866719ef28a133443de7789808e958f78366cb93ddff5e4f692230328875627e85272dc6e0257e4edbd048d54506357cb1d0841bd47e504463541804f4467d477ab47029448b0e32d8c6fba269d365e4ea7112d9251e47f2d79e8f1afc57b35b776927b20b03c0250788edfcdc99cdaf00c193f3a6c12ee00109914a0b7fffc60ad23df68d4994bd9f3d5dd5e0ddcbc106794c0fc7417713382fb01169765577d4a9f41ce0da8252e1c8c6d4bd79d1bd53e2eeda8052de167cd7442f3591eea9f37278c5a703e95504d1db504177eb6854cbb554e4ede1e2afc5b1be19cba197885bcf0372581cd4d08da352cc5de8aea6044fd8bfecdec02d252630811a7835af0a3a3bba0a224bc2c006b7b12ac2d4e7a4331b3ee40a88d0eb8546c114ce743dc707f35ef75ea9925a0d8cacaadc6a33b706f50bfef43188285f89eaf0bf51358836ab605960a83820ccc6f8d897f5803115983506f6f8904247841acd4722aec67e3547acd74fca99cd0e19c394414aa63edb01d61d218944983dc92f1d92fd5bb88571ab93609a1a9c86dcd4033600c5a89cfeff8f282529d41ddde88f261576f3479c9ed6b736ae44c381f4e62cdf59abe295e63d753a2290c273459aa9d493cdef764e7a5e04d3f0ca36a013206b32657b6b74199d7addce9fef0baad9c6cb3f4a034af2dd4e691bbb6aa76f91baba218fc45dc5fe66b28d322767aa0d2628a904a1603ebd6db2449c90b64f6053deedfc527538dabf45bd2da742fe48376544b568a148a33b4fb390ad5f546b926ce52689082ff59fee998b301358f5116cd7e04b0a22069f9a970a76d14777ce1807f7b8182440c60d889988f5dd866944bbf574a401aa3a0e2d71b95203353d6222e3fe489c1856edc2e462263570aa70a3481069e63fdb782132850462f32b1e1c1c308b00914ac9ab985fade177710f07ce92de44dcfef0aad24c9cbfa35a097fc41c8e10f858adb7069487cf1b42c559d789cb5501b751a94fa8878f0ed2d28ad9bdc62a7a3e1a1a6bae6cd8669c2f6df29107d0eb9f5aef18207b4e9e2379e427ddc5f291651659d66c995d5edc5a5ae3416882787f4c44553e447ba4ae6f730de1b60e35e6a3bba1e8545c2eddf0d31738c1e6acd882bbbdee127997c31607b51ec89d0bd6690a6f50209674d8016fe57c25945d6115e549fa5fd7e270a3f8a1b8373f7f689d2ec171c4d2efc96145b3cdd5dc3d0fa083e24b9e6e50962c2d73d337b889d7e4fa71f1509b63c77d5df7f5560c398a7a13f5763819b40dbae2ec5a35d8661841daefffc2e02eb39655bfaac112b4af6f85dd57c8f87007725754e2be6ca11b1c6afde8d782863ccac6877aa265863121e78660e37782d0ff9ed8d90ed5e2d5effd12552f1afbb1f4b33600eb707c31e1c4af9ff8b1a3da7f6a6104f4d39b7701058a7add4799f126949e9e47b84d5d29996b3e6e08b429f1bc01756dd3950abd43cff74adbaadfc7a74539deecd7841a3f0f2361a126c1ffc164d8deab1ca4655f89ac26afe3326fdd80d58154484ae675460fbfe33170f7e681da0be4e28a01a2fd1c894d8659d04e0dab77ba550ce0043be5cd5b531459eb4913d283cdfd2c304e0f36b6914acf16952435d2f4b41f1729660c8a568b82fdbd8ba525e3d72e1824db096c56c3553d2d90afbb89f308b7536f5d799eea561c099ceca83094f75f7c72b4e9059ec85dea40b3fa1e3c5997b3ba4ac733f9441ca0c7d5fb28a5a58dbd9e77979ea42b05fb50a1cbb132c4ab31c1aae8194a37f2e17ba3824f0e2516741f980d2337ca9ed5a92998484d88424c0bc4113ca1a8477c186c622102cbc569b6ede30fffb6ba5636dc7c8ef4d7435029ab83d0e6e4e51e679c2cb77521bc2e6145191901f3e9b110b4817ca8c306205573df70fe81bc5a0ea943841a804490cd6cd9f462bb1d63c32d25c3865d0b1851eed509f613a7c77e66a7b23f2ca314c175a0cd35f4d3921e7445a8944f6c75a8587bc45c563653d6368bdb94b05feb75376eb93ac573ee0d78b3c7ffcaf86cce69ac974daa9ff708f8523e5b9809ca3336ca04c7f150cd74fb52bd90c98a7f7a90dab33e9977b21b8fcbf70596d89a9d1da0c5bf75290d9c6e8a4f4a30876cf938ef07542ec946a7ee79236ed610eff6491ca422517647a103a59e9a1a6406995205663f84e236eb7d0bf8e5a5a3d7336f0e8f7c0601bebef9045baa9071761b5810507a3893160b7ae7642f0457e48d5afa5e2b3648b0ed25b0d07c307dd77770a818ed33d1e74911768af94f61c9ec410dd9a926e67a151e7a16f2daaafe480e5785655ee5466f45d948da4a1274e07d95a5b1fa0a5bd51140055bc301c011e5fea008fbf6f4ec94e7d1e38fa97a20931ff4e01684fa8c3e74875cd05de44d65cf2aabc5fe4c1b318ca507da1bb412f18e321fc704f93d3553be1f5ba5593ea860b3d23732387ab5091bf3b282511140c7bb88d3f2b175484700843de87f20b61d5b917c33da2abc60df2a53fb9316e83823b808fd819cb90caf4a9387deec2b891e2ee106790ffc5edfcaf76e78acc22263eac8c49585b8ba3225ca2380a39e310de504ab6f98e6355a9f55179be03eadacc773acd3c68c3889d44dc3be9d141d6f9e5d64527d250a23524b1f441a2997b79b45f8d6e3603651a338972b53d30210b6418b8c2371e2a2c239891d459a508df23b21fddda78dd124fc20cb1a143d1b3302f23aa8215f690ba7b80d25c0081f113a1199007e44476c44e0457253c69027aca39296e0f51bf943d0b258d32ce1e06aab741acc3fb262f93531844733c0c11e1c60a42044fe4fa7154ccb6a673154e950e7559479caeef9320844e83e122217cd8a62f99adc051d29732b91b3aef30e4349f7ecbc29750208d0034e9c99cb711aa7eae9a95a73b9dd5b491b5f89c710cef46258f2c240f493135f75712d66ee4e1806363617dfd761589f618ddf2111e653e8c9c3f20eeabbbebb9fadb6ffc5980cc26b4e8f913c6069f41835184dd85d818d0ca95ba6c784142b4319acdd6051b8669aabb28f725ef7c42b486f37f8e42f133a242606be2d2858418daf0e1893ac7fa2777012e6acc7abcd8f11b76083705233935a1711cf42381342f19ba6a24efa2899de65ab52c8291e0998271476fb5f90339d1bd50457f172e8cf58817457f05c5256d786c3a8d37e9b42027d21b148398dc9d81067b6bfe3973b0914d1d9f68e8b31022138542056cfe3b51b8bc8cc8c56590fea38b59d57ef9842c60270c06773f09ff251fa5a85d8c6660c1f546a323f4518893ae5838af0dfb0049c3d889056e67af3754c8376ac80f77a01da8e370cb8695e6252e4945e68552b42a420e7707cf03225f25616df0c6a61c1f162ce303373cd9ae377ecdc507b314fc767195ff858967a804a2fe3bd63763f0beaaf72bb1b74dbf3206806a57994ec0d291ef9c8e67bdffa2824817a050782d49a49de81b71aa92d03953a7cf3e052c689d676fb57107665e39c65f5636d8de271199ade7b3ad68c3b972e18645653a869b7880e0adf356e5a8d3c627c36bcc884bca5d081351207ca47c555ff6fe9ba92bb40ef3b560b3105366b0fe9c4c62b2dcdfa93429496ffc717d51194c7b46b5945f69ff4633b83cf74531fb0446e263c96d52e77226aa643b871d2f785572d20234b107b0dc2e71bba1dd28e3397580c1002b5fa58e6cffc259935982eefe270637df2b3436c9362b424dde549ef5321248a187921dc07f5d034f33c128a0b2b0f6b67051736f0132eabea588d924e4bd00eb1eae935503a0c8382bf540d9c8449b6559ccbde439abbeb3a11b532a2c8d688a3711c06f07039b0f31107340c5744be4511e2a00c015a0f432e057090f71140c55fac0006955350c2bd2cf23e3a22516c687ecab4cdefe976d2a657778d03a00e919ed9a8ad7557cde8309ed528159a716f1437f14e0e0ed5da7f949af4fd673f92d5d685c8de7a31e3e12025631da9b993fdca3ed46eaaa6695fe04deab16e4a8f7a2b8142269d9c4987fd4b5f7c6e55448bfd83ee3fb08e726ed7c2e738c4b2a8868d9ce4fe766cf14b013aa2ff92284be5bb2ad3d6e329895fbc1f60dc7c9e9360fd22620609b45a7474666be95e5ef1a848b0fc040a4ee63d2969e4b1fbbb8c7925dde32a564f226195a7b10e800985adafa7283218fe692e3e7864067f069243c87a06085d48389ba60aa12dcb3eb8dbabcceac8f3dc64330bd9acac9bfa2ed467bbad1d992abef303e71b762143ed55734754d0ce7765e12e876693f0d7ab3fa3b2121aebb705722ac4b50a4812ae59f7b9df103a7ddb3569f82a7b5660f0da7ea5d44d37f78396703bb699b085b131786ce02094b4a0b41d5ea42256609db393f559376bd788d3f5b96a1fe075573e1dd42ca97dd73dff02f7873d542dbd514aaa699c9160b2c0782718cfde6c7c2f9a95e7bd66e187071c963923c8da4df78af84f428d97636336a184c1e8c063698dc01df7513d03086975f11a5e7182e81cd52579f3d9026983c164ce37e56660a9517c38503672943e22e212bf17e048eb33e8b8077a6dc8e57b78b2b72a2e33cef01f7a07a38760417a37cfb819af4032daa0a02104d9adeeb8841499963bab41e45ca255bbc085d88d1cd5d6aeb7df94b19b61c921f7823caf818edda69c86e7ebf1b546ae05aeddaa7291194107bc4d1d6eadf667b128b9aee9cf73467fc17537ff045d5d56cb3278578a44883894d11e7d68de6ef11ac32c420ee32a5e1857c730981eec32cb379e484b2091d8aeadc2f19394a3a1e0d53e411e01cb141ad6a1d2f3ae2f122c49a8e9e336383ad6963ccf2c1b7a42c09c77d018899656ffcd4ae4502ab5fd8a41fb2b58c891b80fd0a969aeee139632aa7cab1ca0a75822e639c46a3393b01363d148c1da378809771049d68c6333adbf22a592b95a129f1da402daf8ba1819c50bd8b977ab7535dd6fca66de803111ac381754d48dd4554ca55f44e16fd05c08110beef4fbe5fbaec32d89907c6a54d1fbdfd6985a41d80e448dbe2e10e87a2026cc29f564f61c3d44763d637a6f01f76b3f0e1f2f4bdbc3c812b4c5ddfa3858383876775ae4ec719974b854c8ce4080684fd8015ec854f07e91abab028165cfdb5fb02e5a3ab2342962e8b8e89e80a376f16050d2c5fafe65e9f7bf489b33cf4fdcdd1091ede43e7889580c5cc600a7a0f430616972b07fafb2ae9ca77635f7c5e56d56e9882d6277bd8afe48e55d45b2769273b64504de297a80b5b9ea962b473e5931767e4d64859b7377f0bbd075487d454af85f27f4cd036bf0f62355ce64dcaa8fd28ac665d0d4eb0b45e944f2e35ddab199c4c77e597a8f830a1bf5b7cc3b2a80a756dfe253d25b53f2edca471ab335dd77d0114104f54569dea34007fcf1d9f9631bca1c5e5bb721044bf87c43e594ad6d8d5af8a514e908318ec78052e499a2e564be4692991867b8678b4c439d39e2fa1b75427b70c66426ab965dc59fb10acae2ce586513ebba70d17ec561c435c531d688249d5a84ebda5186df34809a3320795b8b9e54285442eb65afdc5262577908da64c1e27c32435fe283f7d0bba81fc253e36267c1bbe3e05764ec0f2c5596c5d034e31bb1c54e5ed6158da6c1a346ee8ba9ed16505226b5e5d8a6c7b9d65753701af43b73580d1c872e137cfe5fee48cc069c2b8ece88200f982f135bc8fb692baee42e78589e320d31b261b28f9ac648df03b5981bd3a15f7b0cf91385f3880290dec1e62b447750aa19b21107053f36209ae1405f49f05d063e98ef587926eda94840368b59f39f2aa52eedc53189a2e4cbbe601bcfac8d2c39557036204089961ddb083b250f1c85bf14a16d1f1f6e395de6d49975e66a5a949fe2f8a1091ad90273a775dd58eccedcef7f3530330b5107b91572cfd5a8dc982b845d9c6e6bbc75644640b4bfd3422b9562de5112cdfc632ff5e2badb2a1279c67523c35eb6e6c84fc2bbbd6e922093c861d6e3f1fa5143dbcad4db0466b6d9aba7f64900963bd0621bd569da210c3e6853e772b8ba55da4c6ecbb8444098d600dc94a640a597a380a8c5cb31ccd8c6af7e224fbfaf962d3447035f8552848829d3fd3cfac3cc32fceba8a02ebd96a2e0545d34e51ecea554c75ebfd1415ecc0c4302bc12f1ddb97f0cd640df1ffdb530f6a4ebb85d05da22736160065a798a98e8ccc805a06f289a11a2bd57be36c79d2ec91911c3731ef3aa597dea0774ca8e0074fddd76060c4ec4aeb1a703d5b250bef8aee813faf7d7670dc9bc3a5cc972075c6a75455fb58c8c5ad8be554f8952601b03410e5635dbec6b8369b9c932be291924cbefc2b2e904f7656a0f325121ad33ebf9397ba2e436e30c5006a31b25d181c31b71de8b67f81913c0497edf637a2d3b06dd910d8c98dccdbb7a55f1ea6bd05463656aa01f2079eba6738c2bc70ea78d07864b7718c00ff672414d076bad3100bf6df53c814a3884dd21ed57dc87462acf656479432ba8b51d9249871693031264ac0e69df5468917f02a04b41d60beb0f734698fd714785c3b0f32780871d3fb70bcc4f555e60a5236e65c8621af0f33b55f207c367e9d99c3928b6c1543368fda42e09ac18f02892d9d34889e1427c773c4e151c1f9b74a0f03735ef38a7f03adb24143ac702c901b82bb13135703bd506f05f91141a9bc74dbc514548258c21805834fabaef863bf3e3ba482d11e71d3c96b545f5c5f46dac8a9b2ad7218b3c91243d9e9401d7819e2a3b0bed38acbc8e1ae3914a5e397682edfdccfb1128f5291d8afe530240fe009c2f074639e1adb274b83f4cab0fad11cc68359b9d2e767188a7d07574b4d5b538a37d4296e83edee9054e8d5bb605da2b2519d940ee422e845494bf57b2c551cfb7e2414709551a307460d7686157333d0734773a6a0503a7c49e51b5179dd8387f51d01db7fbc9f167e20de426e12ca455bc2eaae4db7ededaee3077090464ed40bb3a243ca5670647d39f8e3ce4820aceb4b9aa5ef80c3392e21d703367105dbc0a3106b917e0e5b8982e585127daa9e12586258116e0a15a5ed1334a9c8aa390c5c39d66135cbabb4cdac53cf76ff5f00fb2ba7e14857589b614ad50f732d8eca8eeef639a45f92cca067b13e68afef3c5bd53fd1a92248ce304a7f479b2adb371bf9555dc39acac53fc58a40b067a1211696fd2c4d456113db4305eb9976d7da253b639505b38f3471ccfb87c78466f0c8b3616d58ccab1fc917c4d7854af3d1bc94371ed8b36debe9c0703ff35912fc059926c74974f65fb765ee5b472daef20269dcdedf8b534feba723aed4318612b516e3e63d58bbbdb6808058eec41a35b08323ed515c500b07e618882c59679ac19486793995090b0fb0732c12e4e7f4f04b8d931685a4d28dcd91f619fb02c507a39361bd784810338be5dcf51bb6002f4118741ed405383a012b996c0d0eb9272c50b46714c1b30def90b043179d9194a922ab84efc751d2040822473697a3e22c4c2d421f54360583600c75670bd0a531f17a1a66c2da1baebc6c676b67cc885484685f867531537fe46aa9971c239f417b063019f9c3aff7ee68f1e06a993a9c88f2bfa188479c74f2bfa627dc748774a0e07f5ff6f66d62f8a89622a96e573910c6b5fcbc37ea3946252f49865230ad98eba70c080680ab74bd5d2d9630a1caa1671c0101d337e52f37f216175e6ab0d26aa7beebb0a653845a97c1c7297ed5618fbfa2c5db828cd2b176bd3ebaf995061ae162e9c690ecc8d7f8df79bcedde88630ffa4bac7c55dcd87219bef5fb9518e73130c825d92a2fe9e1e634271bda7d46d06763baf7a071186626bd189a46cfb0eeb28c467395e915978a78397cabcc6411ca3364e84f76223ff5313063cfebc49f3b282513b4a0f26ef64f51544ad6fb9f706c925f425e54b75f8a7f3f923a72115129140b329efe07dae90ae0c75b7a85e5540afbbdb72c12a9bef590aab8dc02f9471f18eb3031b0b0930437271e5355f80f62f064300f7479b83a23fcfd0027daf02b76bb2693176671259804b21e61223d6b3fbaff2d5d24f2652287814574f28679e1ee48433ca47c7c56b4b75d23d1e3bc66d629549ef7c49f849fa7351f1e51a1befef457508f6bd85654da75179046c0d458917d25495433a400e49162bf9c1b3ba6c5edc7abf2e6f59e7f06535b2fd296cd808171e92e1fc2467464eeaebdcf5f200b9747e8eafffa7613ba66446be94f1455c49c271414f8dbf72c21fa4de4ca49266f6329f0f529c80876bba3d6fbfcc58de0f6f81d445a90b89449f5a8fbfdd2ee6684cf804c460b6bcd839c5266ccddfd722eb7f21161046043c551e21d2410da457c45d9c73ceaac937d50009a3dc50ac99f1d4e4f93224e71b0175ab39ded43cf81a16908979bbd926fe905adb582594c86e336e3f46f666bc153622c8b75c721db40781a5bc21b02ff6d3d50e4fa27509e4e8e6b8b4792ec433202ee9ba0c48364afd4bd0087341c0085c1d28070166e32a0202eed83f59f14b70357fa0367d6599addbf231a939e8a5d0960854bc276020ceef7d74c879a5790091213b2dac638cc7538515310bf04470470c2e9244456c15918c4a9dbdba651a5415f94022539cb39e189de5326e9c21ce0dedfb85ff6a9641095e6af3c642886b03a3c853cf2c0d608fbca8f47cf8e05ae891349b85a8b9341ea1f7ed239cb9b96eeb43dbd7b0a6c362d65f7a8fe7ed6abc10252429a7b7e0bad60223e837bfeb2921fbdb3880a9c4c0899b9308568917b99e0f0ec8170dcd58c61f12270d6831b7353a84e1c967222b253a76ce162cc1aafc7cc569b141edbe930a2cb75dc155d1595bec83661452f6605752e9faba531427f5329f0252f0c647898e75ef45d0482363598fae873f8b4167dce6e760b91bb2a622c2bb2515c8408435b2b7ece1aa7d61325a88ecd47c52f74dfe0437edcaac5e59a02cd2056a10529aace4bc282c892dddc4eded68179366faa4be8915237879dc4486165361482d0fa8f7a2ede0e6aca17307eab813467408865845bff89a615cee23a71eeb8f78a1db0dc997a7d85ccf72f3c87361fa69ba98476ebd51a6ea40654be1062db5dcdd5237938675d720128e5c23a739ab733354625fd27bd9824fa19054865363e6a403e5e19e49a1a2fa2703a3f1ddfc107e479ad13522487c14b06dc6649baa5df884f195e57a90e043fa7589cafe655fbbe3c8553800acf01f7bc8c054c9aa4380e58895354145ebaf2d473f979525b23247c49427f6dd17a797b5c23aed9d700cbabb5683c3147f2aaf88599a2131941c9bf1d055da164a9415b887d2e9e091b9647e0280925310fe05e2ba2f630a5683204de28df7996478192af146e59e079112394b97163d07b9da6a33159c286b262d4a6eec182cdb8f2b2321c51fdb59dea2decfc18f503eba343970e61664895699c6fbcd5e60665ccdbc9a9ddc662fdcb622ed45e15b00802cb5e3fb9b8905aa9d6efe7b261f412a63af36a5f729921dd61eccc19f1613867de1936e79e4dac722e7c7f7c0ec481ae39352310c703f278fcad40eca8b22cbbf764f57445a0ca8a10dd9131ace13432b56826d971d384207a8ddab699cb9c423827f1e73e8cee41cbb0768e3bb76103f010dc56a62f6c8e8fe013b26c97b8f60447f316a3d31139af935ee8e297cee922ebeeb0a58c8b62fe6cda29a14137316d2d80553588784ac0b273391bc1b948f30f9601177f51559b2de10ca3c6e11cfcacfa6408b708997ff107a1209992415f143838b85c9562b01ba7ad024f2141b598645f3d923f25051c60b8d8adbfa50d9e5a643af5a88c4af44ef15a60f3d89551d02c5c98e4794d6e5fb6798ee27122a19570852997caf482c34004afc0c7848357a01ac63a0318b65e607251bebee97edd3de09ea793a5b88d196ac48bd79b548b637a39720bb5a603950dedf45cf1208005bfa6fa9fa87e4cf812d348508ff0929611b8bf05503b956259b7ed05ab1d25a583a7c6e949d20f888b45557065a74b4a7e4c5d8331ee82273a204a873eb6a41eb5d9d00abd8ac1fae94c541fc9af6d52fe62fd348ac17b6fd60de21e8ef20aa130aba8bf8076e48956982b7695aafc658bcc6f383c7a3129c6540c4d174fba09241acd023a9eed4b72c14b5633e4dcfa2fdd4136e6164b096ef206ea732acbba30762cd5d6c572dfb3ca070bf3ab3f3c67d170da840d524e7008f63bdf1c89cc0fa2d295897b00f1251e1dc3a0e1eb57fb9b6f93c82c331556d8617566a6d0395c1eae38411ce42b272d7bfa5bfff2d9b3e90089a5ccacb6e675bb9421809de2696e4a528316178086ca7468b7ee64d88a18ea2731cda2d542918ad1d14bda9e3a4834722df26469026dd53185e3e76b355a2402445b925fbe6e538378efd15280ac899156a25c1984ea849d3b9ae34185c192abe090b374f4aa264454c150ea62e05d6ab0ba420e10c920277a3ee7642c22fedef8c1fabeec179537aa9226732dee095ed31e3e1078d7f107c93d60ec81c08e1aa90fd74706535b68f31057b05ba4c8dbba6f8a8f09a402460a690eba588dedb932ac9752007f9e4869e176e87c08feabdfff09e860b1a018e817b5d4fd85f0114b7d7f8cb1342648709a3e464e73931396144a7878438d9816327938a939260af264356814bd4458585705a773ab99ef9a94149b71610f0844992c79a3f30c1c44e5a01d3bdf1240f5c31ea7b89501139e84d6b5daab82ecdd211822d33302f18130905f4e0f4c952795d661e8289f190216b7cff0456af4714e01e9303bd38ec7a2e2d511dfca8b88d729f339b19fb7469f3d5ea4a0a58c0c6c857f8a514f8a347f536dc66b25d8d00e263c7fa1d22670937890a9651368846020701d281d8768b62ff66aed357eedb498880ef403032b1baab8ae870ccce6f649c3981d447ea4be7cd8307414bf2c0b47d8c7c559a71bcd753ad265267e0987a50e02ab9812745388f509cd169bd6b4e233f9744e50965dd32ea8d429d09e8ed8c64c1c2eef6f447dcd3b882de3fc690cf8959a47bb9905f4508cd0437afe0154a81c130ace534eb5a6977247f425e7328e375472b86a5df083d313d1844255831e91eec4f671754e8b3578aaa11ce362878e573140c9d5b3104cc5ca8aa67bfbcbcc830bc579ee0ea16f4847d15085dc3bc485041128488a383070cab2bdf78a0dfd2b471195a2c026e2e195e2a7013c254c72520b6f081d7948aa25e0963fd48ca1ab5525b2e0339d6dedf530f009993ba207811de171b7db6ddd5de98eb2d883cc0cc5f683191549407e27f66d39bbee1bb773f753c4bac63f1d50aa3724be37ff8856b4cb94aaf8f3447d78d9ae7e3aee2802490cf2d7eb5c4455210263d86b489816f8da431a7abdd583966b8d6c8920ddf06688c0842120bcc8fd18c44729f702d5cc0a5574ee3f9ed694cc92af235586ebc2eead597f47168585829c92a2e8d0cae969ba7707e4513d483b05c1ee844a5bfc0cd19345a53b0e6daa8b8b8ef6350ec056b97c105c7f2c90ab9a33263576cfad63edfa630f1963c6adef97e1e30564dcf38369b200f0338217eb91e46d010ba3b13c45f9839b76850e47f14842db42872b14a250c0b2cbc5d212ee7f823f8a768935f3e376529847c4c5af8f579436a0008844f70add8cd1dc64364615c9c59553ce891910dcc990a0d6427f3bf57701a6eb425b2fb8a12b674cf2664636fcc5ca57452565ee416b4e94402269cadf62ca181d5ff06c85678a8922f7ae7c2e8a0d842838c464310e24914646239100d52f63f6bd7161dc95a69b5c3a57c6ffebf166c3bb85a39505c1f587755ecd36c0c411f52f466346d1e12235465102e56cfce10dbbcb45fa8b5557917f5cca9bf094911c8edf58607ebfb1e1b5afcdca460d0c8e8ee8578665368c3ffdb3acab3c8b60aa08118d8ffe87c8f225e4c5b27d09e5b99f0f0dd83a770e86a24a52d1d58b12f528b6f1191056632fd4ea906d25d5c501fb0035f0a2f5dc69775a2b22823556149825f47e1887dfa88617a207f0620c81f42d49fad09532af2a5238745a55bc0aafbe5d3a8259e2a09c936b6302a862bcacf3d05e5e6fddc09e63f8d1d8cb9dc3827251175905ec6774e604f0c91aca537f6d2d78832fb1c1e4e73a303a93835c6b672a9341f5a9eb38a9b1f05c119b89a41e2c22d7ec8d814ca1d9b7d14282e65d11e90758655a9a457b09d3e889f25d561c4336be819bcdc877782ee27f22167116094fbe0f84facee772f5dcabe58f7e6c292f2aea7ac91ef67e4a446035d7ba9a22c7e59f2e34a1fd3e0c83a78e6525872c322e197a87eb1223f678c8fc2301a6002d85a3e54b4121ee76a6263cf1e7ab779ed4e0dea569b1d41a939376ba9004dd194d76767519b21852cde360e8b1b7709f26f9a676f47b1f092e9ddb9315fca46312caefd5e545f998c47b53405b2daeef4886222186f0267a639e3c756c50c092e1fa1efa373e185d2ad144a57d3259251dc2f9326fdcc10a8c4a51026fdc84c6e32ab80f889252fd06858cfac69ad1dad9d7ac8085a0b5397f28dfd20b933aa9c39',
        salt = '468a562a9a2bf9cd5b1c3b0a33fee66d',
        labelError = 'Bad password!',
        isRememberEnabled = false,
        rememberDurationInDays = 0; // 0 means forever

    // constants
    const rememberPassphraseKey = 'staticrypt_passphrase',
        rememberExpirationKey = 'staticrypt_expiration';

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param  hashedPassphrase
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassphrase) {
        const result = await decode(encryptedMsg, hashedPassphrase, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        document.write(plainHTML);
        document.close();
        return true;
    }

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        localStorage.removeItem(rememberPassphraseKey);
        localStorage.removeItem(rememberExpirationKey);
    }

    /**
     * Clear storage if we are logging out
     *
     * @returns  - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        if (!isRememberEnabled) {
            return false;
        }

        // show the remember me checkbox
        document.getElementById('staticrypt-remember-label').classList.remove('hidden');

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassphrase = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassphrase) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPassphraseQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPassphraseFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassphrase = hashedPassphraseFragment || hashedPassphraseQuery;

        if (hashedPassphrase) {
            return decryptAndReplaceHtml(hashedPassphrase);
        }

        return false;
    }

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        let hasDecrypted = await decryptOnLoadFromUrl();

        if (!hasDecrypted) {
            hasDecrypted = await decryptOnLoadFromRememberMe();
        }

        // if we didn't decrypt anything, show the password prompt. Otherwise the content has already been replaced, no
        // need to do anything
        if (!hasDecrypted) {
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const passphrase = document.getElementById('staticrypt-password').value,
            shouldRememberPassphrase = document.getElementById('staticrypt-remember').checked;

        // decrypt and replace the whole page
        const hashedPassphrase = await cryptoEngine.hashPassphrase(passphrase, salt);
        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

        if (isDecryptionSuccessful) {
            // remember the hashedPassphrase and set its expiration if necessary
            if (isRememberEnabled && shouldRememberPassphrase) {
                window.localStorage.setItem(rememberPassphraseKey, hashedPassphrase);

                // set the expiration if the duration isn't 0 (meaning no expiration)
                if (rememberDurationInDays > 0) {
                    window.localStorage.setItem(
                        rememberExpirationKey,
                        (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                    );
                }
            }
        } else {
            alert(labelError);
        }
    });
</script>
</body>
</html>
