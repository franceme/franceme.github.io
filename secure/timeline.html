<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #4CAF50;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #43A047;
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #76b852; /* fallback for old browsers */
            background: -webkit-linear-gradient(right, #76b852, #8DC26F);
            background: -moz-linear-gradient(right, #76b852, #8DC26F);
            background: -o-linear-gradient(right, #76b852, #8DC26F);
            background: linear-gradient(to left, #76b852, #8DC26F);
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>




<script>
    // do not remove this comment, it is used to detect the version of the script
    // STATICRYPT_VERSION: async

    const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 *
 * Mirrors the API of CryptoJS.enc.Hex
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassphrase) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassphrase
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassphrase) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassphrase(passphrase, salt) {
    // we hash the passphrase in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassphrase = await hashLegacyRound(passphrase, salt);

    hashedPassphrase = await hashSecondRound(hashedPassphrase, salt);

    return hashThirdRound(hashedPassphrase, salt);
}
exports.hashPassphrase = hashPassphrase;

/**
 * This hashes the passphrase with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(passphrase, salt) {
    return pbkdf2(passphrase, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(passphrase, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(passphrase),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassphrase, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
    const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassphrase = await cryptoEngine.hashPassphrase(password, salt);


    const encrypted = await cryptoEngine.encrypt(msg, hashedPassphrase);
    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassphrase, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassphrase
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassphrase
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassphrase,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassphrase = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassphrase, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassphrase = originalPassphrase || hashedPassphrase;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassphrase = await cryptoEngine.hashThirdRound(originalPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassphrase = await cryptoEngine.hashSecondRound(originalPassphrase, salt);
        updatedHashedPassphrase = await cryptoEngine.hashThirdRound(updatedHashedPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassphrase),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
    const decode = codec.init(cryptoEngine).decode;

    // variables to be filled when generating the file
    const encryptedMsg = 'cd348bd20fa23519ac7b99ff76aa9485cf459b7c98629c2f69a617cd7c8d3821887abbcf31089ef0b5b9bfcd2c4572ba8a46ced112e13988b705e1793eb17bbc0dbe7ca858481eb83c6458ce3b47261a7c4ecefdc1d96abe21df714085f784f0198b14bd1c4ddf6da737d96bb032f9465345fddba70f1477aeea4727f7ce7ec9a2fc18cf16bd3c57f311f1a20205eb7690d3a05338e7eba190bbd96b3255ec7842d78ee4363461fbf9d057544ad7a18e6b6413b6f4cdc3e8fbcb73adf289114574755aec1cd8eb962f47a52e0d7ddcd66a626604941e072fca80e241f7929cdbb490b63644c1b0c658843ed6d0966bdc219abe844a4eb35f83d4b74815bafdb8634763d30babe3ee4984f2ad8681de5b606f7136a15c9dc7ebb0f155a361959c9dd5b6608b5710f2d59bc9ee563ec5480589cef46a9f8eed05e953310758f3921cc34102793167fb974320b2f44f0e3259b1d7ac27bb698d2a37fc7bce04ab5ca319ba077be4e4cd628fd14aece0c7c37d333bd3c01200fdb83014758c0138b939b09ec5bda09cb6738d366632d13c452f9c4b577bd7d78f2e21c0110954315f0676fd68cf8f4ae0cb739ecf02c1fda26cf726a83a0b0252d22831477f84fc7bf33ef337b7c1b8fbe45c5643c33c2e736e0057b2ee8adf4429fe279188c88f5c47b2d19064a4c663469d370d62f55fdeaadbfa372a3e7b0c24b46b0e347e7042bb131befabcc9a07dcbf2ff48a50c0c90a4feab3975872e30e01bf2473a98b9d6dc37769f038b651dd532484169af1263fed73309da749bb0bef87fc09cb1d6eda6f6262eea532a232d561b91ec255cb5ddae10f16fc764989b649a7aa188646cd93a472db320a0ffeac5bed2f1c4ffc93b0c808f6e20bfc21609b44ece0019eb5159ec997bb57f6c7d4a4ca5607593780397d8c2f5f3d3a52912e6b01f8b5bafe14bae634fd52b811cc6fb4c01d1d15934fa733fc99e73684be3e2e552a95c8d3583fb0461bb1be92f27a968d4eed36d82a6f3b1c726cd5bc3e2c3894d149fd0122b10c4fcbbeeb81cf83b7e2f92eb0d077d1716b83011e882a9486ec3bd8ea5dfc7bc11e99b4eae4e0ee1e7443fd4aa3b4090b85d957eb19c8e5bd834e679366a57bdc44c31d295f9e66956f5dff650ee45129bde38693e86504cc34acc2b2824057927684aecab3bc26190fe7f81786d509b1f19e218b4ed5ab6c82517852eb8f2e3fdba6c5bf4a642564bf97d5478f73bae0cdee7c60a8c3e84803d823f40d5fbd9a754bf9c49d5359ed637eef3e3ffb28e3b2c30cc561976b2447fd53fb6792f92fd9ac7b3fd87e0f2e629b1eabe3eda6174823831b5436db2fd24d8d13e5f3b19333612022decc9124fb67b436197ff634c5cac42b73d5e50a690b48db5cb69a8e6f8f39c27aeb315576bfa1450c9632dbe7ec14c9976bcab00c1350d10d5e3784843dc6cacb25e3f73e89de87ca5f6188824b4be8e08f77c54b26820acc9d2a5acba79bce624ac90ce84923bb7ab8003e0a596cc7827be4cc6b1f33ccda694b065667c1e15740e3a2e44689e53ff7748e7bcaced47179aae0db984f31f2f09f3dd6120cc225b6ed4eb3c19f86970a1439cb3143a253a505e71293e541bd1db2384a471c8afc31e575b8bf779d6127fe5680364e2bdf909e6abc57443f0384016140d5aaa8e5bfefc3ced68dbd75c7f0b756446f3fd37c76d0b103b79210cd53c2d4126aaeed4dc7407eec2923acb84149e1739d85bd62bb5ee4d5c8f657924c8ffd5f7a7d8e5ba74478609d36425b56059731a0857e5a28022c3dece7b3b12545bd0fdd3eee40a3d915e4fdbc01cd4999afc583f2a58243e5d9d290da47bd20a2bf8357513101ef35516c3fbf659b7d7d780275ff5772a7eaf6a374996c2852e6e7a44e9ba4a8b20592643fb43f83f978399c0a8b1892dd50704c5176558464ee379e44da79ad3f24ab3120305fc2a2428ea9cf8d3315382e31ba19a76c3ea4fd0d65ac4a98c101895ee08830c1fd2a8bbdc41248e1d40c7328e1d8483e2e7d12a09edd7734dcbee716f5df9fd37871702e643afc3b646d208edfff7e13df8c76c5d2358ed20cd295353df3796c190ea06609b7e1376d923b4a9e1e79ba79e210a514c76f91845028f8ebb01f4a4ed0d3e545e658722233d3b9ff0660c034dcfd2f362a1727506df8f94a530150b8976a865f408fc4805b53db0282010691a8d702df618e2fd9a0f59951fbd2461081cf9cb6c839aa3f29f22fc43f9559c04e05709f49db3901a3e387d43500692edfea8b5c7da77cf7d43e4a5bc4540051406168b644565adf80595790710f896ff64e6c971fce8bf9a54ee88fc75b05b5ba722748f50c9170a5d06a02905879ce37b941dda6809eaed45eaefc8d074ef308e35c28e492a63f6c77f4a071f3ec23918b1f99e12639e4a124d10bfcee940053fc146f81c5babdc378ae9ce0afe81ef2f37803385b6b073bceb208c9ecde84a3e194bb76af9c96e03abd68dac381e1d94b7e2fa8bc7ea3faa5dcb28fead0123379426599ef3658d4d435e2464bf7eb0495b9566f17ff8054dda449b448d02303f8ac98e7aeb0fff83efe5e8a1db52b8901f8bfe6206d8b67f7272ed948c4c67e61c988b4cab4c19ef27d11c360115dd242cc5dd5f3ad4d80fba6dd25fddb9b8863de7297291e973676f8da8175e6e53ac0d0a45daea1b56dbe91b28b744b7dc4206c3ea004b1140885aa4bf1a4a0af3a830d2c193e6a575299f4abefe0b9350d4da47e88ad96106edf233e60eeb6a884fdffd1fd7045a1c4fa7190a38478b2bfddf0d2e03110cdc9e8920b5967e51c32b8b4d89d486e1a3e8f4a2a52d3850ab597e3949e0c028e7b30afd11297765c5df4975c87679a3e030f499660fca17a136cd9262a6a049349561c32b4cee566767b692c3f914be8469bfe4807b8aad14d612f88f934e5aaa2cbbe6b5a2d6ef4303da56ed945e5acdf90b56e80a16d936ece8d201ca8eb20bbcee21d4c96d00adaae4941628e8ec81bd9e5947a619dfbd638d9b114779a7097752850c011607f9f165a2e68248582571c924e0ae616676b12e34bee4a95d856856dbdabb0ccc7827cd43e0b8ce809c3c55c4f0d948e3801e9742b55cc015210d6f8728aec17719fa6ca078e0bc85acd9be8a352d488998b0ea275c906af9fe03c637e4880fd6a5cd3d597142842a33924555ff913eb2340125eb290a1425654af27099b019fe68238f311ac2390faef652fccd62e01d0655305c96d802b0ddb5a8f02b041f16270e9cb48b1b3b2c69895a567fbd5f4ed4d11dfae797a14ab5baa7d8a470563a396be0cc992039ec606b497766b7c5ec98b5a0c9282ba9ea38298e1b57d2c860ab6e391a50262ba711e16d389c018520d95f2088e0c988e73c2c9e0f83d24bb1a9d0fb1debe539e4f6d9eedcc61f8f7a93dd8042a8ea03bd4bb4acc94b1ee436040b36fd28c5da3f07ca97a449a04d2f344a66e10e5c67961638ac344f41afafc566b6e5227c6e810192ac6fe19b8f5c87db364f1839b277368189643320b04c357d68d31895aa75229607facb7e441fbe92b395fc6004993eb4f41d6d1514ff6f42ab0120ebe7cfa54facf948dd2d52ae46df86c073b6875dbcc611f44a7d0860359e8a864204d3fad9bb76fa425387baecdeb4b3ff4af35ffb62041f493ad3c0897867e8ebab991a84b9a6050f860be6309f1e7c5c3f501b51dd8b237df564b9f1b45a4d4e2a37a61f79f19b61e565c789198f78a523bae48e55c7a4ac75ace5c49be51dd307cb68a4fb1ba09f7e08e37aafdc868fc1c8b64744e31e6c6089113460b8928e1882c8f22999d18ed5ab0b0b564ea9d081908815cb138d0bd4b5d0694c6c7153810cdd2c68de9cfa2cea8173444e42115a39a48be9d1ec4154e8758cfc92fb70834a4e054ad65e47e158260911983a48a33a18344aa9a52f4560b2fcb6a0ee6c61af4879ffa7f2e345d03131abe69b3aade32bb8a20ac4f5958bf603bb521cda83e41449dc160c4d86b3174d973ac83449e19560622c34937c3c4cad8317ac9ca4dc1c9d3f090c428fc857d24f784e47d68619972bb73be6ad0109b9379a9ee5abf1e570d865a0161734a330a10b65c5e4350720fb3b19e48496aeae842ac918207d9afcb2377938fcbe86bb4ca7308b82c07ec54bb7c3c93f0d95751485071a2fec0177c29737f217d506cf3aee3692cd4fa70d8dbdf9577421b1d7e1fe17db5188be869f0d7e3d1017e03ebbc9363d2237eb44337efaba71ca07c25d80540855be11c4dcdbbf702808aac772731269f064681dc4005fa68e223abdf11c823a1526bedcc9cb8091c1e8caf7c812e959884a1adcf0389b9afb902b9a39c0a8287b68c57cdd627d352ce6a2c54fb7453684ff1e28230cbf790c3380a4ca7281119256bbdc48cdae58b1af5050751eb8dce94126032b92913afe03a44c653d6576b797ad7e65f1ddf32a13b58cb2c6ae8373d8710148ae7686e3436e931f4f9bce43899cc9c681105db22c32823644fd710244bb31df366901f16f3b55e85574a5cdcafc3ddfa55702ac9fddf3d21134da874f4777b1da3df6a1044712b8ee71936e4a775be5822033a7c9002d5ad97f4dc89f1e2a6fd244ab4158d4f4b50c504265f91ced08c7a28f4c7f2751b0c91e266232c9dfe4f64e9e1c0bbdb9ec10bed7c429a3f547232964900af08d3f57f455400ec461fed18875a17755de2bb950ad7bcfc290a7c9e222a137a1be37bac164ce88ee53895ca652638c004bc76847abcf0a7030995c8259f2bdefdfaf67b687af244eb95bafe12440eae30aac11d82922eea82bc737ebce4bbc230ee6dbd290072f1812b6ac569547d9d552fbffad9bc1475857bff43f32bb7ea7e0d4536abfe5e5abcb542df1256d8939a7f46d0d41b9686d3dac7575b6cf8ea12aa0f398ea5b21f3773fb92183f93a679230f4d4f4ecfc391081ea4f452ead8f7760406affcc6793fb80c9751917544d03b0af766aaa1e7b0f3382b6fcf1d2faa727efcc5a329081a3574ee4a3584bb63371d126f6d376adb99155d7bbe6dea2a2217e403a6622bee9940822e361368ed27bb5437e4bf4ef02fcfff92f9cd9316ec954b3719784b7faa98acb872ef0ed9130f6cd63313957fbe96b6361205131e0353648906c5fd82c8aefab8bf51c5fd49faee32a9a500754bc296692b1fafa6ea1ceb1acf0a35aba74e0a22d84a401e6f4b0b6ab20ec7d1b8b7b9976927d08b2e429f755ac42cd836d2e6407d7e9ce89e9612bab7f78fc01d35b95dd8f2eb4ed6853cb216a95909908113e79d84a7ea7fd074daf9f5cdad5336fff3776c574a10c128f33bf8d468e324a173896ea8770434a5a8f9ed13f46883c15cdff9dc8627f3925e6a9f4cf80e35cb9dd04db73d6b411d510c3dd223154b1f5fc08eb227d06bf0e64cdf491f123c2fb6df8440d059589f8eb29a6c5c543f5dd344123abe096578378cc3ea26becf7fd29556f5e4a49e94f2fd5213db2842512cd4c8a7190770bc8cd696dd58e7a229105bab0c2d3cf5532e16c1ed00f9246da8de03bb3f43b2f2478f0d6a5e4e024d98f9e42ce75b3855887c1e62f086a36554f8afb5ebbe1f7f80ccbdbd94f0c217caf373bd09fb85eee2da8315a0061cb9d2d8d21695281e7060b5fa1e40a8f4d03300297efef804997daa9ebda3c08e082cea8789b8489a6e9e8039564b10f3b791671eae03342c435666fa1f07d82fa0004d66246fd0898842dfafa541a2f5591f5925b1afe77515d81af41492c9361e654a7b4c86b278279c19ffb4445eda883e53a17084772ec05b44cbe3cc66360197f006ec7fd80ea56654ace0c53756daa69923ea883ff319e352a073f419d489d1aa411c25a12ef71ddb0c78446a6e63bc1bcf9882dcad91d960caa475a6bdc0324bf897d826ebda1842fe99b4c1d233e52112f31c6bfef56b2b40d74a7f7fc480102bec0dbefb581d48845f099d7066aa23268e88c0662d91dfbc745041590116ac51c06ac3bb3bc3a01a8d418620f67e375bf9cffba0653a5416fcbfde508b46f958a574c3d717a19ade3a96dfb48309fdbcf3c9b2c4da6f09a327ec322d5b903029d9568d2e9bcef2213319c63901eef6f8d529b9c4cb511563f0d2f70e440c609489430dbc0df63e815c818ea6fc5fa76a6d58c9a4d1e66ad387530a6b0854e9978ad840fd9d34f00c9fa61b3cfe201a258c374bdbefb655fd9cc5ac3c271657605843514f2fadaba3dbff3a6b95583c11f85e96459a7c7a2f2ccff52ef3884ffcc354edb8f4849f18d0819e03d79da16372dc560278bd79ccac9ecb8ea547d4057cceefc731a9e3cc25d9dfc88b0268f185d9dff19dccf18a5e649b06c024921be1a3598235a65950646f9680a21828a4a100c0f34ed3590000757f2654ca3773c4ab6a674608e0dd9b0db702d17b3a50ea120efbea00a75efe5f3a43b9b48caba323074ff0e5dd630439f6a6c819c0c0d90347533024e447214598c28f241e207026d07ea183eb3d1af434038de7cc754118dc382ce2d973f37fb391c51afe8b284845f03f9e13286c5c7093b90bde24a73d591696cea8e55f537d1eeb6c37e4b5de12ed147ef0fe483a21abd465c530f47f4ec1519d303e96a25c1291d41a61b38076aa34191766d98ad1cc8e853606ada40b6a5673bdb214430fd595406ffde5ea668ff4d7fc2f8f880bbd1258218cdda2e78cf2b4d7b728c4d902b51d2eda6404bd7417aed9f1e12417054d3211dc84d6edddada29de5d7bf2139dee997349e17cb4f1d017b9c81a6b5a89f3e04cd65851bba3d38bb34217a4a67736fea98f3cc1203e5074e5c9e8d4b5c79c0319f944db21ca642a379e2a7983608609112583c88fd1d1f822ccfb40a620ae386fd4f5d2f7fd6f0243e2eadb9dfc0a289757db1b6d61be76e5ad7ecfe91376f2deb0bcad7aa54adf2d71217d1e02a41f37a707323126e3ed83da85a6208d8b0a80c52f3bb1c7e63651c86fcc190fc2252de786f37a8342b8a984bd3a7a2d73cf8efd67e6a339650b27f8fcf89011dd9020852f43a3b688236bd5936bb72fa7f5939ef8c5276f1b20bb9d4aa538f70205ab9aa0b7ca97da9ac6ee5fe27dfdf424794b358eb732f67884fff926dd6d3228380a1f2b37889f86b86361e101df436e502ea67264bf2343ab9c704ef731c9d96021a11ab14d0edb2c5558202b011955a1c4d0af5839b07dc173e5afd6525343c8028bb4414977f0f7926408ee9f02a1ac1f6e15c7971d406c472647e8d0530ca2c2d8b43a06fa9f54367985226d9b93f9029ab6944b2bdca240ffaefce03dbf4bea48f504d1b2b5bd053f7c37db7b4af31127efe97c44ef6fe8fa95301e614ba87ce2e9c57ed9ca72ba53fa08477bedf51d0738a5029e1606aa2126758f1b84545c04438daa0e1e2cdc848f69068c74d0e45a0dadd591e6de6782d646963ac829f2edbf389e0eac65d48f73a9118126990cfa2ec9b28e9dda43822b79e74ad933f8b99f877f07d70cca1795e82d5af4d47de8f9b73a5fc02d4d2155d5870e070a465a68a100f03b1d55df24dc0125a3a043447403950444c563d72f5d494da54d04e639509fbbeeec8f3b851419f5aca3c39a17b8b5a40504940a4e20280e73cd12dc1a7ed129b282a53b663de1941f71d3d03eb62d06b18fbe34d3dcc15916a186e438b37a50919c650977d12c93d6d33382a10d12bdf4b48868e34496df05788e5b1bc60e9e679e6e03f3b6b6a7dffa419704002c18e7ddea69b42e05933e1bfe0fb1da086e9fee58a612516438f8e89736b80e9718495722adef816b182e65574396bab9fe3fc62d1268e33f9931ce885e033eff0efb73477d3a4b8e66bb6984d31c3965014a782cc05cbe1979e1a1ae01727668c2778938f9666d461ffab94532de436fdda13044377f9df4826e40003fde88488a1cedf8b314cb0f5a71fe7ec037ce3a39433685d85ef0d694029403542006b96c2838b7d67a3404a0edfd25baa26ba53ac8fb3aab41383ebd58bd5f2b96f8788d74c2a5ae1ffdcd499e6e10d59384881063b242cf2af38672b5d83dbdca9b728caf0389e964781b56deb92c0aadddfdbf257458403541180080d51d73db2999824590680ffd2869875652856f98353e94437c098a8c61a0d3afe35685608b8fcd2595d33a729b9d9d56acdd98f0de0755f34b7d87f90de88255b048cc7fafe75616657f40809b1280c06a99e529c0760d19ab9c49eb9d95fda59f26abdda7f39c146ed4f628eee9f94ff209273c349d157a9c819470e5bdc2918780a1ef3fb0e4f4d9b7618f7705a7750c23e6785bfb754a31b0df210293f1a6675697f1cfcdca532585f7091622876729e80f450f9b18218c850af213ad1e9b5791df4901a4943f80b6d42c29a73364940e327e8c31c88ada58d1c8263c1c78094f2c63402ccc67e0de3d507ff0c8b67ed57eff95ddc41f7fdf97ed7ad81c75f995ab643bc759038180c29a46f369685f180e98c75321ae4b4969382aba1df3c7a510b0018c3b70d14b38c8910011e2137c9ddfb1cfa2a000a1424dede41e71b7e8c620a7bc5f9dda0b0a229deb9093dd1ebbf5cbe27343786e376009b5f0fca382d6e05bd450593b074295d9918eea792d520dd9875b284f067ec74e9283dbe616ccdfdeb8dacface07c24927cb019a275e9d8167e0e1a0a88aea7aa6aea7b045615adfc9f8c695e5a8009760b7734f11eb07317ca5494b920fa57189ca2948c76cea08a4cb9bcb106dc618ec5d8a4f0e0f483fdd3ce90d96638b8b3dd51672e35a6fc85b81abc70cfe22df9f69c59295ddbdd4e641605c63ca8fa99eba19c0844a07cfc7e1fb4a8df82b636c9df6225515f76b502f0ccc22fef82a7c793132e9c033ebdc433aaab5881df3f378c64187c9e9be3d0035eb0931392ec74a980c6814083a1814bc5b3d61e71083d3074128b97651ecb5e4f6175cd73bd4459361eb47760f9d18e1dcbc3ff506ed3e7e7e8f93c2894b599484fe6a91383d6c3c16c3ffae71ceff1c5e02ed90ea449316349199b04bf3c058e12657ce06c9373c5210a3277cf7f637000964078c92cce267753e5fd50f3af745855428e08ed2c192f6afb5ba76eba90e4412f719e180f7ec11492970dc8d3e7e027a895e2c3f53a5fc0311a02dec9b1d3412cd1a08a2f97b7d0ed24311cd64c16020477bd2ffbca4bf0c90991491a4b682e225602f0adff982afe26bd447e7797b1ea2428fcf0df68b4f6a7bc3464f986affbbf2914f1a7354d44c819ffc638fb3f79e514bbd257bcb471c9399a48608f99550fde8ab078eb2cee55368780617ad878872ad1700a9acc6d47d9ec2a4b7693abbc955a7fd9fd3c416d45749ccc18885514f0cf06dcb4e5619e37e3989cd3615ddcb9c38003bca0e46ba18fc2a6966eb9523cdf1ac7869d9bc683d899127acd8e0eecc8a59e8d2f0c213b4af5a4dfa04228d799e6625c12d804c3fe89beaf56bc2707ccdc9ae936c852538de5f0663ad48574f9996616400c50de22e2239b6c5edc092eb18f3cfb143e1319d1c92578814ae3ed2be2a98dbf4b888ba6b9607c1b7e6b10145c93954cda479e28798c725aa6a1b1c9181be53dcdd6c472eb00f2da138372c65e7820f78011421c4b1669e63ef78e3eca396be288fa567def5c1b0146f0da08d3b7302f5820076bdf9732188a8e56f95a649bdeb60bf69a5f2bc8c4f0533e7949a48a8ae6866ff5017e143092b47ed29c1cc7e318cd1a948ffd7389ff86df45cdbaa6b689e003fa010c0edd1a35e688681b565f5c8aff4030c9d8dcc1eebc95f8374c4416e1da1f40f6d211efd812385c8010b8fe531ace4fde955e80325e7b28b2da1489d9f45b73f7dd4b9090a654a20dbf4f3c8b4644a99a845ae91c815607eed7cbd74f7f20ba487ec91b64728b76d9d11a7e9565ac845cfdb172222d867989ebc2fe6b491cee6056269aca2c95a7f34d1c60dfb574bccaf2fd03a689f2b019771c46a5dc823593e8746e5f285c9706911a6f7eb7a1fea8fc87865a1865d51b0da9d4a638ed4c985e14c46a514b216a5ffaaf78adfd1225f68bd14859ceeffdcc44ed208d99b0d098e81b17ec087c8439eb1a7c43c31ded00cb44204faac5f59e9f0f940fcf2ab357f02edc53761e4edbdbf005c36f615698a9f57561067ac72927002aba45cdc78cde7c4ad9e28a50e62e5e81e27ebfb64c423b9b225841de00afe7b650a5248e053a3ba084090efb0ca42cf278868c327341a389fa14d8050d777d106308910bf926b580c6ea5f6eb7301e68fcb3d6e20421dee5f4cf877d9f96a3ebce517d0b9e3505dc5bb5ce3225b18b8d13457f0bb88baf93663365bd7b3dd12be893ab123a14ee969fd0ff304cf2361e0dd2cd2be86439c25e13c5e479511ef4e32fe99d5db9ccab809cda91c354b01eb98839a2cf5bb12888b0282258b3ebde616c11b63f216c01ac6a9b2b541a195166c6469fe9eb044e68d187ad15eaa988b449deab2951d00dcd05e2520e33b5a10a88d4e7103f14ff78d8640142fb2b1e70b680c488da1bad43c69d8ff599775d35f7f05ac7951d47f712b0cfe157cc4e2c38f2e6a7fe61f9ce98b3bc6a1f120c8f5c7db1e0edf7b36b18d2d4e95998d119f72d86c4e3c1e48be1df36b9b253e0f76a5c617ef0399ff8cf08f8e426129334b6c78a470ed2567562aae8ed5b218a0bedc8dc0eeb0c32c2ec41742b367e3b33c3b17fc276c84f3e633fdb928d18ae0eb98006463137340f68aa2ad01d323c1ef5ffee6b0aa93031b45061b730012b08b100dc2ea3444123b61181edfb7e638b1d908a5007868065aa3f9c494a5507fa13543b869918c9dc705c6c6d924b74d370e4f0781ab9f9341dcb5b22f480c4306d92e4ad01f474cef4222397ebff9c9bb17361d3898bf41c4e594f4817cb1a0be6e382c8b6903668690706006f7c4c7d2f34a2f6cdde5ea418b5bacc9a7b32bcb360542ca6aaf4c8ae3a79758d8ecaca92f35521d56e281fed901950b186d33a7f0dec291493e9d10cfbd5c436a17adbab24cb51ea807cc4c6edf36c3501221217308b8888dc24738231aa6b31355e558db2f8f84f4cf138eee73ac9e1ab31caed32cfc06cdd00fa4d8a822aaeb5d473c37d52729b4828b84bc7d3dc28160e786b4cac97a5dcd2649fd7b0e55be2f8b7fa35f198da635d7edbb21ab70a39d3e9682106ca790681d68893333298536919e89d46f06ea51f18062b04bd8966cabdd65dd6298f9c428a82e764a8931d180bdbeaabd46d400553170db95aeec85403fe60922350e10ea2c8b1969d7dfcdb1023214077cbb046ed00ed509e939a0f02a635ecd13644326c7f174ad2c17ba14c8952db2cf7d5a3321cfc8ae987f335ee9988bfd21d558aaec3521e474b78a80184944f4ac6f374bcb8cbc25d439ae34cebc36f0470ebcffb1679dbe50e9332de66a196bbe837f8bed6c1979013a7af12bd8360bd5eb859955ba04197b1aae466cd534645052349d928051d6f695b0f9cd465fc53ec921f910db5387d6024edddf23270ec90fa306aca42964deda365b40ffef852d8bd08119e3771419e323f87ee152f598892bdf25e03727b6ae6c3034962e98f6376af18dc7f4dde7421280507505407513758b4b640de01b3a4939b74847cc6f12ab8081b7d49be85914a0e5d2d55566e7a94767b7e72a5c09fed8ed5c67c357e20fc71616dc0269d3984b9fa9d525511b73a9441d71bd600b422bff74a5528a16035975c8dd732f9e3b6bf6d1853023c8a4a171e0c4e9dea2ef161b7b54a1590c40d197979ecb3d48c11aa915b01ddf4a84e71f30474bcdee3aba68ff4eab474194afbfd20c64f1c452f7688614639daddd7c376dccf539258984a78f7abcbaa1053d4c0770d9a44a0f5cbcd86012d1306aadbf715ddc928e6408d2179d84def6314273591e37f6b0c7c4f7c43a2363ff0f7975ff1f5101092b719def693163bf248b90153f81cb959b2981b8766b237c05a03e37398ae52236da55f41aa741a637d7d81f2127babb0c0053b84a9386a53450c7f60b79100a04a8c6a045d95ba21858bf9aa151b405efed68ace0a3d77af5c18ac7b05390b33e5b244099c8ee9d560ad7b5929310851d5b681f2e0d57ca5f85ccde261a67ac407331caae52de72eb45f083b009bf80b538dba11a40e3066e8794984cbb7bcd2d6b6afce26ccc840bbdae9ca255f5dce0df683a29a79f9403f4df2d0db3a21c84d9d7d92cb59177a37baecaf3de297a92f2069fb6cf82f224768a4cf0fdc362f0c83a7f4279de107ebfc43596ef613b694e63fea124333399931a504a22fae1c1920bfff45235e940d698c517174c133f84bf23093cbb00dfb5f5eceef15d8ea30932e905ff12f0fbb5fdab1162c38d47ed992564d723203ce06f7e9314006f418dacb8a0984256bf7418c415620abd899d7b50838bb4436db8a9a2026d2cf148290b427f839b5bcc5f2372905229108e13039779599f79888563a684c629068ce57c7ae17e6cb794b97cb26c373a86e7435e73536c8106e620ee37eb2a84228784328923e442949ee233bc1c1ac2f44f6a1303b7928872047946d3bcfcbabb36a408bee662ca24506d16689412a6fd2342c42865908418f8082e95b3594a8f911165295213b9597ea491fee2e0d0ec98338825778ae558a58056d358a52a7dba902edeb413b7db7a07ed7510fbed8169a69615aaff76f7c4f131059bdd9e27de6213977f690e71fee91ab95a81e7dac8b4c80ebf78d3b741494f2b283b2d3bb2e1e17f35efa6adffd9d323d4b7372ed4390013f404d7ddeb69314444cf0ac667cac2bdcf56adddf8c3af489a950ac363ad2dfa19b787c176bce44b39eb20ca370489fb00460b91e0a62baeceaf2097949fed3e20fc8109ef300a9a542b4607410621a293ada2f7e31393c7799e4c3ed9b8d587d444478819f9613ce30f9117c8c5200a53f0c5212aa7dca00d7a54055129a6b09af5691e6ea0f8d92687f248d47f5f1168df8444098272af495f82796f3a196af5e013ef09d6dc3c6cdcae388f9f2d5c4389103cd8355f20206c2d3c024988526990a7b5c7712f6d0357a03e556cd6547b928c7afac37f39e4f33a3a05cbd15a15646f5a045842b51584e59f97e44645ef93a5bd20a4951f831d155f197b3a4c8ce01a801e2a208bab4d5b1f738387cfe12bc34f2c427eb3c20ff704f07443f26c146129e8f03450815a33ed370cbb58bf9decda4a534296d48e7673e5dc05a5b243bd0683b921e5c1f8ef92359646ba9fe5238ccaa9663e75a537487e210060b23e718b14ec6a21873aba2f9358fa0a634a0e597429a09e2683eb0934e728e633565836ba7d3bde683ba26a72197eccc5e432e274c80cc7dd',
        salt = '529f3ab5ca1a1be1a23669075c49e728',
        labelError = 'Bad password!',
        isRememberEnabled = false,
        rememberDurationInDays = 0; // 0 means forever

    // constants
    const rememberPassphraseKey = 'staticrypt_passphrase',
        rememberExpirationKey = 'staticrypt_expiration';

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param  hashedPassphrase
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassphrase) {
        const result = await decode(encryptedMsg, hashedPassphrase, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        document.write(plainHTML);
        document.close();
        return true;
    }

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        localStorage.removeItem(rememberPassphraseKey);
        localStorage.removeItem(rememberExpirationKey);
    }

    /**
     * Clear storage if we are logging out
     *
     * @returns  - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        if (!isRememberEnabled) {
            return false;
        }

        // show the remember me checkbox
        document.getElementById('staticrypt-remember-label').classList.remove('hidden');

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassphrase = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassphrase) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPassphraseQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPassphraseFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassphrase = hashedPassphraseFragment || hashedPassphraseQuery;

        if (hashedPassphrase) {
            return decryptAndReplaceHtml(hashedPassphrase);
        }

        return false;
    }

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        let hasDecrypted = await decryptOnLoadFromUrl();

        if (!hasDecrypted) {
            hasDecrypted = await decryptOnLoadFromRememberMe();
        }

        // if we didn't decrypt anything, show the password prompt. Otherwise the content has already been replaced, no
        // need to do anything
        if (!hasDecrypted) {
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const passphrase = document.getElementById('staticrypt-password').value,
            shouldRememberPassphrase = document.getElementById('staticrypt-remember').checked;

        // decrypt and replace the whole page
        const hashedPassphrase = await cryptoEngine.hashPassphrase(passphrase, salt);
        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

        if (isDecryptionSuccessful) {
            // remember the hashedPassphrase and set its expiration if necessary
            if (isRememberEnabled && shouldRememberPassphrase) {
                window.localStorage.setItem(rememberPassphraseKey, hashedPassphrase);

                // set the expiration if the duration isn't 0 (meaning no expiration)
                if (rememberDurationInDays > 0) {
                    window.localStorage.setItem(
                        rememberExpirationKey,
                        (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                    );
                }
            }
        } else {
            alert(labelError);
        }
    });
</script>
</body>
</html>
