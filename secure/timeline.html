<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #4CAF50;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #43A047;
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #76b852; /* fallback for old browsers */
            background: -webkit-linear-gradient(right, #76b852, #8DC26F);
            background: -moz-linear-gradient(right, #76b852, #8DC26F);
            background: -o-linear-gradient(right, #76b852, #8DC26F);
            background: linear-gradient(to left, #76b852, #8DC26F);
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>




<script>
    // do not remove this comment, it is used to detect the version of the script
    // STATICRYPT_VERSION: async

    const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 *
 * Mirrors the API of CryptoJS.enc.Hex
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassphrase) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassphrase
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassphrase) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassphrase(passphrase, salt) {
    // we hash the passphrase in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassphrase = await hashLegacyRound(passphrase, salt);

    hashedPassphrase = await hashSecondRound(hashedPassphrase, salt);

    return hashThirdRound(hashedPassphrase, salt);
}
exports.hashPassphrase = hashPassphrase;

/**
 * This hashes the passphrase with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(passphrase, salt) {
    return pbkdf2(passphrase, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(passphrase, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(passphrase),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassphrase, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
    const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassphrase = await cryptoEngine.hashPassphrase(password, salt);


    const encrypted = await cryptoEngine.encrypt(msg, hashedPassphrase);
    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassphrase, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassphrase
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassphrase
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassphrase,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassphrase = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassphrase, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassphrase = originalPassphrase || hashedPassphrase;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassphrase = await cryptoEngine.hashThirdRound(originalPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassphrase = await cryptoEngine.hashSecondRound(originalPassphrase, salt);
        updatedHashedPassphrase = await cryptoEngine.hashThirdRound(updatedHashedPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassphrase),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
    const decode = codec.init(cryptoEngine).decode;

    // variables to be filled when generating the file
    const encryptedMsg = '56d30c1224228f7c5e07897d826c6c974e7a818af377db6ecfc24755df801372dde83d983f14b2e91e47ef41f415cdc47e74435394ea9b941808f76df790b20fc1f29da4fad3dd4f0e42e15457ef457b9355d8135b58a1e84fd5766d3b57869599371919a56a224365717299e59dbf5e8ff4f24aef226b92a5ce6b79f2552b1b07b36a87d50f4590b6f78e85602ac07b16c766ccc27ed4a1b0bf52031d064695fa56d355c5013955cb3473238c254f152c0b42b287f371a59b40920eddcdf02c56763c66109970018ec0086144a8ba61d10a8f101bcda5783ca61e2bccebb9d412c772603c21d16c46bab82d5a9a6f3dab36cd2bb342d497ed6b833e43dccb8fedc1bd68159828cadbe5eacc843fd651627d137b67c4dcb02c8332aece8557ea06303932e824a1a24d57af3fd0ff74b39084f91ef4583fd0ce4fdb42834a2610af7b4e1a4910dc368fedb3e2a2981082d14b60f0e8fe562bd222f620eea9687f9fa74917184a9df57d28ae9458ca28c2461b069c29105988382c11778c4f4b0e248bc0dffcafe833be917117312bdc1da7c13ec69c51b0e2fd0232c6ebf6a5913786974c1938447e0e46ece6a60eec4cfc07f4630eea8c247bda8e2a5a13781001b9c9929dc828049cf22d147f13e9ce88ef0c352e096d4e3275bfbb323a8649769dd2351ef471686d56a0b24c9f0f3bd1e7970c237176cadd3bcf542d097b9f1b60e0458b921fe078077803bd7a40807613230f764e8610c5319c1537120ff850bf1deaf72c79a91deded3fb3aba6ec9ace90d6f045579a1a4729c71e2fc24783ea9ea43d6a52a8787131f832bd1e0425293d193a4abcaccaeddf2c0a537dc13e4e618e9413e5c7cd73c548484b12d7f3556e0997af398d59e6d0fabb006e61e67393c68ad3dfc3f8d029e25521ae443fc69ee5bb4198ab908842cb61ab958f2c78b833a292244547e134734f2cda5bd0401c42f5ff657dcbb2b3815a22fb8e319c506d4358c74f0f7a5f6e7b8ce5b9780d8af2490ea32577ea432ab051d9f069d4857ae49175feba79519f09d257f1a4f9d8f48ce9bb04ad83bffb6fc31c48645f3bb8edc9b1255fdaffb9001b6c88a442112aa0aa2c7012823321a791be7466c225927b46e27c59619d5d19567691f098296d0166c55765a9b2515848cf415e87dcccb18ef6f4a6da60347487e20b070f78c73036295e06160f32c26a328f93c79dfaf2c35554e10bc23f36f17effd800ec68bc50c348cdc46ecc9787bc9fbcdbe5c09b8276ec62e0a59dbff6bd89693cefe22b844a3c42a85d8a151623713640c2d250f69bfea4e1049a9dfed8280a1de3d43143f48cc09dc64520904c694dad5dfe8f9f0d28818e4b21413bba67a2f21f18ab7d6e8d18d4e6c8851e93e8f8e8464cd9f2513ca5f743622d3413b1a42a189ad40de2e85d6070e08dabba4a4c3991a4d29234e6f1d224d554c16e2f9db5b11f09e84e29b0b1f9ab95bb52addf97091afc077ee04d5559235ec3aeb39de4f24ddd72b38145d4ecd146cfd3b3a35316de4a830e9b2cedf7e7c50bb782d00e70941bd76b5894eae4178a178594a9863f092f35a4b9a69f0323d992e22d9817a12129ccede52aa99398817027cb5887e3c1c470d75b267e3d9dd710e02f6d7e62c6b5ccd113e624fab1022e9450cbeb54f5aff67a8e828be2dae4ad15f05692438bf33807209c399e2b3797cb183cb37f64cf619f2548d74bb715e982e8d0f4d9e494170c23d532867d44f8fb3c9cc990a65d0b3466ffccd55b85be93eca8a6c9262d23d11154df8db72fbf60cb29fbd3cd41bc230d3f0c3e5753acd176f39d1b739f87bd61777e7cecc10d9a86b7cbed86fb93a059dae2039594382498cc8d0ee4687dacf36c6b02c6925db9a293efefabfcd23aafb83de81eba621f6ecd210a4d56a7d7103a780fe94a75ca16ddf7c7660fd33a0873628b38a416856e59c6e7d15124cb4b78c0a0fdb0d54f9b9dfcfe7c5b65ff54b4117ad7f372941cd0b3bcf97b7bb07d1f5ee8e4bda154bdb76a043adc7c2037f7b79c8354b780c8344a26c0330a74273d8467b62e411322341d74e72a61df16aa454f6a8235102883f885ba61a5b0ee5b3aca4902a9827ec4311bdef3927b488c124001c3808f64b06b6431c19153432f9dcbbbfa75439c473c5a7a2d6e18c14cecd2b63ae9a819f5713b8218f46abc24c0a0ae05d7557680cde9c4a272caa65b2adb9e7a9ff2df8caa58051778bd6ad28ba757a9c493412c7b7c6c35f2e699aa37983a5ed75c63b668c831a6de669ef9da37696efdeb4bcd28e644ac730cb97c85ea3c79f963302f998194199277206c30a832fade8201c6104ba6c143b5116d7217515388ef8e39342975d98a587bc8d9b3250b388acc08ed8678622d04d6f6444c1ddf4e11773bf3bc738c0161e892f2c55b4597b275133e8115f714bac8409b5f0f68288b35ae507a5e062a938a81ed04466b78903f63f1b635ea0ad26abdd5153f45b67d159146dc8a84df569964f071dfa3c53f2eaf70c1cf7fabda9c475079369140fd36c88c2ad308395f18bea08e7847fafeaf22ac488f2026f0b0a37aad06ac14f3f29690ce348c53f17f7ef91506a8bfcceea29ab530a814b5e5c31fa17950d34175efaf219a58c11fa8b92c2282caa933ef57a10e8bafe507859f496d31cfe4ac210c5292189fa231b48ccbc6379b384af83207ce448908ef39ec139a4e88341077a4e76a8f50c1e45982e1f1be4b8f730cf8dd2d75e19b298f0ec8d48169abf654b5e9dbf6d6abb7bce6a8c1a802dc7e4a7a44b379bda803ed99401c05290613c3df265d31939247bca31d81a33890757be58857c44ca1fb0f25ed68b2ededf3d2dc64bdd7b0e7491d71cfc0908b8148d5e78cb3d9ab13dadf625c0e57969cc135b9ec2b69457589a281dfa39afd30ad7a137121ca9fb6d46b3a4af7a61129aeeb7097f89e551d5dbbabd0a8c6242906fd1eaea6771135d187f0d79d73a86837af47459c50ac85e6fe249f288c641855e1c5b35270ef469ef2198efdb427d72e252a177ab33fa8107a52fc6028ee81c967ae858130524995cbc935c6f46f879722a0e4468743d6a732988b96749d20c840847d5d52f71ebb45244ced7b2586a135a0f5244335e2370d2f8ac18eb4a7d39b8f965f5b1df4bc284c4ff61340f72f1b001a9aee32ee0cb04d295f886173882ecbb0339bf526185832a51d32fbe2e6f681ae6ad18ebfadb51c5254d474bd93330a20e0ded1a50eb7c0f076de1a22c6ce9d496d976ca2d005b605550c6474e4dc84a945cadfd8bb9818aeca69c0d044b2c73d83cac2603430611f664ab8f980226126971630631c339aeb51080bb09bd4bb7e5f53c1158fde2afe13fb4391abd3da5c6816dc307fbd0c25b83023f688abdfbce5239198f319b96ea180b7597f851125709057c2d190dd9460ffb15c807911b64ef3d08625294871482a110bc86c976bfc24081b043b92ed69fe4aa6d1894be56293d2797f883844806226bb986e82a492d35a6e6b981a96115d1a1d56f9a086bc7f812d2fb99ca4537a2e22ad2ad130604c01e0116ad41171b75d63b368330685de7e7b408422f12268d0659d496a77d705d4d0b5ce173178ac977a699e5669f3f6ef0822a9af3a1d99c1ea571a0ce11388b29737e1e457b85aa4b9ef5f3e8d1059b385589b8e759795188e6d0f30d560a68bb1bfbeb6747ea91b66bc655ad7cff86c2dfbf2e57c34e682afa75ce40aa78d81da724c296d56e5942325a47082db730303c12df60dbee26c10961369aeec578ec3e967bbfa8348f7e1e43f46a6f9d2a89c0b3b70fd5bbf8a9781fc0d259d8f4856fe1ee96e30b7ec1fff78f1948bcc00c5020534adf7c9bc18bd4b00b7a1e04ced61908edcbdb430302409b38a544f5e8ca3c49badfd5c856cbe0daa768aa888924c5ab6d1e0307407a8e0235ed8fb083f2df02ceb310523a9a36cdecfa5956f8c0110188812694ce83f417dfca7ce750996d709afa5325dfa63776d9a2b0326c67c1c306305aef444dcd8afded9a8ccbfe803076c28cd06231af8e74b3a54fa68491a9523cb174e810f926aec13c17950957513a7e9009c4db793e44f29528d079e6012d771fe506e067e030dec2ddd31cb18e71fd2b7493f45f74faabb17f5c9e53f9fa0ef0d0b746819c4f3f9846a45899cfcf7861f7ff8e848f841876a900b65fb2fa22225d6275c026a7fbae80505659d22c0bbc9c316cc87539d7dc152719a0f049d795c4cf69be170ea628e982858a1bd69270eca21ee129d8f647227b6824c28adf93cace3d12de3ea12850a14a79df988c0eb2f3a9083d352e4f03a7a106e70ef0bd7f42b42c713f694ae3f904cecaa362cb9744fc24a8742d63aeb4bfe04a46197725565cd0d0e6f0f316d61bf48da59255ece41895dce2de6e1aad24c0acb2a735c4751272e5a73564cb3cfb67444898ebbc7b3b975ecf2c71d519143f76a746955c7ccddd3258e18ad19bf394753eb24404c0ab3de10790424d2bffe3e350f120f8000c2d1d25f75fa8adef4e778da7f2054bd4827917619da4ed837ce4b379ce812d00652be2fc6b78af2c8a89d87a795181ab4b24ef18f931a021b13fa174fd564f2a32a0cca30dbcac39120a41935b13591a48ec4ad739995a9dc02956c6965c1703c027beb673d8efb5383c822c26827b7a9c7dab9856410ae0701afc6551e8991a477ea615ab936f0f9cbbc1e7262c46790446c2ccbf6a279a146fac6c5e4e49626fd6d1e3abd11fa94da29241f1a611c1243ca8db4fa4394a2b19630bc89f72edc84cb71173a2816dad8aece29d10ef5e971f9688d44f7d17e01a60d889e299294d4ee293214e61d3e5d69a8692821b9d6091853e1e04370d85014001de7c5b3297189c6fdcbe503e2d2b4157bc3b0396fb6c8d4e240503dbe72ca36632532964175358b450125c55ccaa2ed61251ae8cf55cbc6ffbab36c613ba6ee2726e473550b0815d686f997687972024330878b2f5d36d6f62fa85828960ba5d72666c46925b1919c997c5622ff5700ca7e37242281e4d3229994e15ed1f978b6a3576a96ab718b86cbcc7ebe9bcc4c52b045a3f75e2451a525fc085fe763752dabc02c6fe4e937623e6a0878e305d192cd4adb9253d5867b52400231a251f66b41f1245586934f4befabfe27c4873f9233b4cf94691e6276c3ce95b57bd6df31311296b5b3457d94dd4cc70cbb3239caffb69aa02b540ccb77a13b158f27a81391068b71bc475fcb923df874b3f637a196fe13427f6ecd4f24c50734667acdcc2b4b72da746ab2872d5402a6975167f280d840feb4da826752a6d1b9452095b1bd49b02a0ebd4276fff82e52309975f4b54f373294df677b255d954c7985ab52f8ea167be5d50b0809b758849cd123e8faa06a29270f46c7887de9f148b2af61fbe12a327e87d4ec63b7d29984fb2fc621e758f0d9462650c4e10be9b77495c2988ad65b208b36fad1c1d2456fd97f34fff5dbdee18dc3458a3f197576cfec2da0629235b138588313db0d79b47646d8b76291d052fec274fbf0a72b2eea079212af67faa49fedff1240e78c8a90066ed15826074134f51ec628fdbf6319a2319daaf0717df61df33254bf6b97ba3c7cfa9155b4d66a8718849d91e233698cca9e0600fb7e49474ce049ef60b7c79717ad7aad8895f54c8911eb84dfb50849312179a31ba5a24160c37bf3f6c967b15c4553b98fa1827b7727710468193a071617b12b7ab94b5b1aa66dbbd1416dd78487a1bafbd5e65ce3a600d653cc49ea56710cbec2ea9f1f50616b60e96e591add670b9d3b7211162bdb80a2f4acf7eef86238ad3e088941cb5d9f970b041c0497c5fa415dcf8a2d2d21bc59d161ceb49059af500b735c499dc6e39fb7e028caee538134780d41850a7f009487419fe072f365141a349186d8920824e1b093a1625a8bb1f0a6a906444f9701bbdafafc641d85bdfbe895c90a3c7d0714d0e9d63536ff96150688786b0285df830305ef1892fe8cd9a0ffdfff114a165f5e6624de371cc2a10762d07ad548be4ddaead6a058ae045fd862c000413c505859fb6da619d6edb5f341423b831026f10904f57662add0a0a237837314e0f59a64896eb9402cc0b746f25ae26d43a0d046e5c1130674ac9e6405a5a4d383d9ed1d368ce77cf94fb0b4a617ae8a467630ae1b6fa056bed598ea0677eec82851911cfa50717ff3854d1942e242d99f84d2815667f536c364b11870433d2e3e504c16508f68fb0db4a57f07c08a4189899e342af78aef8f12e912b8d5a662c57ead19179e0be599a8cdd0ce9afaba520ec040290c2262cacecf24bf13efdb4518473e3b7f3f27988edd228f2aece474010fa628bd3023e0a845bd785eb6f9328bdb5a74c2d52002a673256195e80c0175247b34ca65d5842c57755d1ecd4bd488c8855bdcba0e4a3bfd5752146bc884d5efd2dc598b908b043509fecae741bb79ee2d2f0615c0e731795cf8f5623fefe8869ab60fdab1135a955dae6220695fe9f21437c0df230d9d22a896add8e9787b1300ee74cf42f537135412b7d8ef885c199f3ad865547fb89bd6a992a99899d9a8434f6e2e2a032816a44ce318f5cec752bff7f237bc2a87151c01649bcb0a404fadb2343545e36a7e66cfbed4e13b12455a9cc93f950a9276d6a60bea42f8f89093d9e72daf7821bf54a4ea78427baa29f47fb35b30ea20f7a8caf30fae1664d9a467a1f6c4efb4bf068aac42a9e63003a60e527a731318dbf0f63aae7acd81257e4e1debfa4cfa37e1385fe10062bcae218a1f5428356a485a8aacca51ff1da823c8a7b207be99e8b26c5937b5d656913cf0410060f041cb235c66d39a144d90767505518f0d22d42f540adc2126ead3f47e0886518b3147483c524e880e5db09c363246a79be99ac7e22faf7af6f35054f12c6bcad834690bbd9d8643439e4e3212ab9d8ce1947da9551c608ce816dd1da8dcc65ffcefc3566baf02c8b4607ce7af45efc8a19f6531aa1b0e4bfc326e2b2b5002e07fb96c9083b2b7a06b507e7c9bba124b279b0f5037263d204324b6462a076d92a94c9d38291ad7b6819530c357b2f7b78ff517f1a25806a1a896e555a79da3c982297bbdff5b989931abcf81899b27c765246fed7c76b8b9210edb2e43d953ff6fa19295fab06fcc00f9f2cdd7644b392b71c311be654ae1f3d0955620f2a422560241fc96636daa47b49862e8d218c869b86b75a29f7d755e3ec90ba7f91fd1782b71ed7d945af2d43fa0060857a182801a2b5495d2b76ac93683cb1b2d98017b5003e7513ae9af12e8444f2318ec2968aacd3dab43f675a2efa71712506e434d0795b3bb5e5a0f01eb4e9f205672e8cd3cfd6a4823914fd5518ca692a017d03b2aed075aa0af42e959baed09ec0b61cd0e1ae1e2b434156cc2f26740e9419b825ce4e95b62b609050746965f70e111463bfa3a3d1ba7ea0a627fa382aa185604fd0000b50c6e5892d319bdec6d91a4225bc41d334df1681b7364cddf010c0c959e947f64c554e2a553669e4afa6f417313debed4a93b4c08a36465d86d2544c6fec6aba6184fd60ea3b8905b69075816317ffaaf0ccdad37997766b36e9f52a14636bf07898a068bc7de46519f58f7d464a5aa13ff1e9b6432cc326bcffa458f80a2b6481c9cdd1c353b68f98874bd394ab0a6fb9b86222e81c42ea2d044462071fee24b382143686baf51d95b8a80f6b8136fab4c8664622ceda5b5a8c31195a38c939a5f9a6596e408bcd806800411efdbaad6225282dfdb392893cc0b263377cbd1fd7a4c4623047e57b5df90bbe253f9957a64596a585611ea8229b6c5f7a8fbf50bc7710188d25f7bd8476b1293808c8be82561da4b3be9774453c22e99f8985235e6fa5ea0b43b18cd66dd7cbe12586b7244fad5bad751a2c5b1a1d3741fb5b84acb69bbf3b7a36f752c567eefad31d57b6f1a22eafb60df81dd9933b0b4449a789fb6fa903a6d2eb82f34d9fa1abb9762b35a7e71aa9f20f18a88931b25f1c1229478b2f035deb4f72fe07d2de934e5d2da5007d2222ff94b760247addd63e39bdee8f299f1be4b8b199880491745b7a2b2c39ded1b6875440ed67e2df3ece99998911bc0eca3460987f3f4b2569077e52a22d5dbb81ceee168cfedd8ec9d838be536dac8263651b67c9ba2be209edb3384f165481415aea9cbf2a5be852208ac181d7c266d2de893d08eb8553b0afbd58e0436abe0cc3b8779ec11ec8dea10dc5184a4ba71cb5b6f0a305ca5d48578bee8b02744dcc1196856c3dd3186f308beda40a57bc4e7c33df3db6ec5851e14027020df6cfc8241b785629cddf735a61095ee58194b7f41c7783e9ba6addb260fc0084c65baf26ef20ebe635772fcbb1ac9fc935ce281c46484a7a6c000ef80b25406fbf37d41697f8e0624aaa3f6bbf722ba424ece572cba2875250a040d195783ea5a299b66fdca63d045eb0c08d1082c167f92097fc7a7fa377a7820f7ed7d7ac6fc5eb6b36c9d27e26aea3bc3ae3560480e31b34620beea710a6d9b0f6327ad84e093fa43dad0c390659dbb9653bf9b3932fcccf1a19719aee39b81eb651dcd70f104132f68a3b178086fbc3345eb4cfaf0e0ea742421e18ca23417de7e363da37c36b3addd95b2c601deda3ec47ddd00f3b6c729c2afa3e15fedff215d2f13998a619d05cca03cfa18e15c46496d6c8e3b3f28a9aa0cc4e6492ed5db83d0e6e6e73292550eee889a79cc581a4b10c56a6be24f9bd5ac1ebbf4e5afb3b0589ec7110985e97341a6401ad6e7f68f57bc5665451fd80968b7c98f8663dc160229e2e15620a7bf07f6e123dd15f518da9732bba2d8dde4bc576159160cc555826cd943fe0dae53fb9fc4f04849fd39ed369036bfe88bf4521fa3df4b7759303c3fc21448a4e26cb352319bff9a489b9bd1404cb8272b9cd82ba33471d5c0331616fde3919f7e5a00e42f24bf7df6c3f76842c755b1e2f0cacf395b3b503ab0611ed05e588ee46dc5d5a554a3579ee93f215a71eedf274220029db9fd5044ce1f66593972ad62f12722ca5f3181ee40c3b62b68a3dae03dcda45763e1d802e9605d49a63819d528e5b80aa17605ca1a083c7bd2e160ec235ad92ec79d92d5d99cbf484e811f9cfd538e79dab4ad03a726b326c03dfd519ab7b557c280473ddd20d650dd25369ad0dc4901750d46e9540c52487084f8bcafd899dabfbb24312af73cebf2223d7314c80ad13049efbac5015a4f80d6fdd90d715c487c9f868c16d3a1fab94164b1e9bf225d33a33bf6645b369e3036194e339628e1ad577ceff36a80c7925940f7917dea9933c0f8b6bee3fcf305290ab968cc343e59e3895d8d29cb091f301daf73da49d6cfb56535a7b2fed1d6f1ad0499c7fcfb5d9a2ce56e623e7bd46f792f1aade8629b1d50c20475fb45ce7444f9515b3a32be3f3053599d6dc43dcde13460f852d1eb85656baa190787b734e8b6ca5c32de94b21680de984e6bf541f6cabe62addac9439b65beef12a4a47a46008f99b639ba12bb42e4eab36ba0d653e27e5b3d16b7af17e64832555d358ef82b26690211c64e22f13f3e98b260964fb5d484d01bf7a3d1bbd0132913a3d6e6a65a276e173e53dacccb142355cc52fc786aded7103d7a800629afe1108f1eca88eb02748b20c5f369ef63bc4e26af69736674ba5f2a2e435ac9a53b6226372d9210e21871c0e4bb47fd1984015090db44f750de0fdc76867dc87fc73ad0e8e77983c873abb41c296ca6db4bae6487dbccc051827d9a055fdc2950e6e46dbc489106a80aa42e3504cbe5b2a0a84fb74350dbfe6eb7ee672e5646ed6320d81668982c639f4121179f310ce6c41a3172b17e759f88e2de77bd23452484ccd082a5d4d7309f23c426fa9b07b4e23e32fdf7d1eb2a2912d7f6291204bbc3a0564aca30c70dd51396328a30904888e2b438746edc2b84ac1345eaa33260f32781d51a88ae50935908cfee4aa8be0cc2de1ad5eba4cb72b4071c0d43adaba6ba73b36d5fa6be8fa2c6b85bd581245e501e335417757128d0a0cfaf7f78dbda121b2605bedfc661fe5055ae94bded85575c9010f80bbe43b9f911f4797c6dfaaba0d9eac7e23bfb513a916d8dc0a7e7e2636503835bcff0a28bf8b446bf7e8d50dde7bb7fee61bf6d2ad0a94ba3668d8894f106e28e18b91af534e6ffa0cd37c41d2c8a8b16c60afc5cf410e03f206507ba4c2b2957fd24de083230159c931984a5f77c70a5835796c27cb12a70a799b7faf22c686ef248f739e4bcd0b6f2bebce44440cbd52b95c99e15aa9568379cd60720b03279730f75ea3f4bd2411b47f163681884a3dce9495c70f7f6956f0de5abe790f037989c33439c47a88190d96d05d148cb33b067b9b1dd663b435988b1e3f38c89d6684dc3bc6bdd5b93cec3321495dc9be54327b6bf319db983052596b993bb0d70c28387d8f67601e1b82940f1a6efc6f4395fe3f6bf55fda2d0a629c302c254ae5015667842dc78d7890d4fd23a2e8c10a6395991f810a6e499ce98e8c36ea8f59f23796a99088b3da2a1348c6902445fcb94add52ecfc69132ee13290abbd041741b71d4e6dedecf013292a3b71c32dcb0ea888f5517380ca72c25ef68159309765dd54ded8f287c0986658701ed6a4108457417c28ff8ed1015f3f88c9a92f392a89aa055faa8737fa622ecfde400cbaac2ccea8e4b4aaa19bb1cc704282d3abab2c048e0bae1f3d86bdf444f6a4f8a6c6309b8cdde60f457b53d0bae5b802170a2f2cb5deb4d4f20c8aa0f45a1eb2833b445969205bd6013f84d54100a93b363edef58fb93155a5faa592c242ea37b95d59eba21988330ccbc61ccc91c2d65321b1d840ca69ccd66de473dc8047264cf0ae15bc95b112ba2352df854ef6d7687748a3c6879929dde22285495b639f6587a4d69ad7b4cb5bfac232563fd3f6d158f16718b646faf256e48f35d2e9390012d7f5246204c8368d224b987f90b551560716ea107b11f5c1f61b01207086e1472243bce55b63a3e2bd863e83501764fe8f79dfb8fa0b1a34d8475b55b655ae53236a84d575a0770c2288fca7af79504e3c6776bbedaa1c386ae662909bd72142d5488da4c2e5044fc6a6c90f45e65f83e160fe1a8b50e675cd363e4be65244e5153db8f0cc18b8de59aedfd29935111693790d97e18d0ccf0925af7f1d8919063c50de3bf46675f3be14c5d7eabb7c8b62fd41522cd4b1fe4e1f2255c8be741725fb3317d9207d2efca22a9602047ae64887f2e564ac29a73bfd7e6ebe206a3212efd496a902220861cbaff761d9403f51bbdc6dc803b6ec4669c882680704f162d8af35dd518f765594e11133e262baf2f2fa46d9adda2712ed22223935b31c401bfa1fb33041825540ff8b5f216d5585598579d29b7a41b138d49f509bf2c6963506a253f75345ca5d0df24ad205cf0a9f68bcd077c8cf17cc4689e9a639c91f8c3fa9f8ffbb5f66cc6ab04218e9344f0675bd1bb3a5577ed82a55cbdea6b6238d1b77aaf04f2918623e54001241487f89534cc2222e6b3b37af44789176b4bc59c97c67e8305e6c297a6a04247142415a0db25a9c330fb1572446a3c1706286d66e20e0fa3f0ac0bd9fd25d9cfc75640c74a9e8488f98b55b188d4089e051b5e0ab91e974aa8171552d19624c58ac22030a1f68f3bfa41fbcf1252993f3a7cad60b285daaa1f0000b5914f1f776a400747b61247c95701217fadc1f1a53a5fca9531ce4263008fea64598128f03f86ed8c88879431b436d242dc485340d735c3f405b574b3c8a2e3275d767f3d990f053635a6beef1c039ad4030c0bdd339f4a3cdfa88d03d60b36cb8e7d8a8cf3bf2b71365b0641b5fb1fae0721c6f3e0c42285868678cb55468a33304071883839fd48f5eb8fec6e24e04f1a017b32ca6fedff2a07d39a4de59d39bfc6be7c5d59176c4480bb71e12edcd973b12520ef11fb066d823cecd52d2843cb7aa3e551b926523663a687d9f980d4454c368f728d0358497c12e13a265eb1d829b05c84d806bb2574fca7e62266b408f885c40bb1e925cabd5693e299476032c514a4ae2e76e4c74b6fa93807fb9b3e4b9f2e0ca3a2ede805b41d6eb718d03b9b8f42f67ba3619e8b14895e408addc18855b66376147fbbaebcbef4c18b35a885ea9ce317c369e85167b2951a9e8371505445ae2312109b00031f930ef548060bea82b7e7227873be9f529b76932ef959dc4158276664591eb5bfcc890c3894f49d51a4983d5db7c87c93e259a3cd2c4be78b94b6792c691e698a6ca907ca7e20ff5e3e1e3760022351459e68c23ee2d8117a715dbf81a689a1897adf4b54dfc9ba67e0e77d8c962e463d64f07ab1078f62950dab6d26da8b250e740cd64024371ca8ae6f0480a869811aec7ed7b2ff481225b641bb3f67f4913b058664dca3e47cecfb633027efc3c8d4bde36a7de4cbf4b22a761fbef9bc02b5aa7a92d3fdb260d97bff0c1c308e0bd6f5366ac876ae8187546980e845795fdd0c7ee6ef29a27d6775e8bde72cf35d46dfc1776350d964f3ff7652d666f23604248d7f5b637e769c674cc5b7906c089dab1f2ddb9354bb991f0065a8265a3bb9de3893b5f597d60eb051505b65afaf14f4b3c113c9327196d519a77fe9606f237585706e95e8347fb253568f34133a5fe5a7fd290daf018092b2333ed0874126b01a7dcbb4bb4165cce3d124da23ffc3a0b38b14c3a29c37a91dc5105c5b50fc582040472da6521aa2380e13cd3c2a14fcc196b82bf8b57774a7e02ef959b7f9e8631f1fa6afde32a831e987369fe191b0b46ebc7944c37c0c441927dec833f399dcaf789e3966a52cf61ccdbdf2a5688a9e6ef320687c939e18669b258ee5b11a97c42f7357a7a45bfbe8198ddb233eb6dfb5ee6ac7ece128f39717b72a9d335852eb5d3d98f2d9a0cef675508c27486a7b3817dbe24197e60a6b46b78d2a9766ace52a5747ad1e067e6c342ef758edfb895df6b3ba4b117d7f900949aedcc86564574adac296fcddff5f55d38902018048626641048b6c59e855e5e9ce73e981473b4c071244405b246bd2b3c60842ee2f0358e13cd200d311e03f40220f486fab7fd5e48b72ab816e41196da6ed97fe495bcab4ffb0f240953da0fab01dd7a26fb8f15dd246d41fdaea0b15a9978224a66df6e5e87d0a3b9ac6a112ecabee5349cfe069ed2c70766398d9e1009c0561047751923f71f7333a5a38ed5b226e99c072354c942228677d1733564f930a5330bd5bf2346738d264b9d895d8eeb3109c48f086bdabc5e8cbaad090394aeaa9b77685f6723e9bfb65029bab48c5b5619854f2de88023cb6468db81dff67304ed6e30a9ecb762948a7bca48e64a9977eef505af2b779d1fb9624b9c7e4d8f17997afddabf9f5526ea5f50cfe4377a5587917e1743d29325ec2f449173748a8a6768f88d68e5a2741925bad3e433ec4920a1d73898d7fbd125961ff812eaadb48f3d38c25ac213f6e6da4f109d91d8d8a4443c7602bc621520dd4c99d206159bedfc2d77a2a1eb7c90b56cf92af19408019746fee2fe6efc6941aa3ff52a5aa88626998859c9ef3b31ca649597eaaba20e72e2833118cf94d33b72af9860a32a92fa88599c5ce05c8ef7e48abecac0146a8310e1001bb068a535f7d5833b4134018909f2cfb04a635ae46974236fb7bc893d0c7b3ca853f686b045b11974eaa9b541c01643a568f0b14e94177d5b28bcaf3829b7da27ec355c2a6d02e5277f7d2b94fcc407b6a39a2ddf1175fc3ab3946324e80f53fab3670e5e03213ea358d0dde26a3d9edccb367767d3f4486de6f68c90469f1ec89c11411d638ad0efce014d4430f09687b9f68a02943125fc6107531ecc28b4dc962ecb3514508262c6bf10c436132ad57cd348d8decc9b50f6ceeeed5a8c4c9fa6c3cb84a5cfe9862e5b9cdb25eef9263918de79edae1d566bf10d54e0825691c225d27a925bea29f5cbfc005241103e36a61269ba00fe18f459653e231ed1e4797eb4ffd5e514c21bdb8b36e518dcb0a0b1ffa84b1e65336a1a31bae7931a65394eb782654209238f035c923d257800007cd062aba5ef24a28877e71741e7be72a0541dd6b133fe6bb63a71a6ce509391af50e13164ebd5c4288770d01c8bd8d9125ace4e602c7c258c34a1e85c4a42cb75cc0ced55dcf2ba93d8939d198205a0ab04b43fa8a8a9046cc7db871348d962c8908cb988c07757467213c2bcb2d933d74a17d3986fb1f5f039cb68dd5ae56f701124be066ca4d00a819594f75f6bb1cde96efb2ca910d595c0798203c28b862f27cfefde0e48b3f880b232a48d8ebb5d22c2649534bfee448d1a582a91c38039ca5bbc014be5f24273fc03b679879390f2a18e4b3fa3e682c109d2135903523c790255011767edecb0f32b7db2c3086a9393aaf17089249dbbd8b744f0767fc8f311f9ea036d85f3a2dbbd7472478ab001c5aabfc53991f6e6842bdf57b8a78be4d6d84663bf097c0afdc237119f43004801e0716316c58cff4dbbb71104de2bd00d1a6bca7a1d98a3edb2ff1282b00398860223aeb6d09a8aef9d5464403a11611a12d6d6bd16e462c54f220931fa4999868e3a9c060e80fa7826e0b67d9d52e0e537582bdacde70e4b3ac0f62fcda08e6ddfb4d591dd9f4875a07ab94585ab8fdb965f05903aaff9e54beb5e5107551a9e8b135e49b8253691cceae9a5b99e908469c7314b5b6b26f3bc2ae51fcaeffbc5e4f1e1b07bc322285bb5fb20f3a7592bf3fdb41a0b4252a867a030d21094530ede574552accae79b75c1e88e23a13795c13e5896417e5c47451ffcba2bdf22f826dc64ca17ec61277f10bdfd7192d7c54e2a04431faf6cff751ef2abf0bb01d50be45a0ddf47b1d01c7c774e8cc3feba2e561532287e15862db813cfb3dec5da28594b30e7643ab1dd341ec353363fe297ea8658f2800dda6ab345e450aa037df3ea32a71bfe49ff8d39e25236d02c0b5c57a828ff1b148625c36c895d784102d8ddd1467032fa7dc03772a677cd16f9299dcb80a0daec10b863364ad33c52e6e14d5ca7f024200a2fe924358d9b1216797c23a2abdb75486747287e746cc495a738cd1ef27acbc2ab470f5a1e34c8e86a7f6f6d74a8d8692f41529fc74589409712552b7fbe397cd05cbdab521657c1b2620d185a1575952368467e29044839edacd88e4d616f86683dc5919bb3d6c88742cca2174',
        salt = '54f92217c95b0ad362c00cdb59f94216',
        labelError = 'Bad password!',
        isRememberEnabled = false,
        rememberDurationInDays = 0; // 0 means forever

    // constants
    const rememberPassphraseKey = 'staticrypt_passphrase',
        rememberExpirationKey = 'staticrypt_expiration';

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param  hashedPassphrase
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassphrase) {
        const result = await decode(encryptedMsg, hashedPassphrase, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        document.write(plainHTML);
        document.close();
        return true;
    }

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        localStorage.removeItem(rememberPassphraseKey);
        localStorage.removeItem(rememberExpirationKey);
    }

    /**
     * Clear storage if we are logging out
     *
     * @returns  - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        if (!isRememberEnabled) {
            return false;
        }

        // show the remember me checkbox
        document.getElementById('staticrypt-remember-label').classList.remove('hidden');

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassphrase = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassphrase) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPassphraseQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPassphraseFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassphrase = hashedPassphraseFragment || hashedPassphraseQuery;

        if (hashedPassphrase) {
            return decryptAndReplaceHtml(hashedPassphrase);
        }

        return false;
    }

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        let hasDecrypted = await decryptOnLoadFromUrl();

        if (!hasDecrypted) {
            hasDecrypted = await decryptOnLoadFromRememberMe();
        }

        // if we didn't decrypt anything, show the password prompt. Otherwise the content has already been replaced, no
        // need to do anything
        if (!hasDecrypted) {
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const passphrase = document.getElementById('staticrypt-password').value,
            shouldRememberPassphrase = document.getElementById('staticrypt-remember').checked;

        // decrypt and replace the whole page
        const hashedPassphrase = await cryptoEngine.hashPassphrase(passphrase, salt);
        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

        if (isDecryptionSuccessful) {
            // remember the hashedPassphrase and set its expiration if necessary
            if (isRememberEnabled && shouldRememberPassphrase) {
                window.localStorage.setItem(rememberPassphraseKey, hashedPassphrase);

                // set the expiration if the duration isn't 0 (meaning no expiration)
                if (rememberDurationInDays > 0) {
                    window.localStorage.setItem(
                        rememberExpirationKey,
                        (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                    );
                }
            }
        } else {
            alert(labelError);
        }
    });
</script>
</body>
</html>
