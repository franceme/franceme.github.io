<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #4CAF50;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #43A047;
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #76b852; /* fallback for old browsers */
            background: -webkit-linear-gradient(right, #76b852, #8DC26F);
            background: -moz-linear-gradient(right, #76b852, #8DC26F);
            background: -o-linear-gradient(right, #76b852, #8DC26F);
            background: linear-gradient(to left, #76b852, #8DC26F);
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>




<script>
    // do not remove this comment, it is used to detect the version of the script
    // STATICRYPT_VERSION: async

    const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 *
 * Mirrors the API of CryptoJS.enc.Hex
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassphrase) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassphrase
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassphrase) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassphrase(passphrase, salt) {
    // we hash the passphrase in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassphrase = await hashLegacyRound(passphrase, salt);

    hashedPassphrase = await hashSecondRound(hashedPassphrase, salt);

    return hashThirdRound(hashedPassphrase, salt);
}
exports.hashPassphrase = hashPassphrase;

/**
 * This hashes the passphrase with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(passphrase, salt) {
    return pbkdf2(passphrase, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(passphrase, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(passphrase),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassphrase, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
    const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassphrase = await cryptoEngine.hashPassphrase(password, salt);


    const encrypted = await cryptoEngine.encrypt(msg, hashedPassphrase);
    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassphrase, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassphrase
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassphrase
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassphrase,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassphrase = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassphrase, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassphrase = originalPassphrase || hashedPassphrase;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassphrase = await cryptoEngine.hashThirdRound(originalPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassphrase = await cryptoEngine.hashSecondRound(originalPassphrase, salt);
        updatedHashedPassphrase = await cryptoEngine.hashThirdRound(updatedHashedPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassphrase),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
    const decode = codec.init(cryptoEngine).decode;

    // variables to be filled when generating the file
    const encryptedMsg = 'ee95add010a24051fa7933652a9da95541d3d1f3466be905f94d2f486ac573dbd0396e22b17fa62901f5b148144070632dd2fc5214558254afc8de8021c81d129eb5b96db01e72701fcf5a562c0f58e03775917ef9f912e14fccf8b879b725b4021f75911cd466da72708e845a2249b2a268926a853ae11a05c2bf705ca3d4bf2b4a6a1942e56b1afc65778ebade2adf8206bd039b1ca9e9f57322f1e5b39ea04c9b90eb86abc1bff0a81d81dd3fbee7f0064f80d394ef38affd7c57c390133e7a1028e640df9b7ff0385eb618adffc4fbdf167c3d5fc19d41a508d2e6f5141aa43d9efcab775f581d064f509be21e02f58e9b0b2d0d4a6b50c79182aff5addaa6a57e9e8b3ba404b918b5b69d4b1a9a97c3e5c97b358a0a811fce3865e0ca0e7fb9fbe5d62ff6d06e2d64919c75cb3cc9c6dff5ce735ba7ab0cafe890dfc85cf5e1fd04f2ab871dc5737ea8d1140a6675ebae33803e79636c5094ade638163e19f08fbda4a9e431e3d91b285c2ce4cb94724f4f5b06f35a6586706f0fb3638887d1850929514e9d2bdd8e17d571587cd717d1ab96e7aadc8d3b8d4cd6bc6f43e1b69a4c0aad0b31efc57d49c44a70cdf401618db74a319a95583dffa36cbc21190a3858eb66fb3cec52b312e20d671b14cb33045c40d8f6bd84d5ad6d407ae74319f59ecd7ecc579416c3a4a399d6853496556024e3aa3bea67ab8973f831fe433569110cb220d17cafc4bb49a2264c79a118a535f8549185e69089359b91461dda2f67f724bbe8f603020b266b91b3870074a185890315172d828b1002f3910272c97f3fa7d513d1ec987e172a1f1f648ec6e1aabf7c902c603dafa2f9d7a695b7e2c06057d1348c8694e7d3886a7f2cb8fd54d69ae5157878c8bc48f2fc48a502d19b6ecb87307ea956a49822ed940588a535bc99c93f16ef76e21bad382158b70f045c4530463330db351e44506f7f5690dd1bb051e02a19b1c988e64b485c417768216166ed7f1f22040d72aea1adb12caa83bfd15a6798d5eb0ffa952f44dbfee387d63564f572c4f031c0f6a7e891fad5eda6d41467174467317636d2300f1a230ba6901adc012fe4e2c30cef4cae13d64e927be7b13c8c4b04ee4069ed7ccf5e86a2d9af8f87b8951ac04be9d62fcc6420c7ea1bc74d7d37c29a1d734e8b30b30f90a36e494a9a4d36b1fac874c98fde7605e769e48573e1316a4557687e2f16e31ffa01b1370e156ee0290b7eae34386be00a1857f329f7c0ea87bab99101e2cd8271240598680db79a988bd0e31e5437c4479b2598edab28eec4e0f9d2ac2b79d2b5bf5c33ee8ce17feb64f7b92d1430ef0153b68ca2084611ea1e922ab9d4c3acf93f63de18f4fd689fe287baa0dc9385e613e2a2f2b42827ea6a26e26a6559623897865a9e602630a0b23989a16c92a2fcd193fe6977002540e39a0a3d953bec27bbfa41db7c9fc55886a0312f95f3d8cb843a87c24e78f7535ee9da98917402dd216f35b789556ca4271f7deaabf3ba1b7f9956397c7e7b6b0d4730809ca43ec9a30841a939509676e43a348ac278bbee45465ef167be762e5dafdcda9dc0843d9bb92568a0d0e29120383cbe0fdc3e0e736d874c47cae076bab56a96b8fdf42ec91fa794964efe0680b5ea26497610ed0278f7dea6b20216eb408482ff1f64d796b72d7a0b2d432cbb56baab5b217630d43f999ba1d6cc5750eabf0cee3a7eeb93e4b96b563d3bf6d05c8380aa44b442d96806040b3fc91a13a8db2c8c6053d64e2d263c890548b1bb03e3a9574ee5c543a607830aa6691208c5cda4679a1257bb1f788be12237a423912d6527b54bc3a1fef30a815fd65b9efbbd4ae01fccf6a590a8bd9fb3738a65fd9864e1ec4e6b9657559e6fe05c6af34de87d5cdefd868f30fe3f111b6f8b9fc3c2c2c8a469db9a1befa3bb426c016b478ca636b687801d68e59f3e54d300a380eca53a61bc7f925ce62738e658bd081a6fcb9ea31e1e4d1b98dae10adec8cb366f8872c85d50aa05a28070a453d4447147e8b694fd8d17089611075c993754fd31f58a58a80094467427c1a5ec2242145f6c020a4732e04915e01d3d3d2af046353ceb0bda068aa64cb5710ab53b68cc678556344eff883d8f57f51d91fb20a83becb3e18d88d794810806a90d5894fceaa00eb110bfc17881464c7b7c1227c5373d3776c56134b8db84b0544b8789027270589fd54eba0c4a5b65bc97eebdc54c786638304e7c9c142a7ea3058ec6cbcb3170339767ec4659590520657e021770fbefe54c5ad876f83244913ad5a490fee5d79d086eb2cd5a4b15aff67e05bb8748c164cfdcb7a20c1bb7bc9b9c38ceab9b3d764e39030a4b86cb22cf3a713b31ed3d2a44e6850ab8935342e2cb1e8a03acbeebbbf57d3fbd20c0663ad0f0c294fa20b0012903dcb38762a60ed343c1c11271bff36d42c74e3838e3ab663dcd9ff26dfa88d33ca1f5a81ac508f8b8a86e851cf13730f606f9163a1618715316d87ea935ec856c61b080c3a00c45ec515221799da640d66f9c67391f51f0ae38642cedc1e94d562e74c7a657d358e4674d689dfd968cffdeb07c26d2d5e8922e2d4424ea76abb74bd401ee8351c8d3bff4e8e8cd11ef7087a78f1b1218516aec6546993a60e54112d0933cb5e5fcdc85ce17d4421c1010179d1df569745378bf6491ec314d3f6742d6417382f79d89d66e5fd52afbf388e73667d0b6bfe22a6f146fe632bea592620cead6d71115d98cd464929a98b2cf280862231e46aa236e5812fc76140f585e2d81a9bea7388c504a8636a5afc1469e122c00706b4769a8f08280c63d114a8f5dce566baa63cd4139927f6e6c5ee909ce1aca75b7db773ba44997ae19ee886d7164d1462f94e320271c8cad0894ccfdcf0c4f88c4e712fdcf2018c417e746d29cbd9971980843076c0c80688d7513ea499e7efa7208d89fafb86518c0192497f15bc3ef4b01e5b9876a35bf9c90df9cd4d17651f1e6071a3a4c48c1cc3585e76fba9c89387aa40df9358ff4deec96204cf9440bc178eaf97368e8807a10fd915adc65ef07bda7460baf7acba6c0c99aa94e6474f2a75ea619fe8df43589a1bae27c46b94c95e7f8c9abb30379e9db8bcf9814d20547b47549766a50312ed1d6705eb63d36d0bd5cd64be07bc0bf7ca6109a128e92c4b7b4b5ea3493f6602024581a6dbbe114e959b342e1f9cd3d539f79cb165fdcef0258bdfa253f7de36adaa571bcbff1329f1687ed35e259d85724b8dac3e36886995015b450bb62216c6aab3c5a496add41981e53a43268bff8a76f6d093d2c16e7281b2010ce08dccbf2d2c075706b805fb74a59d0a69afef4825aadd489449ec4dd0605e87cfe555c215493fd7d78c9f311c9304617322df37a161805235756d30713cf4001ccaf10408a1b1954f6a1d22e79efe56cfa928c2a8feb80b7cc1e7f193ef33efa8674d8dfd8b90f178f774f8d8c9546cc0097b1837fab187eda15e5fa5953e3b673dcefc11124aa21d32e8024153b3b1da923e1410da1e3a0b630f27c3b39fd6d63b6f29a053409f324a6a1747d2aad42e21f527e1dada4d358acde6ac63d41e945108f0ff9f3b989c27ebd8ef678613326e79158441a73e4f21ef8843bd4a22f0428f62032b5f210c9622836f420e697fbb0ffbeb07c4ef5215449cb2620276c850618bce97fd766a11470240ace0c15c17580a1f816381d439ae3ee24935682677896a5d545998aa80c100c2c17a6b907d25313b9e2e00d29c33ee7a295cf6abc33255c8a29bd6186b5317f849c144c69691158716f99a4857e4bc13865e5d6b8b30a9a7f3d6c21959b2ae041f9f79739b065a9bcf22c6dfa14430657bcdd3598b7fc144de3ceaf35951284306aaa5402d7d726a979161239fe71c802ab4c0058bdc31f5c58861319e17baf1fec3d72cc74f33f67890843b4d7d6de6a4f142f293246028d75040983eb71c0fa30a5ef9c731b065506e61092de1b0ed6d4cf3535790d26cfe8916816a7f45e578fae709d12bb32d854563d3d46e5da912b51e9392e3175601e10036f133f3d0d1344d6f120fbc418c19474eaa7045d13e820dcae04e9e03cee95eedf2afb25d3dae3d568f36009d9f519ca516db46d00b9abc480fc8b43a5f8d95699ea90b961305e6a20df3cf5bc139b6e9f75c8f6b2426ff2cea76bf1e46c64f0124578c971f57ae1e7598a6bf6c0059bdeba33f1959a4e234fb6939ab0fc70e9da8813398d0b77bd3939d8ecaf926d9ba1ca935fd657931cadebfb4fb2b552b605692fe4ee0245d9208a3a380771e787a6ef969ecabe4b46105dc2e576117b23f222fc2a7b40129d0da6e19887c0647770e48f91bb5026c6655010f8a14c4f8385d68574605045585afab135624eed1e032008e5fa1b0793a18bbe2fcf8d31752f6283ec7b8512275718d32d0df87eb4354060fe35f97cf69ae491af6b0a71e44f95341005f17ec69b237f14c162b3b62018b161b7e65bb53ebfd40b93cb34bee0f0f2f9fb74f70131a6d5ad222b201519f0fec56f0ceadbf7d906ca02bac94cf73434eb6664056069ddb5d49f8e6216de5ff97ab9334c6e07ef93467af660f8fb168a1ea903ce3d846c842afa583d18478b2bb9205e00fa946b4321a84352a857ddd64de0829829ee5ed96bf4b1c0400325a52ea70ca05719cf6ea1c0ac832959a9cccfb0083b125fb7e12273cc7c7a8e7f87c53aadd2171a867988ee8dc888737d64f88bcccbf3aa290935bd2fb0ca4c5b7ddcf62bfd609ad347611e398faa6f75cab815fcf3901dd3a0d35e76253f7dafd28c7a3c469c1d030cb29be65fbe94d2bd65646f9f3e271711b9ad14d8985e26f3bf9df1caf5df04f82594b1999af33c29c66cc0173734e8274343a0fa5b6235cee23c97cab4f50569fd19a421b21ebde17c812b04eaad00ca0db161136a60ea25908b57c6c9044690652391093a7d8c20d2b6bcbc5878bca0472dca59f3f02c0edc2721d966ffb8cb07b0c1fcc82199bb6f05441cbc5f89174924ec8212cec8718a0c828bdcac62cb38caf1212dfdeea27b9ffe7a4a23c8a445ecde4bc19f04faa617487206cc47d7e57e034c0ab5cd0b7f42dc6dda868e873cb27dc8d3a2b54cf990561e3659ce5c188bc5eb5931b842b3b97433086cee8e22ba7b01a521c0836a4f992d151c964c91d42d564c6c547e14d7624470970901d1841334913e6a7bc49aa70f7e8487e110ce17b8c32d181a4c2682fed7b7bd3bcc583f5b9d2c17c1aa9ab88b67702fc2dbd0248efd987486b54c1cf900c71d0d60ed396147dded9aa16acc268325a65ef4bb6fa19006be43294bb7daf5d554a10d1c65839614aaa2ba434e02f132b68a71d31ebad2bdd3217a79804e84fc563e798f98a1d5392b5d08b9b1165cd68e68fdc0babb375fd55d4111b45eb1e28ce5f978d5788f41d4d056e861db1f90f0863c21c7694b62a05b832cab3200af93ffb2400db9864d757a1e74a63de9791c4b305661277a4b500e443087b81e85477e13ebfa4e2285424d1898294680211dc2eb000a3f2f5912460cd2a251a5edee27e661cd19b7f81464b880ffc7c890438228f7159971a6be77b246daadc0ca4076a8bf28e49c1ff4f8820994f0d57d660f9fbfec3a95899e7c6e69eef8351dbd1c86e668d034513c6a61e33d87dce58219327a1201ec1caae7f997b5bd0dc73e5445dce8adbf2cdf96235f47426007ad260b50527b9b529c9198c7e3a2a197823376407c35dc9d886f4148616c3f15f4bbef316cd532a94aa233a72c25ee9f1dabb8f0e257eacd6dce9cd381f27c5b15fed9178fbc0b9102128ecf24a51848eb407c0c0f5b52d93e92e9eae68bb10aa00008e0ded640ea3cfa45cdceb68afe5ec6ecc9480c87cd69d7430d124bd22490ca94c544e321e63d65dcab67d6ef1065f7b590c891ed8092024d722325b9b45703fb8248211892b515f0a4c5d5bc73835d9121cfdb586844fa95f43d69ebdd38d437c1c6aafe7632aed3bded8422d494e98ea6c0691943f217d82f109ecb7bd5f7efa049a86f273f3c72f00f214658dfcad842f9b908e45d01d5ff92939eef105fa094b81533793a8f50ba9f1df9df0da4c7492a598275174851cc7c249efb49706e097e4c133387e78061b926f34c955f863828e0a3a434ff45ca49fb2ac2a1b61fd9ef9850014f517b4817bc125c0c5bb183b8eca52dc4df40b5165a0ca5e7b03f53e411a1936da8f3a5c6961ab65fd7dec99625a7adeca085f3d16bd587454df7508a631d6774fab38ef3e39ffdbcde7449396aca51dc6049e01e057634112b4534a3f80bcc4245fea34e1eca5bb836ae5d75041832323bec25286cb28d559a14d85d7e6d237342b6e0af8243d78c16355fadd79df41c6328ac78ded8418dd4b9bc357f1496bc38beb2c18c47451b988510668fddf473a441191d6a63800cce2031d99826557863371000f56a4ce5b28cb0917e4cf27d07e2714658ddfa099a1c13dbc547c577189417ed59fa76961736ce866cde7c9e6e1cb6d873facf570dae606c65ed43b39099935ed5a0581c4c2461ca26cab1693cb93d8cb3a1e1f8d98e3ebfce4e9f3d3b4072d728e58688b67b6f28513dd0eb37dfddafb87b37b9c4af8a3ba25c798c080d3f17738c26adf1f688515ffad1cecef80e3ede0a2608cfaa27c36eec3d5c8d7d5714d2eba89af4159df6f882f6048afc8f46de5eb8e647d086fcb212c17c515b2cbbc06ea6ff6c5dbb2cf8e4695c65c8fc12f63e66c29bfa6c1ed782151c3e51396cc304cab3cad2d30e283477d00f131d1f051b5132c32861d6b0df1c57d01ebcf66874f6800c5fe7883a676b2cbdb53206e8891de4c6c1d2765dd44939d342a7cf7d998686f25426b9748b52c33d7b459aa7e4ad79f14bf56cf60ed5bfd0bb6e4cd378b5b78aba5382baf9989875d74015dc76c6b5fb697de4a1d90df60893fde57f5c4eeab12cc34220c46fda13782b8323f109b8f788ea4f2f14d82c6681f224f17053e6fd128743c1bd4ca6cdb33ef60c5199e1ac6c8d49ceea733086c33518be23754f6edb4f53d66d5e9f1cbf84820291b2c9af8dfcd613537da10b47911c325c046a2ce640e5080aec3714fd43936dd025a399126fb33e129ff9abd3cb96069dd6b89bbaf356b3f7eec17271a7e690c2e661a9910d65025b9a67088299048b2c14a5ae35340adaa114537fc07bb823736407856e30c371b075058ddf5ac3be3c3b4c65c976138208d3cd14aa9642051902559c297c338f7c496a0df8d90b16b1e929b13d83f64f581ce666fd414de7a4658d5a2cd183dbd36385d9316a47bb1d7b0d8c088c74ab696dc67c4f927fd7e01b15d0f42c345d7fe7e6134e18dd3c2bf4615d9ae820a77b85439133f0eb016ff5dcf73c02f9bd76ea3360a427b7af4bb61a0112704a2e20a63083212fcd88dc2761389c246fcad5322e8b49e30b83540da59d70a533ae8757b3fe51d98b0e0bcd62151a7637bdb34047f5ae7dfbb0ce50be54f8ac6431b3b912c0d430b5b6fe6e09fb9cb3e6fea12f2870a0094bd8cffb86be6a084becbc82e4de5c63390e6a524cde8d3e3c3d58b14bdb5a8613af2a3da308b930ed8c7e9b359ef8fea7fdaf056596f5bbe7051a4b4e7d94c79929d054840281681e443e9a8aaace5a4cd10b61309ccd36c9b71e2630a11d5b1f498b09685cd59a916cad38e015b179c940ecd176a3ba11f79ed01ab867d54ef9c66a942af9db1faf2721ca9e60a055d9135f3f0393a1bad75d90de376ff7350f8f7ec1c0a04b1ac6799bd9cad7a8e3566956ce299f6840cd040cfab7a398bef68b683578ad7b0d1f9d4d1f4e817d7ef7d7321c9c5bba89001dfccdf39f91b0268031a66de27d4f36a036ec0774804eafc6f2e2c6d0fc83467616a014c2858575daedc6d551eea8a29b7f7d44c007fed0dd8ee67c58a4ae69e048f531ff7fc3a1c5bdcb9ceff9cac5f6470d5050dedf3436a7623a9235dba913723cb659c9bb0bccb8fa17f3dbc41a4eaf982a7a90b999b9d45407bc56c10ed9a531461e9d7fa082fcce8a314a0ec2b5a7d6b09c407d7c97c8e892fb59d5f37f9419a405a36a362a488645a589927f89d1eeff919cea81bafde10b9db4f0de930496b9789de89ac3a654a2275859e9cffe5eb1aea8fff5f277bcb0c83a2fcf5bd095dd4db6ebdb03ca18d4ecbd6e8be891a827ba2ae593ce701903be55eea297e1aef69048bb18a0e1905952176561e9aecbc6430891f811f722d850211a02b748ca635dbbbdb840e897229f93fe15a7fd942fdbd3dc10d1c9405499c6b513e246f08ad3a91c53b62390e7634c05bb6d6533496540f61f22070516d6fe2300c4e2a7e7e2c6e6c6401752f206c031c03992dd46391804d279c37ec6b22748f04796bda44fba596bda64de9c444ab45acd0cfeb326e7fde529ec8b6f045e43bbf607072f1b881621ea35faa88d7f79ed00da0b5dc746c49e88ca92c07d0f1a2853f0bdeb7db9fc3fd522b1c72c685f6be1f248a41a7a449739acf327174f02f1a29c26ece9f3f55c1b3e544d00668caf3330eabd89c99308311e24837795bd81b4a7490c0a7d0be5de99cb6a68b06ce3c56d2e0e1d08b30db1ac76618830d1dc435909a73e517813eccbaea4aa745594f554243911a377d2444df179dde15981b6ffbe8b6c4a39b64af7e6dcacb8994bd1fc4b3c2e327ac760aa1cafce8dc55db3ed424d143d0894d9d17dad7712fc733c22b05f8acaca3bccb40cc0d3abbc8b5ba371289c93533ccfa0fe08b30e9dbaa8cc3e024224c6a38cd661cbab21c96cc1dd3cac14a19cb8d021873bcd553a163e7a5fa0385ac4c095ce31347cdf0e5f3bee788d885ead985db7a3ad122bcfbd1ba19a64d2dceaab76c45064705ababb6f26b05f72e1cf788542ee8642404fed47486ce76a61b902b57d173a084e3a8767840b037b87b85904aaadb5ce64e1b83b06cb32e507c699a362d0b82d65a55d5648417fb6a6c52334de02bd29463cb96588b82862bf5027756e9f7d3c3e102e722f924dca13dbcd4a0d285e078ac3fb8522f1378ba87d5f1390d8d0380d6d35caddf550f43f98aae0178370a2b4393342c2ccfb5191049b2491cf516ab78abff0cfa6e61a82bc5a098e70f26f08a50927e234ff0bfe9f939d4e9e5b6e693c2a28f5fbe6d7529f9b2bffa68861c81990856be4b91896a1bf104927f58d01e8cf543e9d7ab75c337935c75a69b876240250efc4729388c52fc851c35ede2e0025c84286d15ccbf44f0694c85863143f72a893e175f9ad56e3c46f1643454cfecd05d7f4b054250a01295eec9c7054671df3bcd92ab7c9779130926b2a2ff86b7af94a4b1f1bcc4770cbc59a94877ec81f5ec11849a6dfdac1b9d6bb238427f422fa88225641f0cde4d4d843ccd7a7942536c0d277a211a2f987f6d16b199cc458318cb87fe8ce5462c4c732013ff5f986f0fb8eacfc3e66cbf2901df15ab1488a2f4cfa187bcad595c8115199e08e0123fe2c40b624335307a87fe25406386c6281dde5ecc6e704c317ac9a9f4c63bf0d1c081dab2d06bf9cd0ef9d778ca7733c0af9f23c88a2f9a09aece42319d7ae0ef23b292386ce9d78f5371a0a4a95e7d77f53a10a1fc2638f77b4a1c11443376a4ba663de6ea65e9412a1629eda1615b69b4f4945703991bdfa6674cc2b83128aa4421e608547f1a19ae071e34fa84b6b683ab48e40aea284543cc11aeb17c20fd7a226aed8866e87f893504779530a31544ffd63bb451cef75edb0779ae09e1293374104526748c89ca1173be3a651abc96f6659fe27f65a8e539bf34c0a654a769af2b3d3afbcd4b4fcb1c9ba71135f64cc1b25c9f4f93354c7b443ef3b7b9cec07581a5286c28d90ffc5c01ed680f4ad038eb7672659d26b4ba14e7c487a2ea45d12bb8d16cab0328cf1b481a800213019a55a2feeff3d137b5b5f3c7a5e898799bc068c5e2b7bbd44ed0a0ba25a262f9b3513e8acc589ff45c5abfe9650d638173916111c6b520bb9c13af5699ca4d84ef9dc8f584636438aa2de934543063daea2b1411fff25d35f2d71d838d64a68ca781e6b0fc11c3f8955c5498c5202110414dbfd1788d4f75f5dbae4df9185ef23b399ef95ace6b9a81904b30283ee844f3fbfcbf4d9bd44fc4c2b6ce7b1413d98c88c81e7f07806170d289f6548e499b6d98bbdcfbc9fe39738eb85c456e1370ca35343c595aa1c53f4b99ccd51a388125dcbf32f1b4b2b81fa963bd8c98947acd2e3208818a91a18ea441f3567adcfa144f416c1fa4b144a11a31abfd7c7eac006591f1a70b10c6021bb49c4bf688521521843b6a6d1d5f1ebcf15dd2769eaaa7cbccb52a978cb0b39eb3fae17f19842f9744008405e6b887aa1bb6e7dcbe56db85d1a089d382c1b2272cc312f7ee8dcc2b647b95a8f920e8ae6162d2eac3cb5dd3101daa8051df8ea887df7279cf5a4a9b35fb6c15440e5df4dee6af268b23124555cb9795678185c868b2fe50da1bb9da78e30f3d0a6183c258c758af2c7f3a53d3ca2599439a7dca008006d02949bad52416d355a0d3c5e1f04de2edc3acd62a6eb94ec7263a772399660ef3c75e5044136ca8a413975ebc40db286f5423cd97c7ce25b93130a6b27c901990e9add4f11679998f42538c2ec872b3a469d074f0989b136c845f69019d6cc668f05c2a25753a2490432eea4cfaa821cf8fd8fa74ffb51e648fbdbd0dd17e6a7327ce5a5fc8e04ac61b455b9d73c9d7ace13e39ac381bc985799bf11626f874b7a5a14bb405780d54b8b8667e31cc2b700615ec4e05dcab01473344b0669980d18cd2e5e808ec2685c62aee31fc669a983047c96c665be15524d9b57e55ee376a48638c04e450b92908e372c093bb320793c1ea20beeb2bcd1e327a17be4ba1517620fd0ca1e5283be3c7377c9f4cd74c163e7074fb38993d8d8ca4a7e25fc613c69071a72ee7b9a293b77abab1f37a87036a60f95f11a33f52caa0234c47c4b1d292cd5a4299e194cf9aba803566d4aab5b66b8a55890accfd60b02b2e63e1c1859b9ac852960b48272b9b16b58ac5487f76ec9d8d2e6df966b097046adf86a79e263cd049e7e644a0dc8c387610f197f08bfeef30c8227f19e9bbe38333b60b1c763fe1e62dcaee9babd209c26e49dc3c4786919df609a077cf0023cc5a26fc20e8adedbc93ca0cdf28fa597e438eb6bea8ab40e1c7f31017fe3ed35ac19f01ab981aadb32bfbeff74b2a384fbd722975699fce900243599f6de8ec5f9707233a8b9a799b1a697507b43f7717a410c1fa408fa81d562f754e7c3331a3abbccb203484d81d16106797f283aae57431b53d7807aebc68546dab41b27416a98470ae1156cf00f6a4297dd7b9e874d4362d45e48bd1ab6a203af992c897e6c3361e910dd076a00e2186936caca3d1801120cede11de0a6097632b06d2ba20f7dd4d349a520a42cbe94aee3035c4c5f8d7f5f02c82d71f439065baf95e2a5c12bb7d80ce1746f92699e81444ce10ed27397f2adf285c7c8729f971f06510956dbe237bb59ef0f7f8cc4b7eb3119e1885ff6ee6673d227130a15ab27f20acc42098014f8f59025be4408e887768df22285dac13c9af4eaf3dcbdea4f15b24c89f467e0c91a053b520e02fe47d31d26eeffa80436c47f9f5a3e00273558295ff5e05a45ba77fa7ba2ed8ba985cc7cb4d0ea698bc4c268e5d2aa14d13ad378b163c0aea3ad96c5c66180e1666a6b3d3d592d301ce6ec206c594e20fc15447869e58b2243503a36043a6eddef2763488ed8bd3db395754579bbdbaab62288736edf14a82091f8cbc2820123eb862ca4a047bbf2e950979877b6931df91d08c83daf0008411a76fd3925bd9917f14c9b12e8eb6b5ad7843eb2fe22fa9ed759ce6c15851cac138256ab90063a38e2a4d3e8c27e3d9caa5f628b23d2c28d3ac71dda666eb40f7c5630c2d1069d2cdac57729e50bfd8358b1c33136c3acb2b2a61243c55410669609a7af28c5181a9efa9fcc9f753f761b21e5163afe217cc37e04741c37dff88909a18b34acb0f79747bbdd2220f375e62857dd89d8cb1594cd617be788a4f1d00abb4fc261e8d4c4b5476cfecad86ba33f8ce459f5a46e2db17fa16b750dff1605a4105301e07ef2d7edfdbdbef0f5156088168b0f8526151abf4f2bf4bd051d2e6ada44101d85dd2fabf6b7b3395363264c46048770aeeee3fd3acffdcfefa8d08ce1a073d67c6566e96a66e1f05d27f2b113a2693c2132314ffa9905b27758d28a0f65c8aa0a3c630572e7f08e2aa1215d58c085e55a7646729ef4fd1c497b1b8d4acc94f3fe445579b96f8d5b5059c37064d753d897f2cba99a6395a62acb70df2642c8daf6543ed9d76657b4a8cce6bd3c44356b02593d27a2bb46a0003b17edab33c91b81455b451bf7f58b40663f19e87003715c861ceb2dca6926c0e26e682e847483dbc94d1a3d9c1daec5e967733a21004a16ec3336102438e1dbea5f91a921d13ac372652eef1af78c6db7f50ca950c2165bf7de2c0af565d8451c3488c3a8b230767f4b2a8979f1e708048c1daced9e995921229fe48c157f0df4df93d803970bf4591a2a1187dead5a848340e24ef99485c6413250c1d8ba06a5a113f03637c79e624387cfea9824b972d12f40ce5528d6ceb45ca9fe71b351120d1812e06b724478c547b2cab464f0ed5dfec6b339e07a9ef0f2b4c846313860f78c5b72d340d6a9bffc49ea9c6cabdc3cb11608b9a31066bc74fcf201d98826c0b1a5daaae6327e8eb08257a8b00273ecec44b7fa632308eba70183ee8223d1c120c3486fd1470238a5e6f352e4a556bbb9e67b3dd28b7e6029371dc3ef85c8fcd4bf36953b216b1a0fb715f75a8a55573e284fcf08292753fe275d483fc83c6c29272e0e2cea241bab4c45659525d78cc5f634f56a5a055ed78e878826ce13ce7b37b79791355e058475f0cb44061e0b5d7c296a0bcf7fba8b08e3bcc39b1e0f0abebccf4ed3cd5c2040d22edd81769ee6c8a70e5818c184ce746f8629a06c9c9a27b5873e68e2335031c52e6aff6f967585858ace3cbab75c8e7e288c08d39451a84caddad95794fae9d24feeceee8336cc7a523df6fb3329557c952b1e1c997356d12cbe967949d27b8e3cfe3d89af15b370e2b0038849dc494bb61dd0b9f2f0414dbdd1f8c4af27b1d768605f0c018bafac2c1758016ed0b6efb0d14bf8df7fd87a1322e1ff185b4823e8476f4183fff994aa5c41bf31f852def099f96c74c3129b6fc96a336917c5507ad6dae51c64e68ed951332a27431552dd60568dd8679797267e5d31ee2b1f2e3f87c6e717f25deb1bb45085df2b391de5db3b759c734c88ef82d35099db82a9403ba7edb68f3f40d095f83458b2cb2ae579946735ae815c91cfb7b6c6ca561154e2e1c77a4e52134035a9df5b46ac9f8cf66af66d6e2db13adca2296a9dbe60cff7dc3e5b2771e8bedca40aaf573aaa1741d929cafaa77df9ba86bf57b575dd0dedb6b7f6d6fb1a531889e1b5383103a25f496d88275294af2505a12e7a3dd411944d1286f5df3e25296ecbaba6cc0312fe704f0583533cb4498d133a4eb28e8cd79c7e80b62674dd09772324b04b47d22ae3d79528a658b062c0b29fae8275405b98c515aacbbc89d0752192a3d93bba039c58ca547734a6a4afddfe65f2def72f4bb56f49b8e848e2253f3df1f999e7b27807a8a0be4429fafcf9fd84d1162d46206d070cf43a51e12a677924de045ad625217fe8d5f13cecf33be2e65f49a915593bdc8c4aa700b7ea1b301e5bcd4a03e45a384f8b804dedc7181d4b8b56ff741ee5ad9482dc02efcd155b0138571681f99fc87013b43a2e1feb81c89d5667fec06ca278b6811d4794e114ef1e8d8f5c0d66bf84ff7425507541ab71e3a1a6fbec28fb35337d4f58c162cd5b514593d20b1c94801877648f52046b2628d95d295a41537fd564ecbf08d18500e97ecff6ec08fa62c4496fc6fcbaeb88b2d9f0971b8b704bf2e45149524d202adb430834f6e66e6b03bdf0c684a9d9102a3c76f357114d302b8663271b42d85513fc5f75efbacc7ef1cbd5a9459a4671df8a64036da00f60206f073813b7cddd9cf140c8d2a1755030e20efee556953993d1a8657279802ca5fe238ce500b2900e4d809108447cb1da2d5ba49bbd01114e1ede7265de7d88219c32493310d1f5629f2ab4acc1e8010648ece96b868d2d2fb03f84b6096192dbb53c14d1ba0a9099e9782fa5ea1f599895449e281704d67b70e10cc505d4168818d271fd334c676bb15025af2802998ad5a948a3b4f2ae6dbaa3eaf3e962ce561d0a0179190ee7a057f8d53dc9d105c57e0d30a3031b106d24bd82424024e53353f0ba4a6189d5ae0a4382bca859acc78ef960eaf0049e266c1de39bbb0cf8ef822d500ee13eecbdd1eb4acf55f24b85c27ca7cb82956e480ee4f5b288a3fd32ce3ab6ba03f89e94fd81cdc480d18f0e53d22ea87a8ba73ae4f1d360ba4ad99e06c927ce48ba41457a4046124daa0b6d07b4c3211d5881a9c3c230d70769743fd6e7cb09ba2eecbf574fd96993eba1932a0a71d9c64103d406b8c2c9eaa50e905f48028d9adf46703d6895b7e8d23c00cb45ae3da9cc5a23b6ffa0a4f7b2a7516421aa0c377ac164bf12b86109a992e6ad725863bc33dff034c623a189484640879cc77fc03e7926de10422174b4ba6fce76754fcedf4ed941ecfa861f75e9bba4d02be1aa56a58f5ee1755fd9742a138db4e070ac632cc574ec80858680dedb90ce2f4989431056620e57ac22e1d7f9cba35bf40ab35c462b08fea4fc3a8e1df79e7f742fe9bcee498a1d5a7c6698560278951d0d253800425d3b61882367acd6fdb6cc29dad5f51139d0d14226e02326f3ece2195a806f6f03a79d4e4423901d4cf57a0269c25ce5fb55c31c0e7d50959fe2d214fc4e3bf9f0d3062e9ee6c25f4dfe06903e6b06ae0ca66e0ecf5adf9ed9965f39fc8bf42e71916749868e0fdcb9b66be5c75a338fbd2d9afd7dbadf58ec1d86ab5e1320b91c58537a28f3222d7acb92e0fcdb962406bb0580c5563aa17d4ca2c64e306e9f81562e916e68ee7dd458f0b5123cba34abbc3a275e9308dbcafa032a6a342737af9e0a9f91e3fb1e2a1fafa73288045513cfbf40cf72b2e52983cf8416db89316517aa34e9e0859f08def26011e6cc6783b51277ea01b9849fe9b7684cf187a3b972f0567537618018ed2aa04bd4f2c6f836baddfce86ca1',
        salt = 'c16692eaababb7fa975825b8c98ad3d4',
        labelError = 'Bad password!',
        isRememberEnabled = false,
        rememberDurationInDays = 0; // 0 means forever

    // constants
    const rememberPassphraseKey = 'staticrypt_passphrase',
        rememberExpirationKey = 'staticrypt_expiration';

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param  hashedPassphrase
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassphrase) {
        const result = await decode(encryptedMsg, hashedPassphrase, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        document.write(plainHTML);
        document.close();
        return true;
    }

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        localStorage.removeItem(rememberPassphraseKey);
        localStorage.removeItem(rememberExpirationKey);
    }

    /**
     * Clear storage if we are logging out
     *
     * @returns  - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        if (!isRememberEnabled) {
            return false;
        }

        // show the remember me checkbox
        document.getElementById('staticrypt-remember-label').classList.remove('hidden');

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassphrase = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassphrase) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPassphraseQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPassphraseFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassphrase = hashedPassphraseFragment || hashedPassphraseQuery;

        if (hashedPassphrase) {
            return decryptAndReplaceHtml(hashedPassphrase);
        }

        return false;
    }

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        let hasDecrypted = await decryptOnLoadFromUrl();

        if (!hasDecrypted) {
            hasDecrypted = await decryptOnLoadFromRememberMe();
        }

        // if we didn't decrypt anything, show the password prompt. Otherwise the content has already been replaced, no
        // need to do anything
        if (!hasDecrypted) {
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const passphrase = document.getElementById('staticrypt-password').value,
            shouldRememberPassphrase = document.getElementById('staticrypt-remember').checked;

        // decrypt and replace the whole page
        const hashedPassphrase = await cryptoEngine.hashPassphrase(passphrase, salt);
        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

        if (isDecryptionSuccessful) {
            // remember the hashedPassphrase and set its expiration if necessary
            if (isRememberEnabled && shouldRememberPassphrase) {
                window.localStorage.setItem(rememberPassphraseKey, hashedPassphrase);

                // set the expiration if the duration isn't 0 (meaning no expiration)
                if (rememberDurationInDays > 0) {
                    window.localStorage.setItem(
                        rememberExpirationKey,
                        (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                    );
                }
            }
        } else {
            alert(labelError);
        }
    });
</script>
</body>
</html>
