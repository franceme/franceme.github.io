<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #4CAF50;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #43A047;
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #76b852; /* fallback for old browsers */
            background: -webkit-linear-gradient(right, #76b852, #8DC26F);
            background: -moz-linear-gradient(right, #76b852, #8DC26F);
            background: -o-linear-gradient(right, #76b852, #8DC26F);
            background: linear-gradient(to left, #76b852, #8DC26F);
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>




<script>
    // do not remove this comment, it is used to detect the version of the script
    // STATICRYPT_VERSION: async

    const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 *
 * Mirrors the API of CryptoJS.enc.Hex
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassphrase) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassphrase
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassphrase) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassphrase(passphrase, salt) {
    // we hash the passphrase in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassphrase = await hashLegacyRound(passphrase, salt);

    hashedPassphrase = await hashSecondRound(hashedPassphrase, salt);

    return hashThirdRound(hashedPassphrase, salt);
}
exports.hashPassphrase = hashPassphrase;

/**
 * This hashes the passphrase with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(passphrase, salt) {
    return pbkdf2(passphrase, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(passphrase, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(passphrase),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassphrase, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
    const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassphrase = await cryptoEngine.hashPassphrase(password, salt);


    const encrypted = await cryptoEngine.encrypt(msg, hashedPassphrase);
    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassphrase, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassphrase
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassphrase
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassphrase,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassphrase = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassphrase, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassphrase = originalPassphrase || hashedPassphrase;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassphrase = await cryptoEngine.hashThirdRound(originalPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassphrase = await cryptoEngine.hashSecondRound(originalPassphrase, salt);
        updatedHashedPassphrase = await cryptoEngine.hashThirdRound(updatedHashedPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassphrase),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
    const decode = codec.init(cryptoEngine).decode;

    // variables to be filled when generating the file
    const encryptedMsg = '99e659ef3cc29c1bcb80ceee8693d89a7970f348781867cf78837daa1aaf080e7310644edadd89d59d18cb2ce795d229ea726064106b0899c61e43b9d7ad9cd4d632b91a8f2eec0807b7cba0f63e91a0195ffa534b47e9d1aab316b0c3e8922ce1328ce04f81e944c40f1e1022524356096d7ce29184fd3e17258ad1f3b202668d0dc90de31d144f03bc5ff3382fc261a473f69d7107e4e244920cea082efbe018e26dda4e83c5ed2f82d9e94ebf8011b1c9de0c4ab98b301d02c384ed21d79b7f60e14f250df65256144a31f7d1d4465d3ce97fb3e530771fbbb11f25287928b28a17d032197037dc2a81759b029b98ad75967afafb7b0798d67b6efefdc8b5f884a6780ce099f42e4b3df7a6224096f57d6139af513950cab07d8f6577d43cb93897e9b94f879f6cc693d796cf1ecd772f076b944634f979907bf655da4fe6d0d18e5d6ea9a577dec6867978195a7a2fc4f2eb673a164b1118373bc098439e83d0ec049e65cc9d8e607578b87e5c62ed7a690df1c8609575a64bd8da24ce664c1fc28fcb81a7b570e476bf0c50215144c18761c02a9623892b162bef39f7b3918d6a21b75e2f6b437e570bc48c2fb50ef725a31afe6c5f2dba159e7712a0f7c773df02c003df31510bfba0853b9c1279c0f35467ab6b4ade99c623d9606be2b8b0174cc0ff8c1445f5bd7d052dc509e9e417f11eab1810b82920ebe48c310e44aa800a2a08f70644ac6e4cd28cb7bc92e27a6e30759c46402a8dbdbaaed342ff9973488a32d2bb0d6261cee35dc047b8f61f0d20e18dd663f211fffec53cd36000891f41008a078c46b0d571bf589a749c0139f08ccab1e6a3a7ebb576aa41faf7f3a541d72732cc6c8af78088e4eb2a5fe81e33dcf40b91e33dd13f51945cc1a4e8d1ba65929eb4e895dc8fa4b4f41482c1986225a47e09c2e067300b9704a62a7a9377601b4dec3890502545553b7f4f0a795e31d4a759b42255ff2a7284654d4399f33bfa183c04d4473e440bf2c12360df17574d94f913123913e89728bff94054d6399710661d6d5667d2ba1457ae05f6b5a576daf15c381f06dc1ea597f12a303bae97dd070aed1bcc5f61aee069c0705e40207fc7bb8ac884bca2c4194885dedbeeb4a78eb6a7778e0427c5c29fe6cd18f7ab5f906e4fa09f30f4c63549e91bd6714cf15944d5907fcee3c8ab4d2bcd0e705ef3b7323975b8df84903991803dca61f7acca3ef087684a615d2a5d1fd995972bd69ec934fb280b25b42e4aeafbde724bcbacd6a98fd889fd1814ece754fb88809bf0cec3f34656085fc7529dbdc455697cc98b28884e1258c5b777be67db0d492fba1f93eb35a80928c00cb2e5f66d35c26b87545157ef61de54b31306afcdc73c150cc2379b59264c48b133883cbc84e0094c79be8b7fefa9dcd7eacac02dc7ffa430b2501bde4b42dc07ff4ecf20e1cd17db882a9dae81a7496b13ff56349e4d3c8e80c45b937cf0e801be3bce02334e4219fa469e8133c8969616d8618ca29f252b33846b0f8fc246d2d031057901ef770d11b9e0b4fc2add316cbd35da55e11271ecb945bb3a2aaaab004d45614091304902ce01511fc66aa2364836c7460ce433b42a4aac79a0252b7b29c75767b04c066bff7302537cd1dd50cf831a51abf62c9d07e1a4966f6cc11b4183dff6c3f5e36bcc36f9462c0fc6d3470ebf6391e385cce4e941ccf6fbaf5768c22e007efe1dde43bb006e451b0af18df6b090e77e6e239b46353f6e6bd470a40354003923870bff36330c824b6632dde4ffcb9f040473aeb71bec8cfd8349d87bd1c5eef09bdc73475d691c80ad1681c67ba38469c2054f4b6a60e95c07a7047b675f36b7c259935ac1c0dcc5d152c6ffbebb2e45940b6530008a09690d4eb54965cf7b2a71428a766eead0875245611c8d4d8ec6594921c30357e0d9f682159c03bc68b1bf49487d145b52d8a6f163f2484c46c2c071e1f3c4da39b114c0d84c8c488a55f97ba67cab93445537d932556778846aac8bec3cb7dec6b04b5e4d39d248d2d4a6028831d90a4304303889d2fe3952b1fa1ee9b5cea9bb8c29734d763377b63cbfe9f4e2ac4755d44c7ae4ac73bf9461b561e74ace44002c1773b9b8bf3e88f2569cff22b93414106b05725c2026ab6081c57aa0f16ab996ee700fe0788df8b9e5f2d985bcd2d3dde2e0150e17b3fffab54c9e04713d8c5870b1705dd9a8fac11a549554275a8cf39dd968a50b783a0aa1960a565b26c96da98787301bfac838ef794f15dcb1e015ce12a95ff069d29a12071f4a5cfb832f969bd2a7ddfe8d25ce3f985b3052b2e6c73796cd0302f73aedef3ae561176551176c2980a845e689b3555625aaedaaa8ed61bfcbe06365e5aaf9619b24252adde51aa58ef3cbf4905cc6895232a5a04282468954b2f3e4ec9938a1e4ae06c2310a0f7f07154c15efdd2bb4f893ebc580a630972c453530b01f95f098fb6b785bb0659d32fa66d27f80b07cc99955041e022dcf7b8da8ca843e87c4a7a61b3ef112cf09a3ea42e5c34b50ce58a656b9350a9e26443ad167e9e3bf43d32f1fcd61c1b17f7c7c0b8b82a984aa2c5cff86d81facd232f00636dcef1f7f9e8efb359ab6c5a05eebed86041fca498b8f801504b4367929087cca9473522320193b7d629f0e8de5825e46d1a505fa6b6e45cb38bd853ddf2e5ea65309c4253153a14a017a889f24aa6af9272a3aa1c83a6a9cc31ebdd6916cddb350f818d57c00d9722ac83a5f7387b6cd448114bd7bef97c8713cc13e5b5fe2ac28c10b9ab9652344bead0d618161fb97122032f9d5284bf9ff61545fdc16d03bc92aec10d5e46070318d304eefa8529d8a97a1168cb87f4d64011fa75b61ce4fa3d72806d71a6d08b824c8179a4fc642659c3aa2cde761417eb9973e4c8d3e659607b2db24af1fb8e5ecaf5847bfd2bf3f8094261d1165699d01cc282098c596cb6ca7970521cee5bb0fa99ec63edacd930f1e9c887ab9acf4f3770c8594a3405efe89f04dfd3238233d1d502ead3ae11f238f28b7bb888f82a5320900eb0b09888af4aace43ce0efa5416784aef257bd10848a2baa5ae5c3404d650b25acc50f422e80072d21df55b94f2b27284fb5fa6cd4b42574eb93956259934479cb9ea84bca8e803e3c5ae0d18b3c763181cee034e1b5bd6666f4680f535b4c3f23c64acffc3d1d29d2a23f6972cff27ddcb618d872da8a96ab65d72e0f46defbe0c8e483c05dc436c92a27c49eeabbca2a80d3ce1f5f5bb9e4bb7318546c693645d92434a9c622d38cf1af35b6d627df81f356dcb793d5653d44438bc602a0a27b7a905f54e7477e8a85ae489c6fc9d436be4417e660f8e24f3ca6a534c50170e65f09993fed68880a2df10ed965a2f6046a81f9c3566e03a9843e7a405d314a3e2520954fc4c25f04fda31abbcd2aa41e133dd9cc30058020cb9b04230bc1167ff33397d2825ba31e47c8e6822249a57f3e913abe4a9e20513c1d45282b063a51dde842f5e627d2a9dda367989df4efba8b451ab10678274a64b998cff0818a9576f09d6783556f17769df2f9f0a7529dae10a631fa79a38f1336a4a673499c1b75323b16c76e67e839816f90ecfbe4a09dcce321522c19ef7ee7a794d5828b55feecdd00ee1692d611ed7f915ef4e4b479ed9f20c7d0aa9ff1959473c3cbbb32f86f95499f0adb393d58722a9cc124428d728cda2687fc696b9b53866cbc679cbba25ce122dfa8c9037e29eff6b7ae233e7cfb7d014ec8be61069c371a9e48dae10d1ccf9afdc2416221c0de3d6a1bbf8cf6d3ff4a2fa0642ab0233e3575175e917fe3689853e492bb2dc2879bac01bf99d3e53f77146588f8128d6f910527207dd7fcec807090a9004445c80ae0d4e8ce93f59ecc8a22229363ca4dadd0e072838475395d392c5890cb3198d266c41c27566d6b3840ada10376a14dbb719295e82c27a61dfb5cdaca93f75eca5b62382bdbb68a13052e3ee93ae1c1d381e21e74c23a93ad2a731f60c14233ea14bdccf404b252031ad85cc4f5837955f0e9c349e141462d0aaed4b613a02c1e3e03ed5fb36ca75b219fe3e02855b46019e779fad5764398230d75a1763a3baadba5a7c29672be4434b98cb3f40020db9ed90d251070fb24e593daccdc99c1c176ca02fe5ab6b8ed802fe3049d1567c9442fa50d0206fb4786747ff9efb030ed20f7d7fd15d38adfcab4fdcb73faf72375e7c3e115b432dff6e24b6e2ca0ea0a1a58320c87f3fcd2f966bbc79f58a6db034d668937229c814f67399e0b5e3bbd972f5b63b8e4309fafda9ba470b17b09cb447069be0d80a725d03df7326adecbbdd18f1cd8d6ac2e3955054201e21c7505d40b68b0079b997c4505099657561cdb69bd48082721c8a56b941a1527e641752ea0fee6c67887ace7d4630be92d2ecc7ab110cd35bc29d011490b589296f0c2ba3a17af392063d94420aec1dd1f6028b7c01b52222f0192fd32f4a4f3de42586a45700d043a03843c621e3bdd79ace9a524b2fbde05070cfb2ecbbbc54022c70e668b014941838b1dc9ba4d49b135d73f5025526410abb6a62274251ffc64a1211498d3b18d741630277b145e21a8392318e5a2a6edb9284cbd0828dd8dbf4531880671c6a452575370b47fcb84f42563955e40b365c9cbf36fc918e5cf1afe0230c4ea2463aafa384f6f7ac80cce630495c2f70f5e1cd9eb79161bf7410ee700a02e0960821e3c5f7a99379829884dfbd61236ab7201be7f5064642c24fcfb0cfa0ef1071f7f187f7707dc39923f089fa894d55373dbc9079f9f49883932873f7f93f8fe429061e0ecc02aec20fabdf4594c7f93c0f88015967be063e32cb3faba79e744d51c394a1d1416f6e858807ae2fea6683a39652805bb490d3debc0a4d4f7ca84400f7c1213651651b1fd1d5b675f11773010dd38293586f85e64e46e01eb0f31ba8c533d9bc2d41ad3176dd1c9ddc9d9573a8eb1f881e6a486722032932d27ff5a247772e8def87b1ec54f72ef661de8257e22117cf87f876299fcbbcb32693fb4e7b06244bbe8768ce81d93747249d27ca534e367a3b1190369820ab90758ad85a00b16f1a0a0f5567dd6cf0bc9dd37e956039707d6ed83ed6c9165925d7811bda7214d0b689214d5f36c8b097f86aae6e4d4774f3f0cdc19ce1a0e9086221d14662769165e2293859d571bd10529822bfa8ac706348f28762473c9af527d79b6ff9dcc0af9fab174230a5360724d580189b7522355f39e997d9ca64a45fb4a3984b0bad7d14b2abcb8a59de01da1e6eebdef0946c000ef46a9cf3b367b0129e1647f2ab107ab8d31936235004a55c655a82294d784a234e508dc1041594d5b1b7f8532ecf45721e4c353fa2dd1ac8e3cc30c88f19169134043807a212f5f927ddfb915b19f59628a8ea1903059247292cdd0da37ec8d13d8362d3c8f5009bef65ca53f415707935727086f823fe45c2cbc3154b42c138dcd2cf85f321885b71c476f56ed0fa906582fe8b32ba72ddde6bf3db7cdba7017c0d1ddcbb616aa7516811eeda4e60e69fbfba74bc4977c76cd5127d84f15c1a0ea0883d43897ac0e5be26d6815f26d675d1f0e98dbfb36ef8ec15c096af0ca8b424b772b460a46902e5ff09cb8e3c4fa2d4316b8fc6b00689f6e99e48cdf72708f44050c5ad3a0d4da37815a658b2b1ef451fb93ff9af46d7ca27d305a71b3d73d1a7a63dac4331ebfc01f8e2346e161fe8b111601d397974d3724faac80e34eefc778886b8ac50ff6ca83789f2227f00ab61d9046f75077878fe01f2611d95ce8981d7b69ee40e4de83242838f28fb34b8b9ce8c2a533a9b3b5a67e1b6049410547ef91632e59ffd1e035b1ee2d43494497ec2611f660aab6ff6e306cf262c5cda9890126bbc287bb5ed3e32d607ddf073cc25ae52b36f39e269da3f3d0c27c8b9aeb976d878fea87b448a3090e582efeba1d750cfe26a82beda943012b813b976be16c1f23885220717e84b3a8613f8389f2178e603a1fbe1a07db8f470921ec60f9ff60f980f2fc61cd718f5383c9ddf4f7828bfa2cf24a6696a253a0205d626cc9eb99e62b75f9acdcb50a3e5011766395f592d7787faeaf5dec81feaa81b14766760a661c95cd5d889079150b7fe4824d2fe9da14a5176af10d519ceb41dff99099a95eef161d6b2bdccdbe0548c42f6623eea482a33cc19b3d957b276be78ad0c24d86e34e4bb9b8f6480c7c4cd50ce4877edda90c57632abae7d66e2edea2cb7eda7226cb8653ae8999d60b5c8b6e5326015c836cc9ec1de913f698a534a9eb1878379e63cdff89bff819049bc47da66f4841e7cb40c563fc50ce533e8e23c55b84e5ec0c1c6192b286ff47b4bdac71a484b1a29647252aacbd4f1f4a1c0156be48d3bdac423ad9c7519cc1406415bd35ed4bd8041de031da825ba557e35566274d34284ac92822c2789082636a351f79577fb144c2b084d86e66c0191f290f599c1d0b94662c60cddab302e90c65ee50dc5ca39a885ab33d2bd11ea293d7a2b537e2e46c404921f50754561b5d463c4803d12814a0178353d9446c494634c14cfb2573126c12be73c9dd53c39748bc905043566b7825df59fbd22c1ef6cc0adce75ff5e1f44ea244bdb70271a1da78a5c56ebb65251efc97ff53214143a77249217636a88a4393310b84b6a328a1555476d955f1c2bf0d808fdc28fd58e525aa75584c95e083aec527020deb9a4a7d24daa89e4d8f135dda7a56d72b4b5bba155b5426f76ace82ce881f2f6e1ece075a607d2cabf8e956563ee618e6d05370c05227269344301ca12f74dae5738524a73f52d350371089c3c0783e3d77009c2865678971dacd2ce8bf4c9f57047eaa09b7052324c27809f2d0bf2a971b85c3e15ea0065c3256de222a1cd7cf74b60b0678d7c0b19620a20acae937cd8abd0b8aa046940d725876049060216076f067b71bf84ea9c3f83a9eac2ba808adf1ba65ceb20a532e5e80d52b55b80032272d58e0c750da1dc7f62fae8309c79da9afbdc0f292fd4fa4979a01446e8710da2c370dd0f5ae3bebcb8615c20655cc9ca27820a3dada858173ba9f45404e6dfeb8ca1005829adc81e1b3c99fe417fbb2e7de0cde6589ef2a07e632d5e6bfc0dfe73c7bdd26be7886f8e4efdcd3900b2e7d9144fa70cb42d325d994502ce960e660a0e175072e0cfa777f157a72e8eca26ed9a957216ca9a292401625bb7fda7f5fa54e52a32a50b52568459ff84f00bcc31b9a0a71b3f6954eedb7c5a5513005e91421be09877c54eba98977a199e45c36820416c3cfd0a9b93d810ab9a9b648d1cc24aacebb011fa228444c56c1a6f3a5e870afa10b4bfda4a46bae3575eefe83cecd2654301e6b1ce87ff547f1b839c4e0e5a28e0836383dd0de0da956eed38178ef74dc2fcb50b10e19c2c96a008ea2248c304ea7d7eddcf32dafc5a4e8adc0911414d86b8a664aa89b7bf59870767a6725efce6724104a394e5ede9eedd4e1a81801f6f1bb95332620df8db29003264ff6d0253bb26c7d35593667fb01a6308fea367b03c8c5f088598aad0dedad89485ed846536b0d45c34b6a744d06aa51e61c9e3c0cab16b2d8e5abc0464890bb62816994552eff3cbd9c182010c36a0e43f02397bfeeff2dacb3c7c8cd4702f0b15dd84b10b1c8d20e22e5e1478cea5ef5c6a323becf3b529b5884e750c307b74280ce36cceaa41b895a5c44fea53201e9dfefd6bacfd464672c804de790e814e9319e22262331ffbdf69e5aae92dce803f82be4e9798536b90e208bd37c8f84ee2a9efd878a3fd149641a3ecb15e6bd46c2f43707b5fcc673e3085ac527e1874c34ac2a3d2e8c72d4c4023403f9e92c60e2ff1d7c95f37a0370491c03074403410c3273c9f303534eba6745c33699f5586605162acdd1a2dbe9829697f43371869e45d9d150366ecf51bcd7143efbcd6885375df38a50852f3fde58027a3aeee018ce4e5c1190d07f791b22f4f1a928abe60377e93d99d1d628727629b77c67b9ade34672107bcf34cbde760b296b6290572a98c1e7e1024f067971fe3a771977a00c31de7ae4a0f6ea67e1da448992e608880ad79cb45c44f3f9e3fb21ca0fd85b22de0926956e75dedc4d87c185a7acd3242b1ef42d71e40165ee2633c5a8fecfe98734d3b9f4eff602b81d9b683495a2bfc144e908ae388538431722baa8e77bcba19a3826cc8ac81b2792915720d8a3dc994a816c2db6315b1809c15b794b0cc2c8e96511a03d711b94277ade1ac3b34f2cb4da491ac59753f33c63f610084bf12f9941d056e74736635aa2bf2f016a8c90e715437a85d8367742a8b0a4ed807048a57be30c9ef1de11827d610362462b52a726a9ac625df86ed14df767d75ede1fda350227de5dde98934b5e0c0de505d35ec59e6d6fb4e5c38f902f564756c4c3249c3b247feeb68c7f8bf030b37f12b5ae8016e0effaaf9b6e4737c2cc32a871fb7b2595a9467dbaecb61df1be4b5b7e19e82d14fc41a23c53548227c2314b08f9bd363ea7bea297c5b16807aa958d8c55ccd80238df9c75e288b29246855613430fe9daf970c5f9f0cfddd6337c48665e7b92d64995b071083863ddceaea5d91c9b62065f8a03e50e58629e1430b3f3d084349eb9cdd77079b077d81d558112d98443a29bc35fee6ed09cb799188ed02fbd5fe59662b7239d498e166ce6b69b8545e15054d7539cea89c6dd03823b4ff14c66e955f95db1cd2b9ecaf1541bc6f1c21fa6e7bd4bbde4ca6ecf7e804fc1d8634c408bd8c0f6d79d0151ec790e1cc2979ea326b25ffc6325175bd3110981fb3ea6b1d087763301f63faec11e8b6669ccd6b3ef5ed7abfd927765474ba3b34c9d4fff8b0f09a185da8d15f4c4ff3605de3a0df935401a9aa1abd320c68efb86662c777004fc07b97c8e4c7f3d7a345b94a5f825bd5eb7fe663cb54857f6bbd69301960626c822ef5e5a5bddcac2e8a3e2c30cf5d6537fc44079b77910e6c68f4d2db83f779e138367d6a8d97234570d46659c0a53371736c6ccd544318c8789282b9a7098159958097a2b4486a42a2e67070ed3408ccd469ff4da071e1238e5e8e0038b3a46b1f403fb96303d402ebba563699b7cbccec3ea7e9b2770bcff7a4d4ed3e7de0ec3e099dddd2d56ab8ee69c6f141f9e70c0aa4c11130906f8857b45dd676db5aa1d4542711b1e78dd26ae666489bfe9ae3d159de43bc3595dac0a70e5a877a1755e19b6da8571cadc2ad2005dea5a80dd9736ecca96fae52eaf14a6b653137e7de8a568f1177473b3909719587cbea411f649c3920107bc1767551eee5b423c71c34586e0815c1f18e07d1ebc12e6ddd4e3686a298be326079b3af66bfd6fcb5ef303409d6418dfa109ae40522e9976f8c00e2559f9356c1316f94f33f42a729e665c4ccf8fc57bb0846508259ea1e78284abdf1e855f80fe74c34d8c7f088e2eb954cce37524b9e2b5a83c40172e222d221b22650c95e26d797a6def4aca3136ac751aa810c95342962046d49e49dae90c5a72aef814b331c1ddeef16208c94a1c7130a6a38cd286e96ef8f06cec3d4129d8df7653add36fbfd7fe185853f6bdcfbe6d9baaf0474377055aea0ebf31606061db237525d281691c7942a4c8a8a8e50d9a04fcf230aaefa7cc25309722e8a3ac7d1475c947f8be99370614eb03ecd8afeffd4462722f628aab74d319e3917c0a95d08df4cc2331637fd8fe68aefe8c5d0405ba62ae615561cdc507554faa9c33be3badf7644c1a5e2ae0a631edb9829dfaa6e4151a469689662121cbe114f5f4ed4fdd17035a2a7cda43426e5af30da3aa8f649e21341e4b0cb3c2e59ec75dc88fe59b31e832f82099d19e5158a417b7accc7cc15d5ed779110f8182b275da36bbad2f617e9cc30cf9cc81962cdbcb507c1eebb9a3ff8e9cb22e2d9af6edfc23251bf7db1c24f4823ea0012b71a6ce8e0218ed0daa8dd64be9a3021e0cb9d77ef35968d27f4c2ef89d3e2cc6d2edb94a36e67e281634cd65beecce275cd99883a1f467812c745fc6b541a132c1503387b3dfc46177e9ffaa082fd55f613f2503c3b8d3f88b6ca4a4b48949b4a83c58242735af03857a3758ac0e57b82027ceec1406075d3851a7667785bc26275a2f28eaa8e8203a7cb2b0b7776b333c36b8f07ca7f6da91390539f4e0d29e861c04fba7065e72611c208f478d43dc3a52ff0a4608e918eb130f6542d9e2863e36605ea7c8459b9ab66bba30193f1ff045604788cbc86e6cfe5ff2f1b96f712049ddf7a7eaea2fdcb4c641a88b0affb6bcab16315958c63ef52d230822dd60633ad6e4ec238d112466962037e8b76e85fb1f140aa138e56659678ed1fca75613bd2426ea3d8a6f5d8e49e513dff9f34538d3c25a5a7cd44f4592bad47513a92433f0c7b50975f6a6b9177c139a815419c2407beffcb2668b78924c0802bcd2fa64c838b375c026960e547d8fd1b8324acc2ea251bb22a659c8e692565e5abc53d34590a70f555c523fddf2c78a6cef062962f33f333637a7535e59361a9da0c3658d6f93ad41487a2ed86c9fb5ebc02227ba673ba74f11dfac9c6d62f593b18f6de0b566d98b218ed549cd3401d635dcbc9d10ef5c07a46f0dd3e436b990750309220442f33bd714af271872eba37a64e476fed8a2ba771adad1b5d27263936956569a09d4605128c1b758373ffa737679f0328559441f76f2bd7af97773af192760feea18516f506270377adc55711b9b1f3dc74321695a10fb4673aad743eb91af4cbb7eb27c3c404e03ae6309dd93e7ac3cb8b640aa78764c31d7a2e13cff1f3273279fec9d32efca16f9d22ea46939b6b4c207649268bbde89773a0c692793c563b248d4b49b4c41772f34fb06ed29fd3d0a0d1a435a2268cfced3d8d31bbe5ff4d42f03d16454de9cafe0deb3efa076c8907aa415641800b13e6a73e55ee7c54cc18924e9e5d2c4befa96443b78c3b70266f275fbd7c00c54671d4f945907cb9cc44307959ed423819ee28bfcb40ab027a7b2448128064c961db02142dcd0a6ce1032b608bd5f8fa913bf872f28e54d30393775c286959447cfc46944034c5e0c510423b4b073c042759cf0d656e412d1eb6d0ca3f4bb37aa76fa44b6d335ec7346799f6644110434114a4eeec3a1aae159d98a584b58a22557c6838a5bb0dd1f884c58de0f503eeeeb852707af675121ee323680b5e66a36550cfe978bce985042547cf6c945824c8184fb10f94943624687b59baf7a0cd54d71622521857e9eed9cdb29a7de9028d833e20be4fafca7d3a1184471747315e96b2192220359fbf6e5bc7d2cdcc7b3d495f6c0f0616e1bb05e6701f0feb66f72ac03e790128e1a04bf8db8fb4f860971e925dcc50db43b3bb5925aacb19628a9390dc0e780f54b9a8544cc6f2eadea9a96e114d8dcb89b17ea2ecfbc71bd43096116a4b13c9290fcb825469d5942281c2370ca20c250daf3ae541a280fdd8c52b74b2f4d8183944d546362344192d4fa1e6edfef1c464cc43314c6e7da57512e1f699beb60ede846e6c2750cae1a6e5542646b121868d5d85eb9e328bdda76379a948c301f8efc181728b2c1ca7cc306e03dc6913f450af7c9057ef3ca52921f37381e7c9e783ffee688cbe0dcf90fa2d2f829ed2c55821830f6497f521f998b820a36a8971aaf58293afec5cc94bc1a9d06484fc8fca40a30631e88d2cb112ed73d9a6dca373db819fb4daacae3da49f6351cb5815597e80de11a36ab6eab8335230abec3c46f6b896d7a33c92f7c09a3f00aacbeb1c60aa604535155670e5219c963e642e55ceb5235ffe6057bf2e42f330088b35ff1a785af0fb11451bb1867d26fc46db3044211f401a7e36d85a3ad499cfb5ca16287436f62e0afe449775a01ad9595478d3cb662328f58f42c3ed102e47510de30ad15c0d95d6cd7a3591efb608a2a181676c03270f7cf343ed9a166497e8f9631dab530c2a696d1a521937f8c1c951926bb7d1525960b79cd74710ebc35ad0c067c29131bc24bebfbea638676fe490cac5b20ec40d2ce969f5ed7fab9a48ec4f1ff9e847a74ebba3ed08741c3fd9174fb222ef25b6f5991fdb7f1af7fd0fd5e12c15e5d2c9773404846feb1a7a3bce30cb8621602100d25a4dc28bae8ee384dadb27f6546b4d5e1aa5488129cc213e211c7b2133546bbff2cf9f8aba9daee5e4a6f554bd5d8f7509c26236e4e559dbc3dd445b4856eb8e690d6cbd067942cb60f037c2ce8b1d5e462224e17e793cdb142fdf7a46b856095d3f81f0c7b7ce0d5c837830e39f0777861a8cbc4e021e9871fe51d38cb5a17b8c3c3ea24bd388bd317c71d7cf3f4e8f3c146e090ad849ec7d27b6032437481710a39e6572f989ae7e51b16b13b1eef5be22203ea1a05b067ba97ae6dffc57d19ea1d214f8d5f87a3e78910353e7e6005e25f4218380c8a60e1c51c0a473d81b86219c2d97b49935',
        salt = 'aa2a7865cc430097c169fe8f6552e7a3',
        labelError = 'Bad password!',
        isRememberEnabled = false,
        rememberDurationInDays = 0; // 0 means forever

    // constants
    const rememberPassphraseKey = 'staticrypt_passphrase',
        rememberExpirationKey = 'staticrypt_expiration';

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param  hashedPassphrase
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassphrase) {
        const result = await decode(encryptedMsg, hashedPassphrase, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        document.write(plainHTML);
        document.close();
        return true;
    }

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        localStorage.removeItem(rememberPassphraseKey);
        localStorage.removeItem(rememberExpirationKey);
    }

    /**
     * Clear storage if we are logging out
     *
     * @returns  - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        if (!isRememberEnabled) {
            return false;
        }

        // show the remember me checkbox
        document.getElementById('staticrypt-remember-label').classList.remove('hidden');

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassphrase = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassphrase) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPassphraseQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPassphraseFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassphrase = hashedPassphraseFragment || hashedPassphraseQuery;

        if (hashedPassphrase) {
            return decryptAndReplaceHtml(hashedPassphrase);
        }

        return false;
    }

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        let hasDecrypted = await decryptOnLoadFromUrl();

        if (!hasDecrypted) {
            hasDecrypted = await decryptOnLoadFromRememberMe();
        }

        // if we didn't decrypt anything, show the password prompt. Otherwise the content has already been replaced, no
        // need to do anything
        if (!hasDecrypted) {
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const passphrase = document.getElementById('staticrypt-password').value,
            shouldRememberPassphrase = document.getElementById('staticrypt-remember').checked;

        // decrypt and replace the whole page
        const hashedPassphrase = await cryptoEngine.hashPassphrase(passphrase, salt);
        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

        if (isDecryptionSuccessful) {
            // remember the hashedPassphrase and set its expiration if necessary
            if (isRememberEnabled && shouldRememberPassphrase) {
                window.localStorage.setItem(rememberPassphraseKey, hashedPassphrase);

                // set the expiration if the duration isn't 0 (meaning no expiration)
                if (rememberDurationInDays > 0) {
                    window.localStorage.setItem(
                        rememberExpirationKey,
                        (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                    );
                }
            }
        } else {
            alert(labelError);
        }
    });
</script>
</body>
</html>
