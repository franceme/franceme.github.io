<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #4CAF50;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #43A047;
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #76b852; /* fallback for old browsers */
            background: -webkit-linear-gradient(right, #76b852, #8DC26F);
            background: -moz-linear-gradient(right, #76b852, #8DC26F);
            background: -o-linear-gradient(right, #76b852, #8DC26F);
            background: linear-gradient(to left, #76b852, #8DC26F);
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>




<script>
    // do not remove this comment, it is used to detect the version of the script
    // STATICRYPT_VERSION: async

    const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 *
 * Mirrors the API of CryptoJS.enc.Hex
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassphrase) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassphrase
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassphrase) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassphrase(passphrase, salt) {
    // we hash the passphrase in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassphrase = await hashLegacyRound(passphrase, salt);

    hashedPassphrase = await hashSecondRound(hashedPassphrase, salt);

    return hashThirdRound(hashedPassphrase, salt);
}
exports.hashPassphrase = hashPassphrase;

/**
 * This hashes the passphrase with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(passphrase, salt) {
    return pbkdf2(passphrase, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(passphrase, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(passphrase),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassphrase, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
    const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassphrase = await cryptoEngine.hashPassphrase(password, salt);


    const encrypted = await cryptoEngine.encrypt(msg, hashedPassphrase);
    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassphrase, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassphrase
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassphrase
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassphrase,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassphrase = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassphrase, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassphrase = originalPassphrase || hashedPassphrase;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassphrase = await cryptoEngine.hashThirdRound(originalPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassphrase = await cryptoEngine.hashSecondRound(originalPassphrase, salt);
        updatedHashedPassphrase = await cryptoEngine.hashThirdRound(updatedHashedPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassphrase),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
    const decode = codec.init(cryptoEngine).decode;

    // variables to be filled when generating the file
    const encryptedMsg = '04cd72c862d8aff3efdc7417f13a45efbaab900abf3c618dd75196b7d1fc7cef4ac312b07c295c8d632111a6fb62a650bed0cc2ab2da2a993bb02e95c876653edcd9bb770f1568e9dd71b16fc737f3578ca55d7b300e82a838678e498e791d1bd3ca6688d2eba4d75f838d355abde6e17b8b584012093271f9cc00ec0590cf4fdd7921d96b20a4822122e2b2a71b00eb6f18e809fccb5ad7d571c52c70a87f79e62190f86f634caf4e3cadc350271f74317b194fd45de1911d86b4d8e43b0c8a1890d0ec0fdcdba01f5434a26e55f6c8603099ad0baa9ff382b34ea784ad767c52497249f301cdc42bfdfd15abe46192de2b2319b23069f79667227f506188f21b2841a98f912c9e2afdf20e8082cce8ef3f9299425d837b795a513df7e4c65654e62e8f360515c2887e4632766535069c633e16325c5c0c4474fa08db9da5d0884a55f4f1f646dec3e23724fd4c821befc43f0881c3e8d7cdf2d9154b7587c638bd4323925e3009425957bdf74f1be15a844d7863e6360ed8af52224791ed30cdffe392de0380c5e46060b454ebc685e7acef3ba54756d6536c1f08754b776678b467389d75075ea3bcc102f9de04f27b67dd2c53ff5fbd8b54dfe956e184cc76f2334a8c7e6316d39dc44505322c7090782e1a24aa853b5eec7ba486674bb5ed756ae2aad85fb57cf60a236cd4588d07c84335d27be1af6d89f407a672e72ab0d1b0321f4f7cb3b2e3821d5300ee9dada4321f7ae65eb0b91e98cfc55ea71a518f62c87ba5d9e0a0d6589e37a5b60683c8e8cb61088a4563b3cc6f50841f2d1058a6b26992b925ae0592d2f270d6324537ef3276ccdfe419769f38bb009eaf77e977e0236518ba74de6f30bf36699e1e5170e0158ab92675450daeed2e15ba477028f2a4059156e51016f3483a4599c5f2cd869f348c59e1ee35956b44fad3832a24513eb002a6b9c4036370b28ba10096284875c3e5db0be5df1f4744fa7e90807467913f57c999bc2040fff3004330499dd3eb412324061e10f28527c3e759a8de0401f8b7ea6bfea56c516971b911ccdb6b8be39f27ac67269e6c990cef8d10bb2c9580be8b0aa2cfdb2825652aba5c3bfce6ec1bef55325386eac25e1c206701331aa71c231de45008e087f65c7630f243f6f0d7940f2b51b0bacf6c43b95102a9873099533732f42fb8e429aa9de9bd3fb1491ded52500617e07a8aa0a3e84f7ec24a75591ac3419473aebb9a2f7d2ea95b0823baf3f332e2d0f9dbb9f246110b7de57b8c0c20344e8733ba3f4093221cce88770821866676eb32ad9db3b815e5c21885f035e6af294a731e05768379811d246d6b76f43456884e32e44d72b354a71c32c655c54a6eb56732920ec9fff81e59cd26d8c265d59d4b06f678abea526a55b98cdc26011af157300352fc724b2ee3673dc027f065fd21472b33ac53654524a2e58bc7003a712771939b0166a5c039326358e8a6ce2a902dfe8c2a79b7b7b06398b120dcc718685fba7a637687af762543aba85d64b9ab8b5f83c980ab0ed63c61a8b9a1d1888ace3545ebc36100d93a1a3f147a3faa93906e96e73a2b41b01641ef39eb1dff71f63463be0da9a21ab3cc69fd3d5a844db32694a9e61bd2ce4775ecccad06d7c596deefc8936c0368dfb7c920eb5f41c54bb25a53d125653f2546bfa3981d0239dc3f1ca2e5cd9910c53980ed2244f1684571699878a57214e476b8f9b567f6aad68b95d391bfb24d56ba4b2d31fa1a25cce02c77ea77ae43db82644d24183070e1584327f04535f43866fec13fb0b09b29e3376a147c194e07d819502c14d86cc1e1bcd4605b8028e54d2ae126d77f4dab0cc4e5251b657ac2770a4ab59af897b31e2bc5f800082ea36a04f7cf77c171ffcb2efdbbf705cb0eeba93cfab53c82f0811f60f31b3abe9918673c0416bd316e82e8f4f1d3767918a1a7932d1211fe1063dc031879fff47279c970e9ae0a4c02359e6c97569598fec8267275ca429f33957763ba4c56abad8f03c4f715aa96b57f295d1cc3074f93ab7aa3036f38c435aa53808fe02d5dcf9912456e502a74a1e96d5161d04b47cdab6ce58b912d7c5174a961efa6fdbf190bd92bee1b73546f96f887367f2f2a5d9afd6c6a336dc4548ce4fd15d0acb843ce91bcf1352721c45f329c114f2027081de7549c435f7725135720462a13b7ebcb239d6669de92c668a0a718a201e30625d288ae49fcf71ccd3f9fab9a2691743a0684874f65fe0352eedfeefcb6d0dc650db93720350f8d343b065ab1ecb82a8140743bda7383b95f41fb0fe50607f6f9fbaba90bb67bbfca337a8589991dfa7b6cc4439f1e12abeba740e840d9103921f700f0719601606e2acf555c21f1175c630a3909a391b34e0f518454d2d2b81cf677aa202ba8939b8f9e609bf9d24e287ab7478fdec31dcf29e3a9173b33e82157efdde242d00a92ebcefa422cffe7b6adf349cb36db473803c7aa8f16b470206a193597b5881b38c0c672d81be2849d6875a42b58165c1900275ef85ccd5c07efd3df412b2bb005143f8234ee6afa7e6a75ed88329224ab7a5646147d9653f5894af975a767050d86c00f099747b288c5e935028cbdced991452052962a1691793d90292ca70d5094e944b3422646129a16779b421b5d96269df962c378ac87ad43642c000d47beeafb73cfc8f7fba7d83a037860d323d5a817cde68b56368335d970511742053f70ef1caa42b57b3a5a11ed5ff2ebe1fa14ad71a7d14d5925046491a987024e696fc9e6494e5e8293f687aadf30d70ef8ee008b81a4b10f73cba763fcf40866894769a2a05791cdd6064dba2e906a688dff8645cfe77597eb6d29917b5cb09eee791d0e31811d364b0837b5fdf979a3bf0db8dca3617499a5edc4f902408f27002a832df5594efd47e2b75ba0848dbf96b7f7d886a25fb21a88fa0f2a5e6e1d748f47e5d72679a5a0f7436a4a4f470a7f02636399d29c5a87476bf1bc79cacd73a9a2cd4d19c4c504f66963ee5dd5f6ae52dcc5d5e49246f7e25cc242a0f1cb37f2194e07da228c47222c904ac5b4011c5827e6ef3feb1d14bbe11ddca49d4db14de51a90f6284973d23ef36b249147b7fc6140ec93598f4b3b4d217dce460c3791416208db85f5f5c390d9c42f4db3dbdce5ec26d32e06a1a92de7003244dd6c2c34fef6994440fdcbe9461da81183761a248c17157c1596e8599cc6ba547a543069f30202c590c49637b18138fb808cd5b83ac1c5469850df8b04d66dd5cc021610cbf10898bbb94f6470ac283a95326f81bf14aff80383627bdc0879ab77b9efde4811b60ccd3eb0cf6fa9a125300e673df4804647acbef5e08ff667fc064ec9460f62d3265315fad7ef3f86da60fd121e17fff4cea082edf7e6e2dea198543788f7ed72c8042715763bf0ce632ce2a177ed71827960df59b19a1fac237b28006b4275032d30d112ff57c351e4355a3878c419ecb6648456278892912c9091876cc08d4a46316a97710bb935f6150ff4920df4508122757d44a3c30e5ffb011af69685cde5c316fbb35a6abc3d26bad441bc0304e8713562d961b81e9b77e9e1f0a6391933fa29c4b660e53471b358fb6a2031707788f178dbd08ba3da6e2544478ae027dffa44ff7ddd4f973cbc76a5b59a4f13dca4f9868dcd1463fac57672b8236f8f37753a7e647d7f9df1b17d61a37e9a65caff34e6deb03057e0942ed62eeb273438de337742fa625cd56ac23a5f58c47024492ceca2b84305c4868634cfa2132bfd2fd7b1355a325fe39393db15087de88e0c38e9e19269b5f6d386d8233b7535925513b12b3a0bc5f35e987c1a700652920e2d03bf44225718d445c1ae862ece41ea714accd20b2bf12cb5b4760d943276a6bdf87fa5a001e0f6b964af9ba61e73a0f8f5b757cfbee6e44d65165d510919949ca50a5e1f1b0dc877e6f4d37b834f3acfa879a9bb0526705c3c4ecd9114390411a3afa393511c200d2d96ba2e0db9fb2d61918bfad1356c902a3b0a1214d8db0348245fa455599692edc824b9e4baeac4a99fff482b247760930dffca68d235657f4f8ca2624c7c58a3b54dec229a894d59b581da3a24865f3ada538b6defe7683248b09e23e148a9f7466f9b65a88ff3a554e4e233ae5dd369065549b04c4cde29a880ca940c63ad0cca70e5c7360fd967c9f8d51c0713ee066d51b8ee4f4ef16d03336e76884da2230b881a8561f0cdcf21afb12ec14c80b5051243993105087db28a75da3f4d48faddec7a2df6492c16e90895d712a798142a974d5b54d3d7494f459bddcfacd336dd94748d7a69e37a429645b42f4d2a548a45374dffe48a8936f8e95d9ecb763e6061e1ad8f95724cb696e1563580ce38f71466acc2d3aabb401719a47eee192e39a09cd442062e84a60f136c6ae80a983ce4879382f0346a30861155b3cfc692522d0b478e3637a2d0d9a954416557925615f8a4230d09abf5e538e2fd6d928b56cefa5d789c1200dd9399499ba5628f6a6d909979974ac838a69b254e29b13a53cbcb64547403f6cf1f2553b4734444ab5928fa153d39416031c0d54990002c68ddcba167ab7391e989fbabc5975d00abef8e61cab4d2c78f0fb3b479326cc81a821eb173b027f59b1d5ad762dd5ba2d65212c1695ed33e8084cb87c9e7b521c2b58166afc0be25460e64d00a2c33125c8dd3aab33ac39ddea4cec9685c3c11120ee0022cd4cd2289bcb338e277db01d96bc12980dad10e3d68e94eecd736fb8624f74213d397467fefb15783e094594cac48b672974f476fb9fe02f5cbe9b3c82d68ce24f4352c58c05e7a5ecc266ed88cd35f352195434280f2f001d0d4793cdeaf88604f10b1396b92f049326cbcfaa21dbb4ee3ec1403121cc7c8a3cdf70197212218dfa05018cff11a5f94e7de96bcc824c8ee25daa6b01f9ffce9dfa0d4597a0979f6076c9aa5e220805c3882b6f30b28cf8aac2bdab10bf5c25a0c76722b76d7be1e08635f4d32686c9e0beab66c34a9c22fa977afa8e2443795887763fe6c0a2fd3bf3a994f5686331ad863776010fa0095f2d2f8de5c65354fe72707d6a0cfb44f79c17e1c0d215f243f9b2de841662d8761d45418510d737a3faaa063e1bd48f2b6526a38a05c7e5eef53b7a7a52cd03648637a67bf2b3dfb412a160750e84dfcab3194be54ffc4e8d340109f5d2d7f97f04cb4dae06b901b657342f2632b444a1669f81a6615b4bc47f9f1330614ca6d12768e6270c9853414115cda69483e0066445ae3ab184c33eb3b4bbaeed9648817ae0253b0c8788ef92c18ab629d76365715de0d7fd2f45697dcd5188e3e5cc0e48f64327d3b26efa2949cc06ba864c37c79576d40540e06a8870464ef90b12fbe931619da1766dccd0b829870ea9c0329d878d5712d6bf5d667e7312a3db87ee21032cfe7fafdf51c4f69eb4d614c14e23c66dc1ae66ae35c8158f7c289b9dcb6f5a01c199b5e0fb52d630d9e16fa4ed852b9ef7d0fc7e73314360ee84a7626885fdbe91c269f8c1c0db39f32a5527b9c9fe1ed5253e17ef836747e07fe3011eea0d1f6a422eb7f669ef0d03f75587116936a120b56105925484c0bc3103f78ee42ec6fe287704422c5fa184916232d7f9d2dee6a884c761d72933ce5577f126fa16a2fe1ba85e6f4fd362ceac3b9b6d4af72a52249816cd7b6cb44310996f21bff7cd51d2224ed590f998feda14c49da076f09050c01c373750f33deabd227947ea0181cd91982632291d5e15dffb371bf5b65f0da2037df93ecbf2623c24ff5a30d1919cd456156bf642d507a9167ed722f18f4bbda8a378037ead84f4afe45c1ce6721d24ba230b18e9a169d9f45a03ee63fc8656a320e0ecff5b3d11104fc6dfe64d5903567753fb1bbd58b4c5078d44958f4cc0d945944ef215f35c51ac980687d98623c2f8d54ab5ca018c2c349785ea36a3ffbd5649ca19d0bd3ebce4321368a9b31a97a102746be9ed5446e0646cc700fbb1dc2fee865a873ec173c4f3ceb423ea508a053a0ff7c0f6168bfa9afe8ada5886a1e0dea01f2d2e5755d4eaa7c8aee8acb09a0a34378e9e3939b8ad293b00b9475d60d14956cd91a759a82682f84fad2e696eb2936b80c54cff1345a5a84814f43d09edc3d80bfcd11bdfbb55d187cc34dae4d2c0d91530f802a296e0cf5579b48751f10cf52e32f3db536f2db093dc4fc81fc05a2fdbf37aa769818466ab592d85421a9e83b59924fabf9684cfcdc5dab7410c477e17525512eecaca2d27e865e4614689ff09889285a5a2e42b47c5836890dd2f20b9e6cd5b6937937854597778eef47a716a42c2e29af5a0f0fae1b78bcd0d5bb236981ea10bc3e736c748f3e0f45fe5bcd5404aef26302400aee8f50659409921b2620342f6f9be64c6a5bda92002a5c9216e3d2e5eae52211b19fd0e052703c49cf9aa0556cc5e4b96ef2c4406520d7254a2791ff1a6872bfc676b9ab0dded4820e172105d8573ce6a4238272d130ae9eb593fa95ac9b7465b6a6d630bb583d81b556e30e8cedff080218f57b1e81e3ff795a4b14c20442769d526bcffce7f5c350fc9dbb54246d2f0694be4431c37001ffd4c754fe750c9e2f6a442906b25ed1f63d30ca23810068cf3c08589086cddd751e77ea9aaec323ac1452163618d5cda4d55ee0f7ab8ca2c92ce396872da9bbc1172c192081e26161c8ab555d564bbdf9ce0925a2b5c2129aecb69e830e43ebd1cfa9dffe13de2f88c5d1dbfdd291400ce4734d55e6edf69e96b6c4c5ff635631cb732b73bfdc9648dce94a14d9099dbfb19f0d16ce35ffe90fdc8fd41a115d3de63306788c5853bb8320700c58363dc513401f9f750a6f58436e1b65e3169db219875b436261822239c4fa7d34f1a29526dfd9cfc84a7fae71244b5b3512ab3bd90c7fc98419a74ce608bd055f3b3f6bd06cf92c1769949e5feb01f9896089526e948c5533351dfbbc821bd00da1ce61cc41ac57b7bb6cb2c80024fff9cbd16b29abb16d17cbc3e70f2675645ccb102bea484c7e5d31f98d29b2f3d6faa295b02c1c927ca6db68a4863de3adf409a2a31b19bf508792d5dff365ff006f0eaef1eeac1b329d19de14aedd792a698e4dece5415976bfeffe80bea02ac5e895883a6473c02148eccae8fd26ce84b946a1b6a7b8ab10a4ea38301d7f1d6a8d9857117243bb3eba5b820c49e1da8fc02aeb83a57b7fbfcc1a89ffddb3df3525593693442fad746f0339366fd42872f03668e343ed13785bfeb27ae91b2b4e50f1a9ebbaf41f395f2e93dc41fe86c4b191d742a75ac8c0a41348f610e8a980f743ba7209e78a71e57537b3e253ff0541c5da57cef37d3d32d63dedfc4a432d5f4aa8e1aa2ccf39f5639bc18e3aba827412d926a1bdd7b6f2ae791dd5d7add117154c1893847a7a06acfbd52bb20e3693cbc3cb6f4aaa82721d43efe76467514c0a5249592daaae028ebb6958143416066e933db2cb3b44c98e7008cf2c5d1d6d379380ca0259511f8d20dfe57332b99f4f47fcada83ae2306a0c6683cfb21019952342201d76ba569ab36bcac78de26b41c613637a41f475766e7de818d7961c0a1c9bf3d0ab195788b5993ff5d1625b8b3c1c69dd29440ed3925b74b6e8419d7c724d50da121aea1e387f070780943eaef0a442e9dbfdd911e1da25748a302b377463d1c16b6a4d120a1da464563759f29a6fc348bedeae08c711307da7fc48d9f51afaab4a5e349dc2b06a501dcd7f74085311cf4be42b6cfb8e07358f447f688d2a06cb2e95387625ab770e90916c34913befd2541b8989534fc896dc8b63729867b4404e1968bac6f9989a25129c7a24cdcb1fb1b9aeaef806ccce2beee36ba271ebde9be6c7364d44e781839a771c2d49724462b85211555b9bbe040fa98a21d98bf3d9878e9709f4f0d79007231e9cd767593140caffd80c73c02b5de056d57c94961cf8f1a812096eb5840e85ccde4c5db641da38ba32c758cd82c1eba68d3cf816bf123b5e88f0ca89a17260afdd1b3f20a8ebec2e5eb39cc320b712fe0175f63207b6a119209a5b10df38584bfdc7b418f4becc4f372167df6e2421ff33978dee5a5d2389528f00d4bb77f581a04b04a27b93f9d1a13ca950c9f9ae223a0349ea529001b020fd75ae01d924dd1129e9022c4756863ad4ea047153a37cc4acbbadfbe37456becb5055231d0d0681f9ce667cca546ed31c665375b52f591a7beb7dd2ceae56e4a4b8ec068ffcd7c22fe46848717f1bf9daf21b300cbf35592faad8f7c01c04ed50e4a0a9d31afbbaada348253762922ea4f8a0f4a3e6918fcd52510ddfcf57b27967fe9aafd3d5166ce3c3add46a488674f3ea6e16e91186fce635c1d2c7071d367122c29c4dacd1b7326cd6ba0f688dcb4a9414ccbfc3f3517f4d70fffc5338d18007a4022c61cc80113d7b0d8b5c70aaac37b5dee0a18823c0f029456417783fe72de07a9c6ca5caa1a34bbca3ee10c856b84028f6d534778b367a3db8d70c131d6e4f751e2e96b3efedc89a9161c12700e96522f7a7e77973c86716e7365205b99964d7b23fece66fdc1ccf3b61c238c2acb04a58c2c9a4744e2f32afc3361a03c1d990e2e9b1f7ee9e48254a9d8f240713f95506921d77834db3ca39b883b651b6bd902dd3f4fb74324f74fd06c66326afe28f7462813bfc070d4d8477f62412b475a5febf1c381e5b837f0bd4c223326c45862c2876f33236f037d901fc6cf62a87a2a4c23e172f202bc2ed0aa23cd06db89b42b2acdfd68d5b5a83ab44e87925def46067c3da539ba6876f0d84d3c54ba2e2c9665de9154aaedf3becb54cf6535a9714c5f61d8d60124a51ddfd566cf3ba6cf832d4c8ec9731e8f801f8ac561ad8dfcf6bba181df315d3ac779cd57aa92445da2822ccb6f75cf31a046be449531e1d55d7e719c8fea8b3ee2edd8e6486a7d931bef746f88e4d235c5090411c08d8d1f0a41774e8d6b53b4ad34ed6e26aed885ac929e4451ca78cc8a275e8c703e812c6b77b31638a3b878c3159ab862f0cbea3a896d156e5b265aab3f2a4ee9f989f2aa5a9602573c972430adc8e93b216790f23bfe31e99d6cd8e4f6981e1c27bc44147ee3f8959d77ead4c3cd71a54be85f7f5fa7648ff199a2ef96df1f61fa27f3373e4b89b688ff999edc7d987ab8c25ed85a1ddbb795b74c10b570d5da5195de2bf90ced306481952c7f47e963dd818be18efb5e229637966e45d32dbf3d052aaa76bff524273512730b65ad52880c5907280c0f41362a7d3f9bbe3fb46f27885fd6b7502ae585a4e2feb00a983816c739c59a38db412921b66b4984e1d558274cef7076fb67487be3bb8b6aaa06fc17e41c6129fc9f80d9947a25a9672344190b88be257f4c524aaaca57107c8fb19c70d604e106eea66d6865b947a5be4175c6296a7185b82e358287949a9ce3aafa06d36780e02c8cb2f40e65c0a8f6a20dc9ea025410d37e57cdbee5c1e8aae0f1497bda23f61b25d0367b9e0d6025802959460f2f071e72f84aa19ee83cf5a23c50159d3093eac44e81ba19b3505887ee9462b984cd4840be3dd4b5bd48b46726ac0625a451b24b5ee219d02f486ffad6a00f675b3bfb2b3f5f995a38080232a42b3ad58899348a35b5d456c7fc16de0132b2d1485929f3434309f23e41d3a835a4d5cd05658d4b93de0cd5f141bdb98e1ec9d3823c596c771fa4c6cd3dd346062895ee0c874e479c17b374bb1a9ec1d071c685a1ed342734cadbaede3afc0be7beada7fcc2fb0c480ff7b2a39064f2483cef6382c8ca9f8943db646002891c64d3a4ef4dfc3f0fd5dbb1782179f87c984aedeb9ccbda684eef388895ac335d00038c8594a775f44ebd74b4050731748c8b6d5d261a2f7c49b53cec1d0a2d8e73fc8ca64a6d356fb4eade056bc228210df108f32dea47041b9395c9975dfa51b4b5f3ffdff4d4632648f48e5f27263eda1e58f1f842ba88e38dc7f46a98753dfaa34114cb384d9476bafe8c70d64dfd3abecd132a23aa22c4afced32c26992482c1ee09d2a317ae11bdb0b20fb863d90e290ffa02c54b002f70f9d6291e12eba75c4a4b6afbd882809121be7091cf9d94712b7d5ba0425e1d676e7831a0da1a6f1675e8f53bbbacdbe5f096745c48579c18c94b59dc3b6f830135c4bd9a2a1cc35c69ad8a6b74f56cfa97f96b0df94eef83a3c03d4907e2805bc0f4cc9b12ebb509e6d7ac787311557aa1d864b6c23693c67c3b05e1b139fcdf0db761dace07ae2d03fd582ce17b14393a180087a529fd69624082710697130c143499bac7c7967ac00dddd68329f5609b82bbf334b00bcac813b3133388a4e34532ccf31f67d542ea963e5779eecd11a1a1a52f347023fcf86f05f9bd7563c9b05f93a39b5360da78bbd194309981e6af3b785a862ec12bb7bfa450677d980c4dfd6f84772b24aaa6bd8fc345c3db338d0e09c8db3f20ae828d94483ef9fed4a7821933c56078abbb0052710d47f4ff93feadb7e25463e63ed33b19d48d05129e502e9ad8c67ef82768aed36c09cef7db063f4af01a8b94926f931d8cd3d588e49033f6991d09142a3fd9ad1c3ee583d3b5e75b8a651ac08e525f297cfb6d6b9ba50bb10198f7e2c51d45315ceb935fe82f31d6daea81ccb3f177c22d1b4f2108d8bf3f7f040c2ac6098cc4b1361d983c63c039dcae911b5d2d7d8f93ed10b39083ef048c0689a2a6ebe2247d3a24d5b4ae7d6080705251e43cbe2258e4d0b86c623b17b68dbe7a7809a50835841ab9cb84b199ab3f2d52dcff482d6907c2fbb4ccc2a09dfe34231e4c2e958d3cd8cc09e2c866c8ed403088fcfacb8b937700fe34cd305c16ec24beb20f0a4d960f4199269c356a7caa254b5a760397aeabe73dbe90bfb64032ad18a62266c9ff7a2395e7ac324e226a470495a7b8a23de22598de2f9aacdedd85260dd1b04e91a03ba1f2c3ef3ff37b2e03a38a8aaf7daaa7506bf93f20f4e3caaf2de7c4ee5311bcb4705d9a4fa2893b24e8f3ccb38c4c7f37d018d5826f0bce1375b474fb5adeca0ee7879245fca0a15596f00b94e455a442ec28471d427bbdd9983971d1682f2282677036d7861a2bff82a54b4326b1f9d157eb59062cb0887395c3a0ca848f973721ffc7a1d8e5eed030ef8dc523707e552bbc30984afd028f8e2ed403ad95098ff3c256a828bcb085b92f5964f22c611a17ad65a43861242c5a75d3a3189b9175280f888d9de87968f2657231f19f3b7f8711c70194e876ce28879f655b32700d834afbc2410f956886a2e6818a96e8a7704d4b3c1d2d4a9c260aa0054cb9b310e7627594e1685b72ca089e05c1f8dc453d4ac80200de466d2397a79b87cd15c6dde9ffe7b5d925b0c7623bf24ca5c8f4e76b1351a431b0ef43722c42ccbd0c7ad1d02bb8e732f8d2bf11c38149018b588b9e71927dd393f77beadf9802adfd21a8bfdcee8ade88a1998c6ac25ec615e9881d0d183deef798a97b449258fe87bbc71d9cd1e13ea09ca04af90ea161a6e0615d12df5f9dc7c2130c32db6a29985aaa6b6b3a7262b5abde8b2ed2ca39eff6dc98b5515b382ffb25e6a1f601d2cd64ba2e88a3567669625375e93cb62f0325d33d9bc44462c972c8ba20e4f0d538daa1cfbd951f08b4d0a0274df3f665ece432b8a508f7a855a78befc149e2a4b17be22bd37439ca45284f00fcc4d2b6079fb1c8da1a9cee2ce4134dc27b54b91dacba8707e665601b4e532260ef7b888e9cc64d849fb0b66ac4701a7002ca263e80c64f142c6cc171716244cd569269788602726c526431e17aa1923b325b8dc4be5bec47c93608ee54a8d7e780b08ad836366b5539e659b9d7e31513b13b21adf825206240abb12c3c1dca5f1c18a3bc1a38fdc9142dbcd6878c58d01c142106696be7f7713454e91806973ab8a7ae802565436e35065cceb6621a677efef9723c59752b7912cb1b9e04396b07da4292244d5080074c030e08b01012d6056d6b77d2bf2a32768ddc95bd4127db43bcaa44e83c3f836b512384b55ca40851dd6752def6338e99d730af5c43df9b52dfe12baa6458993821b1ef9c451da2e27bab8fb207ff2b2c3ecf6434ea32718c15fa30ac035715a34b9f4ca621250a1a7e550a60cd9d3b9589c0f3fd53d39ada23191fdc051f1d3c7738d1bdeff37eaf93cccf43419a5ccb142a370eb8d709c7b1682fc1c3ee53434feacaaac2c1cbf5196daa8b7aa579ac0119259e522bafca93b850092779ba5774dd625a4f40b3a506a19b02804c57475196761d8afb82fcd4a116efafed2b80477314acd237ae724a82859c9e7a873f4bc6430d04abf60933c88a2d2e409cf4de259a7951e99f438762b89fb8b916ae1e6b12b31839cb82a0afea56bf610e7e613ac047531f09144aa8aab87682ea6f576dc6f17e68db9f69ef429152489d096d88948a972cc25cc90695e0a95fee2fbdd881b2749200a33eca5889789f2e8931adb56f0d0fa852024801e32bdcbb845152fb3ca86e2e3c1ffe6dde1becbc8b9ae302b9ba07682c978893eb29e4a0dbf3c435e0b2f78c62c11d8dfbb4ef815af9b6ce3836f37341e73f3402db13ac7ad36ae3e9b35d0aae3795a8e704b07f0f25917effb3cc005a8dc2945f5fcd3251f1e7010ad3707f3e703c456b211bb569375bbb6ab8e5d8c22c580ac19bb4777af177b116d9fbe08eb6839940f7930b9f88860ae860ae98321dba79f022d0d66a395f3420f1f0dcf02f74bb3b35bc8d23f5396204343af27d093ec22d389ef9eb0c535692934d7b25549b4901aa75580c747f70883616dd1668142439f4723f9da9c1592d98f291b268b2e813b4b0515c2df50eb5ce538dc6a48629731d2ef8dfbee2e9168a4001eed5f26b653297bdff792e52ebf2ce8c21a2f8a9f315d6a88164faf2f248efe9b452413a9bac80dbba4a8b984c100846a004d81b65a36398899debf8e8b082ce5fc275d64bef5c533e48c0f2a1eed9eec7b575de807811e540fa53f8275ef31abc145fe765db97281c72574b1fec8cd2fe2d9a4a049f4e00d227fc1560e557c8e7652290e05a2c104c5ee3c36a080ef445964937e150e46f256fc1d9471479b3a6f12fe83debf0e95c75f855e3a639360844b4bebfcd03975fe005c873726c906a617a6f3d7a0fc293914e50d787055b2488b1eb8945c56c968f3f4dd9a7752991b7076424c614810efa5202dcda52f04df6685192118db38eb04f2d2607f462143ff6f283610d33ed144772d37fb86327c0d9e94fc53005c3a02ea9ff0a80e0bccac47a9fdbb733062e372bce6b3bc2fcebc00d2e0d0931a9282b3342caa7cf34196c60b11854c8033c177d3702674d7a0f998465b027177e1984eac9a31aec288a982c3c842cec75e6736b4932a8cb1ead76937226753dce5839a9c522a3bed1034842c1cefd828099dec6a064f43d89fdcf01f4ac690b03fc657b5c7edd0a11e3a36813af782909a670e54a0dfc435ca79cd3a5c59ee78408782239a9831c5fc9092cd9f8663fc8cad9885b9ec9ec0fd4309dedaeb6462721877311230b631a87e59b3d5d16fc5ee24e9ca7de91bbdb6f4a3152042e33016740a441a993d62215a66993d2bf6caffd2e2587e81677406343b096e074016bcca21e651aec4a0d490b27fa78ebfe23507719d38eec36dde633cf42ba3383b7f748ee3650512361596da7b9e051f6ac808f51536603f67d3b0803d47e666a747634926f881eacca71ea997f69055211e87af3580a90605a741dba52bb84fcbcd7b2b3f82e4f6e859e821b16269bf20b769232579530b77d266543c23a931454530062650cd9969d808e69b14103aac577c3099ee41005ea5261006ad76123fba9f93a244994d3db304158cfac1ab11e96583f115dc0b0518b311c3e7b61c74accc56bbad141a763f6ed325918e6c63adb84eef1a59d916253089a88bdac0895caffe64d381097334914dc37d75ff1ebc40c1ed1ace78eb452b25a88d710c9e951ac7c02eeb6fdb42cc77d3bb8c6d2d4d36dc7975804f618d843daf9c329a9f262b3467d105e1f420d2eb7acb1568eb1dfe7ee52900c46cd696f13580b4ebc39fc7589c585b184f52358b253f2d1d658a8c0ccb52d65b7cb5a72092106b4d10322c2d7021fcbd5de541232d34a234a86e4cc25243451acb012cca4cd1aa7db7b3fdcdeddec8240a68ec52bf254d8b0ec0d5f9d5dc65bde6044fa2d4a3b3d6fd57f80e6214cac102f94310b6c1f7569dcb087b30f7e9087f0b76a14458873a2e6dfab276bc762d17481aaa61dfb735aa4347158711e087226fb8f6812c204dd6c31a425cad23c7806b4498e9aa7623467a93b7b002f2acdb32c2cee154022d7099a54bc5cc1f9f04819bf65c53fab565e24a70197199d1982d4fc22ddf4175cbee5f2045d1d98157e240149cd089222899c6f06bdd05cbad3510f96b7f07979d8dbd153d85e5d0de8cbbf947450062aa1443145ff8fa7430d841a7db048cd97f6cf0652bab46d70c847d3e872770fffb0433616d8d7051a3aacc2f7262dea9f299bb4a17cf6e0afe160835b3823bd6b34e5d6eb2dc98a5f772248eec7ed0869e4f8eb41e324a7231b38c177763e356b42864eb12e7762a9ef96cd33ba1a3c9a721d1f3f69e9679f74d30261c538d5f01c2ed2fc9db57bcdf2cbf512c961cbb2438129422293b6408aaf09598309cc905c80e093177619fae683a208f7dd459255a689820572af340531d8b4a68aea4b275fa585d7aac6d0802d2f94bf814b1c76b3bf36ec7306894c26dec760bda7fdaafdc82cea3303a027a77c140b71225995ae58b9031d7f8dd67235161bfe592af5926898a53c805249b0af67aa32599309edbff697493fbff15f6bda1d7730a5ef50594712bb050129f531352c1093447ffc29f4c6137b6a5d91ecf1fee6c019ccabe1555cd41078ca0d7f9393d824946cf00562bbe57cda65049ffff1bd977f376812c6d1dba3304cea9ddcc01bcbb6362f0e13d6e7f7a336122864a1e5d3e71e3585102b2cc3916141ae009307b0ed0fa34b4f134987cfb2934b1b26ecf485a5c1e9d1fbd4b374bb715fbe776841deefe57c26f2d661d38dc86d9a6b6ff3907e9c955ed1163d33e963a73f650eaeb1ffc0e364a3f9c5f663f9655174c7a16896e426b75c05ee57777c419fa04f30c7c4bca5f9fbc64ef911e880a148306d84208635ee90b08af480032037b8587247bc8a171f2d4c76bd829f93ebea8bc7c54b3',
        salt = '6c0b29c25bd10ac6bacbda275548bd2b',
        labelError = 'Bad password!',
        isRememberEnabled = false,
        rememberDurationInDays = 0; // 0 means forever

    // constants
    const rememberPassphraseKey = 'staticrypt_passphrase',
        rememberExpirationKey = 'staticrypt_expiration';

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param  hashedPassphrase
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassphrase) {
        const result = await decode(encryptedMsg, hashedPassphrase, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        document.write(plainHTML);
        document.close();
        return true;
    }

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        localStorage.removeItem(rememberPassphraseKey);
        localStorage.removeItem(rememberExpirationKey);
    }

    /**
     * Clear storage if we are logging out
     *
     * @returns  - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        if (!isRememberEnabled) {
            return false;
        }

        // show the remember me checkbox
        document.getElementById('staticrypt-remember-label').classList.remove('hidden');

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassphrase = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassphrase) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPassphraseQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPassphraseFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassphrase = hashedPassphraseFragment || hashedPassphraseQuery;

        if (hashedPassphrase) {
            return decryptAndReplaceHtml(hashedPassphrase);
        }

        return false;
    }

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        let hasDecrypted = await decryptOnLoadFromUrl();

        if (!hasDecrypted) {
            hasDecrypted = await decryptOnLoadFromRememberMe();
        }

        // if we didn't decrypt anything, show the password prompt. Otherwise the content has already been replaced, no
        // need to do anything
        if (!hasDecrypted) {
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const passphrase = document.getElementById('staticrypt-password').value,
            shouldRememberPassphrase = document.getElementById('staticrypt-remember').checked;

        // decrypt and replace the whole page
        const hashedPassphrase = await cryptoEngine.hashPassphrase(passphrase, salt);
        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

        if (isDecryptionSuccessful) {
            // remember the hashedPassphrase and set its expiration if necessary
            if (isRememberEnabled && shouldRememberPassphrase) {
                window.localStorage.setItem(rememberPassphraseKey, hashedPassphrase);

                // set the expiration if the duration isn't 0 (meaning no expiration)
                if (rememberDurationInDays > 0) {
                    window.localStorage.setItem(
                        rememberExpirationKey,
                        (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                    );
                }
            }
        } else {
            alert(labelError);
        }
    });
</script>
</body>
</html>
