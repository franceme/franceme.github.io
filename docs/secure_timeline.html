<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #4CAF50;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #43A047;
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #76b852; /* fallback for old browsers */
            background: -webkit-linear-gradient(right, #76b852, #8DC26F);
            background: -moz-linear-gradient(right, #76b852, #8DC26F);
            background: -o-linear-gradient(right, #76b852, #8DC26F);
            background: linear-gradient(to left, #76b852, #8DC26F);
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>




<script>
    // do not remove this comment, it is used to detect the version of the script
    // STATICRYPT_VERSION: async

    const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 *
 * Mirrors the API of CryptoJS.enc.Hex
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassphrase) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassphrase
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassphrase) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassphrase(passphrase, salt) {
    // we hash the passphrase in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassphrase = await hashLegacyRound(passphrase, salt);

    hashedPassphrase = await hashSecondRound(hashedPassphrase, salt);

    return hashThirdRound(hashedPassphrase, salt);
}
exports.hashPassphrase = hashPassphrase;

/**
 * This hashes the passphrase with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(passphrase, salt) {
    return pbkdf2(passphrase, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(passphrase, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(passphrase),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassphrase, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
    const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassphrase = await cryptoEngine.hashPassphrase(password, salt);


    const encrypted = await cryptoEngine.encrypt(msg, hashedPassphrase);
    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassphrase, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassphrase
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassphrase
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassphrase,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassphrase = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassphrase, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassphrase = originalPassphrase || hashedPassphrase;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassphrase = await cryptoEngine.hashThirdRound(originalPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassphrase = await cryptoEngine.hashSecondRound(originalPassphrase, salt);
        updatedHashedPassphrase = await cryptoEngine.hashThirdRound(updatedHashedPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassphrase),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
    const decode = codec.init(cryptoEngine).decode;

    // variables to be filled when generating the file
    const encryptedMsg = 'e9719c80154b9ee8b82a3e475c678bc586bf3612640791464b6c18dd90a44402453bb823678023a761a5303da1eee9838d8a56d7b658c1b7072e905484246d62895084ce2ba0092220969b0acdcb098976f64101a4fc4bf9f47292b0049f1486a50a302c15b17ed03a0fa16914302626c58049114083764c0785fbfd6432c3cf189d96bac05dad5bd91741b8f29a62316aefd52087b105d0bd123e25390d85380e717a457f8179d890a4822cb69fac1d910619d7f5c16cfbe9d71c7c45740f39f83bfbc7954924b6e9671162c8a78bf92b49d02d382df298f1e2dd29f1542bd6808edcee38e9a6e51e6586f6685e68db39bfe7e8c2a61a4202c978fc68e82815cc9cbe9be19288b5e75356210a48a845d927b286d4c21dd7fcdb1efa64398c7c75e4cf9783bd6027a65fad93f4b4d555bd66e823f7cf442d553f9f35358dfb24265472f669305016deef7786b607c32d0d8e4a5bf22511a4fdeae9162bae47fd4cec08fd42c4cff1ea0a67244aff70a217b024b4b9d29bccab1e7ca26a4652872e2e02f8853e796a954f5d73e35f37ffef2ac6fa9261f108d3b108b1eb9ab5428bb476763a8fe3ff16aa8a2d2a358492503de8923a9fe9ad343db28de0ff8554ed45251ea8205a012bc8eb5bc86df705c02a43f008e4763e4de89d5246ed9abd9821cfde3ad3f6ac4fa23ee93b6dab2678ed85667045b5c49da8c63fdff13913a449c025c02eaf5430a7b91f0cf9a096b53bbbab7bcad559ff89f38c8923740c08b1e096215084f18bc9ab6d887b237eeaebab0b018f5812087acd5ec91359c6ee3922c0d311fad96399b49ec65d4aaa0bf3106e0c7cbda80baa3fd742b0278d9885aa2798a80955327b6b79e295ddd30c7fd6f293d9b4a99c9a4b34ddd2d51fc4d110b5fd45b53f1a3031aa4ddfc849ed96adbc5d28db4d445025eb4df4484a4640d3fd3da4c13e82af09fa0321b0e972af06dd30f9ac533dab83b0abf1e6f7050db6559248f8c0dd73aba534e0ee8d1c7b3056d9832360ae5254cc8dd1e66ba4b9de605ba177cfdbaf65791d2803800de4c128847d8c4ff94c3ea8bf3edc35055bc8a66c81144c3fa3cb6e6a54c32e70a18de43a869bdf97c4e5028bed0cec0dce4d908d2037ecd3b25e2e757a07afc70d3b40608c279700425972c9a3bf0104cdead3299f40a5fc36b287e01899bdee745a35086ce4b532e9837968f552840df29c88eebfba5dccb6da9d5dbd5d78936a82aae04e2dadb9c4fd7c43a43e61d9dee4446a65a231e4e1e2c4ca38e90151de602ab159c9e7126e9dbba1902deb61e3a6a87a76ff6557af70d2befe2f8026a744723eda2f39812e17e8afb23c6bcd1f9192b754429ae894dde306ad9056cbba2f30e70cb0390fa42177b144c51a3d69e5f57c881960cb5fc8e8a37883499a71219b09d99334abcb9efc4dd34a3218c9a2e07378ba74158f1a8cef03361b4e174096021de3762579f9dc788ef5b9ff76edc8ab7a7121e96411acfcc8ad7d63c33fa8270c9efc61ac6d99ee6003faec6b8578dd85e68cbf17e101fad7cf8b63a282f2bcc7f84c7bf57a187d48ce399dd40da8d702abfa4d82279f3eafd2be5344de9840bee50051e92caa2a576be63706216445ef7b0df4a2395c6ffcf4f008ca0e4914bcb04c5d7f696c8d0bab9fe37280d1b7a3f66decc60ceedd774490b0b4831b8a9f8d5848cb5c6f98b15754b578c7a2813a3ca82b5b3b0a46e5980f8fa29d9914b04801cbf687a57a913b25f7922ce6e02edba7a390ee9c9f1db9541fb93daf5a4b55b834edef394fb762733950a08debd90bc3f6c4a57340c8c7ea6b7a40428f6b4c7e7fe56343799f3038d40a16a405195b83b9845a6310e4ebf287194001cf27d2c9e3602070b16d04692fd56afb4208183be61a3f464cbfd0ae3e4cbd86fee749f18091428a8a8512f0af13f3c7400b8e025133f9b80ca0bf053883c3d166fb42e9a4c9bf70199b6a18d14ce3fee62de621274960c6e8f9161262520b57b95a2165604ba43860ec1b911e5e28997c164c98905c9979ef4c6831955ae262e8e5e43fa05711e60e54e0dedb769d7c50432c491472b5c0759346d29e2357a5e9e006082b22c977fc17b82e9eb10b2cd2f29120a0a438c343d783d284bcca38f598f0a833118d7e38d918df34afe18cd488106cc4cdbe095a1078e8003908cbd64b51458703360417bf4233aea3dc2b79a125a8779430776b6f6020891a67c9d3838b804d6da50a3a9d756588ecaedcb140da4f62a8e16053806e8827f55fe66c2174a449fc5f84d506c9a564e01a3c8d73554743d9ef1445fd236b4b82a816c110c64fd6a0a202fc7573928f33a2807fcf458e7b9c456cea71d5ca2d1706ceccc4917181fecceae4824ecbbf6783afb03884d19dd397166b24421b7c1fbff5654caddf9a012f3adc630aa5abcd9c73bff7a89c27b42a0beebb0fb2ef890a5e3629e514884d0600f1cd4da8f6187a6bf08c4c80001b17871e3f347acc833ae0c3b83089edee2c6228f7c47ae6a865783c5310f8ffc93753e3587cc4f8c81d7e10bdaa3681cfd29b1d1e20f1b0afc2f487a2013a157c3692a9f3c4b93941d8f6e046186698515967b0cf797ef44a92658513c52ad38ab6616b932eb1118ed7f547e83504569d0e43702d24eecf7fc840d7a0074e2bca9bce7c726fa2297f4a7a8f39e30654516b580cdb093698ccf5982059804b130427df10be597f563ff6ea25e5a8ece48f03f733777953ac89bb559f44b19b84cbeac50961cb5d39ce6c54f446b23497b145b1146336bfaafa521de72098ccb2d77857f9d7faef2d711df39c1e5d767e2b2d287f84045f5b304d6d2a90162402f23d333005da63253df54c9b4a1612f7919a2d615833f9abd047c1828861bf3a602255496df67a2a1c23b7f5199f251c941d94e47e47c955e98530396464413133f0a775e5e2117fb22b87f5abfab80182154042aefa420ed9416466aa4d15de8cb36049017e385c63c86c04e418ed6204d1ba62f61f7cf858bf33442796eb2c91794d680cf72b8b4e3e852df30e4cf3740f55b4b513f02bb9bed5ddc25f8a11ef9933a452c5624e78bbd8e99aca73ee3d0ed678c9af3a11e67e0184aa8b2705438338fe9a5d2c76148260ada036dfbec6430f97f6155dcbd337fa6bdc8d4371f11975d0bca8da4c7ee3aecc6ba2255ae3fe83a08b71dd7c4b84d4dae420a5d2e69b5eaf627d48b48e9a3e63472931f814c68e6659c451698b24a3190d947347aee16ee2de927c1091b64663d0f4eaa6329b4d738abc783c7d112ba5ed233894ec380b1d372cee1e956e22adbb3ea896d6ab9a97da5615f2a7196ddbae7fae779dad32e3b0f7ca4bf69550a95c726586c896ad92efcde1232a7e5465ed34f30f72225b27817638aa7fda3cb001810b6d9f456f5499fa9c572d0346ea49cc4f37a454ae0948840757077520e3cd168c97d921a83a238c20c531c49a28f7007727317091e06fb5f827df5d5444857520b5629761d9366e77660a450f92883e0181017a2e933a4f0a25f9fe5ac99aeb85350c0bd319cccad9655d3faa2131b0a00691583eb676dc4d55a9ddc76eeff4c24a1b74d88bf38e82ad920c192710f9aabc7c5121b0452a1377866df037a8821c6542f5af9a821fa9444b43a1b2624a6defc86de733506bbf912747d2887c903fbe9c41d82d2c9c925177dc33afc63074f493a67c34aaa7dc67a4d55cc1f5c53bf9db709ae5413d95f5abdabceb435b382091e8859a3d45ccf37b150dc5cf5d2f3815f3adee768128c39a100b79fedda2b622656f6dc18f18d53cbd467182d2b747e155006868a4d310d3409425281eccd67e9291ccc90003374870e31a3c217a86ea50f2a4c3a78e9844c2e5792b5306dfebc18d6000320260ed4217b7fffff0202c9ff8443e7f5950c5ec0430bdb352c7dd9ce2003e8d89cfc13079e86abcee6db7698cb645cf4811dabc3d7457cc70c5dc004cdf7ae36ef5b52f262d9da9f5aba9a7b3f2e94b6bd57aed2cb6d3230d497b48d1c448dba96d0f55e9df0cec9e0d869b58683681ae3d43eef63f3343be384d63c3e33a93f878e45ec13d3a63c2cb51e98bdb12b10540c71566c9b6f8dd7ea5999b3335055af9a26b67ccc496a9ce94fa0f940c4043109a00668541ad936e3ee7f95aade02a5e63a0278140e720aaca53423b15b04e90014dd5666c9c0c60a6b1e592155cacc578f1a0b5e3aa002c2a04a50e998e972cf08238191ef61aabb4d88fa5997043afade6df5a10a77f9e1780ec4a2c3b833882d4c3c406c658373d24bbc4dc775b0955879ee651e5f9319024fda718945d2e90e1c0ee906d296d27582221063d79820082e5cd7b16464e97fb6110123792d44c54a9c08f12e415a68ccf04eaac0bb562fdf5fbee4e69c0b89fc4499e809ded369cf94ba733c31d986578a8bfce65109f568e2cc229e3ebe7b5e438198303569cdefef5ef31252def4417c7a47b6e257f2575207b345c585e1a8b79071ac8c71cbf32b52c4b55bc00bfe27f0ed10efc78e9ff6569721a1126523942d5beb266ce7b84845e098c9becc8e0238c27aeee2c5ffe0ddb522a6f6108ec64b1fdbb78eb23219c353f0fc2bedec313d5582ccfe3a6951c5d7971ac0d992e8b1268196227fae6f1e017850c69347d960bbd012619023a81b9f1d7fdb5fa0bb62355fda6ee54c5b05b5d895e7a25ae496c75e98b07f74fb1986b43d9eb3e1c51f7be359a1fcf345a2106fbd4649dd5958aa0364a2d5fe5fbf17b4c47c146053dc053b0637ae0df94050a3f012c62351a68936d684622d7decf1e691cd817f06e843c2518f984aa2b5ff0c8f5b7c4ab7f01818aa3ea57de25d37b8e5b665515bfd5c3591ad4c4c0a55106fc81306b776ef9a03fe207bb18a065b46f159281df5491a42e8c45aa95f1e934ef384a2edf6341794bb7afb8ac6dcfecec9351c8ee54a9ed3351ca5addd78806bd99c5ea90073d7ebbb7678ce404059289cbe280968f44aefd38dd032b89e956b47568cd9b08434d0e1cb896f32b8fab81efa4021a5e77e83dbbf534a4246e5b711454457cb3a77bd1fadf7940f1545ab362b8a96938de861d5299b2de2d49f466ba024332d23359635bac2ed8f87a92bc8db143916d87b1d1ef230da136ac55f4f08eaa1c3d27d88e54613c50fefdeb3881d6d63cf72fbea5d07cecabfa6ef1bbe3b631a6ef51b8875717e45864664d65c3f40016c61b26d753baac4e207c3ef0a46b9ff43982ef1bc4e2b8a9a043c5f934f5c8180fe60ec1c1abc7a1255037537fa491f009796ff956bf4e0a6d3d55e0bc9cfe61908fca5740d6635d055945f2565a5cbaecb9d935fa156f905572da9904c7d45747960ecd4a9dc4fe1b702051a4eb425d7c050283fe12c15657d8eb8afce74dc0baddf64b051c3d7e1cda2e38368b16c08a441005bc0c40be709f7c9bdc03920af72cac76e584ee1dd850a97f3f6fac8fc0a3d925c4c4e8a0a2f931df9ec3c5c800d5137be625a3d1f5ff91b488ee8c996ea6bfeb837c871b97263a5bec60e445a0eb539cea3d3b4d4728f84015620b8cb99ee939e833dc348a18d975e6e801ed4b7ee9b7b7ee9abf8473755610b2078066db126181c984d309f70f229c9ddd4a5f5ada3c02864a5db6c2358cd63c075c814dc9157e7caa353752e4368486dfc309636a2c791a7b38bbd6759cc3a345eebd77257a2303f1f6215d9bc1a8d5b18df93bd27c32b29ddca1897f6f81f3f3df86223a718eb1a975cffe56341b0e6337ffc02d9a93f946b40a0080983c0ae435fd7041a8def346bebeca056bef45e4de5beb04bc271b57e34c706e866500b9a159138642db0d0cc26b51354516200577ce0f679205fb5e95ca92daf68ed8f95f30a39d1d29a130e3eaef4acc281700e8ef94995144d8e5d85e03a764b741ddb289d2eb074e898b7e958c483e9e608a0a732dd5f2b78391a4173fbe8515a0e304138e5e951763bfd6649c1c116de79038b92b63b3116edc41ce092b2c23c8dc06bd4f5f35a5d0ee2e51d1f7cfcfcc10812391928c98ec588fb18c8fb2a8facbab5dbbc946e1caadaa13bf6b2a1e51aa6160be2dcf7d6b2f5db0f86412db16dbc5e6ff335da8c6e1edf2b1823a35bb34f5f72c4d0005995d56429b661fd3e7863a7c29cc4bcb24033fff4605ff6a82af265efa869d4e7c26f976d699b34681bc02746560378d13ad269c30a05a9fb1b002d5a9fc639830818abe1f1b7b2123626c7ea11ca3ec92f9a1cabab5f78c77aed315798416da288e4a7ca6a2643b9887c3ac35a2a3a9465fbf1f42a35fee1b4a760467598492d10182d1c80dec7a3471040b60b55420bbc334e2539a76fe0fa1d5915be42254b08e56b17f3674ad8b6f6490975a74d1c21d7a7130f317dcb88788402e0c30a72e9f5ce9dcf34364e75649b561126073f06fb8061409b6bce6ce2e412a19d89a2b42364092788c88184d3d322af17762b3909b170e14309cbd74ce6598abc3518add9ceaa1f3ba386d5f94485acca195511168756a505e2be7afb0e6d7c4ef2a38b390e0207bace5af5de6bb67ca1670c897ed0b0ca20535bf65d771d4e369bf37d743aefb84b0eb7b7755c911e5ddb1baa3ba0d45d98392290794acab61b1e1a963914738bd9ca7a19fdfaa7d9d27c3230f872be08fc5c7e0727e41327e71b8a5de6a197ab5b086b23b63775e99080c2e009c21e050899d50a76d040ee2d1f811e1033db0d24631f12cf07a248f49e5235a05e46973cb6bd10b275626f4e19a85948aeb607513db6549d8162747d72f9ef37f35b5a2064d0c63e6b7f75064d6c9e3d5952a47e1ef926662149966b7db817f45cb42ed3d680b3195788e48e3a189bcf9e7df2d6bb5db08518bce2cfec5ef3ac3ebfd0e2cdb71cfdba65bb32aa34f07a8ed670e3da37750b5433e227a2677064491fb5ceaa0e27ac2f985f3b6c6b91c34dc66bffd79ffecc71b4217c97aae8f07538de4e6c261dfd96057a511dc881034d2e519ae750177bd184e7979cba30e38287547e424bc3e6060a6f1b605189e5bfe7adda2ac78c91e911eac9368f12b82c06c144406c91ae7269c6bdf1d90dd915b672de632f036da01699bc1bf8507fb94f5d9099ba6a9cdcee5703915a4bdadb0acf2c95ffd60b21c34971459584b044d90e6251b0f1b1ff7b8ad69a40724fbfb73b93f889827705b4ed86fcd965c6ccd64be795cc9d518fc44e47e678d53c95bce505742c81f9e95dd4e65410f959c31e2fea31e9f7dac06e61d23e1e626bbc8aa2f3146853b59223dc3529f8db90f9d689bd9720a31308ed2b8d85c93fec19860df32b82af9ca75a05330e2190a7c6e585648fc9208162639f8d4903c16cd9570a478c80f35a651d81b9a3d396c9e08f775858a082010cb95fd9f2f5a8628ebda770fa9998a2124bbf1cb4af83e7f03bc267a6d3fbc785d975f554d16a0286907efceb01f672bbce026543e4deaa0f9687bb245dbb7797d2698c0b53bec5263a4a435d74cc027c84298f71e8db9618590723a727b1d3f3eb3a49fd46247906d024d88fb44e146281fb4e92370752f78ab8d540f3e4a72bf832fb0dca64f5adf5bcb4f22062d4b911d12329eaa30ed9da778f4aeda5c1aa4494cbe08735f67ce529ffc7acfacb05ffd7776fb1a3f560ec09daaa7947c2998da15b95c4960d60126295f48443a97bfd91da45db5668d8f9f9535ce5ae8cbe5f24e5859c9a2d7e6f7dbf47784d05461bcf9ec88443d44ba0f9aecf8295d237855393695a763c36a3a5553eff3ee1e437bcfd3e5089af0d22cbb82974b3a5aa5f9755067aefad8961fa5f50314d5c4d8d88a7c9354f16e30db17bbd7737c14f4c3da35ce7c66807deb081c01f6483c77dbe2fe9f0987badd6b16d72ed66122aaee2dc3d42f72c50883e6a22af457fabba3bcffbd5bc45e96261191de579bc291083b3007471c5310e6d63152e4a18436cbd3449b23cc20597b1ddf95a6a46ab620869aff5c65adaff033c987e5a7526ed758b84a0e367c81689e9de90a3ce307853db7ad252ad25c8b26b90b6ab31e78649a853e02a7e2da101f76c1183bad8b5eada4906ef89e8a5cc0297163bee88c6bba9c93612a0275d25f10cd6c7691378c5fec8666e36e148dfae0a6ad45c7b5069f5e64a08f0da82c130ee84198d5a07b358a9b7c11582b9435ed939ffe693efabec441b0ee68c9e77e9075df4bdea6d95943d036067ba881f43477599be15ae7ab1c290c5c72c71d17c9648ff30ea9084d2c9c80a7d7653914472982d06e69676483d1b54192c9f6ca966c953d8325c8ae023ccbb2de7d008fe654a83bb3f0290a0324551ba72954e6428b5e95bbf65e6e5a53b664cb4018ec0f06db3d3f5487d759acdfd9c8bf6079a9ec177a3e6db8068b656ff0797621d2f42454731fe1b3da7eea01b7af5321d2c1f806f3cf2fcaa4a06958a6b3bed2cfec4411c59e40f733b5b3ae0a3114e0f06709563a3af24b686e288e80ca69b9a9d36c963bddc0b1e6e58f82bb0dbc0337fd62f2d0ce1194df3d81cd4231be431967d3136eed43ee0cd6d759a39ba621c855c9bdfb7f198ded648088f9380998a3934572999d0bab65310f306b647e48d01b59416a5862fb57025f4c35f45a9c911484ef554993e577b35d965c8afa0ad3ac00623c80f302e4f81ca179203546b2c35c8adc20484dad7f6f02d4e92d9e3d4904a855da6668904cb8848e6e6be3726958adb4440cbc81fd95c47c031151ef889622f35f7566b6a69660800a644b2e7dd4a21a2ea2728dccc7fc85095fbc385b5b2cd569155f67ba5869365bbff37b01bc584103863e8f0f0f5a1f036513d4d03435478b46ea0f3c4cb6fb6f44b452b4f80d8352def6356121068aa433c70c414496cf5d49c16f4100863c2b0631226f6f79a71abcc027f976b893bfc29f925ca9d287fd0d47a8ba15002b616ebc1b66a315895b1a415f47c37674813b0d97b2f7fe597aa73caf054e1ef6ecdd17ecc9f7e42d4dd1ceb22dd04ffa84a552cfe6463e6d07aa8b161e8aacb06dbc4d69e3db345d9afdacc4adbf37592205d06916dd8bd991641e99c7f476e3cdbbcf4bdcdf546e09d9f75eb2bd212056e47a7576214978b9461cf3f6dd1135541d1716a68d05cdaa822909e077a501064a55cd9fa94431332561f49c9e4327538edf4669fc3242815598dc6f5c37a315f141059259bd8b4705eaabc33b7fdf27ae5ae06d4e093de1df2f85c8605ccc142f1934e9c90c85e3351dade0e4b8700ecbbbe0c055ffd6f93f6fc530fc26a5785c96e53480e48f0d36b3beb84e498e84b5d30b4308e804067b8fa4300dd362ce7e5c5470fe76a11c0910de80e505bf6381756d111cc6e0ed07b1d3fd64bc5ce35549fe6a6f1c0c84dab3ae2970eac4f8f91a08b1ba0d6983c1c33437c91b5deb2ad178a6b00dc447c83a2a87128ebc1c542245c87e8329bad57926516feda198480363621e78e7188ef0063741e2e01ba9660111859a5c009621007c1c99fdc58cd7703b52deb06aa8ca3cc86d96074ad7078d743938f523e9948688b4244ee81664db46d7ea6fdaa9724a0a259f58c7696574ca2f540817f442f16a00fe019fe454d7a75c056d79988145a5d538e667fa00b6ca1ac4f1f3f0f2faacad5d83c7c8c2e7b92c2aeb3f2ecdd56abaa68011d91135e1aafc4821c1c1265802e7b0a3ecf87a72fa49a8dff2a939c422a7d99141f37cf61d80f27bee9285eb26b0497880d8462299a2e6308bf0157257ed38e641a7771ca7eb8a0dac1667ea43db89018425a47a8eb7d8223c13ee987b6c224def794c4cb42f2c3cf7786905194d8a5a27b45fc14acaf2d3a5040bf589d868725349ebe7fb0abc85647cb770d9c8c59392456106b34be5ea65fce156b73e6bb1e78030e95542c47fb9d3ee8192d72d6196318249892d5190cd7e1eb215d2f280a45b7cd491b2d178ae7c72593f85ad159cbcb1e7360df124048e3ec1bc0cc5c313d436e4ab6736b9dc2222377b85ec6b5b5e463fc9f49f23c2d3e98fdc98f89b11d38a757d650acecba69c980e6a5b6780969d5ebf3733d056081a4a9aa724244f2be14018642b217e9002ea1497ebd7aed54a712f86c2cde2fdb28e753f608be62bfdc1074ed22185937d81e1263040cf146605497b67db3084e4ecebd1653e0c6a36f64049795d334d90b53f603572213258bdf193b63465337c72b8b2a6a9bcb5691bff583c220db0dd9bd1116a28a7933d840fb0090da29a974fb2303c4bbee6bcdc5be0e954b90ca37ecb34ebf34ec1f05f53e7daa00b35e58c9b9b63d053d1d39acb85f402261c02b5415d2cda8741d79dd4420dc0ee36554a781b4ae0e3996c14d506a3d211d15b2ca8b6d3e1add5a32c229cb55377bfd62471a200a5acb6a36f3ceac5a87584a2ef0f482fa1cd6fe8c95d4d6c202f8ee9af2ef617dd435bcd7aba91bbeafaeda71c8c012bb11b0fa4c780f7b8a79318245fe2ce8a182cbf28e4c86a3f6d90d2d003dceb6870c58204abb3a49a35aa872906b6a42dfaa596e1dd70a224b1fc45e01eea26d4d857ceda2c4fc781de368e8b4d4cad6ecbca258fe1b1d23c77af46391f71afef38930465e9c5aac4d5b7838a2a057284438242b9a664bc1e5c40f2f94e2587dc7eccc0aeb9804ed4aa80975d8436e4d4d3762a26cbf82334f11b129e2a138b3a16a461b3e6223b8d1e7d4a3cdc993e380db69834d10ebba7e0357e22e90ead2dce765f1cfa849b895edce44731eefa912696112d7d3afdd1733ec631265f439ea2aa8a9bca7a8ddda3ee98b407abb0e48b1e775dd9710f4a5609d2e7fb3b8ba043387d70271b2e47ec30d501e356b50f12191c97dceaf5d05c1b37c81d03c00c9203869fc4ccc800c4c12f553bf6047926bfad6d339711154abcd6881fbc0a56e8f0376bbb780a829b8d79d5aea84413af0223fc840781e0dc6e86967fe1e553b1f2bac0045ca44fcdf5744a8a3143bf3e8950f9ba07541fd4e8448580b0497b8c44f922e96f2c90c02ccb676d7cbb3f180e62f9cab5d968f1e500c2f139085ac023bd6ad74a4883351f1f277e1112d82b0e19d4c3487db8123cfdf6735a973f9f510306de53e223c7a68f3cf593ab172c60ed9c9634611639722df3eedff421e65d104d7c0a1b9b100713ccb432a4f1cdca91a08ae98252b023e92a1ae87a68426e279a4f74a31b03cdd76a55df78203be57aa82c4a5a5a356276f14323ff5e89283b5085663844bd1ffd8ad622a23b644b3d8d153c56e74271b35c99d5e8e75ad4a4bfe7df62f07350d0a2efc4dedac1fdc2151a068c3f1c2c64a3886feaeb4b5a463b9e8ab62afa3ba7e92a38fde4f2494da7833eb571aab5002b63fcb7ab3a5eec6c3bd288acfbe6798f81d7d84d01bc8dd3d0bdaf048a3e7819cce6554e698bff7f0d6548b5b8f4109ee1082a7f1674fb985a7b0bb86587156a0929472e303803bf9e3e65197cf0b644bf0bf74b89b3dc1014238c6eec5a09043b237d394be4a2f312450a8493120cbb6e2fbeaf7a85063fb892660903b6285dafa29c5ba99ff46f914ec58513efcaae1e996bcbe590d20737fbd7c2a3b585fed11d87ca639b7b584c518014c886e4be9e78c4dd41e12b6091d50d6856885b925f87dab6340036d2ca0d0a1575f0a4201ae6e06fb4a9b31541d935f46a77a363e32eae760a6057fed25ffccf5762ad58ee4c89d3f411fb77cdcdcf0d8ada98e017cb135c30c70afa0c2bf81f1ad700b1b477b848878dbc8d9d81b004a09c63d99051bfba26177bfcf5db587773f5c315413ee17b30de94ad94468371fcdf2282d107f9a8c4d3be37681708e7ab170df049bbf3afc34ccd050787b6e7e4dab27eb6db74441d63dea48e140a896bd4f069c1878652e4e8ce2f5b4c086f80ab1f5ccf2525a4c3ce776c865a598ff4ef9ba779cdbb51d53191d21442fdb7752180e045032e18fdf9d071562c72154edcba03aea3fe7b19e42c4fd51a314e8969441db4020c6a7fc12824cbe9b6ea087b60ffa7b152d1942b8a7bb11acd02ccbfc3c602be197dfbf70f696ba0434a6d9d223bf42fd73c7340f66f10669bb4e99f9dba7cea04511437e0a006d6586d773e46b91361e5efcac4d3bb43137f981ba2fab6cf8ba16737ba1fdddd160a9d39be6ab7f47729b6076f3f01d6b95329cf57ddddc628e19d8af902da637e6f635269be3a6ef32a277e411719077b58dc174d35763af490dbf14474b632b97556af0d9fcd11a5433e37f780946cef51c4ebf3c9a7997aee8a4e490eb77a117d3f1d08755b26b4995377012f0f498519bbdb1ff7d85607288d66e20e5093746c46643a8f35f4447d268ced09e5cdb6e63a0283caa3a1525d4240756bedac389046e46119435847db73c2cdf5d99d0f72947987dd83875a6072cf74f254d7fc3a8c2e6a06086257b9ef39890e128666291b4bcf66ebe537a81f027dba79f095f1111cc1e8a0cdc6d7d06ed5126e885fb7d9f839c27a11b8e4c40c4eb868755f1347ee9f15e6d184a199f3912ef31ccdc634ddc583dd8d13ad4deb6c2d3dd291cbbad19e7347e331437bfb2d0920c3f89339d9c9e85b255728114e18ac1b7b56fecced83cb19eb0c07d11f2ac08df8591e6b3e1b15709711a4a04aa460ddb0828e2b7cf0db0218c85ef4fb7d925d062a64559adf01f82cf8d8e612ee2596dde2948661d285bd29794bdc3d26d609abbc13ce44d701ea090d9acee04e9a5c56dd1af23a6649bd2f0bc9272f40f9ff53951a2d94c83ef924f2f2827cdda8997515f2801458ad1dced93ed595741cb7f659a653a22654763ab4063371b385337dd90160bcdd57e512624163d39650e91c2703a7deea7fc7ab0e60d91495b43f16df30201b4995a3e53373b2893f57660e5729c873a05e77b54211cb518af5d9bbb25d2550dfc8be8c6f0c63d678ae391494ea56bfce3a2e64648223ef953a006fe39988da37ad9ccbd4382a6e719b13ccd22c2eef33990d3d2ef219f2459632935ec5937a6a19687ec761d908dce688f1425f0799b95eafd82bdfe81b72dc2b69c8c737eed62e1e453094514c61c75247209dd0a3a0f9fc315e08070a35b5c6c479b4dee1b262fdb608dbbdc6a88ec500d3cc95f01ac4b25ea210b8c949c7ad6f7bab4c39bbe875494876d1a0c14c1332c8df1e4241a51dfa42f9c07d218e582428879831c35aa184a332573243c78693e2b0661d3d4fcfb7405c456f6036c6f0701a495a83642126b494fff8301db2f3ca8db99333842e4f569b53d61ceebf3cb64d674a55bb15679358f41d8f77460a1f286de16c19b45af689ea26a3b6a2923f518ec5c646e3503cc77b348af0afbd3c35f76476971c4b9e4fbdd04b0d319d62a910e4982ba4bdc6e17373590745a4c1cc71379c3500dc060b60b54afb996c209fa6aa7db4cad414a821d35a594e717cef3957cdfb5f1cdab3be92179e0610f24d41bbb1b9f20b7dcf1a77ba94862108a1bcf1954450ed7bc1af633528f26a25cafdf2cea49307d0a6a39b44ce6fbb74056b4e5a7f12d48e92fb0272a5a8ca34a9a3b861239d619cabd2b55d61ba6f95399b8005c586c8678625474a074a5b3d42faa1072e9780511ca9fc17482b18a4fe879524770ef6d57685aee12d63c7ff557d49a2395f8a8ad482b2d0b7b577b4b3e6d7e6979a811f7f9c4fa94e192c10721f5836ae7ba4574d582e0e530470b086d4ce1ce54ea0252740981db3f40db13cd4cf99b6d335680753d46035ba10bcf8cf4e2f94267cb09198d193a2738da11b1de8045629d4997c52cc9bb93d43217fd91003b0cada152e673a6eec44f4756b49850941c5332f8fd62d47c2bbcceb986fbe0aa738b230fbf065764101fc7e2a66409b0ffeae78e5dc8bc16b0f8f7db9c39d1ce95fe4f05bf034ada47afd891a7135d879f6c04af6861feb6e485c838e563571b77fd5944c2c8082b6b36dbc41d11321f677c7b443023e4ccd115669d140a4e113e18425f7c563b148ce41524dfa858591a24f9472a0aaca105be3ac1a4b2efb8c5a394875a64205d9a48a7d93dc7c965df55643b64a7260e50b5ad15852203cbe802bf27b2b6c04af3c02c18768065796a47cbe51451528534884acbfff3ca79f4b31ecf15d470c21a475cb6b4fadd05dd4fd99ad3804b764db8acdd3b120e5e483e3beb9f64e71afa2b2d5e2316ab8db965bbf26f4f00921472b8079f0f62352977394bbda45cc39aebd19f48b8f95614fdb5d0c5119abf1d92d2fce1b8f1be152d40eb8b570222dd5c06b0874bf03ee3ecfa2b2a597db93765f127bb0ace13d75f4f7559c2d03a53deb68e4f470673fdf6ec606ec008de4038140a10ae1e4fd3db044d28f391ef2ec3f91acb72257623893994e69d6dfed684739b5067277a51f904089e05f468118744439c81e6bf6bdb0967b5ee027d9275f04f71763eecceb3465071ad858720f0ea17e954db1af24d857d9474a08c8e12b81481e39979d22d5b55509cecfa6b23218bd7415875e8575a3dfc79de1695e80bf0784e173f82b3c6a3eba766f720bf27c3faa89317f2140d62b0e9969f30224ebf773c2791fec7f13cd25fa5e2bcbd4526f73d6f30dbf655b32d86dce43aaf8291b15c03dabd60ae92415ac7ec9309f6c95d1e1dd0b946005b81470623a57b316fb0c1d718eed2a32b3e7b836edd6cacc0d0c9d7b3685be92e99bb24a1eb766b7226b4ba9bf86b3f77c5cce5f594c90466daa3ac132ec63f889f769b5c11c3f2cd024e33204ebb2af03e83d0aa6e5f7304a85a65dbaa8e57181fdce39ba20f256e4ac2b732448db321299e884187a77afd02534ab5bd29758785ba69a8b5f77078878db1f28663fbe5e05e6db37a02a5c0c6cc513a99b4b5b7da8aeab8e58223eea083f799bc18a2cd377f6ad8d9ccad286284e4fe2acd3a615c98a427f1f4bfaf1872b6111904a0de985fd0fd2cbe0dc45c7fce7c12b4b1a31d72cb2c0bfdc82f9b76b960c99f4443d7de9336dd62d3e37cabc9939f16be67b181d7591d60bb13263e68e10012c41ff8dd3357b421205045c8463dbd4554d12bb8aab4fa33ebc7302cacae19db8f5ee3b3b0b9a60cc86c2139b5139ef6805699fcffbeaeed43747a866a60d742f2f2caf224cc3adc3fcfb0b1ae9cbccca43a639ab888a679d7c9ef44976c5cc768336b24907ca196edf1c56fef463ee68f402a21d65419a719fa0b63b9d2d46448261dd3eab7d3a77c89b15f552051c7f5045b1a359f75e54ef17c91275e4208d',
        salt = 'a76c0f4f3d00ed7d923e2a2d5fb5f072',
        labelError = 'Bad password!',
        isRememberEnabled = false,
        rememberDurationInDays = 0; // 0 means forever

    // constants
    const rememberPassphraseKey = 'staticrypt_passphrase',
        rememberExpirationKey = 'staticrypt_expiration';

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param  hashedPassphrase
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassphrase) {
        const result = await decode(encryptedMsg, hashedPassphrase, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        document.write(plainHTML);
        document.close();
        return true;
    }

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        localStorage.removeItem(rememberPassphraseKey);
        localStorage.removeItem(rememberExpirationKey);
    }

    /**
     * Clear storage if we are logging out
     *
     * @returns  - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        if (!isRememberEnabled) {
            return false;
        }

        // show the remember me checkbox
        document.getElementById('staticrypt-remember-label').classList.remove('hidden');

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassphrase = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassphrase) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPassphraseQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPassphraseFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassphrase = hashedPassphraseFragment || hashedPassphraseQuery;

        if (hashedPassphrase) {
            return decryptAndReplaceHtml(hashedPassphrase);
        }

        return false;
    }

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        let hasDecrypted = await decryptOnLoadFromUrl();

        if (!hasDecrypted) {
            hasDecrypted = await decryptOnLoadFromRememberMe();
        }

        // if we didn't decrypt anything, show the password prompt. Otherwise the content has already been replaced, no
        // need to do anything
        if (!hasDecrypted) {
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const passphrase = document.getElementById('staticrypt-password').value,
            shouldRememberPassphrase = document.getElementById('staticrypt-remember').checked;

        // decrypt and replace the whole page
        const hashedPassphrase = await cryptoEngine.hashPassphrase(passphrase, salt);
        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

        if (isDecryptionSuccessful) {
            // remember the hashedPassphrase and set its expiration if necessary
            if (isRememberEnabled && shouldRememberPassphrase) {
                window.localStorage.setItem(rememberPassphraseKey, hashedPassphrase);

                // set the expiration if the duration isn't 0 (meaning no expiration)
                if (rememberDurationInDays > 0) {
                    window.localStorage.setItem(
                        rememberExpirationKey,
                        (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                    );
                }
            }
        } else {
            alert(labelError);
        }
    });
</script>
</body>
</html>
