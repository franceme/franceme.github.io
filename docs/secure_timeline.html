<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #4CAF50;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #43A047;
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #76b852; /* fallback for old browsers */
            background: -webkit-linear-gradient(right, #76b852, #8DC26F);
            background: -moz-linear-gradient(right, #76b852, #8DC26F);
            background: -o-linear-gradient(right, #76b852, #8DC26F);
            background: linear-gradient(to left, #76b852, #8DC26F);
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>




<script>
    // do not remove this comment, it is used to detect the version of the script
    // STATICRYPT_VERSION: async

    const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 *
 * Mirrors the API of CryptoJS.enc.Hex
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassphrase) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassphrase
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassphrase) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassphrase(passphrase, salt) {
    // we hash the passphrase in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassphrase = await hashLegacyRound(passphrase, salt);

    hashedPassphrase = await hashSecondRound(hashedPassphrase, salt);

    return hashThirdRound(hashedPassphrase, salt);
}
exports.hashPassphrase = hashPassphrase;

/**
 * This hashes the passphrase with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(passphrase, salt) {
    return pbkdf2(passphrase, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(passphrase, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(passphrase),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassphrase, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
    const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassphrase = await cryptoEngine.hashPassphrase(password, salt);


    const encrypted = await cryptoEngine.encrypt(msg, hashedPassphrase);
    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassphrase, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassphrase
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassphrase
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassphrase,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassphrase = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassphrase, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassphrase = originalPassphrase || hashedPassphrase;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassphrase = await cryptoEngine.hashThirdRound(originalPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassphrase = await cryptoEngine.hashSecondRound(originalPassphrase, salt);
        updatedHashedPassphrase = await cryptoEngine.hashThirdRound(updatedHashedPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassphrase),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
    const decode = codec.init(cryptoEngine).decode;

    // variables to be filled when generating the file
    const encryptedMsg = '23bf5f30a75e900a2b7ce2d21f8c0149d6c54224cf904e6e9943e6d630e587a1c6213a6dd8506e7528dab3b5ae9c503718856c62c248f1c9a375dfd5452b41fc302d38a693f67e6970fdf8052f5aff19fbde3926426b48121d4206618f3f5b3de6788c5fbb03bf1aa279f59e44fee348251b00293517a3f162d91a36044e89f884017f2a0cb85373fa81bfd07cdd4b82cf20ade5d922f7cd46740ea80125cc377fb4fbaf1893b28b7ef6fa39d699262428b2fcd8b5319267a2953f2f63a1cc1d0df91dda7acf9e1c9d4b6d529193b97a66a65c3ee88e51a1897c76c4efb87103eaaaa1f04cb03217624d5a986f881274627a4189460c74f8fdfe24198d8ebab7d68a372baf25137ae786536811855c21de1b01dc993a47a0511c0d5eac4be01b51d118c5f075ab8c96e62c94c091fb62a4ecb2a2491ff8506a62471997fedbbc7f13a5b6dfd2a684f86473726535662eddbda7f6a08014e4be95ab069427a421afe078b27b9ff1de23c7444e63fccac38325879276c13b2f7bbca6c1f343bac1576a378df0a38370c8776fcbf282642f4aca80600905d17a7d39a5c1e805a0ebad89038484cb2e27f7206935533ee8b5ce71c5971f1b4b108defd9b817d7302c0deb020d591da249312ecfef9b4d4905ad6d774dc1dd2b33709a44c7253310cd0da9de5a139894c3b03125702618b0bb3bdb00a0d482750ed8d308ca36c85f64d7d466f6b0cca28d9352e55e4b667df6905214d2eb13fd9c1f5bb34ed3e07b82e0aefe6afa6b651c0dcc788ccdefad233507464bad8ad562ba5f6fc28a270ec60f209854da604760500a0f8763a09f10bef292d2bd09c73f2a72480e6455d5461b6d97378bce4d134873e9c308c89bff89f4f33c32ff5913351be74a6df2a5adccaea26c976910effe467981f821b2ec72c41c01e67d28ed13dffa04f2d16fee24e504a5d6f87dd726dba19a551b2d448fe310e916dbb77956831e45dc392c820ff9451ad854d4a9d2cf163200ad7476813e3a88404e490121b84ca7d676d9a0d643f38da58f3f1d96ce25f3c1cf7c11f7688e55b6dd509106b1f07b21c76c798410475629318adcae49521e2b143a2867a661a4e449df61dedcdcf55685ea85af15898e13c3aa795e92f05b3e1f3b3266d202db1812abbb95ab929b48e08ce419a965d78b028cbd2ad7da08623d882c9393218bc4e3c5dde9580afe63c931858bb9bd1097a6489967a943ca0d22e73275dbb1b9b6bc95fa87283f46ef402eb256d3d0ddcfde81123a7a7965c0d8586ab3a5f378ad8669c50d4663189116f504621f3f69a81bb57d824fdb082a44411fe7f7670c36c63c7fd46e0ba9f96dfdc3210845707b3ab47061577a6ed0f06939ebca0456674cfc4eef3a231d2765ec081e20e6751a340e15fbc25e09deed2c92c6b9dd2ba4b34c5906ed93a612b341815a4255c14a5e12070c9ab41c576e6ed89ec4b9ab87ce09670e0e9b8c6538eafeb66877ed1a63dc327bf7932101a842bc4bc2a4b866a2ae2d2d51da59bd059a099629abc3959620a80853bc8f0d4c19300ff0a791c42746d327a6f3a39731c4539d25e74274fea0cd0ac5d6d38eba82c0b3bb5e29dd0ccce92b288afea8940c180bb073a3cee1485f68c97187bf11b03a36d9962020beb7cdfc3eb47f9a37a131eeef3ebeb5e136ac44ff7fd981b155fae050c6bd934fd45858fd525a75777009431067c94c2a5f785a9c77c5d8b9b8a73ed1dbe1db316a03307f35382920f25f8ecc29582bd914c743211397f22ee94ae19e80bf87525e2e37679afe7efd4b087410692ee433b8515efaf952677b63bfb118f6f9c751dcfdf97658dee3a06dac244d65f77390b65b85e84c58bebae0fa6da807121a82f49eca0c2216a1c08693e47eb6474309f20b70bed136edac9f708358373c1d1415719b2ce589d45d269baa42d3a25d91c27a5e56a19b6bfdfa43df0b31df3c2fc0860818422618855d09f38840f0cd3e627e532cff285de5a2f3abede0942eefa8ca1d7774f4c5080a6b3a9a04dea9cd0bbfe8d5cff44ac87a16b2ba48227b413f34a4d45369a3d23e2c8395ff022451edd620ab362204fc6e8a4981650c0403d8c729259eb07a4d47d64021338b9804dd4dbb82d5c2b8cec500cb4ca8cb587bdcca426c7cf293d47c945953a4b0182fb83f22100cbf842b9ee4270632b419b04bfba64adf99d0f14d6a74872d5e6e28d698bdbe41368181e74c4d1e4e00e0bc3d889a7579c13618a47b458015fcc7abfddeab58b1b080d7779e23899d0fdb8579b7f0848c352c658c37d06c1986e1867f9f1bb8f0ddda659c91f010ebdaf9f0c2ef112ca7186e814c1381784356c64f00207aa1f642358c510317d0fe33a52e6da0202f86df5dc2731e925fcd91f21352665bfbb43cd71324d75f07f67b6a93438870c55441cd34298cb069b9a76591c53b0f99f21b09350f5ad1288c3bb2bf5479f23ab2b193a5a404432a7b307c8b032d2de8b933412a704f834dd5dae388e0827b0712e11d8a9a6b059624b681292a72d43470155f30c2b024a7a4421a16e0a90b19a09fb7a61b858dd93f05935583459d5e92a6e1f95fdff1d066a9e427615441789d7cb67739371738e1f4e041b17a6cde0612b062b413e7a7d7243cc61f8ed1ba6599723abb4ca4e79baf21469fd364ae35d6f86ad4240eee9888267829d73df4af3f9da663787ad0c03d4c20ea8273eddbef420d032bda368fcf716c3296c55b04b7e1af7b4e99821dfa536b6ee91a0816f955b1a058a2de087e6a3dc91fae19d658df98383ce2a88d60e78322584c82fcb0e9b825080b6dc27e262cd5dc69627c72a9ae087fc73631a43e8d37d8da8a1297a9feae26eeb816123a1fcc886199696d61f705dd7a19c242b41b1ea387b38d3a2dc121d8dc8ef60ba37f2230626f7c6f785580af863354136a54598d9babb57b46e5d1e0ae14561c43067ce0d9b9f6ea1a0be7dd22852c3620384162498c36fe9832bfd54d79be006f7ae9ae8e05890d96d3e78145fe9b848ae812a6872cec67bbe11c29b9ca892d017b86fe63da10d0329568bb863727ef8ef7a13a90b840ddb460e112122ed873d064b43e1efa10f8fa1352d103145dd306b73cf652f1a59a80d12deae9497a3882aac3eeb0d95cb14797c5e470e1c9d79c3d909977e0089746c9c99815aedee0211a037beb7f43fb921b04fe7a854cc6cb9a757e179347a9a0d9d46e7b1a8a0767371a88225c71c9486112cfa215bf6de6fcb22495862809b3c7e1ad8775ac022004d56e1b490ee6399bc79ba72d5088e0392766e04ded68756eecb93cf45c69c348bf7b258bc6cb2114266ecc2beaf6b1b48654268058e8613a92d739a9e254c024a1d197b1f41e3b45017f2b2eb8a066cb1c9f1e1ab49a4745aa3ae7c62eff445a403f6489a2bd15016921601fd041e423ab4eb79a624c6e6905731a0bb09e82b2be31da2d35311cd0c857b352e8ca3e8445ef402f3f8e7bf7620f794b3263e271f5c9676ed04ddfcf1a7d99342b78feb50b7a219f9e77d2d3e0b79502153fbb385310aaef2db0e84bad6e6e73be86deb6e8230680c9d13ac8086b0c78067ec25add532931a6bf654d3b2d0d2d609922a44f7d3f4e17d39c5244a31a0ff2ee7a1b930550c3089b6dbfc12ebf4b850f46586e374df1af71839b32d7bfa6b510cbfded20ce7481e0a2c3f6ba5ebca14ad6b30c2f21816d5ab2a4a4d5d4852625c9e73b2152880e47c96e23dc8f3d4f701350538ed349bedb0ed7e038e46e713b5f010fd92b5c673a33b7f1ce2f480a009b07a6afb65e1daa5f92c3bd067dfec948b69f1c4882b09e79a06ea834bc969edf79878326cd8481b87c455300f8e25e87cc3b8992118f0969333708e8f65607ec95eea82a468568c8fcc6487b44df8110b33b851f7d910e5befae35f6a88f80aae68d59765204e1bc4d8deeabe541ea994acd2482b674561169a5ceb2133a7b57b05b0932d3af23df6953afb556951da2bd25a4db672fde759ef38f6cad22b7f44fbe7f1c28c6f1f6fe53fc72bd6b74fe58018703a45338338fda1faa42fa2aaff1723bc85d37f59a57cc48e30525f1c95348a346b85fe8af65f33b3c19bbd1f23e749df9e815cf436c1ec4c170b595841eae53ecbab30928b369d9bdb76a40b7f40afd5f7878d5fa5bf236992bca62809964d250503b77cc31129227a9e0e8a15ecd661d0842548ddd812d67e7b21531abd8b656f9fdf0b5523b9eb397d7e80a66816a5a2b3b05e5861a36905878b22484a2df721f0cbdd7045286ae6ab616bf942a0c237104bbdcc1d589341aea61c49d497c61ed88831d7819d1507626a63b6d1415fe44e50da3fb414c4d9cfcac0f02af1627b3a63284ed503a76bac0c55d254289b7b1607e0ff61c99bc888cf0f714f2cd77ee4b77b0f5d25a7ecf72ecbf71dfebac2caf00af93c30c13aaf68446f5b5ff9ef0e2cc6820a1e011d3e25f43cbe094d24c10d69de60b18792aeaac50f479cafff0dd8807bc57e1dcc6d08bb79c500f029c5dccffbe916bf01f29a6b07b8aaace032f5081fbc6eca9feea6e9b4b87a36f123d1bf36c99a949aef0a4bd093a58e8310f730ecafdc028735aa18eed7492918d8f0ae05c673f92f449fef1394e4f2c662268516e729e2343ec9522f22d5625887a33097bd20f9fb302a5d7b86f1e4df807a2e6e5030e2037d4d587de1be54514525db6cebfe4835562f4323d05f97ba078539cf80ae9c7a8c43cc6ab06cf778ef931bab2710a6741f9dd0b4f0302bdb6a40525441eb9c59b417bd6b096509861b171e8e396aa505e8824412a758fc783658aafefed9e592f54b9154e32f1fcace574c8199e0ec19f5d3c0421ad4f2c995e52da7d5e2c5a333a79df2609c44c8a57538061d1d9e71530f7eae2fb9bd9d301d15d3ef97045a4dd47b34de0666b527178d258847d035af3f3d48c0cc644ca84c84437756e201e7016eaae6d0a4c04c136560e09106dcd89cf7eec79039fb2571510fa73435d229c6a9742f284f6b9d75658400c7db34985b668237fd3420529ae22f8bf117c783db331505cbdd89c5277e4f84262bcfc3bd5e8c01b7cba7c09c1cbd11b3214bbcd69d2d6602eabfc2b0930a865224518769a161b24c4515fd933acb75c48b317d0d60e5c9893484e8dbfd41dc526080c7d13c216eddcdb8f3aa3bd2cede66836aa071a57608fb8b594879193d53121af078f4fa0cb63e3e1ac951014a08216b1ae60373921e488e8add3d468b9bb354f514319073912829a989b154e1af5aa28c382e318072a74e65ce31a484d160bf7d0aa2d2dae12559c7caa87ce0a34ef2070cfba614214f0e95c06a014701b727f2bd99f33d62019dc23147c9da8649c6607c3647f02f3b01e89b551c9c7d050d23ef365c0e621b1fac442cef9298bbee46aec4d4888de7cbdfddf26d9f77fc4bb339807561d2034645e5a3b0fbd6532c9031536ca9be4319e74aa23de36409813e1ef0d5f04d2ac787c2bc080006449e3b1486d8294609402b1943ea30baee844a09e0ca5daba4acf31d17bb1489e78c1fc8e6349faea265fdbee661add66bd403aa3d65f100d3b551616cf623d073722c27aedd828449cae06afed2f477f55f307258d8b9fa41657ef3dd1870ffc405cb8556953fb444a645518bfad74776ade879ae8ee256586dcda83ba4675e3cd699707385b8ea7ef72fe5f0a2d41493c91bcc0de421758cc6e761283359ceaca79afde4c96dc48f7dcdc4df5d7e7641c05644ccfbd35c29b27749cf394503701993e945356ef4065ff983f57ccec0f6369cd50c80cc08d0fb14041d064f0394a5fd9c1530e0c0bc39958b5919fab71337e5183fd47fdb2b9854bc29ee39963e4b9ed9829bee1975b95e06137289048001d89cf4e078b72302956b80b724b860cfaac009987bd6e8f8a701b7bebf640edc329be8c80b3941d39becc2f633765e3db376b2ce6b0689f4874a4ffb62892328d69fc73fa91a4cb889acbb4526ae6f9649be2877bc5a3830f361ad00a6ef2ad4906175be6ac3d280fc4b0672d71bfc0cb0d0dc248f3b93c953d131e02b6ea442475cf2c141ed5c1d872e914a93c059bb0011c6deb103a2ce82e62a9636369381139302a074856da041705d9c14de0fe5cd28cf8aadea0b585218c5de3f614490a9c187a3e09b3840f0b2e6e721650fc499cc710a8be5b268aa05e7497203d0cc421558636144b2b5ee898b709aa8c5de28362bf318bd89cf9f06ec127944b2c1048b70d76cebe0a08d3d0ed778c1ca61b22e01b4497a908feb93cb031c222b875c40eb0e84cdb6419e7c8a734ade3ace26eee32602780ec55ae3452942419375061233877ce267f1c90408cf7136fea622c6dfbe64fb838f05478090c3af5303905511f05ac589c9be82303fe9799fbc3efad3c3c35da72302364eb8bf4aaee1cb238c89f743ce149708f22962093ec13d36b0bc04091b34993eb68d1375f16c0378520abdfb4be0fa9bf962e2c684c52755319e78f1a9e6a9f539b55b7364a7b37dffe377b579a71309c1fb7bec70c58f0603f2f3477fb36f1f25bc31a8162e97da699b2e6dc89bd0613eb8f8f654b1bfe44db8b2a9f48acfb42fdce60b6f58c0d58335b8e845317370cae4ce98bdbbd38a8c0f8139d24fa13ee4a49780d2b2ae70bec13b07db1356516cf2bf157ef9979846ada17fe708208797727e0ab073696d1c5c8c535f50b5acaa26caa02f1cc2b3fa01d9aa243742b1dca60d1aca6c4bcbb86369114d2ddf4ec375af826fb69deadd0dede1b914e038af1e76067239f874a6cb6e25d5f6f4f5944f4333f05dc8ce08b5ca3a7a35be03a836917a86fa2c65ff145e5274593f76fd87716f023a6643ecf33a918ce35ff3b9ffad7ebc43c04a527c05936be205beaf115197488cbafc82807a0f3727669eaff21d80740f07f0e8ce8c10555e81f52242ef124872b4ba64af542dd4a79ae7d665ad73d044ba7a1d28269754253434443e4c5155ed6c6abb5f0adafb06e99cab355dc4d505e5ee83f0d777dca5a6adb221efcc1413b17cdc5f1bc826c6f49db514a47ded4fa3b1872b7457abc774353c28fa29074643cbabf3e7ad16988fb4743b451edc4ee735bae10cfa08be70ad306870653a12747bab50b287880e08742386f07ade2acfd468d835734d890df26b3067401758751850afa2158120ffc4099a78a567ae1df7a9fda524ed01a3fd6c44df6c20f6fd2cab6672ed83b3559662554ad4d0b9efbb2b72742bdaf7efefd5c03ebcabae3761b38a9ebd7d091d6b8b02c1804fe1b3d7b376abf2e9dd7cbc3ec58be90481cff5db73d1ead0d90c75a8c50a263428422f299ee4b1618d66f9b241d93a360d89950848423028073bfc923a1cce64f2efeb4abda8137485dd3c8d679a4776bb41f42a1f7a1d51dd493ff6362e128d939554e4b61162e05fb8bde384a9812a355fa4e861246af28d3eeec5ccac95584f1427ec04c6e7eb1b096d127f654d7c67b5eb47ff17b5d3db2a45a48ff3e29b89d21ca525cab9a6e6a6da01adf09bf1b0e2594bb0b1fbf3c1a32560e2dbb8c5c972536d9570576a2a14c9dd4154ab952ee9108077460e86bf097d28b1a45f1ca86f0e0ef1f223bc16c8ac41fbde3504f13607d03283ed9619eed04e7bef9a5b86dd5b401afadabc5557382bc08aca5b416908d49aa65067c2aedf4147ac66f2f505da7d6b4bc41633b5120c9f8b5305c9670555382e7498ca38601ca08eb8d9ccf4351dc05053b0d9c21758047c3eb9147cb1f7473349f69372ba2710cd5b817c5b50acb9f2f75800298c4ef19dd0dbaefb70a042cd448d7140aef6d8faedd0c3b35f656741dc93d305110c717ec02d240bb8d5188b9a58e4d1c7edc201164ae7a77e8ba8b57f7f018018b6f4b14ac603f2be6834085d73f927f408e5543c4fdcb2b83bdcf14b58001c8578644ecbf1624ce504cb0e86de861ba4a10d44aa265eeb669fd9a32df4d907485e4ee1438faeda936dcf588c0b03c86c68a7a89ca65326ed06f18c90873f1f2324d2431ac4360e09f876e3c710ea20a0604a8818d28aedcf15723ccb89380c7e42b49198ec9dd01927c023c1c6f3d4046dcbca169ab0ffeb9f2271dadfa7ff8316028b318cefe2caa5d77151da6d1058ff7b09f0476d388e22cbe328bed7e9844981e0ea99b18e8c8862fd4fe0f40387b3aeb5f4a49b164dd60a195a00b9cba0aa5e047e7cde32c68cbbf6f1dd0639e94058478aa3ad9d559f245288510697897346ef9a21fa89b33e76605241710d2200c0792686672b4add2397ace9f208e0b9e902a04136780c26da47c6a2731e7dc99a5e7530fde1238145b4e3b2dfefe1a79040d59b58f3a11489954221555b49c8c5525ac4e41cbd827812b7de943c6df548a13380bc5cc5640238e6b97281091ef257d3d918556d5e3fa87fb1c6e3e3af1a9f36c890ecbdc593edfdb34b33c9f2d508853e0b56d6cfd41a331d46ac82a0da44723699bb039b8eb525688303119c5c83eaa13f251501703b9cf2212c85c579143bfaa20460b4ea90d11cef08df5409c98cdd3c5e3786302bb44d78050cc6e3425af18fe591a8045d373e052e3802b031107dcf450dd819a458ef263a780b82ada20de5331155b3da4aafc047852eb53eea7ead01846228ee632160631d3556e10f833b9b6905f6105899f4ae4ee400e8312c0d2f48ab72efa68f87a72fbc1a5dc954d2a1b203f290e70b5d576d8c59026b668a9f307ec0d8bd64979e5e685eea3c2bbfd91ca403c3249cc8c96b8e21ad5dd9d966b322ff31c9a98a10c514d8ff3e5bdc9e75a1a43f0d698c38a0ce4e085a6dd0fc1989eaf7632696e536f7066caef391266f1e854f9167c002e8154e971ff8263d83062c6a89f209472de6701cac7fc8bddd1d05c2fd2037dd9fe29ebce3cccb1a05e0c36156b9257ddb88cc95463316708122bb799bef8f2b2054a053239787b25c5ba6a33ad42895eacc30ef0d13e0121d0a6e546ac50d139c6580826c99091295033b5196765fe0c55a9aa992ecb9f7e7666a2dc469a6fe41ca1237048f74e07aff4e3dbb61470b7570000c3d0e617a80f9eb265485ecc18d9291b475e11848239abe8653174e0271947bb18076eb150ca869356d78619dbb94277c91f2377ac276e9cc20aecf465e932ee2ff99e9fc2c16019673fe15429386276345c37d79df7084b214d7afbd5ea87034cd95184650aca65cc1378ea7fbce53f6545cd27fca6ebb7d8ecb2d9ed7dadb657f1c52b610b6e8c5f89c36db5e573de85a3838dfb0b2860092044d650d667d663fd8005160053184febae3621edf0631c9565e0a2c82ab212086845c248ae2bc1fb35e4fc053b88bc820de6bd7ed3ea764ed2a1da22465cd8c83370e29586fd9795d8913f2b411edcd9ff92ec3a279459415da61f9d00560f930f4a898201adb9440f65fdfa31b25bf1d3fde78d78bd7e0585d62abdd75c81158a3b82874b4b41d9d60f738c1365b1847b9a9b45110c67c7325ee866bafba0af61801afe4c2f74de2e1626e7e2b3e40d18df2a9af8b607f4cb4a6ef1a0e8f6d058dbd0d38be5bcb9ac5e63c9ac8cea34b704a2e017317a0730b987d4584573d58fddefb662f53904a33ef28cda4b2383828590228f169784f241e748f11037819cec4c02305fcdc6751a32cd57e6fc925d3214e9d11aec8fd6672653cca495510085b824e88055fd8defea72684c36f50bf35c2aa38e70ae74a3237d62a25577e931456c3c98627c5daded69e543deeb433d375b9c4743b4ebb96c99dfa830c3066507e62ae4367acdfea0606cee43a6def1eb3a647e4343fdb9e292cef46438168525ac6f64ec56c8b8605b02b37c74b2c24cb9ddf439d604187e026c6c57149febdf551529adf46ace23222e394e222b21d8087b6b1887880ccb660f0582378bbce7069372257b8590e3179cc054b998970ea5710a1ee26ce3e760c2fb915eccba582f4df7d9ac7e9a0ea2af486b2bcfcaabcf0c12085cfaf9fa345cdf463a448361190fc5e4bbcc1542231c87de362c9308a12fa4584c5819dfb3ecd0380b554767ef22345ab00b7555e10ee783eac06388d198a8c32d438e69bbd74d25f5b8346ba353f6fd745de04c388c42dd53a25b76f5bd97c3e7effc9dfbab43f64261c94fa7b82f7d3b087e52620033ef95def3ccc56f7b77dd921b2a4de82debe8d0edbefb3df9a75f743011fe9d6da92ccd1996347b82f95fd15bacb8b569ba51bfbabf716a7bfd76b1bf609867b2c2ae0bc38f1fff0d7cf316f20af23b250891f42298a8cf5e176d51eaaed818779fc095b5388d8f03ece961fb4a4a0f311ddc900930cb4a47f4114884327f435c61f1a4c9277b3fdad89b4c540030cf3b700d016cd9cbd6dc92178508ec675cfae7d6b6ab5345ee4868873889c77b8442aca26cafad1fa4900128332a45145195477583f1a47c2a94c4f0b4297861adab617b762897650dd4936de97bba6136b2adfaa76abac7cc49f6a6dbdf1d23faadc939e18981c4833c6fc0601924a24e3bf72d025a38cee1b48bb9daa00a3a86ca632d441d26207d2703c988b862005b2762bd2de356336fdcef33763126ab56f5bb48288e0db551a9382a33c95f78203fa117b8e2bcb3a56ef341221afdb0a7e60eb0e0eaf24cc610b856de24379fe1bbc32d2ac01fa66cfe0757abab9368a739d6dce889cd93a3a5720f9c90fc0151512551d4a66255161a1527a1d5c94fb5c08e5bf606e342bde7aa35568de574f69e0f60957378d111c37d01417f4a840db804e64385160f7a37bec36866cefa1c5f31f80aa77810e4bd6b19d09858a833c898c443809b7c81b28a886b0f0cfb6f2df69ece248a2995d0debbb5f88b0c42fee23f1c5fd5f4373b77efd02bc333dfd8c8a114ce50d4256089d701276051a188765199f7940bc8c0e6ea1ffad42a3160c92f2092a165e74068b4ee0bcc1266b3569f5e587f1e4e972f8c03ffffc8649269ad30f1f9dbc12a16441d4142a017a0a6692da8aa85d00c80199639a6eb106b9f67b6c902c048ca5ce541c1ba8bd7ef30a6070a660995147a3d9124465ef900f480178aa02b3e70859358a2f62e7bc84b3eb3a74813fa22f92e018e21567e8e670cdc06f5696e3532cce3b800882167577e00b61058f252fd809418fd4866fe2d7ca9d555d534284b8992f6210f1856e0327dd867c20b678b200160ad1cb494221f171502d288f9887dc927c152076b9aac17daeec79bce4c827d0e6494ec22b5985787db8c5e14bfdffa6db36a0d47c82d935ec3b9740b2c1878b729115591f47359b31803785937e13f483e92441f86f9740ec812101dac462e877f0316b0d30eb096496d572013c6952b896b3b1fd35bcb6ff1c793aa7f04369b0e151aebf0867d68a4d0aabfc3041f945e1fe0a108c52b57214f0dcf675533b9b534d06abdff43fd01b4080f60a1a8176ff496f0df1e49a5248cb76b536643002df66446e389b85a037349f6d66ee4abe4619dd1dec5a2a3c3a2621b3dd693a7a22f9a3332df1e82db615add1077c3dcd6d98cc3a2389e87a5eb20e34c55d14543ff6d460893669db989898358a3c9456c2f429af8591c6967bc4250e75af28cfba0cf43ca0eebb440531df4ac2eb245e74f9ba44c97db8cbefa02b6da21fe023857087cf0d3dc94749ae290dca0a337cf34674ad6f46d593e9d4f7065f6b7f414b96c7c3d6497a28f2097a66403931ae6f4daf89412754896c684aed6e8aea3b713746a5f668d92ad4e818b23e6f7cdecebeaea19d642df6bf0b7aeaf5b03a15dd9e395440138495252e682c1c4d216ff9d84ebd49bc81f9f0bdceb8374591554816d6959ed80b4bc981313ae8a97cb191bc04b2ddc5d86206af986dacee25410fac6a2d1b014fc84cc67cd3def211af2130210864037f77eccb78fde73d5f1ee968c8b1a80ad62385542e5df6f90fa1999ad9feaa6929d2ce1b5380c17c74ab3116f93105cb09806a3fc21f363a45a62acc411e68c48507b23707f1cec57ecd88d9de4006818ceb1ddadb2ad0c77b8735f3b238acfbf3edece29d6ef8eabaee606a84db1f9d980b6e8e1a2ee4f544bccb24ccaf8809fe60262b2bc2ef2897c41aa6876e48293f5418950cf732e999faf0044cdcdb910dfbefcffab27be99b1288a06a595bcc6a5d37e0fb7763760317b0e5314680d3b65c55ac3f94dcd1c86ebc509deee5356afe81b8d13cf24f88110ec22c6d59c5bc8e0859f047d648a2198b45579a6928b66f676443cedd506564915b5c27469477c472aed40692370a00ee0ad9266c460cdc6ff35f5230d4d7f0f052fc62fadff42b4f8a338201dd8f3f9c72868505148cd800ab1937eb4c3b6440b4810170f24a0bbd504c188a11441242d209bd4196d840128a24e6e8acc799c9440800416120aa872744b59d2e98f61c96aea97d11f69c35f07b0a95fce9bbfee29e3b7e9a3d98f967fc2558cd7ccc92ed338550ca81918648a4d311961e475accc8e5bbe89dd8bf922a37c52206e63b81d351dd46ed5e778a30a71457f941a61fbe75bdb51f448bf58fafa71286e1cf59fff4ed108f7a461d2c660525ee7129ec766f270972cb5389048ac420b1085dba243fa5551784bb4c5ea07adb64f7d91ef86036ef23b285f81fd61f8ea57fdb6e7c73d7c19c18676fd06f8a0534889918c9718b78a88e2a7ca3a547b510a6e8fbc35f03fbe66c09045c894b836a79047bd4eaf147b3122e2c18be8de32fd84c08874e15b854e430421f597709ef02e4d0dc3ee21868a2cc7c52558b9e186809fd616b3afbdc12a6cbd142ee95b88acba4b24e6f2167be114827f254962dd51eeca19dc6864b65794792422d7ef3fd1baba550ec04e1481fdbf8fc30228c2297cdb25d4b2a6217df437ff7c6ad94cb3d8572a4ff451c2bb64cedba059029206d5fc1d3f01f740684c9ce04e4572cc05b29d99482b35184a148a76f44aa390d9c0b3ddb025df00629114d934b90b20856e5d0fc0ab14db27b62baf2a160e998faa22924e56746d06fa1f93c5fdf374012782cb920702c84719c5e9244859d35e7d10f404943d73e515c989274951de739163935fc754601c3cca910c7a10346765559274e2ace46163e56037a6d3b7f1ea831b48c85d96da023b856831cf2a2b40c9a608231826c8335ef8c636a3bd68c9359f8b7799d21d919bcffadd3edd88cc2c113294126c8453050cf4e40be87e88a804dc5b0901be370a62243bde0636433e0941e3f3bacce3760a3e58baee1ffe0af50eb7626bd57afa36af5fa5b9aa64df5ef1bbed4c540ab47ba07145379cc33e0d6c7574203e5688844bb42764aa2fa6227532d1545303e68a372a4c9b5ecbedcd71268e65d7ec75ee762e2313ceeeba99ecbe7806cf35d93e59a73a83b270c30955027d12512b9035c11254cb2d63d4a3fd362ed7380922e3aa3d15d8df95a62279869bf6786bb80bc26b4410ad466d1135f57a170b3e636f817acb5ea43b1c57e9a29dcf64c82f7fb26dfbb0abd44fd4c4694f22a75081f7a2c81bc3d0e24370866039967839693feb7f77a829fdb2ea0f31ba0325ed20fe62547e2e76381dbac3d44e92c96fb3b3dcc86c10a33c0d7778d2bc9da9266d9f487b136f3f9d07009c78b9bb206671a98f54fb3e989d9457ba0507b083c79471397e671b86d50debb7054f6b2eaf34ea8622a17f163f6c17ff89a1a5deef4a3727fb7fa4da0432ebc041bc5e9168b8ecbe1c28ff642daf17ba194d8495426cd1e7133299537772cd2b624276c2647d8c2db7ac1203af8ad0fffa29964e6ac5cd8b535b6a167ea070ddb02063e4bb03cf2bd599dbb32f02090985d4c9f7be80ebacf559b2980a680453973ea5fa21664babcad270bbf2a25838ccafa9df28c1352538a9f800b4e29daed095a302d818e3feccef4497003bce8d9b8a0fc8f24135251d27170a0713a79be7d648e0c11d1a4d0a109207eb6819cb75b8edc0c48cd9e45bc45e9bf7442ff0f9ba929061b49f4a91173eba90aa35f7fc0ccf61a2d52c39e1b5fdf8f7385af7e0dbd75fe04d70272a08039211c6088f1f660a652eeb35344a95ca9229606b6b28d7e699c81976bbe98ce3dfb2e7f586439b92c5b8c999b7c108dbfbc2ab566db7120ecec79771372f68596b2c4f1e564e2bc8453a6985b15ae653471ec284c801071488ce05fc7061541aa8daf2826eec08e70a3ba41e5bff162d4df5066ee7e251bdb98e44242b35b46efa1b8309189a6ab7dc7c7be1021bc838efa448746143cbdd5760abd52eb8ef8126c76bd8713663fbc0047eeda3870485a709b19b5fdac9a9cddca8e9bc4514fd9bc677f5b9df82bf7d9881ec399aa9112a08b302e9c7486b1f2297ea89102e86e550f59753e187f7dfc483857d4dbfdce514d82fe678426d2f2cf5652b926297284c36e1fc2fed1c3df1e6fc9c1e552d2e8509e6d6369d330843c378294e225fb1199a220e4b892e25f849fab84cf67dcb762c1c3b255bf7c5253895a064c8d273f0d47dae7d12ffb8f06d85284e83703bdc5b199436459de788cf2217de50bbc370c7f87af501085314783753179d609690993ea3a5d695a6fed66a88ce93c46bc5d12fd829f37344c3eb913d6e20eab8f2aea338f32620aa134e41aacce799811aca9cfd121b0508f7fc703a69f65bc5bdda02e11375f95e7af690ec4548d21ecd88ef9d8a0628b491bb830cddc19fdb9f8b2dd5eea9943767748041d3133cdced21bc9ca4ff2cf32d08f73b93788d1fbbf31b1eab70481fbbb3d1579de0664a358789c7af1c43a4f28ad76e6b0f4e62500247a2603584e11a0e28480265e95ca0e1f725fe3875523b6d36440a04e8e494aa425d2ff3418b5bead312a3199a84776bbb849f030680774e4fd1650ca34f9c82d03384da960c3661af2f9076426466738f8e38754f9e7f0a6ae85f189efc9ce68e211eb4cd625a5933e2d62656b96c6a22a1829d83df75f46d519edcfe44a6aa3ee0e5e34b2630f6c725cd6109482948164015efeb17d6266a7f0caddff211accaf7a1fc16396592c253807559bdd5aaa4fd67dcd22186929fbb57078fed3750cfe5d6efba52f49e85611b296a69fb6ab324c27d15e15c808c2b5cdf46b3002a11d8693990befbadb920b19e9b9137ad7dc3a1d2f89883ac9f1d82d8b3da39c8f23d7cfbee2fd3d31cbd8c9979c3da63142da512a34bdc4403955727343988690c053f4bcc75bbc51c40192580507d7dd04a24296794d97645fd88',
        salt = '3602b7a138db283245a9167f44b8fea9',
        labelError = 'Bad password!',
        isRememberEnabled = false,
        rememberDurationInDays = 0; // 0 means forever

    // constants
    const rememberPassphraseKey = 'staticrypt_passphrase',
        rememberExpirationKey = 'staticrypt_expiration';

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param  hashedPassphrase
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassphrase) {
        const result = await decode(encryptedMsg, hashedPassphrase, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        document.write(plainHTML);
        document.close();
        return true;
    }

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        localStorage.removeItem(rememberPassphraseKey);
        localStorage.removeItem(rememberExpirationKey);
    }

    /**
     * Clear storage if we are logging out
     *
     * @returns  - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        if (!isRememberEnabled) {
            return false;
        }

        // show the remember me checkbox
        document.getElementById('staticrypt-remember-label').classList.remove('hidden');

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassphrase = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassphrase) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPassphraseQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPassphraseFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassphrase = hashedPassphraseFragment || hashedPassphraseQuery;

        if (hashedPassphrase) {
            return decryptAndReplaceHtml(hashedPassphrase);
        }

        return false;
    }

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        let hasDecrypted = await decryptOnLoadFromUrl();

        if (!hasDecrypted) {
            hasDecrypted = await decryptOnLoadFromRememberMe();
        }

        // if we didn't decrypt anything, show the password prompt. Otherwise the content has already been replaced, no
        // need to do anything
        if (!hasDecrypted) {
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const passphrase = document.getElementById('staticrypt-password').value,
            shouldRememberPassphrase = document.getElementById('staticrypt-remember').checked;

        // decrypt and replace the whole page
        const hashedPassphrase = await cryptoEngine.hashPassphrase(passphrase, salt);
        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

        if (isDecryptionSuccessful) {
            // remember the hashedPassphrase and set its expiration if necessary
            if (isRememberEnabled && shouldRememberPassphrase) {
                window.localStorage.setItem(rememberPassphraseKey, hashedPassphrase);

                // set the expiration if the duration isn't 0 (meaning no expiration)
                if (rememberDurationInDays > 0) {
                    window.localStorage.setItem(
                        rememberExpirationKey,
                        (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                    );
                }
            }
        } else {
            alert(labelError);
        }
    });
</script>
</body>
</html>
