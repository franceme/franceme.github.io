<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #4CAF50;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #43A047;
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #76b852; /* fallback for old browsers */
            background: -webkit-linear-gradient(right, #76b852, #8DC26F);
            background: -moz-linear-gradient(right, #76b852, #8DC26F);
            background: -o-linear-gradient(right, #76b852, #8DC26F);
            background: linear-gradient(to left, #76b852, #8DC26F);
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>




<script>
    // do not remove this comment, it is used to detect the version of the script
    // STATICRYPT_VERSION: async

    const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 *
 * Mirrors the API of CryptoJS.enc.Hex
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassphrase) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassphrase
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassphrase) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassphrase(passphrase, salt) {
    // we hash the passphrase in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassphrase = await hashLegacyRound(passphrase, salt);

    hashedPassphrase = await hashSecondRound(hashedPassphrase, salt);

    return hashThirdRound(hashedPassphrase, salt);
}
exports.hashPassphrase = hashPassphrase;

/**
 * This hashes the passphrase with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(passphrase, salt) {
    return pbkdf2(passphrase, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(passphrase, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(passphrase),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassphrase, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
    const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassphrase = await cryptoEngine.hashPassphrase(password, salt);


    const encrypted = await cryptoEngine.encrypt(msg, hashedPassphrase);
    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassphrase, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassphrase
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassphrase
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassphrase,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassphrase = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassphrase, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassphrase = originalPassphrase || hashedPassphrase;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassphrase = await cryptoEngine.hashThirdRound(originalPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassphrase = await cryptoEngine.hashSecondRound(originalPassphrase, salt);
        updatedHashedPassphrase = await cryptoEngine.hashThirdRound(updatedHashedPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassphrase),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
    const decode = codec.init(cryptoEngine).decode;

    // variables to be filled when generating the file
    const encryptedMsg = 'd310d0b1f4b082c07b6c23315d63a5a7bf21cff0157a2c5488ee7d6852b0ee62349c7d0b7b3242a11a32dd036339ee0d80164ffc6d1e8053ebc98ec14dc324e785720f57e1d9a13d085a0438372f76bd04044046255c159487e1e50c07b819b3928eb4c9f4e996d880b17bc2e3d442d2d1196ddfac8d9a45c4c056e014914d26c14d8b271ccbed22fa12a74e72d5ce260d7e73f5b61d20d46719f09dd9008024d1ddbad988d764502367312b16999e734d85d6a22fcfcabeba2160d3614ef7dcc62fa13151db8fa9c4570f6c8e5576b097380bd253645adf1fe9021554a4f3333b3b72e32c96876c0e0df8f423c03fe329dd4ac12d531276d0ddac455133f9cfdfb21840087107a7ef4322d30576562c04f771aef4f352b3c2bd4b3b8139b887c0e8d3523925b3ea44d71a30fd3c028f6ad77119edfad1545535ddb183c78f5a5dab1e3542bc3d44053346f33e3902b4e77aff4e8224ae93d8009ce258d804eb75e9eb902d924f56e746937aa42a75faa2403717a56fe7a8d1d998f305180a0496d4020e2ceae5fe5e54b3ffa420265d5bca4435302fd1476ab58dc7f9d9503d7193380ae4db570994421c5298d2cbc6d922de89038bd369cbca922a8aea57274a4bd72637398d14857f148cf7e0bd7b1b0cc5976641410a61f8a06cf9dde39ca0b87251c0b04107248a4ef88bf613dcfc6c2b90167760badf64895fdd6bac59d6ef1d41231cc8f86571bce2a18e23fa00d704cec4d3cdda6aec77301823316be7974aec55145c02e8845d5f2f0b7c50b5c521748080b0bf2c7534359a19c169bb87923d4170202efb111a77e6ab033d30c7d9551cab315f65c78fd51876e0c51402c1bc595cfbcdf4199b466dde3e1cc21512b99bf2b22402694224b2c1a5c0889a34659effef0917519a4f9ed7a5c77758ddb6f55f7bf5378c8437d68e8709073a249034a7a11f6815e9a94dfbc3e898346c209b29cef0ce865318ed2ec4feee945ef2fa060615df66add6477a6aa110c61d566c605898fe5e1c55e1adcc77b4c656da5f67594a330556acbb24fdb4d8f8d56220fe89d91676db7ec20989dc852b1804e05a4f1bcac65e906f0f0ed1ec25809dcd25a8dcd11d6672ff09105a5f33e94294fabf8702d1609219aff3d77dceaaec494c39479d04c6c643cf934e9aaf1911d0271383b583c7d965944a009e14eaeeca7909f7a9f60bba499d8cf08e51cb8e1ce30cb3885cc3060e9438ba552c81bf9deb6f38779f0f7864a32aa0b21bea670975e76d3cdfb803addebfbe02b39d828a8eca0049d3b1a387c6d7c7f4cb19d8c58ddece56284c414be518d72b5c4c7a62b809acd0ad889856471437013656945941283245e3f6e2d5f64a38e38dc7faae8a4bb73d2a296ee1af37c40a8e71d0060355f8eec06ec97d807e882d3000442f8d30566fb63c225371b9c0642015fed67a2a9546e4089ce5c5d8b64185d2d98602ee530e9806b2db5deffc5e4068670c907b8424449b7da04a7e324ad0e5e159e212d9731ebe465c661a81e6489e3252c2135ba9882730980ece2c84dccbfb296eabb57680df12717f5feac4006fe99dfc0e320f38d2ecdf35ad2272b1f2c71f2d180c53b00db57ae1b0c26971ed4ca297e21000948985ad09b42d63674daaf959b662c133404f5ef01e1a7c14762472e36654a982f63fb1af40b3613cebb67259e13432d945f7221ac9c0fddd8cb77db1c47e8f30538fa114b58953672c2e07a3989cf121051e3f5fcf1aa2c85ee969c415cc46229f8bb033bc37a5f9f37549cd12ef72f4d8038f5b11794ddff184a4af5b1bfaa590d73eb769e819632cfd10775bdc9a63c67b45bcd8534fd768ce927f87694fae46b0fb826bc112c2e844ab6836f6b41e350fa6da47ea0981ee4eb296a7fe388361ec4bd42098c53a6cdd13698ecb49b6b03b268f10226552a7dbe5c1fbdd137cdcbeab6cfe4a1d1409d866f3df4b5be311192b2bb75caf87ee9fa848df36901b7d8f90513a22005da2749d735f86ef76b2812552e9740fcebcf529c087c46dd71dfbffc471ee91fbe7e1b68a9999c4f57f79ed1e13f1b87a5fae54bbd97e0222061ed0898deb56bb6af63d1a82615730bf0a3ea7bb2eb572eeb3ae9cf2604d863867ac78ab93a017c573c59c364824fe31cd74b29ce8edf5af6b736203bb24a87a25b43c00fd44eee022dc7f8c2a41d714993ef3fc16c102bb50b21ae2cbc27efcca779745773f1347b388081ced3a8da59349aa95bfa869f4379cc0320ae9b5dd501b4ec07d988091695a804e3279d6b5ad3faa6ae9f484cf2aad2d7b700c3d3fd3cd55cec2695af4d2552b3e72f4dc6b328b3c2fb8c4891fbdaeec5bd272fd8967358f4a5b0abbd1f5177f742b3a6e4bc79422855ed21c29d5473282e72e5d2d0cb6d2bd4900c7e1f136484c23a746a14167f2b0df7af45707357223bf84b321a68b799b264447d57708d2bb4a2d223f0a32e904ca938754bf96918e2adfcd4a5f3e2b35127b7da2aef2793a6d6d95b7a299a0af069a8a5ff7a29a1a6265d0eeee6a0d842b0384b3e480f5e96c3f1dd07e5a60987e8cc007da1f45b1756a78128a286762086dfe79052adc2e1431d3ba6ee92ff8513e531924d27f48e4aad5f9bda2bb2f57596e4b10bbc49cd761bb1a367a1586be8d2ed15ba004dfff2fe45c5ab5682b136ffce172d6dc8675592750ffa2c44e456482912b398a78e4ff4f12fea11acee82e40d5f78c04b51a2dc629831f630bc38e79dcdf9f0b836b2b20e49cd069557372e78528d5e0f215840c5584212b64523cc3c005a5cc34bdd0454e9db10f6f7858202a08d2d243a98d7bab6a5aa6845519580d93832431816691757d276be9c9b32e0a74058119d80aabc86eb1754909a726c1fde0d051c333b5b49ea27c410fb78e0da04f3163bed4e43ecc3717c9246b045d52ec06943c7f7fde1be976ff8d0d5655d98d0c0501e2753e956e4f90b8248aabdc05c08fe52e11e12a047b3dffea326a251139038200ea10a143d7cdc057e5d3925436e7ec0ea72da0251674675da4f159ef67a7b7fb5287e6a86d1bad4dc6e0f3c29ece764d0e56ad1a64ba989c27b7146bcd62fefbe718fb59e4faa9fac40955b95fea66ceb6df787f66cf4af43afdec4ae221d059b2541efd2efaa7310412575cb7857d3dbe47f2681cd7ad3b9ca901f139bae9b18c769382130674bfd35b429b90382e95fc10d48569c3c98c793f71080a9f62e95f3474152241dbb5403c70277e57f568e9e88c2771c870c2ec4d17f6aeb77a3e0310c76e371ff03036d9f64f228cc4533aa24d3503607aef6ccd17773a2e3179d522445d327d44a74e85bd619e613fe1e5437811a754dbf1e2b101ad2a2e68fd744b661668d495ae84de00042adf3f46b7b5f853164b96494711930924bc2c63385c58c8cd27c37ead29984d150e504681f72ac696ef63bbd3cdbca5fd93f30340ef51ce99205f22015b324c8c538cfa0c0a55bd2b126a4748715977fafa0e335a6ce05cb009747a20fa28b49c57aa47f47250aef834165b29432bbc33b883ae83b604bcdd297002be9bffc618db5fd50a467f292b49c4dd434111806025faded6c929173818396dff64c68b804ad757c9a61c29974d603abc40be14098d2a27dd540a34d116c7aa9b8833c94edb7c1b17b50f1a158da5fb31efd2a2b8eb5a1dd5efad82d7e384bd51af94d062eca5b1377249df488bbfa1fc0091d0bdec8046f0ebb03836f1d6002ea7c64f7278a7290d950939a5af5ce21780a49a2f1061a2ad9b0b1d06b914b1da7753bad0bbc62c48160fd2cf05aca958c422339988905986f0db3093fafcfd42eb8c1dadd739e2885d6cf1e97997960107cb717b37e6cacb1c7d952339363b618acc561605fdabcf16725781e4154ca482f763d007db58b211a5820932f159c0a43dda68cad80e0bcae9ece786a41f2e5d9fe0115ca407af5dd7183c4530291c1a7701da5c81239ff882ed6b446fd2e2be29c904008c8da3afd92cb96d436f87d047523842676c464fd4a6c58a1a12296ac94c84bf8425ee2cf288872517eb0bb42df020ac5d34acd94215fea201ec9810777125eed433d2decbe0c90d0484ed3701a85ef676c6dae4c76f98f6ac166b92f660b3d08afc138d757daa43c6700e57649cc065104d46b6f57675c943984cbdb6e11fc22bc7340d0fced4e720c26842369216df6e01ae83b4262ed2a1f220ab1e7bfb8a4bd03e76839748ef2b16cd45db1cfbd17f86f05a3c7e5b7556ac3d18d2b0e0d06010a56724d5d04670f61db0dcfe73e410c6ccd5bdb99e31a68706ea83f22276ea414196773bc060b028432db413db738dcf6315efe3fd501de6cb8f591f7f04d4b29de59f3ea8b95cc05dfe68abb98197fa89e1059e6144046e66834cf751e62a368ddefe1cd18689073faaaec5947b39c4487f82093e7131aa786f9f1c0cd12cd05cc549eeb72f822d8a9c29bf2bdb1c95171b10cad6e3ba617dd67175f2e40369d4d08e9996bf85630ccf46c0ea6f413f8c290d1cedd8fe1b3084b73dd7d5be44b59a94a953c83c120e0f1e469c6eb6e068368db58ddda57c366e90c16bf45f9a9c77c08a754bb0a5f18a5910734934bbe8a4aa12d1e7898c51cdd2185dfbf40d64b74d4dc1ad421c2024ce6ea9a282f845f88a646fffc906a89af89e717b171f5fde4434dd1c2352a5cb4e0b65f8aa474aa57897fda56d71cf1989a8825e5c7479ce0897a681902b7e2da1a578809d4c88dd03600716a735319dba1012da07aa44170604097bf685afc4c567c32fc9250ca432611ce811c678f12960c6ef8497617e33b2e2d414ee4a55272f209ff2502dc53b5bf5ac90ef088be41188b1045ea42bb623d6e8ac18e91c965ce00622ad77c3c9a735cac7797a397a09f2121e2df24af8dae80e6f43a2291e13831ecf222b0deabd12ed20162a4453172b3329bf5ccd2383433437ce282f9b222e010a9f80ad103ce4e63ea174239ce1ea9a2dae0cc2e82cc393a76dd29553eac3f99d1ed9f1528a25939c51e00228002deac1983d402c60bfcbc373f7bf7793faf5fb56caee5a57ad7627ba51082025f01099474c7651eb0e2a9af9b74ad4c3fa25d1756adcf9f1bb70d8de50a519209d20bde026404be36187bfaae42fd9e5949e65c76fb271b5a51b1da07e5282890cfe672b5fae90daf27dcc2ffc0de71fbda85c1f1ccc8072b96da28c17d84d5bc9f96927d9e6f01a539f7f104a24c908325029b7a8c816e1e6ffc307f4b4403535326bdfcf1cf3017715b89e13792c8d21d1801358afc4f0c22076ed820ad8dc29423a667fb29dccfba3b6b8a568c1a53453140cef5efcc6918a3ecba6d5bb7c3ecfa13f6c75f1a58a2ca855d509efe83cf14ed409c233aa7f2ccb9a34b943131609dbea5bfabe35cc9bf5c53f500b19efa95d9aa2e4254af1ddb23b0919c563473211d9c913914af308b455b5cf023d5ff0b9a506d09fc58a6bdd5d79893d8bdb7a2853c9455c8fc5570c16b85dfab84464270e98049dbae2c6b14eda457024ae4c9c3fe1413be0241d6be5f4d5a3d33ad22582d009d45f2c931124207e8107ce44687970ac9e44020c599cc6f804ac6962f79250ef0a814845c08127259aae71f133beacade26ee7899b418c9d54d4bda8675edfa8133abe5b8d825baf52bdb81c63abdea0f23aaa33e4b224a5f1807b380ab07c1a7d2dc23c4792bea2b2b1d224aa0a86a4c549793a8e7ad6fd1d2c6cb39285b0a290759ba7a6318cff0d6a8fed4aec29d374de2f70d3fe826e02b4e015bf8b646e6d950138385bf003f52eaabd24a36be580cae1197b2a7234c237dd33d59e26bc519def497ce8ba06c33efe18f54d81a588914fac8ac23c7571d207eca022773739ded004a98bda5653ecd61810a5b7ee3dc8fb929d2e547c29944015bee06b4624ca5cfae850bd33cdf587f129f20663fa95c6d887dc9d916cc433657a981543d069b244ad63ef3be7c622f34eb01e1d804c9ad44bad1fcbb865ab8d6e97056249278171423b08f551028fb12cefc003ad665fc3db94b251c1a6eae1e8e9c13751b9d14be2ad4efa71e5dfb89dd67a4f01a40fda605c65798ee93a61eddb6fa9f9fb82a2fdb48b1bc9932720b180fd2a092912e4cbb0315041df6eb06cdd9ee35941b084fed06730a0cafaf168cae030c600f5579ca771a00d7a22acfe949794a44f5cd4f470701f433a60e0791785c6a956d611b2a3beb0e07c80f3e5521d3ffee3cf0d430d90cd4d628de74e51f143bd21c05164d2b3fa599c6e47508b4ae9d95976ea6ab5d166cbaced067e61f79a18803eeeff0f50405c24f35b9f8b96648db6b3ba71910b49e3ebbecc277417145062a426c3bcd7b6df622d8535841482593992e7bf65e47cf76c81e24cae17ade8fdaa27f025297d433f26dbe084433f0461d2d9ea6e3205c4e6903bc5b3472957e353a181d926429411c8f1593ab51d5b14e1e4cb953917415c531a8d54e39a90e13d1bbb56bccbc0d18da473cf85cae51bd5750c083bc2a9414ba4b43d0402943da7fe81601ad33d0de2db7b7bcead114dabe4f6fc6359a34116a78d0158a4c7ea22af3068b4ac85c3741c39fa8c00fb17df58d8e88f87eb50098429f40882a777ea1c890bcd154f3a09f7eb257aa0032116268c5e325d69d13a2f7a7d62719f32159e724351ef5451181b9b59581e93b02596ad0bbb5d780cee384035ebb240224de6dfd7a814f447465b69d70c287978944401481e9cb9f648914ed1aa08ef4c7db58fa2b5f93da3accb6fc42ae3c5fac2e2075cc88890ba2f745207868dd572db50d8b75afae1885dba0de9eb5dd521fbab6b07828c6988d456b0be905c9a53a366c58246002a0b15211c2c24ff5c3bdc850bb5c29f54d6fad11115eaf932605af9feceb08a1d3f93c9f5bd1b9d5f4b2e59c6088ebc34ddb0bed3c309ef96a9b4194c5f85606a1bdee176cac53c69bbe5c9628cb3b5140c6cbdfd08ca8cbdd3beb2e22afd30463c5e7d3d50b4c37b522210fbc52f903afed338e5b38ab6c247264e83f6f86caf84d12bc86f86a4be7ad9cab702d2143b1bdc2076e108ca9600de822273f301b8307e0e2d097d1f5358285564105b49c59f94a012782771eab830f6ec281c7031aa868cbc857c381fe9dba1321873fa0eeee6ab4ac368ee8eb703d95a6447912f0f1ae3445599fb8b29a4e6fb301fcb9f6d748f275de510d602e79083ab789282a67ff9359d5006d2442bcb051774a127171aed79fb9b235fbb347a71b0ad348f3bf739164aeaed5d322de39a3cb9c6ec2539e7777a83be9e675146d9ea5371eab448901cbf6da5fab81ca27c44e9348e4fb534ed988c079b5ca1e64da7a618077a26d3e583b6f583d4325ab450286c850c225db602607c21ffe61443d86424f421d263652b740abe87b0e53a210aff5070669a161860b090a43c6781b75a16f249edaf54396d919469000219b3d13f6aa2c61be30cfca26bc933c9819d6574a95bd3565636da75e39f27c67dc53a8c5d5ec353ce42ee1faeaf7f63245936ec4586f2102de357bee625366c327d5a2f72c07f7a0f3007dcb277d3af048e735f30023a94c71001af24070c5e5d1b30010eff6ed1d6809ed5a26695f567857c2bc4cff194b2eed0d3552847ab5ab4f2d6069fd6d90f69975dd8e2c78093df16c70cc516dd03fdbf4f941f491f5a705eb5d8a4e10f86b1479429b093b93251248cc6f6ee49f4780ae983919e959c113cb193216958643d7a2f0ba549553dd5c73ae48ec538c411e8531846e9a8ae6f860ed022bbc1607b45405bb8769aa62ddff4313203f21b3baeb283716431056b2d7628a2a90439e968ef497bbcc16dcf6366d5e9049e4e7465f008d048b88f9164a2032433db49ed9ce43db015529b179c45a7cba491d7aae3ebbc842752b3a410408159e828d8721ce265251d42fabf3f967691e87bfedb5f2a264e09aabbdff8ad2530a2e7eccc55c3dd78318971bcd95d9437faa60ed0d781adedf863dd4f55406bf6ec435773ed6a903a64529efa36305481cdf4aead506980dfe24d97069ed41fc8949b5adca180c14e0972bd1c95e60d640eadd9005c1e34e510cda0779096e68b9035eed18e1e01d681039a6af6382a664ac31af2ea92bf0e916d3312a845ff81e9fa0394cbb41ded6b86953a59ea221cc79c2b05220cab7251961bc94568781d795d920f237a7de8207daad77b74906f82f9e1b36a02662acc126f2bc52792baf2a8b9deaad3ec9481180435c80e75a36ccd689ff7082a3e7659414309388fa6430602c609ab81ece3ffadd5dfecf969e08dc9289cfe0bfe624f1a38ed3a1b2a6bbe75d024219fd3db61155cb32dbe4c46f3d27bc2340b210a4780efb353976201a6d772331b49adc0ec40115cd92183a17f587634920939dd0f8e1b7d8f67ebc6782158826d44c4ea02c95634c3873bd103aba12c824f859bbf807026073a73fae9b8047ce93c848f129242c6b1fe38f4d1d4161048575a025b8b7177822419f3b2b0241a1096479dbd3b2ef8f7e45f1c2878a4aa7baafce2b37d8838ff6929592f2b9d0b9d1ca89e02df74eac57572c671d4ccb866afa285070974e330b8cd72830da2fb43d05df3d92c06c3f603245506d7d76b11706912abdd5f6bfa224dd6e1d67718f2ab23312f22c717eccdb5c517af0220c66a789a493c0012bf0814bd2119e2cec8b173830bd756eda534729d72af7bada00b20396574c2ba773268ddd11ada3718a832e67d015dd4b93a64c508ab7cb9e38951aecbd49958356024f5c3958a20ec019d72202e70efa837a4c0cf11f32c172e99e032ddbbf689a054eca4a6456196b589ad4690d28b56ab87f26208379e6c1a613c2a1f3873b86e74c4a0bcc645719e9e828bd8074a27c90cd5e62885b4caeb6e87aa1b1db390e4e757a0805724be838a7a35651d99042d551276dcecc75e53d786e000e229930d9810c42645fd758029a1e33eb73cc848873a608ecc12aa1eef1438f84ec84a21967aa98eafd4942a549f91579a64b269a8e4622e4385c478348f78f92c646ee21e57dd63520bf03b7f838c751e45fe4bd17825e1d3cf1a739b63deed5888897bdc96bc9a0d512e391a690b8833fd4a1e73876f0073b447aeb1c535a3765d881efdbaf55a6cad626809d911b71459af78cc377006306e30c5a1639d2ff3efef2caffb1ee4075143880eb31b388b7c102e8ab448372ecf1341fe9a5d549e37d4a24e2cad0b2c655d3c92aa6ebf0122bec41243661d3e3f7de5f66d9ed1b7c5aa4bbc86aa2f120bc741a654cd26ad78b4be391185cd00d9af7fefb15a8006f42100ad0d879cf414e342a211a914554fbf60c6980d4765f2a6e98ae1230a93e936eebbe76f5e33d665092655e88e8ebf638fbc6b0a4f20735c012a271a29e274b33f66d13e4a483bf89379a797244a7e2f89c6d9709a660ccba7cbcd5c31baadc4e7463d2b2c7961348223f4a8170fb8ad0862f15a19d23419158a815a86a656f3ed49291bd2314aab57396cd22faa485b8b76a402192bf379ab8203320871f8cf3a995dcfcb9dcfb34d84974b76734571d04c4177968c3b154ccaade74df6e593fd842a09e9b30e24303e21f1758ec8aee8200d1c8e8c5a6c9e288cd0ef5e969b5507829eff74d5ce9cb64cae63f2b7ac04b26114949fd6a056bb8191134e3727dae030688b9f14c27048a08f191ff19e1a9a3572e4fac157171328540dc9f09aa0a448f8f6238e6292fb1d12af79d595384012ac2190f9ede0d45c338d5191f8cbd663c145d918709f105df13d9c31460d73276369cdab8cc594a866d8c1c091f2454e9b9f8f46695ca11cdfa8de8dfd20162f90ec553d80e1072c2fa4b749a1dec156cbe6d9d4d871d79a180a7406787a6b406b2a0a9720ee6a683586b26abf092d4ed4e3ee478836cabe8085cdd4030ada429af24b62de49ae215a37493f8ca11da0b36feb7aa9b3ce67d285a51e173c872f111351e12f875e89a43407237a8789eaf6d211bc58068250aa6fdbb2484c345843e8a1fa5a49d3d73e18a07e49ba7999ae71be44d7315738bf644de0415651ef62a2782304a993178d926b78f223d6bb8ce069fb2861608524c1b2eecbb9e24b9a0472e4be2d9722c284947487d28c473718da33442eb5aa70f63ba317d1452a9d641d610d4bd703c08b6c407e787ad230905269dc721b3ff75080c058f7b6dbc6cf089ca2c8438e2bcdf0bcf8c5b99811a03f9ceaa6271cb725b7a7bfc8f596a22e9d05aaa1bbaca910ab9c2e56675f3819c9e6c66524c45f270ebfff31f311ca989ec72ad490cb1fbe60445a0ad60fa1da605b40a6573e5c7b623b10c0aa5acea96a27674e52619bcebe54d4f8e9fb9e863214fcd1d4cf1e82fc2bd97d2358eb06d218848bceca52fca1a11c9b831856d495b7636b4c97c2bd36e8891f2c5bf7e7d673ad8800c2b22e7082ee98b86f4223400ac599f4c65a3a1cbb3310091189c28bcce3b103f889669d05b33cb8638bb161786f18d9de54e8442a3a151896a1e60ab4573ae094fa91ab22fdda4eb3b95fd100f446416517c452b62f53a3bb591ad80a3750cc8a554c112a4e87a7241365b792146efa9d32c35def03275fec9051ec3fcb568b4ce572131fe3c9664e8c773f5152fe47c48d3d1912a0771353cca0535cc4d610e65e5d623db84cc53db7481d0c655b48171bdd327714460c3d4c727ab404e4405eeef8341c1a2ef958cecb929f23ba508d01695dd4f6739e6a919a4b70ff27a5255aad66e6f64cb65a71403bb64a08c1f20e81070821e244c292b92cf73ea920a1f6787491acd7568a9c5cccdd6c8352f6c325bdc08324a7701c2a4b721318f942ccb0260ecf667b971accc6839ebcf0878c64bdb92aa23ad40dc5c150a7c36c7da8b64252a63768cbf9599765b3db19129982c7e5b9559c78e06195cbe45c08224bf270fb0264c161ace4633667506aa1ef4360c289d93908834dd454d166717e05036d9d1f38c751d4eebfc6f8a97612b907c6cc27aac751749544728fe8335c15c58cabea92aa1d411206d08fc5670777f5547aa231d17f7349b9492b2cf403d995230fbcc78a44a2717b5f7fd7b3838c55589d0ab61af7df8732a4de03b6da77232dc42757d7646da04cde482cbc343592bccfe95f35f59b6a91b5c50d274a69558563ff07ce98365b6ed5aaad10797912eb05ecbe68d76660c4d840465cc7652eea29bc21e89de5615815a6a7d80145121819c59f96b8dcc754894de907cf084bb56db5a1bc4dbc045ec655376b161cc84261af8e1f40694bd3bf8bcac4452ab4b8e069e76872217c83ae51ebec81e1f11ec93c8f2ae87d7eff7c9312008e197e4a99b419c6649fccdf1516345e0e804fe8a0d2263633eedb3e813899e81296318df07d7110cdc8f9b6bc962dd66eaac01b21ae609b63276139226c657d7bc6fba84784ddd52862e9758b178a159c63c6d9d256d6a729cca27864bc77d56d7726c96d118d043b53424e18e7d80c246ace91e861208afc007c57bd105f74ac6a363dc5cba54ad1a351ac5b2909e6097a7a41c637dced055e337c884b33df1c16fbfd2add43d961efec33bc7c8c43ac7f0b3f939a83c101012b564bf3b3c72012738115c227dde2c2994c64cdf6280040edd2c684860650053d3638361578e056695d512187530e8ddd32c5bf4e1ad69ff2947688012703cf76328adb21d10e0c805740bc8199cd0d750e7b942e0b399c03792f0b9489edc65818edfeba7f96f45aa53d99aae0d23dba3295e4e3c27abeb8e9b8b174330a89a23b08735f8c7b2c60390da07160000c4d32d5975cb105ce462293b49df87eb92cf97d61b9270c1558633e327800aecdba3cd0727daedcb037727519ac6509699058527c48ed140efa0841f0fc6f1d932e8798681763c1da58458b4176c7683ed8bcfa06e478902ced4660b98df4976ca17ad5170424440ef4ffe59b7c954f4232f26ae759a110217ff92c2cd2f57634d42f8a88258093046e34b7a65b27cf550d550f5f60e3352d2f4aea2b636208630cdf985093772333fc68b775be7b68956a7ab203cac997c15e80aca5bc215273eeca4ce9cccfc214b654e19b50782142ff2e9967c4bb66fd3c3e8d3657e4cb2132b37acf1e257e07c0f5f31dbb7e671d8f18c8e5ca6b8496141c707b5c3ab8e210f227d8edd67ca4ba48d03e141adf2740b05ec6b96fc274955d6a5953b864dc2fbc4b8e4d5dd09fdeec62a8f453d6f0c0c473b9dc1681495ca29fb5b08950dac6467e321c5b4c3a68de595563b973d744ec8460efeb80dc50128f7fc38c459ca4fd080988744714a57baddcf268bc8b9331abd36e3dc55831b8b2075f1f28bd8d0d0ef30450e406b9f04703817437db9891dbaaaed1d8f3abb5257d8aea79034acefe851d9699efbb055649c7c9f9707dc8f1f7424a6ca4e169253c2b5b1ca54a93e755d0004ab0cdf7f1b0ed7627a7cc7187c5561eef0a6f366186d189fc8e7b80557546ef338a9a663f2535796d8eadbbf18d71d90129585d51e3d032adba1c6fd01d2f9bd50828c900180e2f4e7e92ab012ecc0f4b6335ee0638dedf2f577252779a058fa3d0b80542fafc92c90224b28f2e1acafca140e27b24e399dc5dc268683c7804c1577829cc3f6607bb5077f0175530745a72fd470b8fe0741f4c4a87db4450a938fdda243ff27bab380833e3ff4315a29cdaa25827a9a5039433c06100cc94d2f77b3b75cc6a17131f99e65dc7df86d81f56489d51aed711788f260a6e426670b49f743ac34aba493991e43a8212c1bbc43a192f91d7cc88fcef9d690dbbcc4fb61378a6c4e6cec513a7249daaa81f1faf93bf2ced84bb8e3be52575b425dff502ea7fb3a5513b6323456b325d586dd0d5201215ada952985c5d9fb10c535c9b30a9e861b84210cad5cfb1ac9de9d5c6ab8357ffdc1497544b815818ef45eac23edc04b21537c720da6633ca888403a93f3bc5ba0ed73aa10280b4e7ec6e685ba32b0e66107ead4917d21755d0ae8d414e109139475bc55f71aa15abdda76e2c24fbf6b836b3fdf367adb9d8d2ea56d3871c7d038bf633248e5674ae5873d9eaeac1f9fd0fbd52331fb9952ca02023f670c2ecd97aeeb996c593a24bc690ea17076847957f8a6c4dc4db0ae2a7ac1846f117672e3cccc4f619d7244fcae1c12708064a095eedc248df089531dfb9d7abdcce760ad61f68e704f85f0ea1f0b499e87aaa4d90b9a35b323bbf17e1c895ca3f45212c9363d88e57975fd70c92517a727eae603a56fa831d1e1132629d494d727866c9eb6bd9ac3fc395bbb1e509f88c466574789c11d78ea4aa3d86ba73486162296d11cd65479fd20a335a145d579c5249ca7cbf0ff7eee0ffa2cd680a29b5116f3f12c53cf8e99826898abf76231f35d48048ccb7fd9670c279d39785c57ed3d0176d57922747a0a8090252d75139f9f270da4b3c75c5970be0969eda7829196212ac4f2489ae89bfa8c6e2b21b4df7fec7e9a459f9366bea941fc6b7f62e4819c896b185baf2c5d3c89923e9a47913c08b25cb1294d11a155a2ff10d998532ac',
        salt = 'bce809aea6710c6cbe10efb33acddc32',
        labelError = 'Bad password!',
        isRememberEnabled = false,
        rememberDurationInDays = 0; // 0 means forever

    // constants
    const rememberPassphraseKey = 'staticrypt_passphrase',
        rememberExpirationKey = 'staticrypt_expiration';

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param  hashedPassphrase
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassphrase) {
        const result = await decode(encryptedMsg, hashedPassphrase, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        document.write(plainHTML);
        document.close();
        return true;
    }

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        localStorage.removeItem(rememberPassphraseKey);
        localStorage.removeItem(rememberExpirationKey);
    }

    /**
     * Clear storage if we are logging out
     *
     * @returns  - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        if (!isRememberEnabled) {
            return false;
        }

        // show the remember me checkbox
        document.getElementById('staticrypt-remember-label').classList.remove('hidden');

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassphrase = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassphrase) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPassphraseQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPassphraseFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassphrase = hashedPassphraseFragment || hashedPassphraseQuery;

        if (hashedPassphrase) {
            return decryptAndReplaceHtml(hashedPassphrase);
        }

        return false;
    }

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        let hasDecrypted = await decryptOnLoadFromUrl();

        if (!hasDecrypted) {
            hasDecrypted = await decryptOnLoadFromRememberMe();
        }

        // if we didn't decrypt anything, show the password prompt. Otherwise the content has already been replaced, no
        // need to do anything
        if (!hasDecrypted) {
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const passphrase = document.getElementById('staticrypt-password').value,
            shouldRememberPassphrase = document.getElementById('staticrypt-remember').checked;

        // decrypt and replace the whole page
        const hashedPassphrase = await cryptoEngine.hashPassphrase(passphrase, salt);
        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

        if (isDecryptionSuccessful) {
            // remember the hashedPassphrase and set its expiration if necessary
            if (isRememberEnabled && shouldRememberPassphrase) {
                window.localStorage.setItem(rememberPassphraseKey, hashedPassphrase);

                // set the expiration if the duration isn't 0 (meaning no expiration)
                if (rememberDurationInDays > 0) {
                    window.localStorage.setItem(
                        rememberExpirationKey,
                        (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                    );
                }
            }
        } else {
            alert(labelError);
        }
    });
</script>
</body>
</html>
