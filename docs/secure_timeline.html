<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #4CAF50;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #43A047;
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #76b852; /* fallback for old browsers */
            background: -webkit-linear-gradient(right, #76b852, #8DC26F);
            background: -moz-linear-gradient(right, #76b852, #8DC26F);
            background: -o-linear-gradient(right, #76b852, #8DC26F);
            background: linear-gradient(to left, #76b852, #8DC26F);
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>




<script>
    // do not remove this comment, it is used to detect the version of the script
    // STATICRYPT_VERSION: async

    const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 *
 * Mirrors the API of CryptoJS.enc.Hex
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassphrase) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassphrase
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassphrase) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassphrase(passphrase, salt) {
    // we hash the passphrase in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassphrase = await hashLegacyRound(passphrase, salt);

    hashedPassphrase = await hashSecondRound(hashedPassphrase, salt);

    return hashThirdRound(hashedPassphrase, salt);
}
exports.hashPassphrase = hashPassphrase;

/**
 * This hashes the passphrase with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(passphrase, salt) {
    return pbkdf2(passphrase, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(passphrase, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(passphrase),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassphrase, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
    const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassphrase = await cryptoEngine.hashPassphrase(password, salt);


    const encrypted = await cryptoEngine.encrypt(msg, hashedPassphrase);
    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassphrase, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassphrase
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassphrase
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassphrase,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassphrase = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassphrase, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassphrase = originalPassphrase || hashedPassphrase;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassphrase = await cryptoEngine.hashThirdRound(originalPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassphrase = await cryptoEngine.hashSecondRound(originalPassphrase, salt);
        updatedHashedPassphrase = await cryptoEngine.hashThirdRound(updatedHashedPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassphrase),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
    const decode = codec.init(cryptoEngine).decode;

    // variables to be filled when generating the file
    const encryptedMsg = '67cdccb712188df3424b6e03f7f194856b1b12f0f787a1344e3a73697eefb617916fb7d518dff66b2ecca6d44b9734919ceb9c659e97218016fe03faea03344eedf9a55b17047974630d18e815d39141f509ad1bbdcf72d2e38065375f120dd023669708d1143c06f842c4b0b7fe13bdbabe62e9918ad660393c861a071dc224d653cdc2f1f0a8a7f407142aeec5d5eb10f253ec6b6812a85a444ec740f406ebaffeaac013e55165934ede785cdf43fd9263c15d19fe50ad57b298a8eb723a46ea004b6bb79bc8e44514cd1581db70ac8b29f31bbfb36c6d9298fc5913810dbe63bc2da99f6fd92fbd865eaced6fe174e82790e8a04c42d38b7d84b872ff55236b0fc17da30826fc169f7aaaa1e07781887d87c73b525c2cc727b0fc04ae3a960a86a9342f7439922c7afc62297ca48ead3fd121b33b7fc053a4b87a41a75165cf0a200f57e94987084b6185a7fb102115cafee1da40e12f1b255b8eaa781cc564bd1517415108c0bbcc5255bda4aa52824723abf13a9773610e6a6af478a9582f9c3a1dea14659ac8af043642523c46d4c31e24d7c27a82bf5b93b84646e7ffcae6e648acc17a9ddb24a5c552aa2b1abc13a2af1cda6e55b621cf54be808a5768b8ee09c15879c5015748fcbe1d1de38de5b4d3888fe5f5ad030a865c11fcc66920a8a7fb70a146dc6805ad216e29608ffe0d85a4d95d4c03bfc9ea13745858762fca9680df06c45afaadcce330690a0f6b7179422f8c2cf60c7314d506de396a9a7125c60d98eb8f27f7e295c4a6f21db2e0f11a21f2720f51b1d7402b0e9d860aa3117195d6d73ec51909f8b5637947c78f2e65bb8b817c75ca2ec94344e172501cbdb9750d62a0b322214975b86f46045af42a11b53fffa43ed53eba40552f8f09aa7be185d26bf1c92b2b6692dfcc216a1e8f8c592042e0ccd34e28e88aae006717b27b9b7563eaed0cf495c42a96f3e748af60b5c382d437d1cc92dfab6fbc8f6dc108d5a0a5736d39a322dc04a73a00ff003840729d2a66dc12e7309ac8c682ad174c548c22e595251570fab4eb5f5516de49e8738a302806408a277e76bf1bf2eb6fac8408dc58c47850ca5fba533dba99af43a7abfe478c15b4af134ba5a73c6460d7668bf69f8705f827f302e5ca7260e67eee3e1fdb10cd5357b8298d0988b78d2875af2ab238dbc3c23b63d6492fde46e226ab061c5d15b2be24da8411dc5ce16c0a17b00033026d7af5766799890312c5ab1f452f60e70a8eeab435c81fa8028968d3290fa5e8785106938af09616ecde9ef8d51c3e3c74f83fef2ed8912eaa1a2ca8f01fcc77e0eee5963f15f11192f0cf7430ae540e5be1d8b97ce238c58637dfff0a6588a00903c3608ef0a51eed35dba8eb24352c7e6334d33b3312d951997e002b62b6509e9faa203091963cefcff16e875c52e0b5ec1847614356e47278d86f60b766559908bf5d52eaa9a619b7882b300e5d5ac5c3acc79bf9f8edf1723cf01ff0b334449c0c7218f5690bc26682b20357124e716f17e78497bd3c2a734b1f657a05db6237f9c90f4e3448a234ab6393c0ad01fe32b90afd8b8d345eae21f7fa3b3d6d4c3b8a0a4e343ac05a782aa704c14b4418326694ad50206640f5018193826af10b567ae932f654e101180966d85c0ce498744f671f4bcb7a988cb262641ddc075b46d73de550c7794225dfe917de53fecda24372507e6a149d15ec1c58998fb91e4f449f237fdee9a80fd404ce71757ab49953df919aa4be1a26dc5bb2bd558d1e6497f84780f56c7b44eabb865136413bdb3807090f582bf4085746537fe393b4f8b9137cf390db5aa91d7d179d410a4bce670ec6f129c5ff959c236e86ff3f22f059ee775fc52934280b2027f694b39e991f0775169a481a0a51373f91ef7934b79963836d6ad8d81906976553e880b930fdb15ba9e614f0e527d90519e08ccd86c8f2384e9a2372c3635d304975d3bcbf721f843f3994460068df3c79d3ee3b5c240ba48e94a6208ea5b1fdd6fb9a44acc748e6d1ad4b9b6084b0b89c35e7ef127f8cb0adaacf18301d367e406a9ca995aebaf628c330184dfded887df046fc958204c414d0d403409fa9c2e3cbf9cb0d3d5a0aea707aa397575a8a841d051720a947678d9eed52216d10e0e96ecbd8aa83e3d49d8c5f8efcf229597ffc2a9e05d72553f43c88e8e71a80ace3b24a3d87944cd1a75d691fc7050b0410840477346f3e1aba813ce285c92a918b021525dde9dfc99ff88a0cbdc3a109fe14e0c7cb16ebf2d3a1588cc55ee143d0048fc09aabc413919640145c6f491f488d066b990c1bd9b1c944a8f5ba71480efcea64b276aa0ce986954bfe78529663f0852effc65f0de249ea7960cbb060179852d8e53773a9fabdcb288a9582995ec12012cf0fdfa28f321a48e4f521ce388663ac4f2013c907d016ed6a78fa8531ed67efe2107c8a96725215df13761f20d7f5d6861c5e2936accaa04ff49d97e734a5423a53dfe00a04b1657a73aa06568070083b13841dddffc80c0e75c24610b87b0e42e10f0433016aa5c7cfd245c5a5da0346bbbaebe4db017416b0b42cd97eabce7934c418f70626c4fd637292a8ef11f50d1327eaa7600b0ddad218842a322b2b6ca889de329151900e2d0e580f36777bdbcd9c62d585afb0bf97b521fed8943889de9d2e31ddf145767cc3a574e3bc8f771639b94bdc0ef6e7d02b4bdb8ed068bbd4d5137fc49acdf75856574071ce60ec44f341664741ebb8891d1598e266e32d21436375446a80045febf4f8ce6407aa6e408336ad37e164143baea511d826662c2dac5ae015acb696713428e2a24e72bff21651cc1d7799d76c23094c61567176c914eaf332e7fe0545679a863241e37ba78bb12e7dfe2c9a25e488ce04eca85b0c361443e27c480b0814c311dd626163de1af771a79d3fdfbe93df41be753ae60b9b95fe5d60e1df5c3bbed817bdd529fa869c296c05f947c3c784214cbd9092dc8dd15736d9bfdd916821ac0182660ae9b89e01c430222f6305aaf3066059f63509cd2cbcfa038bd084ea18b14fb12c747095e21ab03a4b9f7fcf6e9125db056b5c6ceada2bcd20c298cc21970497b2678c3338df45caf138cde6bcf0e5d784617f8d7a7eb44743ddda873d40bcdc38445af4a5fda82a09d53e4cb2a9f8b30feef2dd96a7a2d87db0b24c020b44c20096b9a77ac363449db2bf3a56841f45df15f8ffd191a5490f898c2ae94bbf6cfeab91bf140348d538c0810f8d72dd48f1f02a05c607f03097a2e76270e2dd6c336bcded6b672328abc866e1924246954f23e4b807e14f62d31c440c8654261ef2807121e7251dc4c7184256a3d5b4ff6602384bcf427b73acf62ed457e8e834ed15c0d8d8127cfbba6e7190e97e4e2e5fb292447833c7db4a89d6019ad350d0855c7cfff37aee50143c9289e156ba1280bb52d818deb56d955c35b70cb19d378e77bf40902f06b42fdf0dc7682b4b7c146073a7ca8f085a17c4930f8e002391f0012a4028454eee87a81008af8bfd774996b35ca2a7ce5aaf99b49f24aa11ccda7f12f44f0c826a10a35cb9afc845b953acc14c2a48f8e1df114f179f1d18417c3dcea399e5eba98a8a8b7a0efeae12788d0bb57129749e3c0a9a2b6628ad95da4883ae735e5fd71ace5b85608afcdd5ccb8d57db36b02ec892e7f14061a808cb921e19541f28d6d6142b4f7d6c1b2a530e20c7734f54460347b83a83ea4440417cc2da6b7738584797d44b6453dbf9de35e4ac9480ecf53115536f4e88ead8633098e9c6413e10bcdf992d16c405829d8f72d1295b567620e9b5f25d6bf6541926e5c4f04d33f89610b5b359299bcea4c5fc6f76815455a9c87ca99a50c33fee48afee5b8636e6ede2d04cb81c3df49e4c53b4e29634da1b4e748ab259a1fbc727fc924cd495b9d0559794b8ebcefebbcdaf429c948b38d3ba2efbfaded613a4d12003889c49d363be735ba4c6472663dd0e411eb13c4b912a632dbc193959371c8481e3bbd3423d363d3bba6bc568b766c8818b83f58c05e59c38b3e54f19cfa869648080545d73b12c89f8faa98b4df2994f51df3ea8c0c34f93fa85a48eca2b4cfae01186962e6a5ab5f0c3c8faa7c5e3f7c9d5be57289f6c4ba32d8b3ffdcfbe61a20c4059e4c5c64a5d63709d7110549dfdef08100c42a0a06a8dd74e5f899c1dab832869c890983db3dd3a8a47d9c64f40be936caf35ea5d1637848a7b7479c51677d95c4763082db97d9e0cc0a471fda4b989f32d20dc3fd333a4f6cdeb500f1b63870ce7bcd837065f3cd01bbac0e40c5703dd9b4b3890f0a0ae51781e4ad1c69a2ca6956bda38560b16cc4eb3c7a0348ac6a36fd5479fd71068d0aab181e4a9c61cc33e1ac55f77b0a2013b3a760439fa1302ffd96fb90e35a9c5744a994fe9cf642eb3dd0f860e323cbcd87f4d12816bffa666e563c2179c48a0b84949104e2e43ecfd5fa566b61ceeb662ec9c76e485feacecf9244a5bd455db49ee0a4fadfee8e707c1d5298001854fc19da74303df2350f439ce44378db95b602004c59fca163c0201f923cec3dc66b1965eec1b54db4871c3fe17cfb212aaeedd4b497c8c8851976c198c11e35786e9debb0320b0321e8cbd69b75b332e18e4e0bfdb29239524c494799dd2c22efc7761ef3683684255a3a55a9d2bfbc61190dcdac3c0d787191284177c79755b20781cdb45fbeffaf43a951d462a9e7ff4bb48d62671ce7f5227b1521c89302ea0001c8af7b0719d87b8ab8b6b0f10177cf69a1d7ac0a2662aecc218a31a265b7a73486c06b15702f1f1814ca95d8386da32090829129bd1c83d1fbdc2771333115731ac2f4e8c70ace0f8f8e08135b232e135b9604b64062f2698275575d5937872c957d84b03a94092c7d34fac883257f9983cc9ea51ec8a0fae8c268732573d0d9444a7e727af2cd017079225137a004abb30cc6afb3b9948aa1cdf38879cb1284dcd14d655a83fa7159d9f469293659a3ae9cbfcd8a11cc1aa0f33c15d066ae0ac638c964b57aa449d5878c9aedc60551146c416490f6f02f7dae44dd5f253532edf9933bc1a00e443bfc6fc35af93123f0bf88dac2e00fc2a3d20f734c8df21d857d80855b651be1e72564f0056841ab46ac60f5c5b4dbf68ff4ddea1215a66590078325a334ccbef435dfb296b055e6762475e0c863481665c76cfdc9a49f303db590cc6268843e09ba135e97555b722d589a800da67e625b5e8d27a6d47f1d575a35bd367a4e34f811502fc7ab2dd9b659acb818c56e4dfcff6abd5b20db47a6ca856a4e61b91328887a163018bb0ec498a797eac9e41eb02d892cb7e6e26c9a0c78a792b303093355daf4178d3a54e322eb390ca8e71cdc02e82ee47e2af9c6b25f4064be4da46dae25abf052e5249bcf82aee247d654b9230e000ec46aae344a63d41dd5aa129c6bd2b8d7dabada1d177b15100ae6161beb6c3a56cb4b387da113882ab5413c0561f00196d8fb4e8511061fe368560d7cd188677b9c6656cb40379684811c2fe3e6b5cccba9625cca5829e075a28016b8633022727b464d67ed5aef5a4337eae8bb65d8cb38902d8a0930ac48ce16852edf4e352736519f3cfdc62d3fb4fa1cd641d3245628eeb97557e5091a50d8de4d6a0927a7fdabebb0a5a2dafc760695f798c24f1dfdf8d04f349498687636525c1bb148f81e29a131d16e0427bab335da6a6c2cca71030de45b96fce36e443b0d63c01543a2280575e01cae8d4dfbac4ec631c5d5ad8478e8700fa78c4d2016e0057a60c411143235be9eaa468f71d2ea8934fd0a39711ee91507e255f3bf27ca5cb5a995ec93bf44f9beb672b6157f512be4e47c7ce922c74b82c53e814c27ed2faa07506527cc1415bcc6c9005fefd6497619e8f8c11602332bb6c620059342e319a456061bd6e8a9e1a932d11445259a72ddf74ef5ef9fac6d51277c5b98d91651904a74b90398e689ce8228ff02258c88053d056c76707d8eaf15aae5c3b0d20eaf4521204c81e2434a2f83504af72c4ee2af354524a3651609a23baf6fe3f7dbcabfec67a54c0d6017d27680dd11e86e30bc54e5ebec3285040c85faa1d5d40a28d50a2e78df6a8a4e32324b0f012cd26447f49f065610a91ebfe707d4b57f8cf5520c7a61cc55bd8dd25e8caaa2028fcaf71bffc53ac8ec38f2695ffb54f70cdeeca85df2d5a623f12265610fdbf7f05ef9c1f3378a42aafb25a84845ec101f6e4e21b7d7acf403a16f37ae9655682bd5c423c43237ee36ce2b542f34bb769038285b98df8f3c0c6dbdc7c69f1f4af8cc8cee8118cd98150977e9a626b1045ea8050473d0ee0b63f9891fbe5dbea92a3db12c8ab804d7edf3c96243931bded58d037055f7bf3b1cfb70e031885c69e7ce7ebff9282904aa37c2ca55feb7f1c3d03fbc7e8dcd3d16da011c8d2198dbacacf815cfe4c901d5c585250e6b34533941f3b510e8e4e15410f5c9b0ce7018def4d66a2716408525dae35b017b0c5db55dfbd143f39a902ad237278e7bcf2bfed73ee9377fea112f4c36cc58bbc52f7fff9b8d0ce8025e6a3c53ca8bed695098aedbfd6bd6d86989384e4fcfd856ff2c6f9db26b31e5e22b34545c04652b7dd84fbc2732e9da3c181675eef95075ef5163035d16a6bea4e2274806df789cb89556a7803d25a1c1ba20ee08f05a0d74dfdc958ea564fa8a97f5f3a5d302955574128e0448389ffa9f126470430539633997aeed79c8479b7d42f9b2cd83e1fb0e8a5dd597ccc56eba2f3ff35b4dc0ad21425d857f5660dd3fb6f95c2a2a80be4b7c52463b16055beccfb37685265d6687f2838c837d84cd067391b92f07679eb9885159684b37928bc6c38620370b65c4da20fdf555df1489fd26b554be46d58ac2db716afc68eed9a3898911e4e3e0bb9021dcc9eca808bc4a355b8dac2afacf349cf724cd5046d6ca86fafa9ef0d960c10c3608a05ecd87724055f3488c04bf49cf29f5d0c1a91b64c3ca0dfb8452f1b7a505df55398617a0318ee1c8e941e9578a5cef0be4ecc632cccf608de239a3360e2bf6ef6a8ab126f5b284b22c1fdb8951ff2dbc53ac2c232458b731d9e24cd04edcd36befea4a4705979892b4e1631bc784a49321edf8b1a7305c7c45cd99ceb6b9f6e5e7a088daa97d6d4455b1d34935ebd77cea3e3568e0e74469af5b38a0bc3de1548ef1d865f1e99e2a60166af445bb9a8c5d2a905b3a3841b732ee9712c18ef2f64e8ffefe3382f613be5cfe2636f90bd7d8a012e9f17757f67ddc60883d6fa607a8f5baf6b65c852a99746fd121ee04ed965b55b74e031a1b91f76564ee458d32a45ba371392da649c29793a9d3f6aa34652ba064c00c27fcb96cfcba6dadff99aa67009e3c0aaba43a4320e141707ed96f8fa779d3138103af213d2587c0cdef3404d46721a2839f45f226bcc25e96f54f6651f1a3be33945d19f7a069d4ba16adddd012826916cb851a8ea6135debc12cc063ce071e3f4a05efd87efbc400503f605699413c0df7ca7587dead9d8fc5e6bbf2094008cda83fdc4d8113f26104e4f8839d58180851eaac7b430b8142753d9646a9b5812c988e340a4ac93c2c1b74a5ae4ec62905cd52a3ee142995784b34fa0f6327237c4fc2903c416a4a0a5e213eec75ea4ad206169dc17f0174fe2f137dd21a65806d2064adf03b6274dae871ba40f7d1b0ee685d71590756dcef12fe1896de1a99630ed32c5f7936b3acf7b7ffcbd138220f2a26de842f94a9c0e27fb00c1884b4294acea4bd8fea5e4dded4369afd4a14f2cbc413303f0b5c6b7106d18213e51c830e86f6bba6beb420b2f1ac0ad4fa8994d29a942170be62c763a1d9ad58eaa9d098626f1327b1b687e4b920cf67cae7e3f51650c2d165fbd0e19cde93ae01cf984e63ba87f7f45abde0534c635fafe0f9cae724ec09c8f32984aebe19ed4004988e11d40c1c5f7d26047dd10bcd0d29402f3b3787c8d9c226900f95ed6e246009d3b9bd126598726c39c80f364276acbb51fea40d5b244a5087a36077a25b078e86ff4f1f4ee30df986ffa3b49b7580c710b81a43156901840193cd7255fab0f404a30cb4490b4f97308919e93472933187dabce486fe3a18c8c35827ef844cc8333895fa6e7d9b084176d5ca32e73a7e1bdc78c56c319dadedbb5d89b7e9abf63bcdcd411b4ca1dd1b696d2ffc62386e97778c4e07f60e943e445e7b5960f88a990096befde7e77d8cdaee4871843592479f29fa8c746434d197b4411b0cecd706fe8b4a7fd8534fca55a43c1d85bcde7e1d92261cb19b3a6c999c0911fd3784a2340db13a6120047a5798876e724b65aaa3ade67f4f4ea46410697fc1a230471478cde6ba4989e4f205656d879eea369363c417e8b8611909c4cd6db5b2a0f0ff43b0dee90fb8df4c3fa988d0fd1658e5c11e9ea77129d5b1befa1cf8574a5fb803c8e0326ab0ade5ea7587a59eba41a015d2717df59b08fbade46ecb539bb2f9d31f6c676d3b3dcecedc4cf55248767fea7f3a5190a2861b523e9d7ece281e318a71d865d2e28d7c33acbb7ffd361b77e46424c95a88f4c5b28c69e375b3880e780933d91bb39eec18bf8301cd8393286e07fb5e781d303c3f525dea1fb324bf33302ec5d92c7bda284b1da4eed6cca96a7347061203552e74d3415628138feb0301622c40de74ecb414221b8f2ae6b77d05444ae5e9274613ac0817d9ce59b7c1b82062fd954614048e7583fa9d11f32c997bd6f83cd3dd43e735af23e374cc3f144f9b7a04088aefeb036d6359e4e405871ff7b5ae44d071a5c4ce8f127df07abe47eeb2d774b58fb65ae9b833b4f7f437ae84dbd983faa4cbdf6f970894f384fd3adfe3d57b32f274a718262035dae4beff07e671ef855d8e7084fa3a07bafb98d850af999d2271691a3fe88c7b08546f43fb4b01c0fcffbdb47759426bc73610f205ec7d56074851ddce3f63147182ff023505b8dfc7651cf68ca496f8c348b0fb7964e6a766fb9871d27ee110352db953260b0c62fbd979322020af7aa82143b95fad5df89e8dd11fe27062fe4055287b9397affc60b35014ad1eb66433c096d478deb87c55767568f0932af50813d339e1900f057684054d6a49bb22273d579be102b6f2e06eb05254c90afa65a3e3af8f529458aa96d5ca9d113fe1ee7dd644f0ecd246ca6d24acfa8007844425f2dd896f748d60addb7c6836f10325bf003b2b9b0c25bddf0e0d46a914d327f232b01c742e881ff3a86247970e886cdf352146f2fe2489cbb60eef82b01ab3d0ee741299f1b9435533dee5aa8d4aa0f00c52212cad9185b0eba4311ab8bf0362566fbe69bf1f94e7136bfd0f61d35312b39c3f7680147169b0c04784001f1a900c6893c984b6c9f62925f1c02368715d13e0011ee8a2fe3816ad104c928fe41d66b083f0a51ff52634c130560c41055a6375d2dc8d802de6ce796302cb4128b2f9c594ac45d509423c16c96b501e69cf269b5691ac7f35825bcfddc2a370df01c930962b18816c8cd5fb821bbbeaba3e00c7d9bb09576b8fc33870bd94bcc79129d6e93ce20987b3a04ef01b55da33f1780d7272326cab4c4d747d7247e07f9471b5a51f32ca6b06bae391beee5efed69b3185e96b08618b78a73f369e82e3623bbbe13be644cfbe652cc617ccdee6fe169b8539f6f28f88a22e26df8b0fc6036ce0cf6ea4e2e84a88db827fbcfaad7c57570bd772d82580a83f92e9177069eb42a711acfb244c9569c91d2712658df221507cab55e3e7f112d1fd40261f012d517ea0a759aa0f6043d8cec95945c1886dfe2d8ed52aaeeb336a0f448e94409ef6d036a248a47b166b5c720bae51f06d949c3404aa925e9554e6c5566318e316e5c6d6bb4a4e5c867ff06fc822674ee5f52997bade2aec2159a25c624f07f30579333baea0b2ae706217b2773995936acb4e5065bda3d3174de0e6e841eb8f187ce6f8ed96ddfda1a6b5901870fb8abf9d1a8ae850e271406006b46682e9b431ab4cb1733123b1f31e6bd808e993c8bc72771f3d19c286e2d9857853b6a195cddc832052bbe98ffc10bb528ddae5a0d562dbd5391ab676eabb4bf533b3b8a49ed689b79e2dbaaf404db05ea9986b33308b9ea4ae8245bcdd803e034416d1bf8885e0824fa739e109180ce0e0ceb70a9b481a0402b58c6d4bd7ad70b7d841c9b404287074e0e28bc65ccd8a414ecbb3fbd8595ca762890f890fbd7428fcc2b1c1f442efe8d57e70c0d30e2ee6e316e3cc55ee62eb2fd681588fd6b1506a206878a894c76f9cbe54f65fca96f7889a9ab8aafd6a72062f966447c421ede344cb8e3857f6591c91bef3ff92fcb1f78b8496e0a91b6df739f9e1cd3f2c1fd34a322c2a4e4e395066a5f089706a7fac95f3b2b8a67ed4fc9c6402d30647fe3cbaed99e0b7941bb47b9591fa3de86e4c87420137e56080537ab14daa725c818a3819afc218947e6fcd7a382b6c2f7807fca7e1a264fe4e9bad0cd343ec99406539b3423d67aea6253dac78f38bc89d987dd084357fc571e50f9d6a047933f2c606edfc857d319bf7647c452bb202eb624342ab0cae24a3be6a3671c5a000b236293cc6558283ea0f5ca576a1fe4b877bd8bdf4a6a2af9e9f413eeac30c3aa72b13848100abd4cd6e7181db3ce0d995d53a2e712f9af24bbdb716eb0da8b1359c6f67f238e90ee92a23751589a7a57a86d3de4408dc03b781a0d8f1077ef526deaa564379ba03b32e6885976e5aceb4684c52f646b6935913c0484121750d4a5d9520eb41c2c6d826c97492a35da48894aad354e2e03548d5d93fef7a8915eb78d03ef496793d2283544edb79381427010a49a0ed843c8d2cd60bed3a83d2efb3f6cb90f365eff18e6f10d3fb65ce9f82a253d23f5242755587d3836ea213051d26073da0a5c9310c9760adeb311d0bef9fecc46a7f5806b9d7c08ef454af2281b037f8cb4bfff61084cbe51b183ba53fec47c56dd5a514dce5841656c9130fbdca3acb44e39d7de3151e0ec130ffe905ae5dd166afb2cba51e24aee99d77517c1cc76241eb9f7605fbced69feb79cd460e5e972bd9335824d512cb3234a8d6df95ca91ff1bfda05e7d7bb8ea403f9ceb967ec3d96f816b0f0e139f8db08325ad66bded2b439149f99c7da2daf36eb5e7cb2c7980c4ae950ad6781ec98ccf07b2d309722ab6a758d7f8b72f94f44711dbd2703f41c5b3dedebcdd23478fcab44f634bec065563a57c3d41d43ee5fdd349b9c8df08db4e4ea9123101732a7f1ac9e96286af8dbaf6447de3803cbd63143ebf229df75d355159a23aa118b30a3328b688c75e19746918824f70e5a4605edcef701ea1e2bc0ceaf213f6f5db4355a87e7052dc69400f202eefee410e1688e5796db718e49fafb22a96dab7a2c2efe6cf1998581d704dbddfda2cf03cd54ae89b5ce1926570dc02d1cff36ff9216690369dde928f1e5cd36fc649b0e9c927005491cca2947c4958010f86bc29f687579e6a7d2066e3be5dabf863b28ad01fc11f35f36a6fdecb64dcd9b0f32c16e7381f09f74a7de27141c208612f9012f378dc75e609e95be3c3d1fc37c7a88da20f3d9a1e3fb5ce4952bc67623ddb794357a3576d0b4bdbdd7a205eadb59d265b58c07fc1f6392a8e5a0b5a5db6e1c575a5e0932953a28039cfa723885234fca928d0d1e3ac86e50dcfe4d23f080ca0435637136f2e4980ebe7377588cfd654f3843d4bd461138027d78008ddeafec0a9435af22db5474164d0d208b12ce1299b1506714cd42a2f408f3713c4c235a67d636a4d5c9421ed14bd763889787ac5eca6dccdcdf36fe20f1983f4c28611eb631baf33b49585421e1f1477cf9b1a21b248360a929814e249e5b563d9b5d3855c9e43636a1a529f8cc785ae7ca624aa422579d51269eb881cafe6c2f1210daa7c61596f75e3ccbc1bfa81f00035476aeb7ddba9fb824fefd67cf9ab36bc3fe0a4bf017449a0fde2ee27c4094b783f4759961fabc6b6fb758b046d7e80558ea19ed95c31bdee4af694a5e46aaecb807aff85be92dd616675edb699060cb394b9d35314596d08966672628c9de3e0255aaa253e8d85c0720626fe89625222015f1e6cf7da1d2f3c1cbc3ebbbcc5480bb71f84a38a37d65262cfab8e1d246e32091839a52dd77b5d797ebd171bf8d8a97c5dbcaa0c60f67b2617b8730061ebda30ddf8f79de72f7e635565926ef03e2afe8bd572a14e29f89554f88cbfb6e5ef5d46b78745139f0b27e541a70fe7deefd1605c745e9a23462cbbdbcdb4ad04addca5e64c90a7750ae3b460ebcc80b0152c9a086dafa62499eb9d59f0a0716899583e0e2fca9d859b36c6a47226a16fb7aa345b4a73410156047ae5bbd5234ae8aaa61243db6b796ec3158a2e3c8017a01c0a918e5754ffdb44ea6ebb2eafea223d2998a3df26ee86bb028abd7c9c551720cd1109874d612aa7dd5d8d2db99f4748a7ac8d45ff2656c83504794df41a70ad85cf6e2aaf60951ecae74a29d3c082ac48a4ffa87f5bde14c59dcac6f531ce2eed9e12073ed21e55c393c0e84b0fe6427d9cf79bac98c48a55f3693c8c393370354d98f9dfb6e5bbb3a3dc864026335852b6eb96689b1529abc39c36f324f5d20e264494d684a13649ed3bd116e3dc270e154eafe2826fc34c30ce9a35ac8001641d7f78c74ec96b173bf7dca7885009e5124725d1c194743ff6ff9fc82c7d53c4f96c5ada1ba6856b68e9e26a73b130e20c0a0fcd5a2dd229e8f9f40d6a4f17570bfec8f1e4fe187ccb90988253a5319f6f7877a47261bf19f5e2277b895bd6d412dcd597ee6e2ce11ef38761b1eac46e1defc4e55786ca58d8d8bd0df6eb58462c2772b33fc99a9f42ec8fdd22227224f23ee97409bbda451bde1ed84578d45cb20257883acdfcc3b390c8f02b69cb58781e7ab759e2d851fe2f5ea0651db0c1c76ad98198634a2e3a610138dbf8ce06c545e517a03cbae6d555c2326a951176ea33f634ff679be7bed728da2f66d071ec5066d4ebae26aaf8f2920be6f9c244842bff76635324cbd5846bb9c55da8a024c2e621d5d30a7f150911663bc1ccb7322580ffc84cb8f375f7602766c8fcb25ac3dd20368e9a2099709de74190a72f11a736a7fba71db423213d7f74cde17c6ee412065469c1be5a62db67af38e00282d971e44c2259529afdb048f73664f3a5713feb7cffcbf598ac4a1786397254f3b23a48c7b64ae05998e71c3fd88c389e06b34b8078a5dc5d285f6b42f2d3146c52413e36e217d9beee8a9d856a8be445373ea1a93499196974adfddf9472584e510ed043be7514ff48e4477abb21caa30d89f0dbfab663dd223570eb1ea3260b8bfc29191c72611e58e981385528cb7331bf9f678c9aa5cc5013f7764a0d37d7db69939d241c6187e610b85bdd09483defcd0963886437e4562da4e0a4e7b145d998192d1376c5c6aa0514ee5ae2df0c6cc637f7820ec1394cbfffb5161447c303c6cb0f1cd285dc54502ad4762fa91e6bc8e71da94b5c3582aa53e221a90ace09dd91876ddf09dcb20e1e4e5bbcd768ea602c0f825f633c3267c8ff5cea985ae0f2117bf74f97c1703343f57183ecea548cec8be4f1e7864170f41170a4bc57594ca1597a2023ad6867f2255503ea9f4f3d27c82730dcb359bdb6c97373d09c515b0b3345571312bcc05676af6d4ffff51aee949d36a903f1c1ca69759976f7d736ecf1e50bb9a711c66185942b8aa9c3782abc5101be96a70aa199b923fad20eb96372b16610e4fb054e31b4b93e31e965a823d33e92841b62c4534ad68e74018ab026ffb904b260e6d228b60b3eb182da58b85efc5f48411119e2f8a3b1915518104cd35dbbda508bdfdfc7570261fe42fed3a3cfaa933f31d90edcda67c2b7a9b18dded8524d0f01d78e33b4c2ecfba85a1dd0d2d11579ff8fde575d1db07206fff00ebbef4be0863f2a8665612d98e3dee1e4825be00929d40776b7bd7aecab30cb014c5e00b35c95eab7bb14f54f5067baaf9128ef43785cd545bc1f2853ea316a2a0e7fa5a1199e129894bb53b5c16030ab7751fbaf89ead8f67e87adecb5751b4eecd8d12b74e70abcab2a50415e5bf11518a1853f2850f2b568c9747e9d09cfedafa47260e34c0361791117d291297e6638a3a42e473eee70bc437a1671827c8155c906b1af6aa061e2b41daffc7b43ca336a1ff519aafc3c743df037943f5ada5c238ceea08825047761bb39f6a98eac902ce4f4a703edca6df3e0833050e245d6310ee80b77c24c2dcc6b43170a80e154a6d3d4c165a04f64402c0e2d6414e9ce63d6ef105a993ff0345cd50210f343c22fde78f5d65e01cb97833e2ee0d73c6d8f500cdd29882f69a5b2f37264e67455734877d91ce033bf05671b295e69b745b3b0ce1803a791b518e5a95ecc606b4471bd595ffc93c2256efafa8f34bb6b8b8a6cf3deee49ebc3927c17a076e885910997fb1563c473a1ad65fd65ec48c68a3767d6399350917f845922d8eb808a6d886621b49d6764a625707a234a02020e4395273f71087170880358355dfc94206632b884be951cdc2605360b18921976949a520bf96cb745aeeb607e39210efdafef9f383db6b106396dc8a4e6f711899021120bcced731bbab3a3c38b63ec368cda19e0a77c0942c42c0e88c6ba20e25c913ae72b0119c86cb085b32789bdd178461e2c62e9671ba54b3161191096ac61f78e0943b26462d2198824ce203e5370c03e3ab714a58d36f3944ea774143f004c224b8381bc039187fa5c91ba1a0cc58d2ab3a728852553b7dd68b97d3cbd8de54e20c6236ee78cfc83fe040cb0a7245e3dcc6b4c2faba15869f9d3cd512f09be8f1bfed92ede086b0a0e7dd73bd0270410f862aef6ea1da073f7a42b64f53ece476845b9f25d5e836c7afbac98679b3a4d6adcf6da84323f50baefbe73896bb25a1d0f3670004c39086574a7541387e48cd3f9d635e2e04bd645fc81e2d9177cd52fdfaa7171e0f8c3192e2c54e746fe2020532afde682c317ca177b63ff68f03d0c22d53003d7ce90775dfdeb3181e573767d4ebbf2c87ac7ddc6fbf985330163ae4c59ade2eadcfa341af8c150fb4b9ccd3def46d1bbd152acddb06d61e602716f342a0d85bf6919f94520aa922b6f499fd0fda54d26e740534de870b9fba6e1f893042f12dd2776fee71ee539c5a893d30b4f9a293fecf0046f12b00177430fd7a241733ee31f6ccafe4ef54889d4591',
        salt = '9150118e68df8fe84477b43237d25464',
        labelError = 'Bad password!',
        isRememberEnabled = false,
        rememberDurationInDays = 0; // 0 means forever

    // constants
    const rememberPassphraseKey = 'staticrypt_passphrase',
        rememberExpirationKey = 'staticrypt_expiration';

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param  hashedPassphrase
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassphrase) {
        const result = await decode(encryptedMsg, hashedPassphrase, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        document.write(plainHTML);
        document.close();
        return true;
    }

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        localStorage.removeItem(rememberPassphraseKey);
        localStorage.removeItem(rememberExpirationKey);
    }

    /**
     * Clear storage if we are logging out
     *
     * @returns  - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        if (!isRememberEnabled) {
            return false;
        }

        // show the remember me checkbox
        document.getElementById('staticrypt-remember-label').classList.remove('hidden');

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassphrase = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassphrase) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPassphraseQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPassphraseFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassphrase = hashedPassphraseFragment || hashedPassphraseQuery;

        if (hashedPassphrase) {
            return decryptAndReplaceHtml(hashedPassphrase);
        }

        return false;
    }

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        let hasDecrypted = await decryptOnLoadFromUrl();

        if (!hasDecrypted) {
            hasDecrypted = await decryptOnLoadFromRememberMe();
        }

        // if we didn't decrypt anything, show the password prompt. Otherwise the content has already been replaced, no
        // need to do anything
        if (!hasDecrypted) {
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const passphrase = document.getElementById('staticrypt-password').value,
            shouldRememberPassphrase = document.getElementById('staticrypt-remember').checked;

        // decrypt and replace the whole page
        const hashedPassphrase = await cryptoEngine.hashPassphrase(passphrase, salt);
        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

        if (isDecryptionSuccessful) {
            // remember the hashedPassphrase and set its expiration if necessary
            if (isRememberEnabled && shouldRememberPassphrase) {
                window.localStorage.setItem(rememberPassphraseKey, hashedPassphrase);

                // set the expiration if the duration isn't 0 (meaning no expiration)
                if (rememberDurationInDays > 0) {
                    window.localStorage.setItem(
                        rememberExpirationKey,
                        (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                    );
                }
            }
        } else {
            alert(labelError);
        }
    });
</script>
</body>
</html>
