<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #4CAF50;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #43A047;
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #76b852; /* fallback for old browsers */
            background: -webkit-linear-gradient(right, #76b852, #8DC26F);
            background: -moz-linear-gradient(right, #76b852, #8DC26F);
            background: -o-linear-gradient(right, #76b852, #8DC26F);
            background: linear-gradient(to left, #76b852, #8DC26F);
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>




<script>
    // do not remove this comment, it is used to detect the version of the script
    // STATICRYPT_VERSION: async

    const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 *
 * Mirrors the API of CryptoJS.enc.Hex
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassphrase) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassphrase
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassphrase) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassphrase(passphrase, salt) {
    // we hash the passphrase in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassphrase = await hashLegacyRound(passphrase, salt);

    hashedPassphrase = await hashSecondRound(hashedPassphrase, salt);

    return hashThirdRound(hashedPassphrase, salt);
}
exports.hashPassphrase = hashPassphrase;

/**
 * This hashes the passphrase with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(passphrase, salt) {
    return pbkdf2(passphrase, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(passphrase, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(passphrase),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassphrase, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
    const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassphrase = await cryptoEngine.hashPassphrase(password, salt);


    const encrypted = await cryptoEngine.encrypt(msg, hashedPassphrase);
    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassphrase, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassphrase
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassphrase
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassphrase,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassphrase = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassphrase, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassphrase = originalPassphrase || hashedPassphrase;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassphrase = await cryptoEngine.hashThirdRound(originalPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassphrase = await cryptoEngine.hashSecondRound(originalPassphrase, salt);
        updatedHashedPassphrase = await cryptoEngine.hashThirdRound(updatedHashedPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassphrase),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
    const decode = codec.init(cryptoEngine).decode;

    // variables to be filled when generating the file
    const encryptedMsg = '80d217b50899cdf53980a90cf7726c4300b2879e1d225526483091b3b6ca452f3d68e8fd484aa6e1044b9ccb84815b2a7fbaf83f5cbc17cc753a5ae29257146f08e9eb738be02d7479036628f9179ce498ba0343bc5a76e67c1f4fca3c287ed915e116eb223c17c6dbab9009a52e0b193d856ad55f14af9a3e44812aa06923a2a9a7aaac45bddffa4bba38652d7cac674e36b2695df6167a9b9a34cfa8ae13e74c9ef37bb6401ec36d8f01e3da509e3e64f410ec7cac3881d82afe963049cd43e5223a58ca8f5bb6ab9f0a181ce708631b5feea79112289a49ee9a060fa6e1996c4e86e26e06f2f3c1b9f9e5c766617bde24a73ca6e8b03708583d01642d99f02b6cb34188428bb11e7b5a31acab14b93d1f7b5fb8f952b9a3e97b0a4aa75b0cf41eb06251ae9b84105a15b107efd24630dd1dc27c9a4fa9fdbf06da190de9272de74f41aaf269636264a26b53c817f3f473c3ce542b3aff6dcccfc3efac2920964070d626b15221951974c9e7c8ab3dd0dbecee300c5cb7b4d1e35a15fcec4bb65a96004cc315d1c2931b8ed8c45a01aaa6a90274cf25d7a7d8715b7287578d10043293d63cd92da828af16f14a97bc37feb9632025fac3200610f712c84c4d9814e1b72c59c6154e0551e9d380f0810edefd0a7819478b73a4bf918aac3bfa417b23de1939815721f08a5d6d1bfb1292fda449641579d379ad97c3d6e6167218416ac4b865a143b1a9baf9d6f83b347ef7e957c9a19362c45bcd943631f488351fee4e89826c29ac9f5dc9c15c59365c372d799aeec5954fe8c99a759feda8bb75c95687ab0ec8bba4a0816fb3224678e941aee0f6b5689a8553bfa081d70cd4feb40ced788da382352b2bf80b8881052ac1dbe156868eaa848c69be6888e54ed9adf3dc75da9563a30991cb4210daa640a11b85c3d1949d5829afbf50daec9fea5d7d59915b272fb0bed779e007a5821c14509e4cac85e914e9d46510f0315b9c95f3a913e553b48c93003bce2f379e77dd59aa9c4e464dcff08e00576c949e469f0ca2c9a04a1052bb0bb12b13fef082759bf35c08278ffb424c0af213b3b9aafdd7a6b76be6322da7ef29b732e71631b0b346d9caba73ab4dd8b533a05fede095ddb514bef4f71eadd3a7f69a8bce180657d64e4bcb9bb66657e828c729093856edca7740d4b0dcbe4600c5512dcd09e96b98f10f4fdd037c7256cbaf9f7499dd75e3192c769f8643707bc3a1a06af29316f87bf8202baeec42b74d5bb34dc4d222198d2790ddf12508e2e6f0c329a79b99c4a7679ebf6fd28ebf8b1d295f47df267045bc135afcfda838d17b9991432d19a0bfa1eabc8e6edb6c9db8eabe36a2e34f062c763c977d22d3778fc461372be4a71b83e8b309dc726fdf8b971d4275bdf768d6920bb6f14fa76951791ce6561558d27449faa95df3809c4ee9dbf90d35bbdff0edf2682fcb2b786bf37178b6cfd7a55e2eaaa5023bf798aa1ed4d878d9a039f26964f99a33480737b7632667a5a7bae0bc049a4a447578164bb85a0b3cc0dbd1320ae4b1674be4743a8bd4d397648a17a6b0c48cb002f86819b2fc2a144fac0de13474558da881f555bebbb4f5b44c0b536401faa50446948968f0016d7eadec3d2c66369028c7f99e45357fd892dd6968edb8ce8ec8981d69d78668781d402450931b14ce0c2f31fe4d0c6e38ae86f8cb92e072f212dfedd91a3fa7e6b0545aa9ea438ffdc46bbe98a94c86abe2a179a7943d2599eeac9b539349eecfc7120d491103d891d18fa3ff17a719c6fd233b2df8b89fde341a36f4796ce855c347980e904094192fe2dc43075ca415b058cd13a76475a4c5e4e4206ba9f1873255373134f69203468d9903125dcd0b32c8147c1365f319e721fe7e7e08cbb01a370d771b899931b7eb7daf6e178a3610745ecbd29449ecdd9979255e61ec5446875d0f88f0ef2721f1f701282706f2ce21968913325b344b8a614cdc924db4b230fac916ebff0ca4b532464891f771becf49a2c0a018ba728da6576fa44441a9e4708bfbd4af03cd5f2b880a4c0aa5b23c14a7b157daae64bbcdf9cfd436ca4b15617b1127cdb91bf589e1c3ab195b598b4e47c534f23198aabf1c79222ded9ae60c3a9ee8778f62951f94b31b4b80b50258722ef51c58086da2ebc96f7ab1b04e8b6f75331d4e9d31374a854d9761cb5f688abed6f03945347cefddd267c863fc758d9ad05cea2f5e5dd45ef155d47131ffb33170acf17c0618e08d27b887778a40d38aba523d0fbef885059e27541658b39a24d30e0f8cc7ba09dcd6489ec8bb0c5e803cc9c4b33f5ea43f62bbb348f515f5e35ee1ad1b762b59da99663af45b68f23fe32455bec006990dfe38daaa99c512bf459d9b25b4dce42c779afd1e9ae561f4a11876fffafad3fe924969e5b95764f613aed50657cdad8db5151b677435c812dd912f2ed4e42fbcd91a960d091af2ea0b5ed0df25cc2dcc600df9893d3fd393452996fbf5ce39f703d5042cf1f3913415c55a0ba81c4648a800225a1cc6507afabe27828e84437f5dfbf6dfac46022198ae5423d6495bbfde7a9916c35512093601db7ac2be73316d87c47b465cdd277dc1c5cfe514861dbf4806fbdc500904b85a4872cb72923772c2cdf8b88687cf5d107ab74ced4a537680654b52d2f605fd49b7fda54ce64875872b250d3899bf1a7d2d9e270c88e14a071699776d9e5289c3449bc91d09621eab1bd3dec538ac7d053e8aaea1ff964417722d0a27c0e9de12232316ed56d6b6e16e73aa0f785aea3c2436fd63a201d8920ae2f5f88dd1676456a7b5fbd6cf8ec7482d3071eed8746d6f90a30523f3135022cb8d69e45db123872982c019372846bbbd14d7706a34719d9e424247c9187a13e5963c56ce5486fe447161897d78733614e484ca2527ff93f80b69eb3de9512a549c14d641593ff4f79be720b3bfd737116c3754fbc07a96e63f14b14b32134c920154f80b3c6fde4a8981e8457a2c6fdb48d50dee47bf1108d9d8ab8e0cdbfa89b70db7dc79aea90a1bc77fb2ab2ac65f94cb61454107fbc0d299d9ef2dcdf078dc234f7052aff671a8005408dfb4816a84fde056a118544e9f0c6a7d5e50b1e245da20a7ea02ad051aaca294622c01414c0e0c46b80b166d6fbf60308fe19a9f29c3742a78cd3fdc834a7f96d8694201133fa9782c337ec8ac9b022a542f3aadaed211d3b164ae6d4caadf41d4cbc9befdf6ef74de884d5e2fa401fdf85a43908a1dded85135a89e513626fcedd22089acf44ac4c378c8000352f254505010c65d3a2d73b9c9bb052a651c0528a52c1fba4211c6b4d79567fe73c143df1c7e1bf19a1265e28d99afa4ac92e0ba5929a11480fe0de8331f2302457f1536bc06e5271b3657babe0c825e0be8f683c29d8389030054719f10a9dc11ee7975cafb66712fcc39a711f627d68012060bb1bb17ca5c18226aeee010b7f97599c572148a0dc2db9a406df3acbf6b216aa466a49221ffb0bc6308ac470726c409cbf72a93dad056a1f6222a3b16a2b6afc3c0a6af88b58b9a229d2965cae779778ab21090b4bdbae69feef3909c58432be4464098a1c0b7248d4f1ff55a47de2b22a6cb3768308e44bede7e0a839f80a398e3ada02a152c4628a81c0b1555a211fe14aee7b475862452a69096643ab737081447bdd2fd2ebab63f9ab6999f12c4f6f5b80d059e442d399e476a1383069ebfcf25a7df79212c4713263a4870ae15e3dc90ddcf0f7a6dd928a15a69918b78b8d8617332cf8a305462c0393190c07fd84f8b31006731afefbe390f0335d664b3698b92bd8a644ef2af5fde1f57c0476b53af1d3fdf7b7be282dd20a7d3774fd4673873830f5bcfb4669d04823a56370a235c90ef14a1d1d261260c2af1b7c2486d4304557f6f20b7f48cbe67b9d2c6b74ffb0d55926473f3ea3b48ee9a6309a6991c1e19605d6af1a0756a6e4f30ec1f69d0155e6a539afa4e799a51f2c822e7f9e1166a010a80a33b24b076250ec809c43d64903ff2a236a648c9d3207be60efdb50a2403dc07cbc9020237bd627f21a74d42da81dae891a46204e05cc1f04db8dc01e935eb637335e50d6e5bebbbd1da3a332215ea5c2bf096bff3673aa5224fa03b497bee0460cf510f398567e95c9293e9ea92bbb24254f9eed48b201eddcfa19947797bc3f4d4ac5f3ad686d7b2429e76a4f488dc1a854e8a0541be42198132484d6e457d8e1ddc51800b2b5c3ff19585246be3678bb548f8e2cb3537e37be6d4e628ec120b80f0666b59bbef70e9bd475ad5a294210a73bb7d4a30c6135fbe77f5be8c599095892c4971d9b99b1f2b180b3e4d109b1f53c1a60381e19e515e12ae7ae73e8faf275ad43ecd108ae7b40afb0422bca92268949b33f2e8b2f35b4403345839719c3a70b1d549e6144c9f511b6c19f072cda499651b41d359672947e3da812be210bf52fad7449a8887a299c169f1949106e0d7b9f7cc7332c90947ff84ed22d1ba5b22f2ef5b71c5001006bb32ed7353c40d98a03f15f82163df389ba8b9673faf7c05047ee419fccd8ef9a478f9d98b1d84fb8119d69581e53ab82e1e261d1cc9202739e7c20cc1360ba7f57c72f9bd8938866d4e73d27d3a7110964e10e18e93becbaecb2d5b3e791715fc785441b2086326de33e059f6fbe0028a22dab643716994d53f0655452a887fc40eff296cfcc0897ffa6258fde6eddc59bf49e2df03e78ef357f1841f13bacc8c2d1acf54674a3c77e00347d7a6a7d0393d862787ec0677c14838ffa5715969bbf11f32c6b2c5f0629483ba37c56c61e5ff9acf9bfdb8de52960965122dec80c4dee740fb377fd14707d839503099ade6ca6dd400f08525fda12f3ea271a905e3d34833916c1d0cd8334794ca2369a88d287a8ed43c4999398ab552a3e0e0a014692624b8c5be45dbe870dbda2d8b865831c2c2b1cf67853e407beafe1c878dc6552f1e317ad9bc8b6e2dbea5adb018eeaaeb3f3487d259c053a22176ccab92374bd7e65ec46490a931f767aba623016824814ddc17db10879cc09c5663dc72c0670f64eeea19101540af23e0de89d467cd4f36715ebb6130f4e760378f10f3a252cfb89c8cbd73016906052e96a186dd3a4c3a1762beea1b2f8aa33083141ab758371b744879898be651c7de2a21133129f453dda0fbd27772c0863f69a067c10d19228eb3fa8adbb33516325e5335a1bb01451c24411504f691945df74d63979677da0df9dfe5afc93ed63f678ef3b8a0aed41faa35eaefacce39724fa5bca6e574db29927f55db193721ed8aa903034d278ddd349ff5e97047178b4fdb44f4c702609ff31d2160ace58b3f2d18858206b454780c86339bf188ff9765838c3a585d559bcbe57213814b1bd51cb6ac618ca2bbdb0efcee7a87ae9cff14327393e6886c36360bed6f8d80f832385cb895a8494dee51273d3e740e25c3e401e81f8705fbd9d6a08884db12e230d2d174335303b75d086bfd09fd7ab8dcf9c6ce65102b346240861b5aafd44da8b8949d31757c8d8d97a834835fc9d820cdc3fc598311c0cf9fc5aa1ede8ac90b2af5afc7fbf6518cbd462af81de6e7521c00d60ea3aeb12874969731e6725e89d66983a1a827e9362a7962a8dba81b6e153fde44c2e11ec29921ce1fbad9974f06801444c2310f55b698b51d9f49bf537d6e374cfd0088b982f966d4d7625b9aa2bba9e8944d532e0c7f03471a3d2fe2f0aa4e2ac39ca9255f96a62e894178febbe7d7953c8b7e91d0013ff3cc9e70c8889affabd9b57cf1cd36529489f25597a99ab6ed2bb53f9bcbea46834b0f36890231d5dd7023df69abc5649b234ca153263de03132c43081db295c1434a99825227a0092141563f02ce0947c5586baf375013dbb28e23770d8002e5979397a827452eacd5969728b09f76fae58304c8bc7995a997618555c27530a5739cfe06942bdcef8dc24e51150bc702a9196b10d6f1f9b13feeb20dab9ceaeb71435248aef75094614b09e032453b1b53144ead283dfdce230650f4ebea1b223f81893e43c9ea8f439e48a4986a06963644de3e3f66c688de28e6fd7b3afe5acd5c5e2b1b5500c311a3cec17e5b4cbbc9be4687c2762dcb1c7df91a10273f0e225d4b530577d9621b548732d9ef1029d8015e468c55c1fb535ec70a7cc4958d9a79638ae840329c397dd968bd3728453d94dacc27247bd14202befd5a8d118559f1e373173053ef434a0a5b0fa81fa22896b311d43695e7551680be9561bee3d6f2707ab96b69252fb448ae63af45d9f4956bb3fef1ae2cfc904b0dbbf7ca4e1d2fcf7a2ff5ca8a5d13cca2739c2210ff2a9f9c8326513f29b2a164bec1dbd1661c78e6311d06a072edfbd932593250e3ba4d3a55aa928099ed2b062808a99ece22c746b5f6be0a4229c27a0305241cbb6547f7fc36bcc91862958294b728c9678664865b2612ad3a864aa948231401ab0494ae56b7c8a36e163b42d9b696d3d8e92c238dac2dff2d6058324e7a897741c3b4b5a0e033f81f1021f5d048bec527820fc8bfcb7f3b93b88931f0797ccf178e5a55706cc7762cdda040a2444ab54992f745fc7c1607d0b6cc91cfdebc51ad32b013f8eb45c907473780811acc8fa56a5a783876f4e8ba9ca5955c223ba46fafd46eecc4676eb3ed62ad3fef6fd8c5c6d977abcdb263f7b874b2a564a553c394e45d7e092f92cf713871f45309bb0db42cbfc6a4f00b94a1eae1aacb1e7ab9aaab79eb446c702b10063fef966af0eb53569dea54128e7caf58527020b48847f2597a6377fd2b2831ba28ce18861850f8f823a90b1a7a7c5d2b5ec804879d546347595c133c409fc68887982341b7c31f516ec6626254ff7a40e812258f4eb22526ffc1da2b18af22814158d5b1a8de49f5b39d21cfad164e65039ccf67081e9629d5c2743a7824c87abf13931b761da1f703f413ccff0a399a604596199f8f4a32c73f7e148507021aaea36e6c365443d06ed10f8943e39fcda2735f0905a3dd7cf0fd8e76e15f7789dc983a2891c0b60dd981902aa462f7f9f5f9bff1bb569b085bc022798e775b179e862134540ddf4eb6c70473a5f9677373bcbec7c9c0a7caa58791e1810e09cd6592c4655a00707ade3e7e3aaf592c952bedb396bd68b3ae5cfdd0427803fe3d1865e7027c313f670f94eb5eba715e8ee937c875dfd907de0a89ea44b613efcb98cab7035ff68504d6f2afe092835d11d2331395f2da9be6496bec2005ca21af4c071834ef58f144cb5a87d3e3c57f6b335ec4b7fd94f17b3a49bf551dd33d4d10b0872291e4a9ee7332dac028f9df1d3c37bbcaf5287af0862d4b5d7f1919a3a804574e444f393a9b842bdf1ed791eb735444f5a3ec99937e31791003054e58614f1a66452e5a974de03d52b78ad08b486ad93c0863cf0dd5df5ba46c191589c598344b84f307d3ba97acaf83d777efe1b477a0a1e804772ce5a095824a088a48cc66a250dfacb48d592e31659d53e7164758b845fcb7923a4c31c5f5553c88bbb9f3e865c0b1941153747aea4cb25567c235d5b5fbbfb806fab0488f48ec79f157de613784a075451c8cb5e7e77de667d72c8fa6f2c8fc04a33bfafee07c19ec824eb34e936c0a4ac3b2ff23b90b7030109afc692e3a039a04d562f4f7fe9b2e80d8df640e44d9d7dcd22afd793a7d657656fb91bde3d0adb8a9e597a0d8786defd66c2aa7a036cc69a527265fdafcac222b6b5bc6c097499345d98ac6dd1b5a74a84b5e50c5b31a72c24c9b81d555ac384f109a7f7834c89203639e2d648d6460c0a4c062940e6515b91a79e45ccab678a8609cede79b6f934bfed8b7ef920f5206996de6dc0e8832032c306c28d97519f4fbb55bfcaeb2d26ebd202551093293c3d96d042d8216e8e23e389e25f6abd4cb7e0a60f7da6c07b5dbe216fe2c9eb9799c9b823be7a56fe957740b1241d14d4c956d64b534a4853963d863b757d5c7b48ae03006494f3d9dfbffcd23a0d2d56ea7eb03cc24114a27b79c290bffec31d445be819ef7574f038487b17f8b8dfa08b60a9361845f7b1bb444fa58b5f30cdb285b5dda8c58aa1a640deb7d86aeec65024b471f374f3470dd31579046d755151958d61398710df7db29b43f6983930273ab97a57d6f4f66034e81a8601bbb3940b43a8f285c5869fd1f3b3d5269b66405feabd29eda2da60b4bd51512f05fac3a3b49c89475e445be1f1147f73241caca84f6ae22c28a95781f897a9f463dab6b69d1fab7f24a32d3686acc57510c54a08cb8e08bf1d906103367362f744ca7c6a0c7ba2086ea9fb0f46104cd47a84ad8ae13b7e38f7b2983621741a50144cb508cb0ce14c963a8bbdc717f020339aae4468ff36cd245444b1614a4662b6ade8b084a40dab9338d002c3e81ddb2ae948ca31b900814c4786a921c7ed2ba2528972df010d48998fd2ee73994ba973da3e9b55c72cf98ac3c07bbd1ecd80e9ca628a9c04e77f74562772db8f22ca2b2960bfe7f2a369833fae04d69523dba1c97e6f0a933877cf3dc75428159ffd1ff4dea94e4d8e411f82751dc3fa7924d27ddde3cd72ba1e7f44e92bf10c1b499d89d5d3ac9e8c6aff6208cacd15c18440ac6ca80c9046f0a9cacee5abfe3370ed91710bf7b7cfcf23763cf1a1b6dc221d124eec3c3fd5ca74d0c8a7b97665f3709884e273f477336ad088daf4ccdd1ce7705df85cf9aaa3ee92b00a204977e06c319d4eb19d238aafdf07106f05067270e028c6f99377e5b1fb7050c4cf26a5a8dd88fc16b3ceb0e2a407c6eec34511edf170cd8f390e899da0ba2496d7c4d2e10d90ba1ca05f3972a23215fae15e67b103b3ab7bf36d66ddacbdf3649a7b591cca92abf411b2f0c05ac96f6f5a528949ca49af6a6a1ddf7b6d9c16a135767275169202dd3f041631413ad296a463332dbb796fcc10fa9da8a4b49a67c7de0f60f9bb08a113340ca56e0bc034fd90bb90f5727917ffc07658e8a1264ded337c882bdf967ca0cb674405186e4ae6f987d1a83d2c6d6f75ea739ff9e9f0b96c1759d7b976592642b3f3fe25e6da0284a5bd62ce66568192ffcc693a6c3f121415b8b64e1a17e67dabe5ddcc79b73df59f4917a8521e6aebc3f7f075d11b5aa21219ec00ac11413495fc3a3efb124b9a07d62aab09c2a53aa21596f19f110ffdd9257f0ec1d7fec4b7be63c524deec234b8aca1cb65653a80aba397e5d25c34f3c619e4802eecf08be405238aa6802dfa4215f7cee0771a3e80286f00f2fb097ac673ca6dfe10b572704aff03d0ae2959a849c6b643572f1612e9f880003f33b1ef8259e4784151cf308a5eb35b59b64d8742380e8d69ec078b743f8eba5e4c21585c58d04cda6ee7bd25c9d69b22888aece304238d10cad81b9936fb2077ff7d2eeb7c80f2899e4200a49d115ea45030329bbd5883fbfc95207c0a1e100b956fb289ef388d776b9a5ef19b662f0009e3b3235fcf0293dc4abff4be850578579008768e79877ced592b6a8f3eb51c503a21338d9545a9dcbc11ddbe66321f7b531ec09268bd73152d1ce02d9af790d09d125953b8bfdf8b4e54dab4c556f53375b08cb24758b46f02c509ae114600c06b7696f1db5219d4ed5adef5e52403c93f2a572062875069286d2ccac482028dd002a90080729cd5cafd07b15f87cd688df8cf9672950ee30e969e2abc19468a9b748cfaa93d03ea1d1470244af9caba4c092e2e8d0c157d7e1196bbf86050a4a0427f0cd3a467e85355d708272310b75c63008e2b7660854bc52c5f12397219878da33d900221ad95920e72a36ff915358d55b488cb06faac5fb3b2d6aba6cec68fcefb878f28355b172b086a7e3f51a7f6aefec5ea0545ae4700529300a3ede1c98ab1d59f9786fa859c54bed27b53b76ef9fc5216241441153b45b6b8c645869e86a7e7dd3ae3c9a6a13bf09d330e5a3a2705efba9944cd9afdfdadbba51e7fa145b6b510fe2815f6d3c61a7600f88949678a0acc4181fd990c63322a8583dfb93fa24c426b3102438027673cab02c77dc3ad95ed828d6f0d6dab13ea58ddbb631927d6b46dd72a8ddc9930943e7d916c611f79d4c016dfff5c8c3b59d8c22afc711083616c662b82965b70bd16ed7de2ad82738043ae9bdd9658c5f47601cc97002abd932891e463672a4394875ed24ec0882deb2b1ccbbcbc96a3f5ad1450fa57fc5ddbc58523ec64fc3a28dd8b8b9cb47956fc10483cba389db5d1ca62509e322e6e8b9aa696f6b77db5293ebc98f5301244db0dec3cd7c9f4097f5762deeb1ecc5ce2de3ad7a358df24e7abec157a823804f2264194974e43e747fefaaee7b369052d97eaaa13a34167dc398bce76b2d5626fe876e9dd5d382775d45623ef67b6fb81a84fbd69e7e5561a3f7e05fa8bafea8a4b9b41e4776b69c3aab9e3e32c6959969e83a5925279a1459b8f7331c797dbeb79ccaa7dc7fc33d9e9f476f408397b25cd5fb9407561d2bf399177b07e6c57b168ea6561dcefcea60870a75db20bd74029dbb304f2faabf24ab621ece5c4c1fc1ed21aa791351fc861f6118cb66ce523a191456139a3e627526e129958eaa5d9eef783c40c5a8af437535a710dc0a558004d8e7d8986e4a82ece1fd500e118c42983f9de481578b645c10cc82217288bdd3a4ef79b9fcd474dbab5d56dc0adc06dc1b659d5fc9c638b711c79d0d9dc95cc96e9f35ea08e199cfa6d9322aaf416b38425fac52115f68fef14f38930f010c3a44008b85914ba9973f0352437862487d4f767502355f120032a9e310eeb6f445c34e49bc833d4b4c35fc4a59f4563f32ca96e523fc1e50b24e98b5280c627e39d32b41f5ed5f55474f58107635cb329a23dae09292547f22e70f4cce1cf6a0412bd2cda1b4818ddfcbbe9191dd18c7c686386419cc983199cb0a510970db71328b04832f3e2336cb5d5bf58a8a036f19254ed6e2d0a244f4d838cf0ad02e7d8a42dc3ec1d6c8a81d7b5e9caced0ab28dffbeec8239ef33f4d745dd5fc6554d43b8a39c6ddb34ef0d2cb5f4e001c9bc99e1dfff99e270eaf401f4c6b44e540c7b40dc30e320442ad79b4fe6ec2bed81be03b56345f26378705da429e5b6be25ce8d3364f4d27d0e3ada1955674cbe1241ef24e70ce4668ce6164ba4a901cef734d79f92de816bdfc81b04e31573d33bbccdfc6135a9a172263cfb95d51c8cbacb94540af7b3ebd9858ef40252202ffbddcd3eea1bf3978557c377ceebff286d6874f4a2baf92de69973387f998351d8ab48122edf91f4176f96e050ee24ab5dc92d957446698ac6824b300ec394047f4e8e919895f4e9e8bcc81dedb34cd005623ba1e45859f260d703a0499cdf7ef260fca519aefbe726327d7842ed85b8ad3966332768b0c59a272ec82890312c5d2fd33fecfb27a2b0c7d268af244dd4daf20ec0767de7c061d6fb725d306079473d940c3d17f35c8dc758d785839ad80828143c8f15b2ab8cfddf12c78735e16ca82ea2aa1bbfb983ee6cd99b236b269594a9206fad262b2b5f50eb4adfad4b5cb97c7e2da8340d5b1d3f56783c7d723f593e8e1f76d8df44e1d7e66366fe8a00ab1c2bd36c7303d1b24acc6e4d4a70bfe126ca5896ca2ecb74b516abf711d0da48ba546308bacac2604a0dbabf74d180e74269cf4b3a1142e71ce45a59896ac1fa76ec956cff5cfb09ad0fe374d6b0b04d57dc7da607439a6e71ff11fc21dd10d062ea3f49ce4366476be68ec0df7e7f667ba2a352993ab43b952badcebec407c6feff38dfb34acc493bf7bc20e55fcd873080f227589c7fcefc2cf21c2404afc8df50bd7b11f12d60cbb33207fa3daf876f39d9921d928d9835d5ae9eb2a9f68695e09779479361ad7d7f0a68787c36364260c59091ce7cc5e6194b1c27d7827ca99af24117583139a2f7c603394c41c593121e0f111f2c3725ed7168596e7083dc2c475ba2162a78cfed2a9b275555e58e455f48f2d60353f1ed62120e6a55098e2a43a262d3789d738646bcce7a166003671c9499227315ef4e38d57c0aacbad807ebc9497e76b93fa8b8a8263149029bb9f2fe705a32ae4e987f3aac203f5317cd545e3846df9ded18099c3d69b6400f8569b031769dffb4a1fc3544d006b2b9becb8a969f7d591ef4596261a7208c8f29c78998a57956e277754cf3f8297b438c3d4d843d51369908cbda617cb28e76eef63b45e42d88ca477535431eebdda26bb1894440019d67cd3ad4193c7096b84beabe2d8bbe50e9a4a228ce34771f71dd5c5b27fcf9a7e6ba343ad8b1006690a4fb1a3761811cd9e117eeede2a762fabedb4a1b7ad53e22f9de0ad2e6a94217857e7e6f1307794b823360af85b63e5df858561430c2f6484a1bdd4e3fb025230fec3ddd2dee58dfb7d6ab79a00e793ddeb8a8da295ac55e933fea4770848d4bf6303213a83242327829fa351748d6e76a8b9dccbf86a97a75cb18eacdf4fd6b3232376cfc13727e3217861e3db71124686cbce8de60edd62f213f80d0b36d059392af226731e5d3e08e00eafb61882dfba6b4e9dbd770c36494fd06d4a44319f318d69801b8312d99e4d1b1fa1b29e0c4b5fab08f949e6558ee397655d53934bcd26c5e0a2fbb3d0cf8d9ee3c15c88677c111daa741ca4a6bb3fc4a7721e3a74412af300e0279899d5f1264b0c3ee860b7f0078153cb46db5acec60789cdd6a60ebd6f23ac2c24d7a3ae384b0cf9bdd9fb804102d60098a5d84e375dbca383a365feb6205e03b2ad0d1abc5cc9a389e8401b21aa80baa89b9ce3acf2d4691b8993defeaa2586c978083cf8e563743f166a75f69010f9ff99d429cba6fc6c67e18a87e35a5d141d208d40d588d91406f95c6cd4310a39352f04f8329854fad1f09b2007ca04e562bd69cff63660731dc16a838970b9f786094541a565cbc417e0a7877e34ad2d62b309fbfe4d087a06fbc0aa4294063614cd0e0ce6390dca974ebd9273b336f7c426fd6874710b1320a1d7d36780f59366236096ec26c818e90824da4b7e703f168339dbb307907b1ebe60ccdb01f227d4961c127b4e77ee6c5aea374aaefe25bd96f155081d741bb2acb66c89d92090e550159b7c934c31a9f82f4cc839e81e244b6c987b818553d5943f85f181b7f8d29a07e28825c4794439ff2508272a1b8376081ce3f1ed6396f5c9f192bf53a2ada6c36064de7c9a574199647c4c567d2451f1c9f0112f86266a71a78849aa1b1282e178039c19923fd46f39f9be61632b978be6c4723e41510c4b769af14be57e62cd8c840265f220fd46ea506e6303ae22f52e75bb0b3b7caf57d5f6e32527f0e3e9fb98061393c222ac79d0efc172c572f00e602418175f5b1ab39f23b2f8ada8b8cf25323d303aae06c2d2b406a414470792ee28b491390534680d154f1d65a15ff8354b4791f2916153a466d9457f3644403576b0ec839b1b5fbca7684fb91acdf23e755ea2598fdf8bc771e92387935ae3f13e779d26b7a02bb788adaccf5c4c1a16fe9b079d75800ec46635f89cccb3e053bc2d7b47f19bb56af2e9ef3fde0fae45f1baf5d19c96d4811bdef8cde845e131fa3f841ac1a6895ddde6a2e1d674e649f28bf25d3fc4afec3b8c3faeeff4dc50c81aca74c449b791b63648407878172e7c749ec4d9626f4304eb51116b7fd5595fea4a1ec7ca224ce4c3fd8d6db5e90ec418234bd4a07c70cbc977af78abc633d7326d19a224ed337671e6c3d1f56070176e5559b735dd083db36a7376cb49ce83084e1da43665d7a8f934991596db7a572362ed8756a059a7e66deedc0cafacf649933b8abab3b303df733f5149c76829562acde6694285378f58123fa7e9fa9623884c1be3570452e5f708efc084438eb30e1afb3917001b10fe0a69df290891a904e1840f1a178da309ae953cfeeecbc49b2dc6f7ce00fb2bd3c7068b35b4455ed3a7f3163b351c3b169ab6f0f4d64cc78bfb4ed700379023931d138595efd2563cbdef9e024720169fef6b480a7eefd8d2261faf84b60bc2d6df7f00a7bac4fd184423a8dbebdda399c3e288f8a652d726a5ceffc4e7b4747372844ac822802f9871a24d20953b8e5d209b5191a9869a9c9b1a523093bbbbb72a3867f81d1a7454a9d477b4f8917136a5717ad5ce2ac3ea47c2f3b6325f25907618a148d30f97256647db91f76c1f10e09babc618efc8abeb4253d6dc8e989300db76607b572ff292addf0ae146a89d74788031165b52075564491a9e5fb7ff66a1ff0e8f7066e78782f45b368ae35ae549f8ccdbc29cc9177ab9be6bee15daf6d9d62ebed2e8a85e52c673430e426f61f065c128f88fc44280f1d0d9d7784df730e7b1ecbf9def31cb8d1fa1fe5c08a2645ce27854ea403e552aaff902e7f2d03ea663bef1f8f2818c0da2e2946f83e4d45e153f2f15384d208a299aa827692e1017b6e44488789469e79aae1bd1488d761810332ec4e8d9402ebdad5ad5274ddcb98839a161650fde6f0babfd1dabb78540d055cbdb234ab1b06d59a6c4a618c16a038ca4dbc398b3327399f198d7005d4277aacf752b78432d2f6738f7ee5b634706ca5778a16c5725a2c2ab975727403dd171cf903d7b57c8f023eab8427cef92a8917175b9b521e84009bdb75b9ca4774943abc335ee3960ee35493b7a399ce9929680fe7073efdf34a15494d9485bcd94f84feba512d3c4605ce1e055fe2fe6e6f3193fd1e327cfaf11eaad618025d9903867cbe12a4a689c241c899e4769dcc71aa892d2e36ca2d9c1af0b77ab7b6f7c8b163f92cc599c390a23389f1c43660a1efbc81466c1ce7bc0aee78c11feeab6601573832c1dce6e073c8f1dadc8c8ae3690fdf2ca3410195b0625a3fed0a24f3695179f179cd8c945f8ee32bafb91eb15f5a30f2e9c10c65e020054c69b9440bdf54697f6d0020bb66e976bde92e60eb746848d37c12977919c61d536a4a89cb1efa8aa1149b2ee6f8b1c6cadace1b2672eacd6e7480fde3c73f1b3f9fc40d70551a99ec0ff7e0859d2506f8dae16ac78516061687703287b6f35213cbf4a671d71e05d0f0db3c7a994a8e21b564a6d17096ca38255e5388344fa6b903e2c90ebeb10a8c0d9830d5b1d1bc3a3ad1dff6bc0034071e397c772c5ce04b7b41e4d7178efc424d8e46bb0fd825a1159f410d6a4b1c7c9ad61bdec1e83e230b7c6f627f0b808162ee15a0d5667d3ad0452e1cd82030e2c991eae2fa9e3ce45656629fad6a319e82',
        salt = '42e506c8bd3c60b14ba8f89f4a74dbbb',
        labelError = 'Bad password!',
        isRememberEnabled = false,
        rememberDurationInDays = 0; // 0 means forever

    // constants
    const rememberPassphraseKey = 'staticrypt_passphrase',
        rememberExpirationKey = 'staticrypt_expiration';

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param  hashedPassphrase
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassphrase) {
        const result = await decode(encryptedMsg, hashedPassphrase, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        document.write(plainHTML);
        document.close();
        return true;
    }

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        localStorage.removeItem(rememberPassphraseKey);
        localStorage.removeItem(rememberExpirationKey);
    }

    /**
     * Clear storage if we are logging out
     *
     * @returns  - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        if (!isRememberEnabled) {
            return false;
        }

        // show the remember me checkbox
        document.getElementById('staticrypt-remember-label').classList.remove('hidden');

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassphrase = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassphrase) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPassphraseQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPassphraseFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassphrase = hashedPassphraseFragment || hashedPassphraseQuery;

        if (hashedPassphrase) {
            return decryptAndReplaceHtml(hashedPassphrase);
        }

        return false;
    }

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        let hasDecrypted = await decryptOnLoadFromUrl();

        if (!hasDecrypted) {
            hasDecrypted = await decryptOnLoadFromRememberMe();
        }

        // if we didn't decrypt anything, show the password prompt. Otherwise the content has already been replaced, no
        // need to do anything
        if (!hasDecrypted) {
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const passphrase = document.getElementById('staticrypt-password').value,
            shouldRememberPassphrase = document.getElementById('staticrypt-remember').checked;

        // decrypt and replace the whole page
        const hashedPassphrase = await cryptoEngine.hashPassphrase(passphrase, salt);
        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

        if (isDecryptionSuccessful) {
            // remember the hashedPassphrase and set its expiration if necessary
            if (isRememberEnabled && shouldRememberPassphrase) {
                window.localStorage.setItem(rememberPassphraseKey, hashedPassphrase);

                // set the expiration if the duration isn't 0 (meaning no expiration)
                if (rememberDurationInDays > 0) {
                    window.localStorage.setItem(
                        rememberExpirationKey,
                        (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                    );
                }
            }
        } else {
            alert(labelError);
        }
    });
</script>
</body>
</html>
