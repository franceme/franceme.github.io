<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #4CAF50;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #43A047;
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #76b852; /* fallback for old browsers */
            background: -webkit-linear-gradient(right, #76b852, #8DC26F);
            background: -moz-linear-gradient(right, #76b852, #8DC26F);
            background: -o-linear-gradient(right, #76b852, #8DC26F);
            background: linear-gradient(to left, #76b852, #8DC26F);
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>




<script>
    // do not remove this comment, it is used to detect the version of the script
    // STATICRYPT_VERSION: async

    const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 *
 * Mirrors the API of CryptoJS.enc.Hex
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassphrase) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassphrase
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassphrase) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassphrase(passphrase, salt) {
    // we hash the passphrase in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassphrase = await hashLegacyRound(passphrase, salt);

    hashedPassphrase = await hashSecondRound(hashedPassphrase, salt);

    return hashThirdRound(hashedPassphrase, salt);
}
exports.hashPassphrase = hashPassphrase;

/**
 * This hashes the passphrase with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(passphrase, salt) {
    return pbkdf2(passphrase, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(passphrase, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(passphrase),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassphrase, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
    const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassphrase = await cryptoEngine.hashPassphrase(password, salt);


    const encrypted = await cryptoEngine.encrypt(msg, hashedPassphrase);
    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassphrase, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassphrase
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassphrase
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassphrase,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassphrase = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassphrase, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassphrase = originalPassphrase || hashedPassphrase;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassphrase = await cryptoEngine.hashThirdRound(originalPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassphrase = await cryptoEngine.hashSecondRound(originalPassphrase, salt);
        updatedHashedPassphrase = await cryptoEngine.hashThirdRound(updatedHashedPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassphrase),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
    const decode = codec.init(cryptoEngine).decode;

    // variables to be filled when generating the file
    const encryptedMsg = '0c9b53492d6636b742f15bf8d0b8a3f4b51cb123e6db6887e3201bc9a979d57a93bef4b7b8a3a864b7079e758d6b09164099f90e07443737d9d241a9e923f5c6821afeef2d8a294340d9258d0e5663d521fb932a62af27c9dc900e1ab9707a15082a3bb82436faf222199c60c3fddf9622281fe31c2fc0de270751d681a47373a39d10f7331f9b7f2e8726691a840c5a5a14617db93e03b22b3b64580e24b2a7caa0cc1919144f88d2bcfd20f01fe10d2c49ea9300e3cb82d13123be5572a341cb169855935875e7b63c1baf30ee2070923b11ab1a38439f09b12cbe17f27c9fe62c82b0cc38e76d325811796df55cf02b5c290708a2888fca8e0f2516732218c45882076cbe9deedceb1c7cc5bcc189bc0a7ed25b3be9881a9104a988174f4ab71bed99a25cf18e3bd25f6872bf2030574836050328859892874ea015cdf295fcd5e009591507a2afcace069bcd558a65a1d61a845b8cde791a2e4a9706035bb127a68588ce199862fd66acec4d4b3ba9081c2d2ddad12784202bafa9e385dd91096e6c9dda5ce58d709185ec9ccbe8d45ef41bd5bc1a84ed08a92a282003f9828e76d1a1d6ce4818d2f728c2d164b627c3b5bf508881b3c4f77751f8958dfdd18b049b2024f6a40c40f28f801ab2339a213c78a871eea39789bba3c6baf06e9c3d7a22d3570de023381bc60800625b62937d091bfb109403674615474fc3ad9d1072e2ec8cf0c336de479dcf43ac7725ec6483fbb857f690040e147a6051519db821a7a270c40c6c5f5688d6324b309ad3f4860c85bddc3926191a87645657db3c4f31987c57b0d6a66945e45b30c76cc1849e97d54dfc567c7ea03ca7858632482077d91a5d391e43c00d8459be188e2c1a7b2ee204adbc6ceda9801930e3ecfdcaf793ddb30c8cee7dbdf223bef6d308e033d0f87dd145b5aec446f2cd9bb5f9b499a3697783e7d6c9beb8073bf58ba88c621fed2b7f6d99743e69fccd622c8c59c7b395af3dd7f97ff89af93a78d2a440db296f58644feaf55e503f6bc22d789897fbd7287770b46f0a94308641f42dbd4bc75dc8ea0c69110354d94211dff52d960c7f0b6b555f1994852c8a307802bf57b50206a9a578c3cffbf5c3dcb6a5abf798f315f33845614bd2ece793dfd432b48e153c43759a5ca170ef1df8415ff1931afa24cabee8aeaaba5da9346cdf2aa995d2ad866c8dc3cd52ff67106081a424003ee1ba1084f7410899f1f2b07358d343361f90c84b01c64f4177c953f07c6357cf7703d6456e637f9350c467d745c8cfae13805fff5f96807a31b4fc03afc7c6b43750cc47a028f99f47087195991551f37667027db249fb38a0fff1eb42001e92a2eadad2c4fee7899d5b342a93863224b29339317f604023a29143526b45d3ec96792307a009c349617278a05e862d74215d6fab5994a8d6947266fed3fb79a946a621b283cdb51dbc9047f0fabd2b59047de86761163de1a70396572a1b9bff5ea9868bc195512931f87490a53d9f3e3a895f782e09b842df4065e9ff84aaccafc154301b5ba7aa4fbe7c01ef664d1648a491b2853c249b6723cc963eee4b978c7d95a3681ecbc2deb86801af36896d2bc067ec905c649adf3d49fbde8f8dd40d5722c95c276b4bd17a149eca1e60787c3c15bda56dd0f9e21fd8cce94cbd54484f443e208181f13c5f9123817b58f68b45ea26a2f91f4637942c606d2638f46edf451c38d97ab093efeb6c722c69ee53d0b172621235e2153520f8355d91211058522c9dc2dc60fcd1809a07f0a29873e04d98897195980e5e4aeb6c80f9bf0cb39033dce07e1baf042c5734c919e4d9c838f0bd369dc1754e03f2e61d4cae76f602ea9b987f6d7d1aec2d207503810c102e0ae921eb29246647f866198fc84b30cdee95678fdb512415682af4cef2baa7cb7881f548a62bfec894901eaf4a818e355a2418b677ea19b12dcd7cc1a460d00a80c2f389ea6d48b66c28e00862dfcd82235827d374f178924aba4ddfbe6148ddf152b9fdabee68a7a70b706ad5e5e8c2b59844d029b510329fe8a1d7abd1327e5cc3f366add9aecce59c33ece79609b06ae299790a15e54ea3050e231ba88a94aa06f3bf1b697d01a317c8a16fcc4c91fec711848fa177129bedd4ea6ba171435d255b0f75e56c21cd0ac9f77403183508748f663dbc2e0a989489da115e560c6cb51d00b002ee50c5c2266cbe67c18c0e572643a9a50d82f2fe7c4662eb8cc7beadb6d107c3de59c8e30354a04d6addf28ee43edd85b0fdb1e22b47716e4cd6e4efd0449546dc642da9c2f8939a25835100c0b24b0810eb597c93cce776bd3871f748ad2e44f73c543e57ab2439b1fa22d15bd5819fda8a12323628a50b74bd1d8f4e661dd11fdaad270938a1a6b6b70c6013c344d419486d10724142fad925950fcc1005beb45735498ddf18cacd76c077df9a3187f950a7634eb005f17847a70e3bd0a6586965e152ae26d94b298658854e4a7e648e24af5c1255a99856302101c1f8cf1d37154c9362595f3f0f2ed30ae8fb03e8b73826426808d9b0d8d04b7c3f473394c3574416240f1831742f4c778239e1f77a4c0cce90808430874fe19234254855f86fbc8d5f3bd9ac76cce98c34de6d3e327d07927590aef636e159d1652878c3e770fa855eb4f90148da7863d83de2e4b8169b6ab69a83ef08849b4568d438e47217dcd110a33b39a90495e7a422e51a761d3deafa1a37a78e7634ec335b75416aa17749afbc8e613c4a0f9ede946e1646e9aa06620ef97d0ef39a493f058b4fba96baf0b08f2fdceb4e3bcfb71b2c0bc72b5f7d0710fb32dc7f931573d9492de67c50930ff693f029631e2eeed8a73625273d4e4598e284a67053451357a3e7db07911f16f950bc47c928aca12345dac223c0ef2722759d6e42e0e2cc097fe6feb6cf46bd2e83f7347ae97c924c1708e42ec9d421a7903b7070d13e72cb74cd2a2fec19d5d5b70c48c8c012270abe25d500ebf1250001487e1d4dfdc63da53a9cb017cfc6d06ed1af342318e7ee9ed0eb5ef250bcbfe679f5cce313ddb4d165880e06e7082b1309fae95f814e483bb76a9c90c06f1bf898d89860c121d8db26462486e95ae64bbd34e746fe536da49fe3d30c15d72510fd3e212835f176e477ba502c0a30de64e48ac999e5eaf077d45779249c9b15969fe74cd56cdebc0b47787c63d5235f4610f0814baca22c790bc6b923075e096d2851769bfe9584c9ebfa251d4fdfa4a4ff4376e674eb2d6fae45bc14c9b619c1e76edb4b5ef9b92b79b8e7a0d09fbafafe91c2a45a73880e3eff6df26021148031fa16aa012f60d5a163831d3fe0fa2ca15d13bf3e95c02259e86411e79f546a65f56997041d49effd3274a0505e8abef1d0d01d37ab528e0a873776bb2a149c729b44f7d3b963833d8e807636b2e7ef094e3c2f0da8c05ad5c243a8edcbf1e693bb350802d857cd602a4b13beff6488bb35124acc8f3fb90bb3563a92e9de867b5645938e608640706e41d6206e8e75b5357b4046e08ce1f07a12a80af244c3aea1fd7fedec2c0f2915e8551cd0c2622e5b4034071d36329a130a9752a7ee74924e12fb9b1fe69dcb4190782bcbe30e224f620c741e72af8967d234f3db4eea3f3019fbeb35ff2fde2a3a25dd9c689e8665b9ccf2972b48e7859d410db2107a65942dc3f1f3974c2154348acb2f09bc29ca994bbd060d577be783aa0d6edd50107bf6e6a202aa11e73a3a7f6fd3e7dbcac4031289803321374639eb7dbda32a4310247f4116ec8a5abe9a1a63b444f4b119afa480593ca7ac0942e9beae199397088946507e11d92c2174024596309e86bbe494a511e020b5875cf74fcafc4dda79b7012bff61876b3d22cb3189e01fb524c2bb3d0ee33ebe4e2c450ed0af1d3fde198105d5bcf4d1535244ab0941ea2f52b0e4d9c41be924c0af0f55fa8e640d558503cd6563ce5371a0901dd92bd66d61f29a63d18d086efe922e5a2d697bb25a6954a5d292013c1029eb3f40f13e22a9d34278e94b7cf33c6eef7b35ff296efe14615a12e1b9c8ccb7fc07d1e5bbca79cc1bb801cff7cfe1caf0e56a2bad0b81b688141cdd353b10d3241d0dc5dfa07a4d00cae49c4eea935314db0d0ae33c95cf62c0ac26069fb30034f6fdc3fed8c2fd92e1fbff1aa69486a1728535a05ac2550d4efa4eaaea6ab31695b298a1bcbedf5cc54ea311c64645cff7f6cb04b54921675bada54fd36cf5f368eb040d5a9ff19b25b4dcb46b8c5230caa68994a7c523ffd0b4352e925c3410b3f655f59d3f5380603eb5acd2e8657f490ee70e69079d3eec2ddd1861d522e41b9f396f6bc10adaa730bf161f2400a2df273fba8c1805681aaa2e3e257aabf105fa0bf6f23b4d3a045f5df270825d4931eb6da81a8dd8abae7b4837509ca3cdb121c85992eaf1fc3e32975b15e4a75680666c08658ebaaac44ec9d4a729f5ede0c5ae4f59225aa0b7c0d15197a9f65f961b9c2d12ec23efd8b62d4c4b31eeb2f0b3719eb3c7881e94b6783c242bf2f76733134405f203c5bdb92941a753fca1e797778cc78a7b04d799e091b579019dd61f2a5146e0f8594a4307a5da3d1b9be44788e01ae88d2620ae81ccfbc3ee07f277a38243f29143e1ba7d34d81ec65204c92f22ba0fd4f1767fcd476d377a227fe4db037d213db837740adb81a2a77a88e86f4d7191d4cd66c24c8d86f2fb7a4fe5ff7bfaade4ef4d7d9ef3bec332d900f9eed3faae9437d4704b3c45ae9979310d0b10a1bf6ae62fe2db3ccfbeaa75788799f3f685eb1297fe1d87018614b7c6842c103676d8bcec3a2f23f13ebbad2734b63c49f5a1f238b70943010139ce65cf5f8c28c30ca90701c1f0e8e79d612f9035544b037f64e3d5d8566a13017e592006f19145f2ade6844369a1ef31d01094ffb5f8bd8b03da4ce8153f7dfbf2ecfa24cde5ce3738bcce4a10a7067fd1a9f496c6c6f32f3e489049b784e4af5d8e3a9781a516f88cb6b342362c3490effc5a79dbcbb04f5f8f6d3f477594e5f257e513fc39ca6080fe6adcc40b2d7a95034b68f9c00fdc07a48dab5ed5225a40d5d0c007498fbdef86b65f4c141334a7f9227b1d9fb15e1601540d1f05d15713f9d7e007f47d7449aef1e92ac887b33d0d1bd7f813cc11818a16dec761892516c1c0e1b28ead1f79f6db420a60cd87b31c8ff156915dffbe063e2e0f5e9c04d3c55cfa390a768fe58b0946f9a29004a88ab518a02da027c597a77db7b4db32feb8bb1254061bd0c035874424961f85c5d0f2bfe589803215b3c8077919e5236fd0206170aa08e01e777f6c6ffa05fe1d6596f468cdb4d4c6cdf0dc0965ccc6019ba38fe41f2246c8278285e84657c5bf34d4a16ee85234a3561ea2362f232bfc4fe7145cc29d00f5280f1b804feaecae258e447d20a49f30977e8f3a18d8698db8a002ed99cca3c92369913fad46035717d1647eade0bae6d4e036106d3903d051f0d0c6bd2be05dd5c09d7d321beea44d9b3e22ba937457819502c5145fd80a33e64e7055bd832b7805796ff7655578917bbcf093f812053c50daeeb4acff4d0281722992120c8115fe4bc64223b1d462a501780ad102e398deee1980d09c740646386fe26ff45b704fac724cd2549773dcf592e51cb3a02243886e9b576f948518e679286036bc3faa801789ec7f298315792faf11b5431b5f1b9cbac453bb11813db4706995137e91aa2de4d0709d99bc9c00d942dfcf6bf8ad3724a4ea8ab5e0d5706f945a0ec89865af5311237a1d35460a435326bbeb67a18660621b1a4398f3ec475fa319a76d06c226ae53e0c5c523fc17b12af33b861a4db48647f837d68d6f4b0e7934cc622cd454e520a13a83ee6a44bf072740a794bf2f4df215733be7db744d681cf1008707a1e344113ec97e343fe8d877dd3da7c58638f92ebfa9d73e8b355d92071e35d2978ac7eb625ef8929aa68e2686770118300cb2560eea5bf31cac70cbd8f4d5972b0c7e0b8fa6ba714626f87340a3d8f0c311c8a4505c273a7dffa4b6409ecbe5977d391d548ef013724de338d0fa9f57bdf2d483236805b0a3fec2f27555cd762a8106b048aa97a41ab743feaf20d1be7e26ac6206f20256217047996d0b6b1fb8b3a8d2d59c6f1a2abf8a7bcb9fcf5a75d2b27b9627c8e7a804d999acb23c992beedc0f7ef35f199da5222602f8c5f0728be1c52bb5ae7251354da075abc25492f12d0d14d11f62b675757c31f37b337496304699de75a259688ac6f85ded2678a6f927109db9a44114b192aa7fbfef61b3ab1f75e1ba60c7e89979f1d074956b312f15f7fa65d028aea7cc9189485e56866eeaa506996f82fcd9cddca4be362437ec656a2dd7d093822c5f404ded9e0f27fbfc4e0277c9a973928034c35dc020d8ea6567f4480b5f8794e68cf13d8ef5e6c0293c536e41f621a87935483b27ed8a5537c516ebb9edb86bef79d134efd6565ad77150746f6c41919d1046d9f8cbc360b62cbb6f996fdac6a1f107e2407d6763935f6fbfebddc892724115b8704fd2615d5a64c9e0de8f7f550463d261a711504c22ee2916faabd2cc1b1ce6e30dfe85eb485e77f4df85448bce9734ee96e45970803879332c2f5574012d80f9569a5b9c5761f4cb331b45dab2d7be364e0c8e3ed72f0165e3d1d27312ebc9ec93051fc945b5c73d8216b312441c8520832812a8c1c27b4e0802f1ea3ca9540e4592cffaded1af82f93ea9bcbeee74f9c84f9c5eb8bb6b82c47aafa2452b7688982d83b9f7df4e28581615e05574da333299df8465f1a14daf3e4a5d4c6fd2a90b035fd0c782451b6525b86791fdb675bfe8080670e091c79850ba461304ef518adc0039960bc3feb3088116a4badaa651ad28a94b804957787f7690f7b6f15e6568e9da9662885b9a31ebb04689fdf85842ae3308db789398ec6df2c313dd098b5b0881ac8f63ee0732a419c2880ddcb86936e9ed61248c6f8cf471efab1a1ed3863514b769a884241cdf3f0511330e9312edc43f8e209d204a8cc57c0ced27948f7039236faf65ccc2a3f379997bdf75262af3dba8779c70748177999057ff4a7c5489885c51579672112f83fa271fd32335b10fdb8ca64a1021d5f7211e990544fe0d0d6a1ad5abed4dc94cdd4ad17f2182b725b030c9261386baf22994f9fdb85e6689183667120acf184fc6a9d342505d87c4d0f534c780244828adec50e37de3da6d3eb95bcb3f5f068628cc18aa44bc8771fe2d2ddb0ee036621f7514c0cd282137d76972acb731b913131ca9da4a80969c6b784e7013b8801a4ac8a0668e21b269fd7e3b2a215fdf6c9abee3d1b056cf3f16e1593d9353b1cbfce33d523f9ec03cae76d89f6927338d828de053028538c1ad92c4381202b4afefc25c1366e505e1588c70fc8e55a2a322406f97e8ab7712628cdf5c57d4dcb5103ecbc219e3b9eb283a5b2045871d0d6a969205387ec597a21dded28eb8a1735327492cb52d59484c1cc5b2fa2fdd2642f391653e23bdf4f49a55651a54d9055e3a333bfc5eae5e07785158426cb528c6bc845df7f375fe07ea1bd643aa100531d2461b7d40d4f0bb0076385fb28d39d44b38269de541d8ba3f60b2539e336ad682c7f7aa9d27ac17ad66cf95a55d516762dc5a338f988f4eba7669ab78944de6b54b6bdc85108f42e5fee88069d0a581f229f3f799c12318cdcd412da43e739201f8cc84515e1b054711d0c782e29a926be52f39163f9fbc79d56a8e92024915b43f8c0e057052e0ab8f71009bc7b045e64d181c4da0f3b8879a12e95d1ba47ee163312298af7de38c0e25f23f28f12b6b06238e51abb3c07d1b231c87b37bf7d467abf6bd3f41483d79019234587bc557134520df23ced28a412b849df16a429e4ffa1bcedef657fa066419bb36801cf4972b32ad581117c9c41fb565f5dfe5dd46b68d087d49836d74a1f764a540b0921e411e4e9733f22e9711d9dd5e6719efc581f6f921a4945c663e3308149de7d6a52b74c1dfb0d2b8820b0779c4218dba2dcb925ee4916795a917f97ea6e0df6a301cecc97e12b28b9c6c65c9844f760bb363c5be52fa0abcb40a4b33d15cb792523594433d9598e2a09296978ec3494be815403ebe55b7e34c6d147133471bed97329e891ced8133b69d07e082f4daaeb1aa8e1d0f01b2f8f58af46c3af045d916c5fe0285c95d86054b75362f5c7c527b4bc3c778e133c0c70426dcca767c2e508c95b31863922596269f0b091f146dc51cc1858a96b1f07f030d70fab5c19c99ac32ffdc9afc8ce629b4bd1d13df89bbca65f005fa4c200588e76c9655dac8df3f2dd5a42ecc7a38d1b6a033c3a76f1374207034461f59d942f5dfbba6d159a1b5276caee918af2264e56e743f7845cebbdc8b5a2db89399c91f561fef78cc0d9e1ad3b37093212951f2e36c38e2e6edb78fa4421cedee3736e2cdc79c6bcc9e859e250a2d20be5f3191649c2e12ff8bf0c979e0c1faee77b59d7ba6f53b380accfb46558c236ab03b0b2615926088e473bbd1078cb1d5a654b24fa0096e5b2eacacf3142b4dfcaedd3bf6b06d4de024eb9d1f436c1acabd6ecf5f69c66398061dc52a5e8120acc125d8524d90fbd227df61900f6c2712335151b6579abf2b7821cbbd8d56eaf4f9013dfd4653377f0fb4683005677e7025c0efc3325a85e7ed893d01560fb2a1b0ef8a5938fd21a739923c5b5b72ae85f350f1f4090407b8aa6794d4192ddcab9c3b334236aeff339505c9fb3cfb1e7b3a6815d3daf50eea364846daa57b7917c73e9f45bcc699d0cc87156a71b7848bb283db0f7c26aea69f444656cb4a517cc0107d3e723d77970259c9c6da1f2e72f52b00bcf51e64181b1630a832f52e2bfd57807d01c4a0d914d0907442bd0220012520ff7e19c637dcb19b25b69e16e73863de0e21e96428909c1fd76fdfb6c492cb4bb2a90448bfe9575a4527340ca1c22e6800abde1ecdbb2e02b3bdae1e1a3e0fbc332c0b157f30d1a5e3d9c00daaff0db3bd5fe1a547c2c56ae599bb412d624ef6e8c28a1162189819a60b081e32935487db63b35ceaa31008a817e8695740f5ca1c1cdb47bde3785db56c9e965d9f0d345da65950b3428861d13468cde1e0b0b4009249e5cd3f46626092c345d28544014525af1e04d65f5a2857139dcfa9acaceb9c67ec0714825ab1ebc83ac490b806b72176c58d12b8bb125d25f4b51acf9b9ceb33c3edd9459bb3747dd450b762426893e846487145633d023329b1d516268ca64401eaab45e01724d839563b1d113da8f521cd30bf978ca458267eba5cf8e17034c30ec128f767cae90c3702df0a5a76cedfb85b46442eb4cf6840356e37c619d8daf059b9b20a6f2a43b326fa6f0adfec5bde7849f76fe0e2126855127babf5b18d0f1486d41693ce0be41d6fb87a7a0fe4a7190ef6622a7b7053a9c027d19471f4ddd89a68c02cd2ce9d683b49fb19b7b833c04503d16279c6350bcabf39b04bcc7c37338a61ecd6b3714ba7b78e11fd3467010c39060f740bce89d686df125ae8afcc76cb541eeb83daa76d99326ab46c600776d46802a2302b319d1005ae6ca1e902d0ef52be68c167f06686e63d0f11f8876d0f79878b7e3dfd9d0cc7fe3439798997e648d5159471bbe8fbb92ac18306c259031316148b706dc92972c0c14ec80e52b4826cf96908a67f304486469d3e757b1455b8d5dbe927b5aa579e1097672b312f4efb24aa4746f2ff12b855359a52c8235bc496fd2e22e21ef163418d0a98c32dd94c596a6a727a93c7ca94112c9390aff6be09fad345857619360b5c7222212e0df71cfcf38b8dc51fdfe5421574f38c19866463917893eadaf70925ee888822592350529112d33eac52035f43a011d2b08bd3c57b746dae82bc6f55afa17b70e7162d4823c4724fa38399451804d4311449e710083faa32bc3060a81091933cbc6205a85c39f6301de75723ee9330e32c63993512621c7e48507db2adbdac49ffc56fd46e90481ca201bb994e6d5496e66f5cc36db28a264cea92153ef80246069b936b9a996a73f0360b7c700316820bfedccff6a8a57da12566bbbecb525e2f39db918b2428c8ae9e55ef6daa57561060325a1a8808252d45f832587beb6a29eb19daeef0f7b829744f150c15de4aa536d01643e860cbe9c432d519eac6a5cfaa927997521b5df381e0744eee6cc14cc2ae41769ee128747f792087ce581e84384256b5a4e7a93ca4506f8be3c441bc4758a4ba3fccf9fe076d0de347e327a2b04088dc1b4382be273d84df8638e3662ebc2153ab90d7def7233d66dd669df0ce53cd066663aed1afbcf5d99b45168ed8cf1653236e040d1064c736b0ae5d03d640dfa935d32d0b3d5d36314baf61cccc71b2ef3c306603741980d308f978a8c9585ec47d6ac655bf7d0c7515501df7aaae705f646d51396cbf2d0e90d232d7c9a06d8d996c084a1651a6fbc61bdcac4d216af13575b44dac029cfe89689822dc36c6ae783aaa7c4cc3c8d2d0126563c44635ba418d50544e0020e72868439143d5a1b8e80761a72c1b1510aa7de1861bfcec2e16ec0a969942e41028ba870117860f3c1669924edf7335a54c58bc0e541a9ef594c8238f33d28b3dc335546f3b821152d152b011d881c2ecab5d906948cbf4e06925a3716209aca6de4c6025a5f9d6cd526c409490e9523c8093c158205afae3a4f718950d5645b3970292c4da7ad69fc4194a88f364d00965f402b32f1301bde8e8bed413dff453bbf6bcb0a6bc9364a39bb731ca621da77bfea3a22034da0ec157445f2e629fb0e9a6103e0e9ab17fd716424049385ec83de9f0ae0e11c0fe664ab1c4237715fe80f88e6229444bad86e082ff3df725c8583d0e29b7b322d3b2c2618439a70b623c181a1ac66ba462bc2aca4b5efc50c9cf84981f28e385853e771f49976d2fe588d6ff491a8c56ae71bd5e919bf8fb070a6372cb66010ebd9e9d3a07207fb846bdf4903b6b6a33cbdba8c7f620a858a414b72c9509eb7752186ff1834eedad42330d87e60a947871b199665c24f9263ab209b54becadf1dd9454d9d67c96a26b8b5462225407b6966dd05d1cc5e8eabbb5c807f2096cee5a116244504096cfdbfaee1f1d6d27577f729c422d221fb351bd457ec4c519154b4be8dc79c845e7f495ecda1e4f6f851628a189b14571c991dc678e23b21af9dd7f08b6b76317d882c8a3da927ea1ffbd1b0fd8600874f52a749e7eb1f1983b324bdcb34e5a4888c4723a5143cd2a8f6f658fd0874ecd8d8758625135a03b8e320ffe6e8fbe1703be851d33bd59216781a188e4f623a849eb86b7d040c9adf8e898ab78af45396894d429d1f0c74f7474ee9389d48effc39b7c08284824aed9128085dcdc67243f208b0c5f89150769fc94cf79aa034e9506e301f0cbe579fab7bb3829989dc645846282eb392e36d3c14d0d456500ccb470c3e3176605d5c8317f27ba7ebcee1a2ee06e02953c7bd3cd8152135cb59f535d77fce1ab58b6e96fc2dfc388caeff937cd3bf03ff102d1ed8de62e064fae5b052cdae596675346f268ed09b59ebdb1fcdca2822bc9c8e0ceacfaf4a633650100ecf4bc52c6c2a26356c3cb7365cc6f1345850dcfe6f5e5a648989d96e8cc66c694130d5a1a931e56f97c5ca5f98c121e9b1a3f7654eec904b4b97f9f795aa606db5cc48e2de0c66e68f6476ea6f3cce8eca0d8487a05913c0954802780fbaafea51e182576e8ed9ec64f7a73c25ef4b60f11447c62b11f884193ee89988d625208bd00bca5f65b4ec3206c884b7d53ba8c6c1c1a2ba2ec86ef22c02c0675145e182c4cba7f44495355489ad330a0d33ffcf6f664a68a02e3503c1d1874fc7494c755ea9bf105fb3f59df32920572384ddd46b36f4bcb7095998b10ccae59621f30ce21fb5f6586db4d124a3ae24657204b2cc2fe478c4051e14f8d5c25665f2b381c7cb0722085257b2a93857219344888a709b29e9c73b91da920a0777886e1d480ef9359abaae2fdd26526b6fe19f77239486ddf9bd744c8d4d13726f122fc83c1bee1d85dc1fa1184c1e183f26c016bade1f4cc4f0b79e05031e618ca013e7575dc4f1573e691d3e8493181a7bddec129417ba2ba4dd42cf8d8f9d2d48fae108b27c3ec5c33ac799ee01a6a9bb8f1a0817298d7d0f28dd51cab5dc20ced088b232349a17893f6a3337da112d0e97d94787997d5b3936074cbe87e78ead340906400dc7111232f920f26db751a97f92f6f7fea08e7b06354f8dc521415d93172e08023548a6bd32bec07f95f1b73c8f66ff8c0d68f43686362324853dcf97f9b70e81488746a4a07d996f80a9f477b7c8cb55d15afa6f67f1fed3984ed99c7313b5d1596713cd8d80e18e79c028eb448ff58e66d984e526fe7baa2a981b479fd10e9c3753a5875e8029da63a87a101dbc66a2515883a26def3b82ad8c5883b97a2763d7caeaabbdc900d3577f862f534163649a36a271fc5076153319c6beb01c3fc79fa09ed068d86a30311d77500ac30d137787a1a85f9da5314e5366d47b8fda46897575984cb271b2c815c6ad40ff692f139b2f649f035850e2d82e23b126151178cc744692a85b7a228160369b87133dbbed2dadc26f1bf8d8ca63983a39b92e86d4ca83d2a5eda426de1aca7ae5d399021e18b3569f10b82741dd76f25de426b935fa9f0912faa1665f3de77daf2eccc5933aa002f3b4758e2e76c7cdb03d66398eab67bc7dda0314f6ec166da4728e145b012824ce8ed6a4705a1d92609f4a1fc691daf4865c74b6fbdf2514fcc2aa7c84ccaac245174252032584f03d1fff339ebc60ba24fd965b20531f140b3b6ce99d47647536e10f5dfa4346c27d4841b701153081c161e53055a3cb8807a26f333e1e0e7c8aec601db81accf04634f7f4c08d4488241ef21af36ae864fd28f43467c4ac21d7fb722db62674af37590d7ca00008ad7efe7843f24cc69a309350659e6bd9aefa1839fea87124eaa451062553d0e97bbfc3dc8119b36d4b87aa399132939db9361e357e45093a32527e8f714a88a52fa1d4f6b33b0c19714a82c7cc7903c3bfdee1ca89e8d31c85b5698c972358edba3b93efc02bb81f892838107761b4cbdf41e2c16dba7baf1636c5d5c07a547432fbf9bd0e4e8c76c0edd31f371df90e620e423ccd11b1fa8ced34f86f72f99d1b1336b6e01cffb47b7d6f0188ee7afee0a48eb0156198eb4d5d4d0648b3206174232a526b1ada730588fd707689e6b3a9267051cef8a7b19627e7267bb63df9dd2037a37f3b0081eb70688c05c8493708fd237099d7e75295b42423d10ed57b9477f415696c8c9f4b933425fbabba736ec41e1efca219fb4d2c29c7009c2c359d2052cf0c0e65bf2b52079216e9935312dc116e676440ad322cc0e5c6aeb2680838dd8116f4372863b9f8a7ab963eaa7290df2fd5623ba2d6f152afcdcef00d9deb41571fd7742c4a34cf97bf34be4ccae4857d32f7a327ce9fc951ab0c7e8e1b701710e334e6353813fc603d3d31b5d6068ae0d3d35e03d8dbffe7f15bcf16ddcbbb2ca213889a07e610b7e6829fe53d96af8326d82ebe7b829ccfa6c9a5d0fe122dabf0d47375dd0805e9ba59a75c2e0e89270fb7884749505c11444a39298252ac4ad333fe73984b55bd4841be2993cac2ba6923bcc3e5a117915c08e05c8f589048243c90f0921c640d2a72831b070da75596fbb8cd31dde2f2e806b5a471dafc3148669887181aa8da38e719d54a0c847fde99fb03f7a5eb65b00be8909a2bb77f3d41a96ae15d99587b2c10f0af7fe7a40dd0778ceef01672c10941c0cff64c98a98d0e35a2d1f0b1b7cfff9619297902bd489f3b8922fdbcfafac1e565dccac8aeaa2d050a1a437c0623426076b631f8e2a5f81e1c5ac8ac27695d60e8509fa080ddbad7c9d4f1a516f42e19a038493fa2958a9321cdb9f822d02cfe766a09e31b6471593a78c66cfc9836a72a580ada92ab56875487846262bc94a1474f6d3077426c590133cc0ba43c8a04b736122ffd2a0f763f218159b9b330b00072e89e4ae7c22173bba3e151af63e297a5bb3af54aa126389886d3ab5b352ec932ba89ef8ec796d0bc4dfe7b2fb7d6a35fa14f769b71317f9e2f9b46595e569e5ad52458cc25567667276b4fcf1e4574d4db44bf28d0ea81fd694ae73c27a0f482c0ac38876a233a99a1e5b22c32550bba00b8ed8cf0dd0cb6518991a1813591dbed106a66f9c900c08305e63981bb5beb542a7ea7d7fab83674cb358ab62b882c479155ce5274e309d2e0e7158ba536d856ce7de56f493184134732241ac25598d3d23aa55ff9d1a8097191a1c1ba7f47eab7d617ee0bcb3785cc28278f65fc400367bb584b6247f17ec98108ca8b1eb864c8a1d0c5d8f6192f4eb5a0f4b733ae712e1b036d02d20c7312ac4eed640ab66f108c852ad696578854819771db23abc9b5b3f2254d031926d72ae23684637a729c91ebd3435bb67e517f5331709fe4716e28e5ebc1f61dc29b41fb562e06525430f158d2b6661b1dea1cf398a0c155eeb2ad5c44deee577ba8c487d39d88cc5602ecd560f2cae659a109aac28b8ab4682708b67c09feaf84616710c53ddee33e3fb4174e33c6a13e3d95e1688500929dc32d30e6d26313eca5ac35834e4ae4a6d25908caf2932ac6f0e5b497199e6b97241e4399ecbb2d0dc430067977362fe9ffb053edbfba85e53c3ff62ac8eb69b4140386a445aa0f240e15eba18b5c2c9b8d3f871a4c9c2b07852a6497d379853b3fc07632bddff9fa9beecfc5df5b21e23e97f78bdf24c2a3669b9099ec71e02f1ad2d8c8d28680e03e311955a40307233763c6e89cebe8802aa7c7fd22a38892735f637fd9ff3fdcb8b8b8bd0e3d5dae847619ee42581caf9dc417d05273c4f6941d91abe0f98ae41e7c23c5ea2205188c033a2578a17a830dd0567d0bce776e6ffdb83f6c42514b6f259b8aaa3865c246e347211482f681132135f6a91488b82bbac1966dce654e5baaa4a95bc2eac07c5492f12f5c2592fd1afa49267d32103b172b15772afa849ae20b58b5ddca006fa88be3f859cb755515e80ad47264a3f1328081e4bb2fe5f6d15e1dd02b842cdd59f3bc60cad1c3ff22bbee710d1a5361c35559cbabbc7d74c489d9bae1cfe87c204caf61f4d06e37a97b28eb7311c4a2ed4944aba6c9c67cb4b9afd52baa35d594771f91441c68ca6b5b7dc910a6f4cf06fdd71c9c3faaf',
        salt = '2fa7352db46e92e44b9e8b7e5f617622',
        labelError = 'Bad password!',
        isRememberEnabled = false,
        rememberDurationInDays = 0; // 0 means forever

    // constants
    const rememberPassphraseKey = 'staticrypt_passphrase',
        rememberExpirationKey = 'staticrypt_expiration';

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param  hashedPassphrase
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassphrase) {
        const result = await decode(encryptedMsg, hashedPassphrase, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        document.write(plainHTML);
        document.close();
        return true;
    }

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        localStorage.removeItem(rememberPassphraseKey);
        localStorage.removeItem(rememberExpirationKey);
    }

    /**
     * Clear storage if we are logging out
     *
     * @returns  - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        if (!isRememberEnabled) {
            return false;
        }

        // show the remember me checkbox
        document.getElementById('staticrypt-remember-label').classList.remove('hidden');

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassphrase = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassphrase) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPassphraseQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPassphraseFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassphrase = hashedPassphraseFragment || hashedPassphraseQuery;

        if (hashedPassphrase) {
            return decryptAndReplaceHtml(hashedPassphrase);
        }

        return false;
    }

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        let hasDecrypted = await decryptOnLoadFromUrl();

        if (!hasDecrypted) {
            hasDecrypted = await decryptOnLoadFromRememberMe();
        }

        // if we didn't decrypt anything, show the password prompt. Otherwise the content has already been replaced, no
        // need to do anything
        if (!hasDecrypted) {
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const passphrase = document.getElementById('staticrypt-password').value,
            shouldRememberPassphrase = document.getElementById('staticrypt-remember').checked;

        // decrypt and replace the whole page
        const hashedPassphrase = await cryptoEngine.hashPassphrase(passphrase, salt);
        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

        if (isDecryptionSuccessful) {
            // remember the hashedPassphrase and set its expiration if necessary
            if (isRememberEnabled && shouldRememberPassphrase) {
                window.localStorage.setItem(rememberPassphraseKey, hashedPassphrase);

                // set the expiration if the duration isn't 0 (meaning no expiration)
                if (rememberDurationInDays > 0) {
                    window.localStorage.setItem(
                        rememberExpirationKey,
                        (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                    );
                }
            }
        } else {
            alert(labelError);
        }
    });
</script>
</body>
</html>
