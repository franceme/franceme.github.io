<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #4CAF50;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #43A047;
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #76b852; /* fallback for old browsers */
            background: -webkit-linear-gradient(right, #76b852, #8DC26F);
            background: -moz-linear-gradient(right, #76b852, #8DC26F);
            background: -o-linear-gradient(right, #76b852, #8DC26F);
            background: linear-gradient(to left, #76b852, #8DC26F);
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>




<script>
    // do not remove this comment, it is used to detect the version of the script
    // STATICRYPT_VERSION: async

    const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 *
 * Mirrors the API of CryptoJS.enc.Hex
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassphrase) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassphrase
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassphrase) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassphrase(passphrase, salt) {
    // we hash the passphrase in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassphrase = await hashLegacyRound(passphrase, salt);

    hashedPassphrase = await hashSecondRound(hashedPassphrase, salt);

    return hashThirdRound(hashedPassphrase, salt);
}
exports.hashPassphrase = hashPassphrase;

/**
 * This hashes the passphrase with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(passphrase, salt) {
    return pbkdf2(passphrase, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(passphrase, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(passphrase),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassphrase, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
    const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassphrase = await cryptoEngine.hashPassphrase(password, salt);


    const encrypted = await cryptoEngine.encrypt(msg, hashedPassphrase);
    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassphrase, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassphrase
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassphrase
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassphrase,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassphrase = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassphrase, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassphrase = originalPassphrase || hashedPassphrase;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassphrase = await cryptoEngine.hashThirdRound(originalPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassphrase = await cryptoEngine.hashSecondRound(originalPassphrase, salt);
        updatedHashedPassphrase = await cryptoEngine.hashThirdRound(updatedHashedPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassphrase),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
    const decode = codec.init(cryptoEngine).decode;

    // variables to be filled when generating the file
    const encryptedMsg = 'ffca8aeb5f00410a734d4e04cb699a8f9a8bb885df0f39b22a0dc3ab57b94ff8df09cbb3a1067f5c521742abac3014150d55db66577492083ed624f209c94189207ce97f309a79534f8734c0bc99feda5bc5f23a32b6f665fb23a45e10c81ff62e07ccca1708bb64968f35d0c700c98898d5b629604e793a2da314c5aab349fa74749e9d7f57ed74cd6a5ce24fe2423ad560cd85df2b4f88d97f2a896f6e61a9526fc28349ed306be8dc6e361a15097c7229fec01bda52460b99b528264201a72e04c5066a1392187714f41e0a8eb9526ae8199cd955d225ef293c9abbc9775680ba89f9f2f6dc70b270e7be555e21c7776ad5847fa24707199a2b4370e7fd38538a071cacbef9f745df9e0846112bef18b58c5a40e796100e00792ceb7e227687c331ace50a4c1b139dfa66eb4daf046e9286073ddfe812fe82deb72dedfb315db6df1e4d0da9e00efb85704e715531f9c7028a84d90ed7b6797aa4b070544db7e50ebcaf7169e5c40c38a3b7e240eef28b3865ca48f71b869c6fe99376b7292f2b1ec08c51f201eeddf30ea26ecc135441550619206f6f08d96f967b0cf29131e93a5d18dd2ce73f17b964ef7fd34d4f02e1e1661c66128a11f56e5b73ca831d54b34892c92703951d737f584acce1075e48b39571b449769bd193a3e274bf8e52ba5c9723db96741de3bdd87620b9d7ffc767fc0b46e7645616fbfe1639d4534d45b897c6b9835b82d6e2a106c7e157cd53ebf39e80aee60fdd45d9fde4a8d7b75ccb88577db94fa6414e5160fade36637c5e903f165cfd49e8ae14c1ddf1dd7388559837dc49b635e83743acf2c6d6ffd850755927a7b7835f20f52bfc3c11f70c0239ce2dbad84095bdbd6d1ae554ea437db33337397e50466611dcf1a51924253eb5be9018b1f4dd9f10e4dedf870d7f5af19150fa00558d5330b5fea48ea7aaa3b155f1a7d12498f1d1f0bec61c137d0552ab820813f090174876a1fb7effb82939c19232967acdf2c9043b5fb081ee2630219cc0668fc73b45f9eaa1f151fccd6686bf9a85dbeee602045cd607de6b979bd0dc980fe63cc4e349dc4428922552d62deb1be3ca08fdb56825f8a4c3a266bacc49ea07bb799571671e77fe13a83ff434b40180ce643e80a70f37ff57d0c7b205810a162c5436d42c818765c92346442e33722902b9186092557b399b4512bb39125ad638593015aabac2448a56a9b8e35034c236cc22acc4f5a9ca19d65c1e9ecee3452b5139b0952ea97b41ce299abf120c822c7a887f97c0d381de1bf7dc2037fc203ec1da06817612703ca4b9a792ede29706c086b01cfbc4824e92395ca237554122ef61260c9cecc58ead3d44074cf704ed5ff11420bb084b8502a18ba237b5475397575479573766c366db5fc434d84d9e36472befe3afd17069a271e44385eb3807184ac340507d7ebbaef58fcade30be4b375eab79b6160fabcb64a28c7d6a3a414179daea5f8fda13f15b3d72d8ccba0df6479673b1bb9f0287e5ef743cfcb8587482a0f48e400f40f764b323dcf5f9201f4bed436646e9801d96185e644cdae01eebe871d0e4e8c753ffc23a92b8b091bf9729cf932088e70458e2fa23b25b233f2b329633bae58f5c97d43411ca1eee0c050e0ca69dfabd91e2124b6c26b39b0e0ec18f4c1cf123bd157ce9fd605e97956b3e0401dabe452b1351126a1b5b869de1d83f528519ef93a46b1df683c6bb80e2c13a84c6668c86059905a703c3a91eefc1b09f23d722f462539e76c1b351bf33594a7483ace22fa73c4c3cd1c9a9e822965c90645ce5ea158617b5b0af40c2e7b5cbd7e71a92a03c50c3a210aaf8a0ceafdbe7fe29e86db1871de90205e86b21c1e6ce6b7e55cb24eca415a2204324e7b45685c488e10e46405a7883f34750f3127192e4283914df50ff93006a98b63c6eba3e5e0907f25bec51ef67eff23adde52247c29cb6e6fa552a0604b4b476244cfde352a2b5d359887b061702379728be4b58eace5d0f081da48a7075f754e8fd9068017b184c5ca6754f347c787639c755792a7067bc99f7441b3a2f9de5db6a0fe16976646eb3b64ea9e180f237540fc182c039d7b961b03127c2658a15ed119d6bdc8e6e9b569c07a3ad11deee797c6e31884da413b1130d94a0296fad80f31ce8a88d61ea6bf1205e568151aab7c16d6b5d2f073c3fe29b2eca02db7913ace517f70c2af3084d135d9c82252d3a715f47480f8edb704a9b5a64dc641fae7a171f3ac58319e95e7035a4c12d11435f9e66581853bfbf7af272812721e65f053be3b5a4f17e233d40d305103278c90b81a3d2519b9c207aa35096b25efcfb74854739da702ac921449913a331c24447b2a138f9eb472d9d9c70c2b9e3f0b0ff8272eb2e7fbe0a8692f52aa77f4b40d4dceb812f84d72227684341056dddbe3547ad5ba236762a405c5b530f6d891022e01144f37dd6134f1dc90d142785aac1bda1aebe8261c05dabcea404a45730105d15560f678bbfb466cc6f7c2ea5d8b507c85d40eb00f364a06c0576aad116f4c76bff8656604e0d189d96f121322814239acc0c4b328432d10368ff8bed7ecb37ef098a03835893990e1fbecd00d5a3d5dd6430f01b71b1bb4f6dabbeafb43b74c0ff90f411ec0ec246ebc6b62cd22289b6b9a736735aa2f8a6bbd8df2105f2c943b3fd0f0a5d9da0fc050fde41407fa0e5df46b1f3066bb906655c27870c8b09c464dd21744a7c68af988656a8a2776d7947663515394f41feda9d818003f5de0b6fadf5c927fc5fdc7f5dc15547a548d348942f40773df106167196e2c6c2eb7c0afefbb22cd4de01773fd90d2e628d36fc1b557d34df84328ddebf253673543189391014f285e54563cf6ff7e627fe05323c07ad25113830d2007493679101aecbaeba3cc54282992d4be68af4d68e92ffaf79be54d1f249d4a088d10fab191f45f67e6303e7a85efd007c7fab170347d8684dabba565961d96e5cd9aebbe1cf5c1b28d88dbab5bb103ba0cad7cfa43648c65c5473f2a08263a5f516dfb8c5468eaccfbd65d531760366285e3b1100fec1f70d4683170306ab7a1bbd82134190154fbf75a1e1bc3d5f964bf4117917ffcc799f397d088b19d2dfe073a481b45e95e76209945209711a5dadadcf6ca46babafec75127828d87837c5ef1b00077be9a15c8d0ed97a14fdfb75d20baac94594b61925da0d0c9c9b14c4bb3afe94a8ce0f48718329a43b7fc0901cabeaa6bf62535a738a1ca3139ba5344a50e42ed24f6b048af49fc584e8aaf53cdb018865899845e6b02df8450fe1fdfa3a4d396f714f1db41899e48aebe4afeba06060efd9fce0ea51df786a738e8d9120f869d4edefc223abff6e1e85389bfb2be9728d1d0439f5130eb637655ba0b30f1a7129cc61022f140d7f065f56cc06caa0a919c516dbbc31d74b84aa22ecf49deab8b3e19c1ec0311a10db06edd09fc455479a97501a150455ff21beb0eeb64a67bea7371f818b8036ee51cc912a15957b0288d11e5d06f53773f9bd65e1e0c212fba04e5b59b0ddaf0acc7a299a7d07c4b96ca195297c8b2afaf1b3f0876e44d0cdfed3ee3573e848d39b80487121dd522e33e5d858a2699579d23fdcdf73c586180cb7de154f6a97688ba77596f2c408824c8b1c98f4f4e4494520c6fed672aa61b461a601d4eabf9041af5ec0e07c3b8ef8c2f52193c2f23b6b7034f7d0ef39dcfa0968538e32188583be1d5527bf2011f933293bb2bf7d5f223959499659906e8f26cc14dd37786eb2b604806ba7da9d377c63a9ca61f3004cf125274a9112b1277a9de96d0703f143583f5bb72698956268e11c649d27d269b08f8980b6d0b4372ea05a762a0b1a075f18534c95004af1d487355fae43309055b72b7a1306e6bd1e48ba7cb89650583383f6bab110e468bd9d580281e25e8ac57ba2f1dcf44bd9e312cee0458ad6d087d763e368e06dec8880b9a4f2faddad1d1c1a3f04a2f87475aa735397ebf90f72ad9d0f36e0a3be32b1d7b0d684dd5888f9d727094563bb11af330d19a61dd31c779703c49d272c9450d84529e42164362e582d75c00f3bc66f6743882485cfaf21d196f863bb991dd771e419a1c511781df2a476fd2290bd1126a82d46bc31247e02f5e1322dc25abe82033cec96ca1569841f794538e1810d745f4e88c965578f7a43885662640f26dee550fb81f0de60add8e29fc931e3749181cc684c409f703224af7c7bc048a876a6e1d12f178e0bb2ad79983cd00992224714422b2644b1570bea03e867de75b7a267ecb0360a9a8dceab8a94f36811eedd09f0f19156542cfe54c028ac4417051b6f585f5c1955cce2804d229ef5ba608c7ffc1b350abe6c888e7ecb864b915fbc88f024efe286ec099306178f690a909a7c13f764d512e6fc4ecf2bc84899a3c1b3e5d4e322f82cd578c8975ad7fe1287dbfd1dd20198d40032ac13425d44a9b42177b3da17c1981ba145a726c3a377d9d49025a9d11f40a78580981a75197359e6934fa174f488c7748d54e7e82289350d43ddacbabb780648adab8353de1eb8f2202666ade78169f6275739742e40f5679dd0061dd23f16185870bdd51167312eef0b39a48470d02e17864c84b9a79d86e26b41e898e7e13f4e060f60ac8328c38bbee50f151df22e384aa4c65fb89de9fe67cf77fa8830eb3b1483e6aa06eef9ac4ec9e50acc84d409ec86def014041883f289d02d15dc9cabf2f9d5e16ccd2ac8a7ff8e87e805c7d9911284aa35dade1ba8575ec2270d8b16266b50ad3c17b7c05f2048836a1ecbe9d04e67f88976c2b58d80d61e5f2595445ed7da0b50d0ee2e40f9ccbc26007edcec0c2bf2f78815ee493fb42d88b8be753533d9d642a7fb805d77e554db4aece5cb6f72d04e0044263b7aa1451d279fced253117307112eb759e64ea89e0cc7b0c0e77d2d311b476fc89068cdbecbe174a5092a93828241608b458872ce1f52fbc840818139c4f874318891b622c907099158ae0b60d753d088a2202e58c7d3b2fdbdaa52727e91f08f409727b11e7ab931fc82249ed73145508885c9820b972d67ad45655e538707ae271f1be293743032b3ed946f1d33fbe3f32250d1d48e3894d85e9f8ee4424b5c5751079d82aa268d350767a5030ccd309c62621551ad2e40e89115679e9078fe369ba99dc4650b35b38606c28df1a4f48e4d6cdd31596b65943260b6c5acca114fe27683895733ad11dbec366d2d890025e4ba770dca1dd5d5524a78f4a1de2186c689021d94ca7268460225139d927b3dc388006c23f32683096424e9ebdbdae7b50bec3e60872c160fad5d77e08f4eb04031ba251ba8a14f054d636d43f216a5c2216808766a2a619a99f420f69f83563b83dc88e196ac8d8f2633eb3218b1159ea8fd28df5f38ada4a3348b80230f9fb5977671fbb3655450eaaccb69e30bd3655a867609c087f5c1d25fc3c815e9d513b5e59d538eb2221391e7fe4f1ee7452b02782ca69d73a55bed63eba61eae574b77974aed84e79388f99bb91bf9616ef15d7eef8198b00a8fc4de31f7a0622dce84959d1c4e496687ebff41a4ad1756beb76a46a30f19c71117bb2fd4c5df26d20799defed3b3caa244ab026564d8c9f469847f1c8f418dedbc1a22b6712d1e86d1688ce2920ec46eb81bc2b97a1be9186c7371da2508c28d3a1ac81e4b818120991566e53c5f3ed3a098f4ea61da18aaf1cf9c1b31eda7c783797019060b210caf56d5eee722e930af98b7ce50f1b22f347b9c85a41a5f84acd3a197bb12f92466628984ac7d6ad0a70256bccf199d37234b655c5e843d672a101a720f0cd7f968c690588d0c45a5ffa066d4327f11e3a0ee8d9598c0a46cb8ca7b76bc797b2a7c05874b4972131a41cec5f33ce557a94b006db9beaf70ac43569415aa015216af7962d31451f87d52e7336e90ac80f60220a331a9512fc62108015eef1e6be2604179fa3d3ae4fc91fc6045a919dad8521039f941116680ea15e6be7434c2be557c95716deb2a6898a789541724f7a48d1308ee919c8c1136673e3d235ac4433173d219299579d3019f07aef619f236df66491276293d229d5472bc33c52d8846e3c30d7a97374dd15b8bbdabd0b2548b4c11f90f7dc72b2923a68a96f8e622d4126ef0098a3862ed4a34714c05e8569b3dc5729be7588b49e10a26158048f0e2d5c9d577a0b06a2bea7baae9dfc544f419a01a6431c11a0dc2309d7f764a25db53d2902bc89591783f233fe9cdb26276a6b0a3caebf19a7fa0053ca0b81e8ba37354f1f77e75456fe735a0fa4072aa751fab34f80f34e9b7ffec6e8491553a183b61db087a0f251b43f956720ce1c3aa074979fe414b8d9e081a5e3474731c20577878d46a4190b38e70dcb826aec537e445479f8e1944b9869770e8781cfd6abc2df537356dce1f05f7cd161cae2ad7bc8273149075b978697e65363b327bca0029d275451ed7929cda8898369bdd985255ad3015d158276a5ff7008329cb88741cd2d7af9a22a2c6eeed743df74b7c02c4d2e12941a835813236c0c3f1f09b43f20fb4a4cbf053a70aa03ac0569e9f68cf0f74f9509bb170d0f629816c5ea21e590d1242c04f60f5be2984c130c4930115db90e345a1ccf51409a5989e65b227eef5592334f1e633ce104cc5f1be991b0d009ca654dd08cc87b132585c52b6bec1529b83e0a40a1d68efbf49475b8c9363310e27cf3fb7e238e6a109b4e111ff8e00489bca20fd208056b3cb951db8c49f49c35ee35e7d97d5b64fd51fa169479be10dd3c5e636d331ad2e9ca67fad33b507e61c1099f9976ca8091ae3071c78896b079a024411f6e4ea1ffebf4e81bce95848bfad2637e6f10d200063fd50c791353b293c8758fdd0fe84eee0df68da775ccbd7740e66c7ee063b7f4e2b2054ef826f092aa41014a43f3b6a9ea0182ff014a887614fd552676e4e9f3d67eebbb20f919087844b2b28af3791d911c699eab059334c73e302bd7caf69fb84b0a3da6dcf863a32660f4395270bab6ee420c449eda18f884422b636e49dc8dca400b23b598e25d024f8dba3e6c1f2184f2b46f576e3d237a7920bab7be01c52725bd46f8f9494cd8b8fefa13ccea3089952ee1e65d9bc0f40a7667b65013916839239a899979cf80b5df43f277f5971cf1952772a04e7b47cdde04de2484a6ddfb437c054f1157e55877bfd05fa9212d1d0437ba61fe82781f1c02f794ce300a635bb2aff1be973812d62420cfda6d752d23393510deefede8c80bf9faf6a9136dd7dd02eb830293c7b7bd80a886abed16babb1dbde192b68e743a2ef5cab1730b46e53e7325861e0f0ddcab8977b409dcc0306ef0ff1bc0089d7fc384af7d2eaf1386bfd67d02cbdb07510e87352aba0253047ee10ad7764bd9fd1adc3d0c1144c31bc96fcc609387e46d7ca8559bd8f60705891da808dfa509698b4d4b66936d5f5719df35474f668d4b0bc7e6f27a8d050097c08a63b24ff32a5f13d4fae2b014af9498f0f9d659fb2e78ca90466e22f53c94d604059b640324e12a6ee47f281efa901d9e781c4405ea76e5c7f355a0aae33e5e5fee90e3ab470d52da213c4270c61a80feb448462c78f5134054b636be8bfd6c777e6b207c4c6be1353a489c428ae9f96225ee56750619c3957bea1318a9e926dc3ad4ef8213a50605d0810fffcd88bb7c57a1bf1a6f37903a766a8561b481204157c2afd7cf8c439873406b1bbe178c8351de1483b69d43bc086ea00b370a925b0a1ebe07593ee7e21960c1e9974740fb4586e071bdeb725810fad3d094ab5920a7e86eef161e7130506d0b5f61c34dd0e5d16e55c0b8816e236385849ffab1ff6d02b2fcc49d386450353107c33eb7d61e10b1b180b7e9fb707d8764dd3db0260302d1e7044afac619c8fb94d14f4f85265777ad74d318a181d39af7ec2a86ea18ea6eeb574358b36832a64a4e782071a72796f995fa0965bd2c013706b8bd4fb282e824e147c8b01a6dda2a4177bb7dbd92da32a17d57342c8c4c77f367fe0be35c1035af2558f802f0adda40672de50f5c480a5df0654146de813e3fe5b20f23d922d62ca058a306f11d8cf451761f95151f7976422e5b0a62dd1d42c64f262b8b6cea61a29344d705a0953b79f2d7d66eaa7366a36f883e420b7bd4cc77f75fcb71d43747536572554d334fbd7b169b0d4b56a2858eb84c0690bb60adfb29e44ae0445deab90c1d8c1bb653ae998dd2ca0d73f3060b3d63d9a1b3c1226d98ac39ebdde404e0295ba0d031142e6f836f3083228ffb0191765b12c0799457bb399067ff7b441cf314e086adb3e1aeda7f20e7c62740d101a132b03dbc2852d7a5f1e39c73580a25fdd28ab79ffd8b6950509b85f52a12581fe6f36866b8d659d17729421b0d2b154d3050ac0ddd7a728dfb5485524c71d2bc5e97a06f8e3c2f3b1f851d62aa5d6c51d512944ab4ee864e01c4544fa6b13f3ee738790e66e13771b3deca9e5e4f8faa4a5ae8075b5cd1fecd8962bb2a92479b614bc1024760830dbf79f663a6aee25201283d04c31acd855e526a17c30e44cb6d8c9126a545e170ef424c3b61fdafa8435da9275a124006aa1dd9b11b30909229c9b4234cd2492664c3e74b10e9742d1cea3319691975ff6a786a37572349416a3c21421c2b50edba8afb447d4259b096135aa3f5b76a5aade25282fb1018280e95a3c18c803186e30d048303b6fc5f804071d821e7feed04f4050a6323f8e8a6839108d6607ffab61e3eaecbfb44f3b01fcb8eb08e918bc4285d18e6b18367156987a95fabab8538b36e6c88155b1ca69168dcdd04f110dde4d196f36de407d717de69eaae16176ab3c10a2adf4271a3bd031c88e126fd0a50e833b20d2ac9a8e6fdaea2fcd0caa89edd9f1464b7bf7b43e5a3fd17f5108f8adc198ed2fd80101d7d0bfdd4c322b5cec053245605880ad886f50bd4cffeeeaaa902d0e138c9e27b09cdc87481b04b9229310ff29d701999ff1efe2f22056fed2332da0478d6ae32de989ba48e81c35f423da21d6d41a57d4a3c1d080bd1049ca1263f3887b5c770080a4e9db7208c3bcce5a42aa2407b184e6760706bd918e9401768af8e86364bb6139c68725669d026b230e421179b0a53f68ba46e69812f3453909187bf9543f864783549c486390725caa723ee23c59fca2f75cadc997adad0fac54e6cff8ccfc3a6128ea5da109ee5b67b8ec63e7597582d2c2485ef4841d751968c71d113c6140c6505cc5f28ffd39aab6f2c6b6317023f52807c5181d84278efe29b805b48dd18236ae4d71ccf4632fef532676b78f6b70d2c5ba2e6b4b1f487a25f37409f0699aa7181b8e921b7c00d758e51be4006dd3f00e3e5349f6ecbe02cf34596fcdc126d7a9dd1c801526657e4e31ab4dd99a84327ad3d315918f3174fb4ad44435923ef25de4cd9a9d3b62d9cebe3b1f9f6910133c8639f06717cfa373844a66b9f236bee88682f788ac19c46218f52aa3144067f4047793ad8b0d71b77307762047824b82a2932a29e9f93e62081340a20f12f82f422de17211afaa2cb392dd5bad644a8f2e7b252190c75b611413e728acc68d2ad5837e50881eaf699e74059057bfb5a458a68a598316974960f2fec1041ce6873d71461011967990ea7bcb44232f4b2fde9d29f3af5c2d41bd7831155c57c34088797f32c0e0313fe2fdc027b32790bd84a21f5e230d58f37e1a84c2ce56799faeefab41cbf81e02d5afc7f19ebfb928a6dc8d90fdcd996381721496ee4e5b3bf0547a9c71b72fe251f874c3fcf17173820e74c91ad27cfe7b3ab9ecc6d56af32b983acbdd2c121063a59f8135883409c07e08e9187c4c341fafb4f772c8fb50792b7c15f63b6513d02d3d94100df892af87b94b53844a9fcc4c64b9541db849d2eaaefb1f302e954e8982f0ac74d0ba4b03e93d5315b1c71aca223b12139a4c5cd2fe88c614454cb2428a44a7f8cfab63fb5041fbaee23319712d6adfa3e9e6d38666d36ae152be773631224d3126520638bdeab5c77b2aeed5f258357a202eeaa853263b6d78c9e1b2f383b351d0f339853ab2bbb7b71247410379d6fe0d1b511b536efe9b8d11c04ad56a2d8393faa498d878baf95120d174411a58c8d8cd8e62f07ec02b7bb61ae8e4916876545cf318116aaa86937b5fdca515526a0edce72dfc1f9316b56a4e22bc937026dc84b5b0135830e87e2743327bf17b22554ec57ebf59ffa1252000f33833e313838ac60eaf9d0f8d08ec54e01dcddd60a9d56693d80ff176b673d91d885fc60e6e36ab7cd2b440382f9d99f5769bad843c81e4940f6ace038edc6d25d01fd592dd5e3fd9f6e33ae3cc222be27f7ce8893b75dc5a1da41bbf17247d1a96da988dd7f0900b2fb7d04e0a6f6d1fecaf9d2eee295b6879e6c79febb0c3be05a419637ae0adfa7cf6a5725701be8117bbf55e42b33a647e644178ef6c0372bc68216a889e4ade1c416acc7df06b3c6861b51e7aedc9c72e23c1991d473990f5531725e627454c1aa287205c3d617a91d7151f0f8fab2f8e754731c008183f4f4a3cde8faef995f6e854ecdd63ac9084d84986ab115cd4dadfbe5285f197a9303e02e56f659230b6ec354a9faa5158adf1d9fce5f6baf0e8995c303dea199afb52e2c2da70225e3be86492f5314c4845f513f23f1087b68aca4f222f2476839af255d555d2f0d9a57c616a30289514a86b99296501c2354fcb7ca1a628eb5c1675829ded31cf059b9272636e89d9dcadcef3b785852ae2ee5b4ba06abd21a53cd3419bfb48f8dbfb6bf94a28d69fd2dee1f5f4d554343a3282ec0e38e0aca3f5efca562d6f10bd446b9e78b61276688f8a58306c504a022dbc96c117224e4a1146082d9665d75c66bda57543a51fac450ce6caa40baa10ed4fb98781165edd2d936822213eda048c09957058ad5b194f4df2e7cf475a55fce871fd487e63b35c8521576f1275e636e276355485f69fe98379b3d43ff6af5ac8245332f883f6d255b6620f896a6f4fa4976bbf71d90612fdb404cc8d592eb5e248c2b5e691922f9d026980cf3b5ec481fe5e30e93850480a3129fe3ce364771b737a9aaa1cb40c658741446528e1bbbcc3949683556ba3df6712b2a0ad95361ce4d030fd36e3c15534b672ffbb910b978f958c29005095f989c12135c8cafd95ff854b5d3516615eedb55d79b248da71d30b589e476ba56e8712014da9121951494dc4d73475de85d488b6098e4b84096a6607366f9d153d39e53e0f14bcf5a54d57a5ece998e751df9464b1df2e3b12892a43693a5ca36dc5b4cbab5683fb8fd8c003c693590aa7c75d2c50e91106d205f41f0ce767c1623c75cc8377f62788971fb785f585420829eca2901426cad9bc470410f9ca2f05420a09e75dca7a484b47f11a03d6751bb9f4d92f845eeb1a8693a3641349c81dcb23183363a69f58f0182d742f1e669507b98ce39adfd2b1b2f7560d036db0d1730a92785cc47f7961fd30c8027a5f6c96f4eca255ccdef1247ddcc9edc462f26c30f7a01232ba4362f16e18e6b6ff2a3844040ecd03ab8023e95ce2da26c394d5e39077b771ec4a9a179f1e9b1fd1917e5041f27b602df505241e734d7b11e8304a6eb05887b0cb5afbcefb150ab4cabe589d829382d42989fc24a748f0e917cccab755ae9e9af5e535ad9566d5c491ba81321a309395bff7c497426a49abf25e98c7709d7ef65919603f0d5a76ce0da5b28daaae1fc3b1c0fb9ada456fbbc95cfb6861932a7f209b6216a2232d581d0a77726ac2516ac1bd6b2930f0e44ee958276b6b1023cf5d4f3680e0d8965c3805fd05c5836a5562c5ff5dd7a0fc1c0e4f65960a5006ca5c08251e1ab401c9e2f667a99ed8cdf58a2ba3d66f77134a0f8b371c4e76d6d8e47865743bf862c7f40cbf78e44ae795ebb5859778d9722b1141b750e63ceca5ae3d38a81c01f6a82fd674fdaacb93a5e82db185cc91a9403b186b8fb094524e3a4d736f7b88dfa1dcaa0ea93405c5d38ce73cf24e80b2ecffbd5fddcf6928528a42d7cff25e30b41359dec8c9d5c98eb8dcc1bcf3fcc0441efed8530a569916a519fba21925401b41ebc0c56f8bf25610847ca62c5196e529479b87fefecff417b59babd650d389a15d28839d1d3bb8b08413e9211318ba748d10ff3c65a2cd737dc41104c704e6d85b4339f1383d7d2b212e0de861af2a870523e40cb3e430932e2b022df954cb7e4a1b32887262d3d442f6cbf1ef8308e46f5df3c12c0c7a7513781c8df5989074e1fa4d9002673b9434fd095215aea97fe7bbeeee55263df79cf5175e3224d3ee32c4f807ed4ca56a5964c6a8e1652da474790204b39ba66d13bec3c6f0f202c8788d64a8589d0f61e2dab03b8aebd120fe067d5d02f9e142b7bdc4894b6aeae4f91f6888ea558f6d104cbb11ad8baf357f75c5593178260529ad123875f33c328d71fee9e7a9eebd34ec7e74630c04c793a74f9deb8300503b3249a4b483a642c68d4ac21346069d6ceb64bceb6387505eb2ecba66e50bd526825db3028ee431890bb038d0709d3aa273f288caa83f8f904164d94d304e54701a168e3164f69be5688bc8daa59afba99db7b5b5c5f76461c3494bdd900630cb5d273cf6a37c210f6ebc8d50e4d0501dcb537ffcf0a91816e0d56e1daf251f407f598874faf664b541854d0e8b6ea7ad822874d4fb329bc85815cf6e02390f99cb9c3ca703c0a5f095756682d01ae287422d8184c7f588cba4b5988df261a68b6087059584aed36a9fc10f52f37d84693230dc45ad1707fa6500411b0169bb3e5e042ada65f3275d99fe692cd42219f7a69f2e02858a81f91884590385b233ef91235bafd94419420b13e4b98906486c28a6dce74408208c5c901be7f2de68eab23efb86884846e6d6da7f265697a95869dc2e46704054a66bac4312a0cd714c426a6912a637d2e3aba6c20c889681d026abce0cd405ca0eb3f578807be3c148bd13ff05824e2c0488ee85299535855e077dcec6cb052f4b58f2d12cab3fe25952c58108685040cb6832d5f7f189dc096d0325dfeedb6a602e4b15a67fcd8c53ddd1d37f0098f09a42a8d80a4ea526d6210fa41f88a637536c0a63587b94486ce5b6f2486382f143d7e9eb87a53b73dc754da8625854631499564b75aa65246b25fac7dd44f1345fd1566518fdb129dad0c755da07acbfd6b3f968bb96f3af2e3c99ce8edc26505cad9988ceb666f6a14e560808acb05c5732d6a65243dac411efc598d8752cb18a71b0bad90a69371d24018269cfbe7d8c64dea0fb287167c2c478cfd4849e038d9379ec046b4a92e821a7edf84805e98b128f4415de5e8408e6918a6488ec65488e06acb9d1872ab8c85995fb3889012a5e8ce58b48d6e154aea299f8fcb42c8292904578cd719c59702e28dc18c43550d42f04592de6b04de26552e5bf39cef84fa7fa7d2f6bd74690244cac21c926df1c6bfde5ecdc185f1cef1c3d036f6eee5f6bdcfa40e1a0c69dc35b55b4addbe760ac76a7c9ceba2682088f86f0835a2e963e8a0ada65bcbed77ad6668b035560656aba4d7d6b4acfd3d08323341f0cb5f4e785610a5291ad901199a698836e9a7abe4992ecb75286582d9de33e489b91babe603860a395a64a5f591dc7900ed4915bea6e9754841dc1d4d1a80f24f94cec8a3e2bdfdc1e5128456fbb34f35cf4752a2bb5bdbb541e699220079b69302e50afc9b408c7a64bb034479037d3741b17fdef4d551fdb3111be04b146ff602b3c01e6316409c406e107ea7aa24316162514f0ffb9c6f2746f0904187901832a48d43f645b4d5ccf770f10a9be2355fd306427d7a3ed0c6f86951c0d6767bdbc161e2f6541c548e783278b127a34451db9ad986b4b3b315a3a4c5317590324e87a3f2098148005517288699c49a16625222cc1a24a5ad5b7a59a4542c84b66cd3c458f05b47fa8cf70089ac94dd15be2dc01e659b26e7b0bac13244d19bfe98b3bb86b4dd7c100a606fa7cf90fe08122a14be85389d5e56488679917063ee13b25684c0a813dfe4151c7379cdf5a007257e20979960ea97eb5d619004287aeed1a02c661dc96c22df7a2818e455b85277ac3fe4efe06abaaa79f1d42dcfd76668a5a33484334be0e56d7d39630671f63863e7876632f6523769ad81c36dbae234a278023c55fbebbfb9ba5b16379fe24ab97c78dddc4ae7933b16916d30aa48dde29a274113229ccd8626867a93648785fa1ed5770da788137f2fb6ecc2996f80f84f1d0d80e6a6d140de3344afd58fc01625769ebf844338b23c8cf27711f54960d6c1986ace4b6d378741e9343881fe8c35e8617cafc868a1c3f270498d6cf7bcb00294eee89bcbcbb123efe9ccaf41fa74620d8eb988c971b4d0e410784f3cd4f683829c84c21736191c1830c04b5dbfae58b4d367e97181136617b154ffbabcf9c42fec8dbd7a65c837b0349ac91bde8ed1e1bbc352c52c2bedb1d2bc5cde50da6b7fdfe1dd55218b87d00a568ae06e1e67360931fff20ce8b9782251b17114650a36ebbee0291631bbb19b7c247342b33cf0d3f3bf19cfff35b7039303d0967b3dadd913168161d1d9db2c2a792874da61390423e72caf102fc7af1409f18186b966ace2c7821e267fcd3bb28e26a92ead4213500bfd132af804c0d0e4030779a438e6011c0054a81fcf472a1400c8c56953e745cbfe55b9985ba14a06a89d512dbe8956e4ff4eb40c04209bd081591828ed68c2cd19dc5dcdc0b04afa27f3e376fa6a6b5ba16e88f5554d48ecd01b166a80e1c4e3bc6b062efc9f67504c06b2721371f9f237b9b9699c1986f53a5701088b39744902c541f1410ceed7f0be073d400d42799af1be3b5a5a608748afd9c06686d1ad87cb50f9543b27046bd1df28e5c9ea405815044c970e8a0b2885b4adc56a69cf93db41e42065e139f3cc5e42fc37d2506d568483001db3d7e812ac492a7d1032608a8bb801fbaf8468c150db18940acba5dfa7289f6de8a8ca250d58ad0e76dc56b603d04ba0072a4396f2e722d3bbbf380b0cec97b9b3252c7919b62628514dec2747e620e02c4592eaafdaeadd4a0cd129b264d993d796eba4474ea2d6ad234ff61bfa9de46b953961f7e78f7fc815694786489ba108ac9ce3040ba90343e5a754ca458c43c5eac34903a2194ff88cf27ec2fc958132cc09bacaadd0ace84e80a66b157ffbf80cc3acae801d60e1223676d74c43937eec7b8c1b5',
        salt = 'c53f4fd75ed43f59468d7f0752bf1a41',
        labelError = 'Bad password!',
        isRememberEnabled = false,
        rememberDurationInDays = 0; // 0 means forever

    // constants
    const rememberPassphraseKey = 'staticrypt_passphrase',
        rememberExpirationKey = 'staticrypt_expiration';

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param  hashedPassphrase
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassphrase) {
        const result = await decode(encryptedMsg, hashedPassphrase, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        document.write(plainHTML);
        document.close();
        return true;
    }

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        localStorage.removeItem(rememberPassphraseKey);
        localStorage.removeItem(rememberExpirationKey);
    }

    /**
     * Clear storage if we are logging out
     *
     * @returns  - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        if (!isRememberEnabled) {
            return false;
        }

        // show the remember me checkbox
        document.getElementById('staticrypt-remember-label').classList.remove('hidden');

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassphrase = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassphrase) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPassphraseQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPassphraseFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassphrase = hashedPassphraseFragment || hashedPassphraseQuery;

        if (hashedPassphrase) {
            return decryptAndReplaceHtml(hashedPassphrase);
        }

        return false;
    }

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        let hasDecrypted = await decryptOnLoadFromUrl();

        if (!hasDecrypted) {
            hasDecrypted = await decryptOnLoadFromRememberMe();
        }

        // if we didn't decrypt anything, show the password prompt. Otherwise the content has already been replaced, no
        // need to do anything
        if (!hasDecrypted) {
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const passphrase = document.getElementById('staticrypt-password').value,
            shouldRememberPassphrase = document.getElementById('staticrypt-remember').checked;

        // decrypt and replace the whole page
        const hashedPassphrase = await cryptoEngine.hashPassphrase(passphrase, salt);
        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

        if (isDecryptionSuccessful) {
            // remember the hashedPassphrase and set its expiration if necessary
            if (isRememberEnabled && shouldRememberPassphrase) {
                window.localStorage.setItem(rememberPassphraseKey, hashedPassphrase);

                // set the expiration if the duration isn't 0 (meaning no expiration)
                if (rememberDurationInDays > 0) {
                    window.localStorage.setItem(
                        rememberExpirationKey,
                        (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                    );
                }
            }
        } else {
            alert(labelError);
        }
    });
</script>
</body>
</html>
