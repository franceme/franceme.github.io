<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #4CAF50;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #43A047;
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #76b852; /* fallback for old browsers */
            background: -webkit-linear-gradient(right, #76b852, #8DC26F);
            background: -moz-linear-gradient(right, #76b852, #8DC26F);
            background: -o-linear-gradient(right, #76b852, #8DC26F);
            background: linear-gradient(to left, #76b852, #8DC26F);
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>




<script>
    // do not remove this comment, it is used to detect the version of the script
    // STATICRYPT_VERSION: async

    const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 *
 * Mirrors the API of CryptoJS.enc.Hex
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassphrase) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassphrase
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassphrase) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassphrase(passphrase, salt) {
    // we hash the passphrase in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassphrase = await hashLegacyRound(passphrase, salt);

    hashedPassphrase = await hashSecondRound(hashedPassphrase, salt);

    return hashThirdRound(hashedPassphrase, salt);
}
exports.hashPassphrase = hashPassphrase;

/**
 * This hashes the passphrase with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(passphrase, salt) {
    return pbkdf2(passphrase, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(passphrase, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(passphrase),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassphrase, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
    const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassphrase = await cryptoEngine.hashPassphrase(password, salt);


    const encrypted = await cryptoEngine.encrypt(msg, hashedPassphrase);
    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassphrase, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassphrase
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassphrase
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassphrase,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassphrase = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassphrase, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassphrase = originalPassphrase || hashedPassphrase;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassphrase = await cryptoEngine.hashThirdRound(originalPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassphrase = await cryptoEngine.hashSecondRound(originalPassphrase, salt);
        updatedHashedPassphrase = await cryptoEngine.hashThirdRound(updatedHashedPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassphrase),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
    const decode = codec.init(cryptoEngine).decode;

    // variables to be filled when generating the file
    const encryptedMsg = 'aa543643cc8d44ae143ec4562845ad7dd97f4c89e2796e0c6f1d4cadcf22c4fbdaf9cbf364c08a65db45a273e513656ee2db18d4612562c1fe0bc096126135a6cc7df6aa4d1d99a9f1d4f45710f016e2ec9fd2ec5e590fcfe98e5b2cd554f04ad376cf74d13611774622aa674cb2cccaaf0ef336437a8c0504c8d84f3cb23edc11ee0282e49de3f27c28d62324912511575a2f46be54b97c20883497488a85a09d76f09d5bbdb32fa19b877f8537e85f58069a20797cfab3a94ddb762770d6f4f9a1821c143f837880bbb077fbc0cb9372aa88e00ec6b1b7df98b278852c24e4232deab3b14e508cb214efe08adf6cb29e3797e661c43e7b06a20c29403c651a789a5a7d14648096e9e7e206ccba392e22a147a959505f7a463edd24b943438df222d084c07aafa8e929de8de710ef523faccbdc80ced92767c26ea1e697db340b971c5670c13a0f6a0656080929b8004a008905755e59b8dca676d452343195769baaa7729555ab209f02b1cb652a08dc89def412c4c06ab8e720edb889cc94e4f6fcdac37a8c7343258bd99590a730d10677d0ff3b80fa8fdb441fffc6e69e0001b749b4f85491e9dacbadb424290d709a14dac13848db5bee0fa0ca74471229fc141fd5bd39e79e01d2895c91a71d07cd3bbc078cad3fd99290b28096ced4587ad6a32d05b1038177e99e7708cc99df70dacd41b0c391d462f46b1f4914f8eb80443f1d1a17d9db44de401ff3feecc9ec5560a36d5227b915ce05b3a5a9aa806010f7b4a7b6ef0fce2bb8a3b20b9225d51af8cdbed3c5abbda766d1464081ca48a6b315ee96b91047cd1c6a860d56c66e4482722de4ab2052ff6368527ee336ad40dc02d6efa78a40cc34f11321e5b60faf5d489b54fab990d458ae4755fc6bc74254d4ed79f87b89cbc8d5b1ea46a2a105d68c71df09b7d244ade4f1cfa9b8af4693709524da0dc23ea42ee00316bad3f7c2ec5f78cf875fa4a89aa89c74e0623b41a3429624bab2cd300235252c33f8f77d40c576fbfcb034955ad152a534f5b7fb8e8ea82c8291f866541b7a78eaf7d6a26c00cb68004144498ac11ebbebe3288b5e1feb44110c3af9cf29f885664308b3ffd121eb2a9d13b4f18cfd6a8b4e8405ea3fe901bb6341b2efbc9d42fcea3b5faf3a28da673585f11c2e1ca4b8437611808cfbceb5d8b1bafe03759ae5b8fed67010a28632ce530451b00bb6df41c3eef29a1e1fe86deb2db636ee215a6a92540c9966ee5da221dc80a58a4703608099d055eae683dfd17159ad9297811c627e231a82ecb9d5f590c862325a27b30a3b3eccad9c8677db9f3ba4b96fa723dfb946d22aae0217ed32e4222da93b23780dfdec78a360d90da1fe17f708433abc4c25e979583b208fe7fdd423af701499b6d9d3d59ba9681100b6e89570be90bd5a41cc5b2deb7e4481bbb4fb8e75b03ee20c2f2d01b7c058f3d73e07ef7911afd15a5f94dacdbebf22ba485627f4a0493708888604e812f38f30be8a3c423a937ad82a103d159445261d4d200678993e3aa04505ac0f31307276def980ce547fa4995072aaa4081ef1aea0fee10dc82abd59d07710003196635f9686226233d1a42698b38b3b7df6bd3ab2200649a86a570b4f298e894c1fe1800ba0e1570e8c7e1eae77bcb701f7c5cc3662a8e189a410c580e6f327b301974daac586f1764c43b944a769b8aec723645f674342c0ec829b894a2c34de61efcbc2ca5c8894eda14b04ddba562e9bb8105a72e03486e8eb62ef1f17a58355728d1937f605b4e964cb6b9e032166c73e2275d0b37c9b1c7db88c069760472392f319fed556d462a15f1560e43fe205e5dbd151330386b57e56652d771f0046af0f8c8ac5c4a6f1bc5762851f3d44ad54a23a039292b51ea7db027cca3bd2d7e137b5c789dda3cac2280363981af7e2e782999682f754838f15732da79fa60f48868467c37869d54cdcbac4ee4d3f68320c4271180a39b41e0eb3a0109150b6fac67c9f60ac927b50e27f340e4dc0b8760d598eee615ed5262653abc286afdf276158cfb531ed54c0408750eabaebcfd38930ee69de8a8754d7209845ddcd7ea608b7e48fd1b07b138abe8ce18452f8d7508d4fb2f3839a3bd4903e9e74964c0d0271ae0f317616f923ae26184805a205e907dfc6ef799506ac0ef3d34a4c673121c22386388232ad70b526beb0d87c516b03c7893f91e709a004bc81b833d4b5c23966d3df1f692374ea824d392855104067eec70425704c1a585c80b45b25fe9928068c494e9ab54f7ec1704a518e09ba0872ba06a64c410d18f6aa0f92c5e1d7474eaaaa472d0c468962c4cdc0e8c26e7f38748a2c9f3d992312f70e2b5c8f039a9b4cc706acd50b6db5556a9e6f724ae17b253c36382e91c6315bdaaaf3b34546f8467879cae3e6b6c0109e39663f0922ccd25138cd154255dd585c3167029658030881cbe654fe4416511b91df34772e2eb12de4f5c407084134fb4dd7f306bd0d9a9cb86a01ce2f971a34d40258c69820100262e04e64f15f178ff83fd98ebfbbb8a9244c188f301e2eb333a0e1f8012f87e6120186a7948567ea8ec7299aa80b500d8819473d8c4335cafeb609780945507234dfe94e185d1126e5dba4c18b355c76350700511543a85464ff619f66afdfa1b5706679810ee2e90f49d54c02fb2278f155b3c76a25b3e9a031a1a5ef84a9cca679b5101268bf1a41c777b6398bbc00c855fa85c97cb4834cb0c273736f8d65ba5eb639ff837c54be30d63af1c2635db9c37d48eb71e4b7fd2455e065aba1ffefa82a4c6bb81c4c4393e5d9575bdb7a47aec0c8d5dbee63ce2c7c43127c5a100c4300414ee7613bf7d1f2728b9f3e5decb3709f392ae6259818a33597e2259c8601ac6d60402acae29ac2bb614d0ad21e9f94b0552fabdd56c32d0da03c809b9e97d0c19f5f78f2ebfa8c547526490eece29939ebe80290f197c3b2a79dd1ab8a6f9dadc92c0681ea4a6919b1bf4667968263fdbdf9744109ae606b4a16945885ccd465fe0dd5d177ff8e11f8c4068af9fd23972c64768af445cd1755100fbe8231766d0c50dd365c2c58ecf37d8fa6811eb38c63c57fe17660c72ce91f41c44a351260b8c53bb4ffaa3934fc7d0e7c12965f8a6d4e971a16a755f9e1e906998bb5363b22a154589aafad594f66484f5373c101271a838b333f1476874048e3e2bd629767c855bc28e9cd501dc434afb47453f5a731040aa00b3665546bfe8723af1cd5d81e69b33d93941c58eaf377db21a84e3349d56a79f3ed57f21e47014700323a8280249c0b6661f8cf7d57fb6d55085a30ed4bb1e9ad65265e4c48efefd921a982523464f8cc2a60501b5b3ddfb533e31acc85e645d25770f156b7f217508a6b550cdbb80740753eb2cc4be67d3484a0f8825166e849b1c589a0447a720361c5c733d8e8337726843027f5158590bf5bcef7a8a02d3b3f430e96a02af3b2f40013f508df9e265cb31efffff978d5630bcce08b216c73bfc2c0f09f408fd0e9868ec5adfa7448375b1fec3e72f7b28d9030e0e49e7c7d08b6aa9b0591b9f7b95d01c65fd9483efbfc947d8b915cb000a552143251c71b3d6604e0104f7936bf53387faf5b1650048578a244240793b2c1314d9a8f558e80428675f0bd2b74895c5bcfed68f98f6d264249e4334f1efe36233842468e8ab1dc73c3dd478cc886edb65d12025c7e3e92e1e4364c015f6441bb38b90c36f2725e0ed985c4eedabbff16e7eb804a776af7fbeb6a9273cb2440f8c53a132ebc9cb01c53ecb14b845ca43c3fd6db27da032c24e851e4d291581d0cadd89142b76c3e5e0f0f001c1afbd234b765d6d9be372fe0e71b61095bfb1a540e6bb9ed8e0baa3a39e28dfe3c5712484375d9bb1202c8414f5cd5b67a2052d9921ceb9a49f2eab179152d0bc7a0087ff5a267323b2d532b850e27e1d647309ff02974939999d22df7e70d07e366824917009cf3cf73e9fbf2b46ad6a45112e1c447bf31b13d15c0db2ad04d1fbe7ded289028d14f3be84b1afcb8e1448c8ac85a82b35b6c26030d6dbb3e44e0021af74e7a112de44a17817c2a12c5c67fd2112a06e8e923a812d4662107750acd121428cf77a284ed6f1691725e22f064d6c6cfd6be7568d335cc4bd76d3b29dfe78ff65e2e4c259f72f96c97b3db63e02206625c8d44cd3cce6c30bfd29b40a004a607d3eb04acc2ffb35e1e8997567e12a16904f0396a6848486fc60ed47084d777600a25f84f6f578cfd3d5e7de10a69ebb4fd26e2afa38ca8e9c1ee56d42bd6aff2234ff9fc56ad88eda2692efad2639a4e55a2dcfa947ee34b2b1357cd7f3715c3bfb1f6a2d643331abef143d3c4ebd5d9b7888102ad5a2a4ef10cbfb007e12edac58d6c907faa3dc43fb0b80538e59ee21ec8a0fa89c26ba16740ff67770f30c082e499c04f82e12e09e4b552fefb4534b0ac978e63b83bdcf53dcdffabcaefcf9c568ae79a4aadcc8543d0b8fac3ec7b4e41c0735c26220ae7665833d4410f0b8f956b8e032941a28edb06d9105ed876a5a4ea3a9f47a8a2d5d5a973cc0b071214f5a6c280f489f8cc55e29078b36fe425e3b86f9a46dfacd0d18adc7788f0e2747ac7d8e9aa4b6722e738a14f48ea3b22636aa3696655f2c851d3a5cffc17f846d21530826a166f60cbcf7de9b6800d06654ec96214a95f28c48bbb09366678b2cc920ef37b74936a2936bfb169bd5dd70f72f0ba4afce0d2737ad334f71d2f9fce0169e86ef2fea7ec47f1feff27272614e8933481545c9a2cc75beba176645fd5dca01f6a6b59184cad4c1b63502e3b9071ba452c39ec6d368dc9c5289fa0d6c58ace2d9bddad5bc97adaa3242ac6330451dd8594b0936c3a82d59e56a283db4c06bb07ad2d24befbf3f09d6f37fafc16e223db6a29f0400c4fdd2572d9c08aa1e4d9edf638458c8ca92fecb9c977826663824d4211394bacc3e94cfff3a200ee689bdcf47d4b3997eb0991d685635eb35e07b8106b934a8da261f68c3d8bff70445501f30872b41a96ec12952748c31e99c94cb00f88222c511c279ab17b928e8bc76bdde5ba61df0794b9c561467fe95db2add2a0a91d6e88e914976459f447534c6980cc3310f909276ec75d84e514e6be9cc0a7e8803a69f28e8cdfb853243acd1b18a00286626d6e667260bbd644903dab977d11a77ee79333610338557b7b7aeccd598760912ef4e8e638f6c5eef9c1b5dcb8b0fa0c53a7fbc6353466498f0ba3cd9442eb033a7c5202fa2bf4461d37ce0e181b44b5da46542c152a857d12719be70d5233f207edcd113ce466cc95654599d9695af75dc0c0a894d38f948399272030b8cc007417686332b7229cebbb58ee2ca25aab28e5e5f4542775f42f753c822de3b39f53ff9d1eeed5003ea7d2affd6c780865d44ca410ecc911e1f129e3fbf3504d93d6fc46388d16c16cda40a32d27309cb3190827eebf559db0f85ec74e88683f4144b8aa03f996802a5c9ea6c52e7903672b9f6147c29d614647d21e8e02dc6944f13a793a28bb1d29c41d145ee7f754848b4a53198b41053cbb01c59b13dd700f60110273315a43d48625932982ee811142637480a294c18acb687ef2631f52e1c2d252cba8ba05309cb5c76b4389230a091ae93d3cd4582e5f7c256d4040a0d751bd26e007a05ba135b1b051c1448128e277de8c462c7feeb9d4a63c6b3665303ddb4058a01d40b19401a161da7fc7614852b3647302bf05abe56f3e44b1f760e81ab52d6105c25d1f856f42275bd80281cb7b90c38e2fc213a662cd4d2082ce1974eaf263b32dd9d6e9938f4e446fa271465648fc17639599bc71cc49515b7e838937dc5adef1b70393bc2f9d191df082df3b6c70093afd4352baa4988b4251f98ff51092535cea5b1f12cbba1d7abefc14b8b31a024bffa196eae1e569fd1cbb3bb3321b588afe979db81275d51d7acf6f7b0d0ec622f80df62c0dd28612a8c26ec665c44291aa8b7e19770c4b3f4c39f94bd74378263907ff9013ce23904d96bf80c27c30509a4783a1918b38da2577fb4993d558fcf8b6fc02ba4571598e369c09fa1811f3b7e2bd34a7d127276cf6f58b0242f6226bcba4d2d23d5ed67949d6e9c82a6771d6d3d7819e2f0d483f0b090e11ad735e46a5f88307a822a7f2b7a525251aee802f391189d823d8cb338d218746c4f7a2e76491cffc811719fc1715f26a91374a4bbda44dcb6760a360422b182efd995967cc2b29b93ecfa36a803d941b4f81d8bdc31681556836aa2c740ca1d3bb1563a6c768956bdddd8103c38eaad8868e8df3abc99299ac77bdb2353089afda6c05c7fa49e328fc8d1835646d220c04a64e549d2ae702ebdd515c41f7ef075d1df9087bb2caffd4d4d0313c823e9abcdd73fa53a88bd6836262dcd87cd63ae85fec2d8ea89ee90467cdbea0278c79aecde087d6f2eb7d9cb776566a73912b31eba954c7c22ebe9869b34f2acf0d22eb25d5709e7d32d7f8bfc6213a75d358590c5df3557d35adfea137a55fcf303e0e01f8f306302f1fe2cddaef6e388bea978d7b2aa45f3aa47a7229610137268bc2930fd9ed4126fc4dfdbcf51684d022c56fbf0cd483a84c66396fdc15edbe3dcb8a5ad9b1f521005d8a6f9c18fce89de247ab52b63b3d17db20d63921a4d05d16efd1055790096d6756410434a8bba74900429243af893999029beda6085d581a1d6c877fc2b9bc90460404ec04504050f35f04fb79127e3f63823a105c96dd77aeb98e7d85288f49187236906a03929869f23e454f8cb4090db2a620a93a1d4037c2a3f24a2aaab93ecd00d6c83b80b224033bec02635ee90c2029ec52ecdaa60abcd1806c5fa4b27cd6d190141904fa2343bf997f078fdf62321ae935265c366ce83ddc05eb4b46001fca9971bb83254a4001ae2288b7a3bb3b91a14277845fac7a7344f6fff31c64449065788ae3280cfa2e931ad4a274d43c04516a3b3cdd77befeb51a3a6f673547ed4406b42e998833a74b62a2ad5a67b97c4d782ea7bafdff53c7a0b0fa64bdaacfbe7549fc67e9983518866e4c89c4fccccb45e5b782501b17d7fbc5e4a41cc65f573e272aedda8d10211985faa0769f0d6dec7fc2cd140b817ad52b04216b7e800258ecdea1fa3ccec7938988ea1ba7aac1329c7d1bdcfa34804a635706050561330716e2051be82d56db11e62d3caea2beedeaaf80a8dbb18430c15d93b77f22d42f7cdb06ee0275b231e77eb1189da0efca9f70b245d5fd4725ff1988380af39f46aad86e6e18933dbad2ca706e3f98de035d2c6244688c9cb2ac14250f533bc370e30bd1dac4cd5c7be4ca317c19a8ea8fd2a280a55b76847c60e4f0abb196f8327994343b01432217d00fa4f0a5f15774b4ff1b90b6208823889cad74648ac0a4435abb448254dd232e4182d321d8219e08300506b2cd3732bc33a7b516a2fa31132acfc60f88a965a37d02fcbead9e26a450f00a6cc7ef3f004a04eeab355993e8f96afbac83f89c8f6be7a38e463c769962b8e7b0a890e582438130dd49089d2bbac7ff3df4da6ae282a679932b34594bb93e502899a78e235c0a2dd6b79551f798295b2fb67f51443e8a192a7d0a40998851508ef4d16d729869876f96c5dcf748f6e39ef3b20a6bf6e4456123e00e24e05c4eb594850a1fd58cf73e9357810872498cd702d16f1af03112fd6567c7c86de16fb0bc3a4bc4342a1f78db6a67c80792cc3061a086cf182e66bc699861e1cc6a8c2f741ec2752d38d178c4304146e2270d97ab6af40d34af04063cc54722e8f3535ddcc0a318af6b1180eff35c588d94d3712b2c79a01ab8da5402cea0e9c9e710e5715932ed01e4829d76403ae8f8a361243e2b0dadd7fb4061386c76c2013ef7870f9ea9f84fc12f25a5989d4ebea43ab44edaf0838182b698d3c4b24e473c1815d55017479ba58458bb9a957c6f4977347c5ac208405bc2eddecef8d6e0de10f503245fa40601c32b98e10d6a927e967d56f2cd946ecb7a7bb6fe954b9f5586e9599286e1dfe6e45a97bab3be4986020447560b290f88a7b39aa3ad52dea33719ee829a09601474d92edcb4621f71eb90cd1de577332fd22451ffe086504f704afdd177031109b194ebef8d3a827cc255e0623a2ef84ec895a12dc37d547a34204a26fb58fa12db7993c37947b69c2a0e74cf7583dd39a3b1e5e757a455bad015b4d2849f80ade5ea237d14f967c47231395b4ebb17b84afab3688e0fc8e0f9dfe9f9b170cbac9cd08b529d1204c17024357ab8c26d876ef5dafd9cd9950a70c94efa7271102e402f44ffba5be0bd39ecc168fc23dde20f29df2a6810749089b1dedd14942e5fa7e2a62aec2833a0f6cb857d2d4651a7eb6cad4ed65e125951b51ea1256fb844583ef51348f42d41fa219847ce4bedcccd656b4b291fb65ac207c756fa5a0d8d14fc1e6c23ecbc31c31cf302b652c0d100267bea92c4b86acd7d176e98d355900af3a493bda18962ffe6a1c3fd19e2b562f6288a979b2f5cd9558d109847f984ebb54346b6f3790ed31785a6a8cc247ecf147bd90d23be2acedd51d59f14a9c2648c7695b6585cf4f6d4812d86ac8fd2f8347128de7d955d1a69af84a574eab8442bd37ff632c5f28a0db51eaf9fe3f4879f3ac1fa3921b8878925f438d5951872102b374a1a076cf2bf2c727ff84f6a0b613aa67bea6927162470a776a9076124a5c45f12648f94e8642cbe0e4d88c3a2e2daa18b629db3e9e8f147646f649ad06842fbd7868ea9dff8cf06e16730c9f8e56aed9a6b11e2943cf9cc09071bd2bd485d034f7d45a87a99a13b4cc3bfdbb1b5c30801fbee131990b8941e119db534db31e98b128d2357cb36fc2dbd81830fad43c232edbe9e125bc31bf3d14a8509c572992cb959b2f5ea16973ef61817b3c24184b9824cce52fc4c6d8a0b448366edf01e9c0a512f8b7566bbb06706177858b8846d10fd8f79735d8e458209d4c94da1ebbf5e0ed0025b1526348e4d3915555364a0e920f0efe0cf98d3afae1178da0000a11816055fe365093fd913684083c6c88cce2e960c34a35256ecaa4fa17c9c30e89b551b60791b502227486604569770a13a2cd8635489b06940d8d1dc165f78ac2589ad18479dd8b582406f5cfda210b178d2bcd1eed98455e5ae068df868fbc1db0b920811006275b5efee5b46a2ec4f1be19e26b5f07886f530aebf23bf70a800bccb5310509fbb3ead8a4771167dcf47ec4e75eb2fd558c9e5356adf184f04e399a885e83e8235c482a340f4a24576a8f7071aa01b2db0ed1569a340b703397e65576953cf6fc2d9edfa26510dfb175afa76db6d3b28a2ca935e91018ce757c08f5ed62ebee065143e252f73c04637a49da1dfe1e94ec2b5cb716382365b30da5eefbe55d3ec33d87c50a099adad04cda49c0dcff1047f4b7230f480e9717e0a2cfb0b4d04dd4c8ef7dd56c422c9303503b58d3a2ec4092fa2ed7b5d5fe9ed6c52e75ecf968ca0aeee9108dfca0a0b2c2b57bb1d4532b0bab94032aa2b0134fac33728b7a988209abf9cba828911758053e66f2901dbf49c2d1f75b36d95328f14ca9ef5c82b92597591a9a04435ee2a0daec23a11f41018e1802beb9942d71005302c99c82f0c40f9ca79ea9727093dc28ef7d5e6fbcc948960d2fbbeac61f3a4a324c9ac8291804448945a4843b8c469a831a94213b62c75fd2bb99be6deaccac596ee0c11b8b72f000945539466ee6a025b5e53fab4151981e302056899e5da2ccd97b92ac0e0e7f2f16d6fddea5e131bbab094af0e3b4c829d7e4ad3443c1fac6275ac4e71ba5dd07dc15560b3415dc5248685933d696a9c4ea7a32bfda4f2214c1ccfee1ac7c50876ef73041ac7e73d895068db92878e8790f91092c200343e56cd3088494c47c0e9aacab34b5bf6afecb312703d5d9d4f0bf20c7a3d5c40572de1691c8deb15b06546dbffcc668d87f1b008baba47be45ba6c027e160a70a65848dfc58f890368b372c72cd4106d64e5407007bc40319ed3671f4a7c853401bb3f8cc6f55791e9a99a19e5890edf05000fd9ebe07e22e5dbb756c3f861752b1c5d01eac3f193763423b0688b137b20e1f7ecb1db5749f3fb827cff837c6795ea63b988da09bae8c882cf8d6da1d39cafbb3d00e841a4563e0b0351f04947b6ba14ef5b7376ac3deff393d73fd807a05816ade7c56075e6b6b155290bc6e046c1f2007084a6407d7072ee36c1d667dde6110c01e7be8a660a2d9f69130e3bd0d5febad33cbe3c50f4c01de818b7a51d8289a6524f550954f3a0340dc9f9e5fd50e05529bb4c89c96a930d0702c47dbcd50af8673b0d46709c6099369950a1e3e810e49b973be8348a5a1bd451d10bc68ec4de80f6a3c73d4abf484bed2917d92016bf7308a8f4b677e272031d6319183200d72be39098d5429e8634eb13790e5d9379fd62c5428945c38d941d8ca2898caa90882c109d1b1aaf6e9ed80bb34b299135af184950ee17873d50cf8aee77245065fc4f104b64a90966f4b928d0d5e4d2428cefc17cc82740d0f1542cbb41c4845fc89a779adf29b059785aaeeb7967fda1eb40103565cf1eb6fede23b9d9590ac29fbd812cc248052459d04fb060240e4564946ca5c2c44629ce39660ce9c9ff7823c67d6f87de6695e335cccbdc2ed564489b7d1cc69f3125f57f5504a9d189f3089ff7baedc3c03383025e73db15c720f7ab58b4c170cfe84c2649f0d02f7be02b59b8e23d59ce559b3e0f46a63eb9df4c68829694e6dd5d621d44d1564de4ecc5e8de56807b25a6df358449274d70d0cb6d0abc4bd8c428304ae6853c93c9e07c2635a4a0a064c80172de1db60365a41592c3b0cacee93d3eb63d1af5a09d071e800df9f75d8c0f48c91151fad515afe5a16f7bccb2527ad25ad830b4c694c7fb8cb1c14536b1340d3a342e7467dd0d7c9092ddf2daac81278c2fa599e03aff6fd0dbfbe2f480a9e10703177e414179e827938bfedd87abfd826930263ec2c6a448a1436dbc1d13b299cd60052e61c3bcbbccacae1ece6941f73fbe8a9a44ee4494dac88ed33e5911e802e66f9b311c9023f41e6bf6c982d8171a6305cace73ae5e18a1eca73ef568b0840839f0d72d1f2413b5483806c655cf91b96e46a32b847b66efd791b27a965dce57f33639e11e077751c7cef8f29d268f541a06e7770979624ede9b068609e73278ac8704a29dbd3b9f49bd5c0969adc6a0e3e1c7117b4271b90210beee2f4466f5346ac210a7fa6fc7ef2f7cbd46a95feafd983b25384120a0b3d112276f0c30a5b2966206d6b9f2c0a6a9872ecd101384550303f35ea5f2574969a9041ab82be7464738913bcc40971d1147ddaebabf2327fc4130612d8de056e75c31d254cc92ec4808a9b3faf28f1122d0c3def7345c4c451c6630b7bd50ef09583291eb1e8e79c3646ff57fd586247b9c9e48c70c450af94ffb97f1ce126e6d8cce71682a3661bd582f19c8dcbed568c22b53142225d9ed34535abb65f8a073f0cd4046e575094a63c2bc97991b72e27f0a15c97eb36537998d0a4178ea6ff054fb890c338f312cf0d8fa0cce69e0ca86c7fbe57609cf2324cb43818259fc340dff5fe0854aec7b5dd2468dc83a391f5eea3e052ac42dccb1d83aaa9db2046b55c433414a6b7b2c3d56480cb009966a8aba9e160b410a50d2e54a7c0ecff91ab02eb280d0bf34bee7269a65d364270402b751002da4e750cff889eaba956449377ba666ff54731e37dfbe776c26239f63ff649d38a17a0e93fd8c627116f039a6a250bc5ac1f9d5d53338bcb30205faea3771656f1452e5ce0cd972143dce4942ea8b377fa99a6f617e1ddf133e9746b9ccd3f79858b0ff9b06da6195ebca750cb8eeb266e340da9651d9d3ef8cef79405ba90e28a21f0b59c466e1f3dba09003dc1cdbb00eef6e634525810ba1461b50ae37c67d3ef92a62adebbaca9bc83e56e17dd99d246ff6e6500fd8fd8ad9a6458fe4dc7ca500243127142a398a449c1d0116706e4e4b6450305598cee9b95052224109caaee96e37394b0f487818bff7ed3dd5b0c103473e78c67d920aeb276c7c6cc8747f3b4dc142f680263850c36e791da04bccc057546415894000191ac5417f51b93d68424e3ce1573a7f4431734d9e0077cb2d5ee2768e711e8bc20d60bcf708ab07d77649cbceb7ce0100cacde5d528031c591588f9d90312fbcae18c1015fe3ce534e5638bfa63888c442f80317a56231b8b993adda6b2a212f838af762fa11cd6ffba9ee638f608c0035065b74c63dd4a0995c9a22ec49357f5ae46eda3489a47da7f0e425439f1e7e22d4ce639140c552cb12e454b13b71371312d9c535d770700a41f3e315beb9cb561b245b065c81227c352d8bd8a0a2f7ccb9a4aac79049235a29d258cff5d8e9639753e429e9a5ab6b8dc416817961a9e29d01b26547fb0a6db8a253e1e9b82fed4003ce20abb96662d45333a3edd7a80d51b9ba54b986cca6e2c5bf95813bc34a5e673e9d98e7645fbb6577828349499b581216b9ab569b21c69eb8ae2fdda732a6e5d9bb24d90389bec3172febd213b38229957d6996005e81470e03e1cb6fe4bab32851dc3495b9d90a8eec25a4f9616817a1a9fea6b40b73f40d423ee02a86453cdca24c7fa0f1f7c5cd04e90c22d462f179f0bd3007588b283882febf37e3bdcfd749824f4311c09f917e8c4f91990923867bf691b0c4c88399af43b05cb1d3a7b2b8588a8b2fd838a0c4ae5987b57da874dec2bc8a2476941711e559ba8002adaa27228146878db26858b241a4018cac4945ce51fceae079ffd46a5b4294d8fb6399d79904c4c038112156480c2ebef8b962161e7e06518a662cd9743cf0534edcb4de13369f2b308ee27f199bf4f9f845d347b758361a23201fc01553b75312dec20ae265da75b33c6877934a98ac4250a35d8949847e6755cf283cbc9d29ef103682c7ab51c80aba5f662992185f46f4dcd51ef30346b30b6042e5f075ad3b55ed29c4a7b335e8593294d75bc7ff610406395f8c0bcb66d7c1bffb6035a877e3c5ed0895fa0b156368b8771e274ce76e125faf852f8087c825ff3f582ef9fd82f6785dcb89c93ae5969f72197fcab5124bf9e6f0f4da51a05452b2d42abc02822515d6cc3a7922d612bde9867a184d7c0f7bc0b98888bca80ea536d53cbe1bba6daf216bc9809b6eb810184966c6f34ed99a1ae404cc00e011d3bdce55ef035011a42644240a8a1138175e05ddb5b09c693c5bbd3a8c1222c1dc2e106b71c329a2d129b16f1811ab20bcad998ed90102a4a2e4d6556a4f5c443fc46f56ab8639e5f5608847407a115ddb77cc3b3e963048dbdad1ac17d74004ea5354766522fe544c9525744c0f1e88c50db509f30fdc61cbe55bcb376edf00d1ce7e0e85aa4b4e7e603cc13dbd5886c5b4fe2d3f9c4e2b6fc9fa853d9219d2329b95efe5996864753e58b5aec8f43dd5a7ab11bd17abd4fcd281b284703ef8ef90bad53e69579c8ab66e8c7aac2fc865b2a9312b6a899ec5a1b3ebdd0e6ee6e80444c589ca52b90219729b842cb4746f07ef3853b281dc180702c3fbbd6e7912e5fdabed06eb2e53bad1f84b2b0b14febf4aba4ba083af1aea25de610ca46b59553d3a45b39e88800fa6f047506358a739289783e1fa18721babbcdfa4701402538383c993b8edc2cbf637dcf6edb05d85808660105865ff8a507735c54fc1c98c9a81a29338e700ca1bebf3531dc4ef4d3918d62a9bccb68920200e9e8019587889d28253f6a23543a6523372f005853a16bf7263d8ebb2f564c8e090c80a3ae7d5d6be5ff0a5d0b70157d7648855faf9d03681a821c7e626da03e1c94d1ee1c734cfc4a34da80e4c958179598bbb40fb020f01114003293ec1a63919447f513eacbeb96d91ed6974dab96927f88a228e809a7be601c1dddcb2064811d1d4ee4ab3e1a0b5307c88fbf67650a73eda783026c9eb291fd7dfec3fc1b8a092884e00a7b09f6bfc443e2281f6719d56ca9ea16d861c8015b79065df00e50cd33c32d17645ae3e690c2db9536a20d45a43d24ef6ea1f18832356fcdd8dde5015ad7ff48c4f38cbfc19604705bdff601dd3b408d028b44a0f1a2ab1339c79d5cd40002daec6fe06b3eef62c3ba4f64d993157517b4f6b4212b6fa16499e79a1cb1d318736fca461a9c046097f2decc956ec66244272d515806b9b8e2551e0f9786a21fcb39e71f36f03c826b095e8ad4945eb2878bfe7107a69edf49228b6053a8031c620b9a5c6a0ac5482caefab2d5c2fcbd24539493d584b0a30fd3997107ea5bf1dde5fb3d752781a57604afec17fd07b8f2ff946779c75a62f0dfca6fb6360c0c81f440f67b711aee784a4349b2a5431b0a1d62786e636396d6eea27b01a176c711818339904e29c4c365ddb0ac2a290552200c4c212d884dddd0b7960bab1844582b553484c1545a201a1172581b51a6722292b76e57b576b9d1439357a0750628a8f1ce6ad250ef7e6bfbb3518db9f0f03bff47470a2b1793fe57e807f4632ce4c4c1cfdaa6df2940de86a55cffef2162a2a27a93e89a545f5b5635e8ca58cfd7c87f3570770a480b4f15256fb6ad339d08fb237cd084997b9185e7515d481f4b4172314defa06fa0a052c73074d27d411833cfd777236860831f50ea7ad3db21ed95ea6f86789128b5973624e9465916c3febc6a89b175955ab1c572e49e17cd0d5f6b51d93ae5153ca3e91e62f17edbcd139f9c6d1baeeba178d37b2e9d27e2dd853672246704d5203a1627d0a92c534c5a042bf2a58aff9b12df8166207caeb5167c49b3d559adfccc86d86c9b5c9927dee69bc016c36a47f8dc6ff5428792285a19eca83091b12f63b046613d885f292a356c6913e38fc5b38a667b9097534db97d980ce2af7f1c7fbab5b69b00beae7bbb0eee01b78da9038e93be8eb739cdb3ddfb3de128bbaae527206e5c90989cca31d379e3017118cd82c73898219475746e17550e36dc6b57185b576613d6149b1d802a9904935651d267c49230ad65c3708b90143e552bcf01f917645126637afeea93749352abee3599d41e217fa80704dd9cef324dfa6e2c8fb583bbb535f0b2f04452d2a7f573a9da9e4af7993bcf81cf3627979954291d42061b25d82cddc6d5740efee275b7356d99a1808c5cfde9ba9529111ec539707e3e96d7e07c9f0570b2654b2e05b29c4e29d5308c427de02654c30d509cdf8152ceaf754e02a379',
        salt = '40742431abcb24fe3d9c9082447db811',
        labelError = 'Bad password!',
        isRememberEnabled = false,
        rememberDurationInDays = 0; // 0 means forever

    // constants
    const rememberPassphraseKey = 'staticrypt_passphrase',
        rememberExpirationKey = 'staticrypt_expiration';

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param  hashedPassphrase
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassphrase) {
        const result = await decode(encryptedMsg, hashedPassphrase, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        document.write(plainHTML);
        document.close();
        return true;
    }

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        localStorage.removeItem(rememberPassphraseKey);
        localStorage.removeItem(rememberExpirationKey);
    }

    /**
     * Clear storage if we are logging out
     *
     * @returns  - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        if (!isRememberEnabled) {
            return false;
        }

        // show the remember me checkbox
        document.getElementById('staticrypt-remember-label').classList.remove('hidden');

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassphrase = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassphrase) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPassphraseQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPassphraseFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassphrase = hashedPassphraseFragment || hashedPassphraseQuery;

        if (hashedPassphrase) {
            return decryptAndReplaceHtml(hashedPassphrase);
        }

        return false;
    }

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        let hasDecrypted = await decryptOnLoadFromUrl();

        if (!hasDecrypted) {
            hasDecrypted = await decryptOnLoadFromRememberMe();
        }

        // if we didn't decrypt anything, show the password prompt. Otherwise the content has already been replaced, no
        // need to do anything
        if (!hasDecrypted) {
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const passphrase = document.getElementById('staticrypt-password').value,
            shouldRememberPassphrase = document.getElementById('staticrypt-remember').checked;

        // decrypt and replace the whole page
        const hashedPassphrase = await cryptoEngine.hashPassphrase(passphrase, salt);
        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

        if (isDecryptionSuccessful) {
            // remember the hashedPassphrase and set its expiration if necessary
            if (isRememberEnabled && shouldRememberPassphrase) {
                window.localStorage.setItem(rememberPassphraseKey, hashedPassphrase);

                // set the expiration if the duration isn't 0 (meaning no expiration)
                if (rememberDurationInDays > 0) {
                    window.localStorage.setItem(
                        rememberExpirationKey,
                        (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                    );
                }
            }
        } else {
            alert(labelError);
        }
    });
</script>
</body>
</html>
