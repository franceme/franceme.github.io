<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #4CAF50;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #43A047;
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #76b852; /* fallback for old browsers */
            background: -webkit-linear-gradient(right, #76b852, #8DC26F);
            background: -moz-linear-gradient(right, #76b852, #8DC26F);
            background: -o-linear-gradient(right, #76b852, #8DC26F);
            background: linear-gradient(to left, #76b852, #8DC26F);
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>




<script>
    // do not remove this comment, it is used to detect the version of the script
    // STATICRYPT_VERSION: async

    const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 *
 * Mirrors the API of CryptoJS.enc.Hex
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassphrase) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassphrase
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassphrase) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassphrase(passphrase, salt) {
    // we hash the passphrase in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassphrase = await hashLegacyRound(passphrase, salt);

    hashedPassphrase = await hashSecondRound(hashedPassphrase, salt);

    return hashThirdRound(hashedPassphrase, salt);
}
exports.hashPassphrase = hashPassphrase;

/**
 * This hashes the passphrase with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(passphrase, salt) {
    return pbkdf2(passphrase, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(passphrase, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(passphrase),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassphrase, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
    const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassphrase = await cryptoEngine.hashPassphrase(password, salt);


    const encrypted = await cryptoEngine.encrypt(msg, hashedPassphrase);
    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassphrase, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassphrase
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassphrase
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassphrase,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassphrase = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassphrase, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassphrase = originalPassphrase || hashedPassphrase;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassphrase = await cryptoEngine.hashThirdRound(originalPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassphrase = await cryptoEngine.hashSecondRound(originalPassphrase, salt);
        updatedHashedPassphrase = await cryptoEngine.hashThirdRound(updatedHashedPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassphrase),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
    const decode = codec.init(cryptoEngine).decode;

    // variables to be filled when generating the file
    const encryptedMsg = '0e66a7a166d28e5e4c06f294e3f9396fd1ef1e3c1705a9fb64e93ec877d3297991f683894e6056c7797910a3a038c932ce36465acbe5198c04bed798a29b75fbf91d3aa59acc67458c6d5ec41b5be97be248fb832b8824f4027b09273231135eae1789d48c213750b858f20c1fe2353ac328e9fa05d078d7e76cd5260bdd666f31112b223af319ba191a9cf6df830bac380a0a22c05324a1670f9d889fc131040d13acd0ea244640c1604bdc0dd7cf5e4820794695deb178eda393540b128da4cb3665212af40a9c360cdbe357608622cb73722c4576da7d0ab43517d6d6bbdedf6211211606098ddf7d32331e8aebb74fc87c0e0cc9f6b56404f6594e865cb3f060e11278332f32e36fff9c59d1d4c8b211da0ed42b4d0bbd15478b7297d831d1999b54e9817fa87866f80811350a84f2fbd022b4e32c890d619b306c94091484e4eb6e3b48f9d7622691662cc1527c32727f02c8b8e348077dfc039a9b5b3893925ff185f48f1521df8ff796c625936d45f788c6954fe10796cfbd73688d371b118b8f13f0a3a4d3ecfb91414b0b156accb4ddb1306af2571e1fdeddc585bec895b8bc7e64b3155da21f34a9dc97a3933f711729a1a60f7f7d782bb48bd51f0e3f90bd8ad47a7b646682630a7942a260e2a26aaf9be99f8ff2ce0e568570278fa7c8a6fb15011f96f0bab5ac3aea9a3e6a4789978f84a04724462134e246e4e5eb3e79994ea7847adce823296b607897ae00182d7d0ad97a817e13e90edd6eee36a7bae431f709ed92526b2286b5f8ee2edbe68177f659b4dfdbcc438f51e0363b0377ecda60d047d803cdfd29b9f0a77bec3a9559ab79ace8c881dd56ef6903b4bd447961128d3137f00cbe854337086f727674138fc02f01675309b5f1b17fb9c3a48cdd4aed88cfc22878b465825c6e9af1254072deba16d0212767e4485e02539b7eced9986929cbfd4adbdebd95ef69e5ea8609a9d2bca50509edc540a866a37f1f32d385c3babd93aa34579a93ce030665cc5d9412bd190607a9a2a7937bcc127f83c3beff7394b89c7520501ed363c157ae29d61eb801f597fe0a51b898a06f570fd403dd50daadae8257c2049c4d62518083a772cc51ffabed8ad0e56c71c880a422d7cfb7a180a453007161a9dc35e9f622b2ecd29c765e7e7dbe16d1dc263d15e54dd2b5f7eee55d24bca4e75b485321a8ee3b5637b45dbdc65cb83f1960ada9246283988e11791e84181f191d55be13121bfed379eeb874597a98e327b37c56deb0e67f2d10a62eb3e59356291c4391e785efbc4c92540144312dc02cbda52d48e7f9ac1772c5775ea5aba93bec39b7d250ec28463792def922cd2281b346f0ec2f5c8a65dd958c33fb09344af5e84f6c7b626de515aa6fdb3b02616bb7e0dfbc29c662a4ca958625c7e08fef3a223e71e8332f9bf7ce6e86852278decabf83afcd796fe0d135ec82d2af8f379335e7c01c375e2165264772c80acbb6162498db08b11cf2c89aaa46b4de582f168b7a879c405d1404713f2d45609da669f4bcedfe798c742e9dedd0fed96b8ec56b9fc812f74a4e259c8cf9d5ef62b811203dc93676a0aec761557aef00276a56cdf8d3dbba25094a0762c8c12b7dc2f948bc3bd37e6fe5ee443bb729f19f9b00764494cf068ff7065673117914f1d9b9ff83790e9eef4487a8cd1b32daade1c6153a5ff2d5772ffe5b89499b4143c1f17a7c0f8710a70d1fc2a38a9d6d9da86c3fbd00ecded1a65d10b47eaf4c4f76c66c37861b56cb6c63476e5f58c82282823001d440ee48e9d25ba7cc02e5256467deeffd043e6a8a165197f07c93f47474c65044b7b0fc93cd118863f93a3fc66d7e7719637695aea17aca49b9804c8afcc1073db694f6d9cebad071fbdd02060ab6c3e1e50f3c20d17e6f7d5665b15d915e243c2e231650304ca17524134080a19d2e3881e2d4d82ac7254beb5eb0ac5fbb6f1112988c8da5d79d691dfcc941c9e8d8e4fa51ddd0e6a45a3acd28ce492c432e6eb09c1536a44d5770727af4cfa056e0f85658ad138b68f9574f7945fdddbfe5060a9eb188414670b34c6c0b13f3e64b6835b42a457ce66fb2429c52927d3a70eeea5cdba9982ae0844902dbe6c4a1336be20091f292a37beba9f269bccd730ad00808c8ebe8bdbf9d72bfddc3202ce454c41fb1b74fdb0be0b80283de7668da1aeab0ca28b2e3a0780de07c59e57d25da07a29a88c3e85fd63dcb9d95809cb80234bd61eef46d2db0d12f9b2796afa66e5c9d0718152b27985e2a54284f1e5007acf02329aa361cb6961f89b057282776eea24fd751e9762b78bf8d28a9990ce4e43981fb2ca960f847e5b7acd2e5dab7695eec3f15079c9b901dd3bd1d9686622e870712f80fe3b61038126acb42f06e47ccfb35030063e696bb54d54d28b5bf2f0f0a7a9dff613f8c11f49606099e5546fad096f96bb73b3d7648c400af884db038326a1e9f64da96185ceabd4abc03f85013a78ea45aa8cff40141477286075eb9b20c29ac5ebb5a3663308673352e8e6ca3401c8fc34d13121103ac50608304e9815cd6080634069761e67a0b0664dc6c6640234a5166cbe2a65e14974e837e0ea853e5246bef2d3094a7162b8207ba00b618301f04fc79b6229e037e78b1ce1b8afd79242ebdb292bf9bb9f5f40f32bd0c72d8190b9447dc853e4a3532e752d00e3593b4bdbd328fe0143480d67a17cc55ddbd32ed1f7b47aaeabfb4c709e8123206c01c8a989b71d5ed4c5b16f7b2193dd1d20af8b8b7da41ee50f8478891a8e3a6c8e96f01308e1189ca4acce7eb4fc148274679bacd1aa9fb7a1173dc00e278b7e13a1e49398b0c50411ade830e91f00d2b1bf10e8493c6c95149810e3dfa6573a20eaad27932464aee75f3cc06f865471ad31c395a1f5d242b41bcbb67ab5c634c612ebc287e3f9898217b7057cdc4759e984cdf3fd9b9529f44081b6a5bb7a6253e388ff7f3d903a60d08a7e23595f355ba1e71042b56eee46acddc6793468523d6fc1b23e8757b2d751a71e50127ab7e3d16dec8ee917b425f728bcaa5bccb6aa9a81533a80b541d0583d21382b0df1aea7cfd3ffdb53280aa85289b479230b88e605b8c8c32e75b6b2b99b6229f6d4e156d3ed4a2662d82db13a9a3bfc0c51d7e4a52830228a2822e20893e0ab1fa2682180a8fe002c7e5bd42d08b3916be1bed3f7920f378a5bf8bf1a40393835c90cb8d4d1417f5df961d21954ea9687a948ddfa6f50cdc5898038e2e821cc49bfb6edaf356efb160dddf9c0497a8275dd8d3ba74ac10b5bee166da47b7bfcf19b16814f0236e3d7675789c236fa35a6b4674f54ba9bf6d8b89c68147c4766c64186f22fcc05bf24f08e138e847e029bb2d413d60131883f5bfb28e3ea9bacaae8239a4800860568652df9301f48c31eead403c7f563d886a1f377021ed027c6ae43069de614c400c67822a7abeb5e2edcda54ef3695f22dfeef92708bf7c233e714308626f23f7c32b3f4211bd787098645f397dc2c61aacec37b86a428c4ca4c274f72f151948094040c2fd5d33397928d5f5a8c2b094904e3449dd4f17b87caff93956b9cc23973d8fc353807175566418b9256f7ee80628126c912c42cb122c8d406ad2a2f6529601b3949e61cae7d7089d80f4267264f040a6170018381812d2e8c6e1ec68fa15eb2c21728060870c307807fe8527c18a87d50c32da17f004f41cfbfaba467eb53ebf2a3dd16dade1f8f970d759dd57234762f77556d8c8597637c068374a3a6cce857057fc469984d80f11f76ec40491c28ba876af96b35647a2ee4066ff3a8c3c6f535312cd02c795a1baae44d017d861d7b1f95c782a087bf1931f08c26e308a852ed109ba28ed2271739973f50a33f0febf2ed081513b5c503b73c30da51fcb77f6f51a12e3ab743efe747bb5432dd38a7d654e912694196342214097970570fdb52089e01b14ce593389162cd6d442e529463c2ffe954a50229e00f055f3e252795227ff2804d4d9d3fac79aa23746c83fb552e92932938145f35990a1a78721f7bce89bf8c8489c6ede623b273efb5d7536ff40511a304d5e1905e04ae9843d40dcb9da4ca06f6fcf2a4e5f5fbcb03ea8b165f9fd2a81c3c9f4e603c023bff310ec57f88c32bb49bdae9a42fa3249f1b4a68321eb9c2d9001fd61e5a0de12143e9da36fcefab30aa4a0caa38e41b0e622bb110238a99c4fab4720013ac6f4599c7465491fd2a9ca1cbc2430c08a4547aff1cbdcdf13572c2f0017a053318171d6788eb2f9342a9016d5dac3c87216eda2487544e144841447d1caccd297dd04a0c5a9dbec0b05df18918a96f531c0fd298399c87ed92609f8ccd92e57a9c51974dc1a158cba812420bddfa0bc351e03c164424af21d944e90094c21a2f832a9ea0ad8cc362e0c25c9c53763e0c25acd10d67f830469d7f6e04cb051e5a24747d7a9d5db23e26fe49f0a9a5c5cf860267c7132be24e2febbf3eced583b42c4075bb27571a5f9187183a94c92a809712a23781c8a1ce1e3fea856fca6d17b8a4fd5e5fd3e85d5a1fa52677ebc7fa0252e5a09bee3908af86b250fcb7d3b6c4592e214cbe28e736db6fde2a1d4211bf50e69f58083359d500ff767c6e0ecc35a9dd482b764a7a650900a3e349d870caf4ef91654d748aaa5da12a81a63eb1c4315bf65979d6adcc6bb20e065093d91a060cc58aca07e694daefd60b535f8f2760d9685d8a4c6ecad2cf06596f576181a3473f0ececea143d87fa5e654f88afdb1b0f7c985b757236413a8010e856f05e17c06ff2a90bc3827af32fa7401eb02ed7477111e072da174214ec838fcde6a0b9f06253eedb7405fb118afbc251103122b7f6a401e80e1c717aae646351758a0c1601a511b827457e3fd5a85d25a4a1df49bfe6654c730d6a54730ae925c0ab73d782c0260d1bb63860bf4158ddc8d5d2f94ca1347c635c950a3120ac4176ab7014db9a1d0b17894bcdd2353295d694f2d6bb75d6f78ec25f314787c952f63d0eaa664274a46b6ac7a7b2ed2d0397caef1fe40d401653f6f1f71f2b6a2effa3742041877c822e1eb05a7b720236c740457dd4a7bef44034d3f97d9a0cb7545c404ef9a3bd6dbb76a1cd3037af4da65e217451f300f7fb1d97e2337b9d9dac2796b386552c3dc2cdce5252d152d37022fd8ab281eeb15a493d2f38b44941a1b7398c55cdc5bef31d3ee7a320f99035ee4adb301ddfdd91af0b16f7f74b61e3e2f89a13fee86db58811823b738790562a7405e185d17ea7a42ab5f36be2c83e0cbe4a65fe0484e3762094a43c9e219d51d24cca8fd133d346d8de45fc30c0441fae52bfd9060809afbac46a50328a809ee7edbf3705e40c8ba524c54df290120c118e84940596affb5653fe5d357d1f03a1e5b8988c9b94727d3c0a15ad4e24cd1d42ec26b57f92906022952187650ef3293d6105d2467de89b29fb85674b324b85f63988f552ca18295dadeb07596ad5f026380014235557b9146de97370b08eb753dc31fe13e93e1689f6f5afde62f778e234d2a5b1bc97e15d493266510fb0af173eadf42a5c00c11f6f741ee28dfc721e2866b4cb6d91446b88af0d401c0c003652c9d207139d462b858666d7d372b2a974550d7946f8172fb6e4733990531d2e228337d3d84650cdba17a7a185df48ddde5d2150944ef3d37dd5a054b46bda2a82dfc0bdf923ac4ebeec4073bdb6d67c18c9aac2907443cb0d9342588e04fc3844f2a94754064b1ca225d518ba4835ad130928e39bab6a43733191a02da1cf8b426b0cc96d13caeb00cc37055b53ada1a0bf1f50d290fb9b3ae30a5bb7ca6569845bf3609dafef7b510c3dadf7972613bd5c0522840871b9fcb822e4c2b5d5bccbe939bb3bd74967e264363dd26e77ad594b65424757cf28cbac900050a588225278b4b79a10dabc1794066e956bbdea4f33d500496038272b66adb0c607bf14523fe46fa09a74536fda03bc68fc75dacfa299626068fce981da8241f8c89edc43d4c018e56c1fa273adc18eabe74f3a78ba038b4db6268288a8e69937cf7bbdc8b30cfcc3be6aead282a7a92401f2a0888bc3cbe6dfc71416aa8a62f7df794a4dc5b47dfe3c8375139927472302e48a02b6b491a6380f4d022aeeb28e27e9b454d5c987f1a5bcdad7b17a9a52a2364fcbd6ae5a92eba54d08d1fc7e39563134d2316c617e20ca8d229a6195148ed88c5bd625af7003d74f8def7d4cfc123d0d1218233f0b81ef00a8439f11731b9083deb274b964f96cee833da23b31ef9d6f74f152d4c93be1ca4835f719e1bbece6d7b0b2dee83119c438ca6acee9d793fca5d5d4863abe22d5d468d690866173d83605060803e36c3c99a19f18d8d6a2cb7ffe2dde92c53b39c063444f02df3a73e9b1385bc55bd4eabc8bcd1eadb5d6167a58e4d349172f69afbce198f108f092f343d399f55612b6c203b359d7a30d91f46f86523f96f0bd9f559f1e21e4c18cacbd691db3eb5d573ee958fd32e2b6418e41b01ca3bab3f761c99074348807f16f1859ad68c14ba2b95c2bc3046b9d2b95c15546ee0472c7643a1acd10b03247358e91d33ec454b81ebc46092cf6b9f5217d00da012f62911e9c2e65d7f8b6fc8d817899c5a2b341c2ab171b75c3558b498ade1cbc3904fa6becb027a7c17f7c4ef81beffb49cb40604c703a8ba3b8ed37ff8a89e11a3c136c239f28ea2a71c98e8185c1447592cafefdbb30bca76645c41c2ba124965071556a71c534f3d2638a9939728b2c480fd8abfb3b2c2b83890a2984b82a77faea71d961ae48139f42e8db710f5b929b80393d5ae59e950b302721ef00b7c3d32f197f8c7a90efe3e645d4d13a919b8a870dcc57f1651f2a2cceab2061497cf33b684f4a13874d9fc04c3b511fc50bd87ebae0e357d26c31a1328e8696e28f61f6631c9e200251ef509435fc6efeac5dba6cc13cd33a198228bead294da3fc3000284bd82d955a702178cefaa7b6aa759dd9bb653b96b26fb021f65ba64b87675dcdc1aa98d678563c58f7482782e1b77419882b6dc5c749112038904b33bcbbed1f76d018c20cfb5d4c149ec3f11e5c1c7a352c8b22cbe6564b3913a38aef2aaa612f7cacddc8dd740a605e36ba5006bc51f4c2c7050b1ea8933ae96b295f4016dcead025f13a8ebb18f81b67d614adbc77fced7303f8e95ad3f788e4a3b5b9c10d8c80229c922349ae33a64057fa144c2022ec50fba79fd58370e338841d57689062c1e3a6e82ccc44210ad7c4bca98a9e38336ea63f35e99f159b26535f09b69ca02888bf31409c10ec476f51e6798cf186779575bea70fc5b924cad2b85b50079b595d551269436dc9231b2f2a3e7c43b0b0f7a765084864c55cbcefac8ec44dec1d6aec211cb2d1af800f0aab4aab66448e6fecf7504d97b0fe6b3ad6f81b34297363352ceb5aa8106d099b4c2f811a773281cb0798884c9a6a9083bf25d85fe9e9d3583e22d5188960187d64b4d4c24617ce12576efb52f32dd046c1d10955de5dd8bce5caf5075df768b036b5b3f626477775cfc230d567755e1286da49585509ae8efbd12586b62b0f0b0af5225d672e6998284916b086663524fcc3397b2a1cc41da8d0f6dd7438a27c07c1e94bd5497d1085eee9160f35d0bda26750ca1165ad7338ba9325c0859cbbdffe5dc53626195e93f23c344d90211c970e498b2ac67b85bf3aaeeac97ba05d6b1cdf3d055c5fa3b61f68709f5163815d8556374ff51b79f2d20bfe9e233e83807fc49c050c2b71ce03d66aa0e553041a3100e5b11e9fbeaaecf586bdb362b2d202f9b2f3f576b663598f59146267de5cea6e351f1c1422a7f28724798fd984da3abb295a3a00ca033758d9ca0293caa4f2e64dce0d80f322eba0225c75a105ff13c48efa67733e400db7b6f5b016c58eba29fa6f821895cbb3c8a2636757c870d648077c8acad6a9937c15cfe9967e4e565e22e76beced0c1c9240857bdfd40d3874c372726be3ba064015ecde560dccf62706f87aef97ea19958048292ec6d87735a2ddd91aa9ee0b830804d037588ba42552b60de7cc0d9480783075866c1b1621b17b49c021b67e1998aeef6f8812f7226df5345e012d31c8605f72b7d78de0699d63af9e5e6c34e5ed00cf6c2017964c1947bd617f467dc872a85a29ec9eae69b9f4ed8f8253544ccb1bd100f1703c90d17e3d30661432b36a108fd083524bdf34541c8dec2dfd409bffeef78f8bed7352ff4dc7b119a550c085c037de384515938b43462ac434cb8d1495693fb3d08c623f4a7ee62e5b786a0a09fcaec8a78eacaf07c9960e2505ded2d8bd5bba2cbcf78f18aaf1754ddb58b53e68fa1ab5754870956e07a0abd3ff2f29dec9f7c4b1a1a0ae607708facc4968cb3db512b710145280af44802b7a1792d27284d6bec13bbe2c98b8998af8a75a0b38a5d70b69929ba236752521d66d9adb52ea14dbd6aefcdc2c2a7efd229bae613978e980e8eaf03dd51e3f23e800a4817c2b82e88ac819363500b6b4cd3361cc0afc2c5063b1dd421ff6688a8c34a44f5133b463e27762d04d48f6254289e8ebff47c0cfcb2d3436b042989940279c4064336ca338fb179d83e99ff33bbbd5a31ad125bee0182d6aa0f35fcf5750250dd509f92a7333bb635047075b4a4fe6d0db79a628cb57b6caf4de3ae26d3990711669513c5c19f0fdde4a2084b5ba624017bce4d574cf180055abdcbaec5266bbfc335bbfd64d5b504ab4e4db70be2419a69ddf68cc97d7764d86795116dc4c4169b2f6011775e2662e92faa0530f55fe86d6c77c58efef699edd55521abc68ad6bce7ce4cae4ef9b5b56ab4467932e5d6259b86f278cf92398d6a99e7ed7f913d9c471031663b074074704aedd236cb30ae18ddd21e2861f26ee14ef6caec6898dadfea7787dae4c67bcdad89ff58fd88f640390defdde4bb69e7fa197d2d776809ff5630df411dda9fe43c11288aa43211812e70d3f54096a9848892e3da3e4d834c879fcd4ac579fe4067e55a141a057e51a72509264339bdc6c8a413ac15c811ab3f5cec5ba9cbcfbfb672351bf64efe0469e1838dc6d706b8f611c11af3452794ae8d6e17c8a99135fa38452d49974aaefbc290e434be58563abb4196f8c5d84a8760b3d0d432f2ce9dffba1e7236e3971a53f528f2953da929ba5c04823949aac5cff3e53858f7e1fc2af7770dc2a1ecc253bc0f252f3798c45ab49cde0124452e9f9d94caa926d07f812ba6ffbdb9cc534dbfd7b9d1f737c2de1d2376222a033f23d6f5ad4ede642175d48cc6bfde1d45012da4562e7833f5666f42ce074e8abfb0ba3f67c77b453154ddcbe2aa0b681dcdaf0da5ce950a9db27a7f00afd3fac61669b5ec1bdb8c76bf4c24aa2546d3a7785e3a319627c07dd020614aff7c268df93138d92bb40bebaf91afbe4b9dded4808c0bdc4dd13d1d6036622ab22051e32349f46c114c98361427fd0e05d10aad2213d216c9c240df9d6b343d4ca4640f2909a5ca7368eca5ed93e49e914b536b9dd8978292f62b336ca40fa5ffd8c0b174e6822f8b291e981fbf614572b19ef8bc64ea350c9fbc091ca6ebae2664eac08864859ce64b0d3123f42468448c3bf4768f63520189c46b1b947c05cb8d46c4143310c4caa870072da02071c0ce0863122e279d13818d94c85f72b649215eddfc8268d7f7a79e342ec438542bb4043e1bd8af067e887b1eb30cecf5698e84ec34b9c899e6b7bedd32d41a83c04b5f9241da29a61347f2e4771e49084ff6e850436ce3f3a37fe060d3dd0fe63738ecc77637d93af06f4c23bf274c6e21794c704a68396ed4b431bf418fe4fb9e88567692ba0a69212d5f0487bca7890f505584ee97983fa1a15d1840d484a509bd794584ed231562e319dcddd0da81b8e236aa0af8dd9125948a9b73268b539623b3799f73dcd3f2db40f8463f3f6828b46c96bb6911aea9f65e91164f8e9d67e15e88cfc591b9d6e13ab4e8ef6f8cb1a03cec98ea4de66c6650f19140bb023e242b4dfc981ecaf8cbe53bfc6c6909bc110502a4c097b1d102ac36cb72ed6209084b45851f6e384d053144e53cbd50d07798b0acabb4eb84f1f99c00ce21c9478fb0ebb963fcc64eabde2ab3a0d92738b481c0648d4cede633cd2d89b87b38d7a3421e02e37ca017bfe98024d0a31f5a083419b16d9a451c737a7b0f138bce829a36db32b4fb16a73907b28924f90a10c6b54a6aa18956a93b4e1f6f1aa08a8ed08022dd8bb7cd868776b4eb216a847e33d0ee967b1e861bcff5592e82621154f789c93aedf44b53d192df3e168aa9748702ac5058cbe78bf8d4ff3b699ce39a4441c5a812d2f6d317387c699bf8bd3558a20cda9808d9d12ecb394166ef5b516812bf16de95ca41a6ee26062aee860eb8258972f3851297666472d452d04200c0795913ae9d56aebe3827643301fe45539676dd5c0b794bfb6bc6ac82e1d18d33beaab884e3a6cf148a94776c3bfa1d7e5951a3164ab01a7494ff61239facd7fccb67bdaa6457536bca34d50fc5d027cbf6f7bbfdfcbf00f7dec1bca3eb27e35a45437dca7907200421e4722d889e7141663852a356afe3b84541770eb4472750f433c8a3696ace60c17a7d8b710df9a394b946197be0cee50e8fdb0d35489ae2b240c24bfa079a414c318f8974b6d60b1a5a044de3790ddbe5f7fbdfa65c5738aed11d8101308d58239eb78ac814adef86e1da77278ed69433f9b8bf5375b95304d7369dca591dcaa937e1acc650d2d4297a7523effda5eabbcc2ca13691cb44f3f473e44feb609c2b69cc4be46d620b00a3dca48e27ce3b3910a0907549c98bbc279ab966d46dc763832171bbf9809014cc0386a49ff882e93a89803b80e11fc211560843798b67e5cf9f2e3a80e8ec9a8af56820bd77263ed2b13a96ba0d52930a2cf4307af6c74989c8d0a4fa7ee5219bbd1168f652265410483fb4783f48b0c7edd161ef1a4210afac3982b76072035614b22c9aee53334b5d230f86b6c5c76cbe908b7787662e6bd0fc56eb6106a513c4d7cd86f3909aa3d74af5567f36d5175d6cb3bdc817ded05270e98468486cc51150b1ee3e858b6adee972202051739d038e9412a9a3e45852d1f6e8b4b007334ebf0319a26ab97f4f1a1479dd52c0ed87ad2bea9c5d3f5695c28f632e7c0bf0387dc2363a6bfc1c0af03a405c947ed53bd31cee16924b46b51277d1b68079f46c6f8f7d8635f3cf80cd6d612ea2925e65470724e56c104b084617b9acffbf1414d5a305485318db4c557c886ea2b7886818817509c15eaccb8bab5a81cb00fdb1503bb38c8c08909ee8730b91879dd9f03cddfbfbcca8d3b4532a51269314753874b968ef4bb3723e7e611f41a4b24b6ab1e9834c008d840a025b99023572fe988b4d0bbf0130471d958b1385fbd340458cbf8e9277a41679fa88052591fd870653c101a7ae605b50c92c104e2782198456ddffeec5ead2d2f31a8e5b54f1cee75418423462223199532931b2e074650c49c08b39a07d7446a319f93f3104be343092891085cf80e7d941b5a2eba0811f2c21547980359d016dc5fb6b7d1c3bc2a6c7b886ca18dfb862b16406161cec4d9902e13bd4d0114d28a79901667e2d4e41acf14165fc4aae5da29a9bc14a30a84b0fbba1d689e5f0252cfc497dccc4d559f0316616ea277fadb63691383830fc2cc5e18fbf45067985a874a525a0050bf973d41773fc131a0f5bebe3ba5ba3d18187b9539738f358600c2688eeb029eb4a8c6a83dec531c4b1aaccc50b70093750f714f5a7eec29fed33480217b05268934dcc2c401b298468fb6f03c532ac404818e931fdb3d06f0c08a987408511253c9a54f0a9917d4396ef26a3a8b8df8b9fc0f3719be3a4199808e40d5250e036edaae4c604801f1c1369e7f1c00fbb1b8e8b7b400364c37b2a15268aa67ddf6302b59d5554e6f5fba34bf7fa63aad77ec6e5333fe716000a148ffac2b2e813fec037d6d861d18650734292019cc56b080c25159749b0e6fc8d9013f6e7032611d184702755abe9ee786fa94c08bb157447c8ec4a0aa28da1111c30ac9eb742fc7e21bd416c98965876316a7f05ff25d1ba86d118e02a92aa54e9886c843d2e21b40b3fa6b55f2b6afe8dd71be5ed6afcc4ab489c140f70da2c0e700741471c3d8bb2a53ac1e831a5a0a6e6202a2f994b62a67f2218886d21bb78afbf0678abfe446c1f9be7974ad2ba4e35d8f28dbd3841b7823fffe985fe5726622bddae36dc772816def172fe19161559593f4dd625f16867374cd74ccb4e5630b7b8fbabdcde7ce6897eeb0bec787a5cc89ae2e72f0da89712b6768251510f56e9b2c722e2bd75b1f10ed675f1fc91d47c04365c587937a201ca32f1c337bbbc397f502aefc5a84fb5dfc5abe8350eed3acfbfeae2f8f8036fd698b493c1c978165b37530e6c223b541408d6a4d6d6d69ca07bc879f197276ab34bd205d8810f5c67bfddada51657345717d0c5e5e6f5c7f73e3eb9174358ca0567d4d69945f5d9496129db1b843b39babcd61d9c8b4b0224adde5ef6107e654f61d09a7ea301cbf2d5a65343c3c1b968018a0b5e5b7a0783b930d0f18aadefe56d74c2c9ce0edd946aea01790fdbc99aea7a3d231a5d9bbe2f488609288ed361bb2040ec2e0a77cb64ffd035de6e1b5810b941c2aa6f067b993ce8df7c282ef9570376f73afc50f6a2cea26600e9b2e9b7df0eb4b496be27cfd3d37bef5c2ba808c30ab5857e34be4027b4107d29c64fca299c7a3162275eb1d49a81620a8b2064a2b53d2ad9393e3bbe964399641f09ed63d4427960dac4a2cb7d32a18ac96984a078faca8289cb032997692d04b88c5fcf9920f5d476d9f8f2da89ec5346b41e8fdf350dbcaef752ce6a14fad6755a69d70fbf4fb06e7d925f77c9510d0f77b09fbb9b933ed60e6828c6d7d88f1ec457b3af0f80fd65de56c343d78c5f7874b368d5c1d459ad8121ba6ec7a6a3a0a695ec70ff6998f32d3adf19ce7c31ba1b306add3fd17f2563550993736ae7d250cb804b3c148876e1a578ae42fbee1db80a4d2d130454969217d15295218dea0fc1cbd4ed2f9d9cf24544ae00aac124a906eef4bca37b309113e1272323d5b48cea7b98778f320128ca6c807b22c135bc3c58d1a796588371beb7f353fc19f44015482bf2d185bf0174daded90e714559458bae6a188a42264121dbaf7c59d061351610a7421a18b7eb9243f40c9d125d5f39942fadee01fb70da41188843a7bad71c20d76aeb89dc14c6a92051868dfd45906bd2a4b57732a46bf4a8d4f220c95f0e21dbdf2df069cafe542c2a77d131a7df97a6a161d26c56844329ad254d49f5b58b0478fb37161d0e5bf4fd66a4ce24f95e8928a07e147bf09baa8cf155927e7e7336051ad448ad29159f46e33de171325c26667be13a6fa730f79c0f5ae0cf9dd39f79761bb21a9bb7d8494ba6afac12b22c56a440910cab60c9a681872ef2a4139439de659466c091ef225fdf36ac27e7e48d4d86c16b1970a478f1b4ea801505f259494a91a15ca7769e57bb1b512d0fd9bd005d205ebec7cf41275bcbf41b941481f23090568fbdc4a6ab0b37750fd69194f1b2e762c387ca945b303070e2499f9682e5359107361f7160e8f61b8a1e264f9f56ada9d4b9200881bd45e092d0a54b153bf4fa63cced20ad6b785cfdadae6ec8e83dbb1a0a35757407987140575382e37f60fc19d34449b67e1b8c4c242be1269b823b223544ebc0d2ed052c1d58b20d369fcca6822663a27012064d0d9f3d429838fdc1c6294cf8b0e44a39a9d2fc81bc1532697dfb09c135d579eafb4d375aef704d8ce66ca7a5c6ced7c448e5176025824fde31392e8059204cefb9e03fc6f61da44c9906854c6d807d4402988a5ebe3ddbe1f7ae5e3a403920d75a7f76cdf477432f715cf6a2c246c70f109a337dee560fd575cf23e77767fbf8fd6f229ea1d5614a75cc1dd941deed8b205bb381d5b78a409db9e210d33519c4e1bf34f6ed12ba6981ed5711a34e1ae4d7a0a1c4c937f7df5980e3d8694c65d9fd65501b2a9c427fa79e5c3551f0697be4d32f0418529fa416a970cbe7202933717fe9cf564cf654e28fe00982018ef94dfef6066e1853a1128ce2a6e7cd1522473d4a122ca2f66c6999f5787102d4462e25788b672f6ea6f355e1d53032667445619f197b70ce5a786b367f84a5940cca7e12e23c893e495a8ff8782ebfbf08cc62904c1f937357a654e0be76436015d39c0d825ea7fb665ba46dc818acf46db6679c3ec77900ffb681223585af8bad4ff48fe96877bfb0b87eb5c79ce1f92ad74c6cebc3d6a9f974be285d9043c92ad39074a1017f1ce391ead2707a9d7fe6af626763c8c9d55887283588043fee2bcbeb8808c1a7d554960d368d7d64e8b7feea7a5c1afa841baa0e93a0740e41a41f472e7ae308e28ba3a654dd970e4005f3878cbfe5f6b49c2024f1bdcc02bc746aa5111243a986ec526f74a74270449bb279be08471173d4f6765b654a14f3c43b5d3ba8b3f4aa67b259915c8bb5318aec8dee4c38e13f293ac72bb2defd3cf6fd018676e065ad1303dd1f8941f63bc642e9597c0c07e7c9fcb069e54cd02999edbfb9cd97036188db1fed95489502f304221a3c1297962594306d5801637956b91649f93ec1c194d797cc27f4f86e7729cdf59f2be298348925971bdb2a2bc007fef6154cf13f6c26b9a0af9ee890c56ac8427387967af080a3e1455b42ea5961b86e2cef5e79e82b5bd22d5d237f2bfd46bec2a549b330390374d815c4ad8bbe61bb67245e6019782865306e056fefb4c47d3ef7b356a059ba7e3ae3652748459c4061acd778d0892bc85cbccab47d654ec3ef2a1b1de108a17a5a6a552477044d5664a83313747c10e4a3efc15a4d8c5952db2752b87c3f4291127f3c8909b63ae78b706366f963657ed07364ffd9d3e6a6bba5e1920fce879989958568b46b9e19b2e1cb30ef3afaa5622495ce014ad6f542b3225cf1579f5f5ab6b06dc576f63831bcda640d155298c89127fa3609a3b8c4476b52c0c475df2faf1184ba3d1be21107ed6cc2e5403548730e420a5e161264325cd1aa9242a3d11f1dc8113a0f066e4ae77b2ef9b20d760ceeddf6f1e714d5e3fd8765360546aae6c7245ffd924fb4395879db0968e96e9c1ca0a1ac966e5c2de3d5e559b6f76ceefbc5221a4750feb4dabf158f554bca8f1a4d463a46f3d4ca68cbd97282e',
        salt = '587bfd195366cbe13b21b58f3af59aa2',
        labelError = 'Bad password!',
        isRememberEnabled = false,
        rememberDurationInDays = 0; // 0 means forever

    // constants
    const rememberPassphraseKey = 'staticrypt_passphrase',
        rememberExpirationKey = 'staticrypt_expiration';

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param  hashedPassphrase
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassphrase) {
        const result = await decode(encryptedMsg, hashedPassphrase, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        document.write(plainHTML);
        document.close();
        return true;
    }

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        localStorage.removeItem(rememberPassphraseKey);
        localStorage.removeItem(rememberExpirationKey);
    }

    /**
     * Clear storage if we are logging out
     *
     * @returns  - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        if (!isRememberEnabled) {
            return false;
        }

        // show the remember me checkbox
        document.getElementById('staticrypt-remember-label').classList.remove('hidden');

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassphrase = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassphrase) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPassphraseQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPassphraseFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassphrase = hashedPassphraseFragment || hashedPassphraseQuery;

        if (hashedPassphrase) {
            return decryptAndReplaceHtml(hashedPassphrase);
        }

        return false;
    }

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        let hasDecrypted = await decryptOnLoadFromUrl();

        if (!hasDecrypted) {
            hasDecrypted = await decryptOnLoadFromRememberMe();
        }

        // if we didn't decrypt anything, show the password prompt. Otherwise the content has already been replaced, no
        // need to do anything
        if (!hasDecrypted) {
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const passphrase = document.getElementById('staticrypt-password').value,
            shouldRememberPassphrase = document.getElementById('staticrypt-remember').checked;

        // decrypt and replace the whole page
        const hashedPassphrase = await cryptoEngine.hashPassphrase(passphrase, salt);
        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

        if (isDecryptionSuccessful) {
            // remember the hashedPassphrase and set its expiration if necessary
            if (isRememberEnabled && shouldRememberPassphrase) {
                window.localStorage.setItem(rememberPassphraseKey, hashedPassphrase);

                // set the expiration if the duration isn't 0 (meaning no expiration)
                if (rememberDurationInDays > 0) {
                    window.localStorage.setItem(
                        rememberExpirationKey,
                        (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                    );
                }
            }
        } else {
            alert(labelError);
        }
    });
</script>
</body>
</html>
