<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #4CAF50;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #43A047;
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #76b852; /* fallback for old browsers */
            background: -webkit-linear-gradient(right, #76b852, #8DC26F);
            background: -moz-linear-gradient(right, #76b852, #8DC26F);
            background: -o-linear-gradient(right, #76b852, #8DC26F);
            background: linear-gradient(to left, #76b852, #8DC26F);
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>




<script>
    // do not remove this comment, it is used to detect the version of the script
    // STATICRYPT_VERSION: async

    const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 *
 * Mirrors the API of CryptoJS.enc.Hex
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassphrase) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassphrase
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassphrase) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassphrase(passphrase, salt) {
    // we hash the passphrase in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassphrase = await hashLegacyRound(passphrase, salt);

    hashedPassphrase = await hashSecondRound(hashedPassphrase, salt);

    return hashThirdRound(hashedPassphrase, salt);
}
exports.hashPassphrase = hashPassphrase;

/**
 * This hashes the passphrase with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(passphrase, salt) {
    return pbkdf2(passphrase, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(passphrase, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(passphrase),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassphrase, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
    const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassphrase = await cryptoEngine.hashPassphrase(password, salt);


    const encrypted = await cryptoEngine.encrypt(msg, hashedPassphrase);
    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassphrase, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassphrase
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassphrase
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassphrase,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassphrase = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassphrase, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassphrase = originalPassphrase || hashedPassphrase;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassphrase = await cryptoEngine.hashThirdRound(originalPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassphrase = await cryptoEngine.hashSecondRound(originalPassphrase, salt);
        updatedHashedPassphrase = await cryptoEngine.hashThirdRound(updatedHashedPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassphrase),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
    const decode = codec.init(cryptoEngine).decode;

    // variables to be filled when generating the file
    const encryptedMsg = 'eb97c51036d266b2b2e9fb6fd15ade15c52ea8d0d08168647031896e47d48a2b8f0ef99ad7f5558482027b83e393edc9ab4bcbf93dfcd8930d40d2e6db8ddfc878a75d4fc68e8cb3bedf6a48cea2342865867ee499c6858bd47b12636acb27a5c11403d3c1f3e2597e55008ea0097935fdcb12dede0815521206b5096c7c8f0be65d39809bfa3311379a6ccc8c46a35c9d405970186b5c795c6e64fdece9a6f24e0504a886e1325badcf2cec0d0d51f97411f2c58dacc7d40630b01b1939d25aae0fffcc3231c634be2795551face47aba1f6442a64122785a947fadd3a8a01ce428d75be32ca54557b96b6eda5ce231ccb4f9f39c5d653d97b2150e43b2dc309c24aa4b57196c46729029e76942b497d22f63ec389cba3cb88cfebe55a6ace658fdf038390244266295539a76820f7b19fd3706d34fb4891240e45198365e8d7079941f7f2e0b1148f0672fb61cb1f221e452e176217c61f22e0749fc85087a3c36aac7d56bca523ef459b6e1500ad1fc22100801b0dd58f0866e50725b6b0e38777f17c587d15940d0aba28216d79a4f72c604607aadfb66895de7e7c4785fbf0342844685063a9c806d2b683e880615b36700b7a601d5a47f2ee9437e53c109a43fe5d7dfd07bec5ef7976bda23cb6a11c9d6be5c51f98a4b682b7dde819febc1f43c91a181433f7f2ebc33224d73e9acad1c1e8f9455dad98d335e87fd6951af90bb6d9ab6f402e71bbca96c692ef1438a8c995616eeee408c33bdbe181d99a272797874c321b3f15f59f9bb2c69f2cee92370b64187f4d0a39087c30470273c98b0038ebeaf8895c8a397e4e951530798ba1f10bd1464d603d9854abea4cdaf4add66e448e397c5524228a4f793d94d7a0d4628e6d9d6edfa2770c0b1a252d28a3b502841d30e5990033fd976973af8480c4f84cf7a4a4a805b7ec541920af140ae610ca6741170c37b72a7ff6d8db5ff53bd296ec886c6bd9907aa09ae4f6182a0ba29dca273dd44fedbae57d9402b830ecbf7978d13ca5d3d47e901c0b9ccc875bf84580a4db1dba017c660d36b8d83a47ca92892f2333de55ebd06bdacd5849250a4d07d8977dc86a23081ee9d42f7d2b4db3fd7d24031d4309568aa4e1de6b1948c258a46856c80b18ff91d7d626f46dd9bb715fb039222e38bd88947e60be4405803f52630040317e6fb59e50c79b169bf738887ff6d6e401571d23886285daa9a80c17ec2aa2288d11fe41895c372cc89aed5074ea46e1f8279b5b7047a4480228e1b6c11425fbdbb5bc393b29aa9e7a18962111482e0f6f7dfbb7363eccbed194c189bf63593915f52a1eb4a17b6f5da29d66bb1ca5603c56bb879ca01d5ef6b720dfed4a9c8958cad3a30420ac46c281981619ad43ec26c4ee963049c710db20151551f1c682e57f23d43f6a372f30a3f4ca844b19c3ce32b9d564b861f8ff8926cfcdf2aa80fa5822911b67aebc2c610ed1eca5ce51a3db37020a81ffdf9a933b4e46bac466bb5faafb0c7fdafa6191e842782863c88bf26a3c135157d6a62e3ffe2f2581dcd8df96281af35cb5a82eea9b7ee041067597e8aa0ca0a292ab5d55f7e96cdbc46af97295328d98fbb16464eb340a2fe3b35dd77e1ad09a086ada9328d5551900a85caf55dd79e95aadc8a66866fd7ebc4e8296d5b444626b31002d3db1a6eafef59d2ac0678ea4ea21269f80e713946d4e46e1098dff51d54376c1e3061d78c459b409ddb022fccb6050ed01ab211a8e47c3018f1144d9da96c746a6b6d0648dfa61b758eb0623836bf252404add5ee7118a5f33401c432fd8f5beb15ead16cb76fa9458f4a3d538d364953020805d5ce0595dfd3386e4dcc15583ebfdcd051d8265202aa5b2f018d01f93c800d5c5f512ba46d05ab9ec68621e43b238031829dbba1f35bac144ec02bef90c555c8bbe7efff757026ec902decce689f04348508e660d18e71149e368c9f136f305ba2fdeb23faa2557e9991b6aa92f092038ab4a73f06f5b122aa3091b7a28735e1e1883d61d2b19274db11e7100be245f49c2258f414f9e9bf2741d3aad255b553be4ccfad105b91e04c7319279a8ba23e9af173a9f39f9ada991d0826446ab920fa016121c5a4adc5ef34856ed7a72cf8ea5720541881ebbbf19845b81adae139ded62680bac30818fe9111191f1ec12d1fee50d451b5a70d2c7447a58482062d101e95e6090f2fe937e971e456199b937bc8d7555aded0895b1c6762e9cf352044baeee5841170404d46210bfb99d4603ec5b121feb5b50065a1e69bea5e41bfc0f1464d6cc39648e08e9111b8654f555a1a6a15e6064fd1afc9136f46963d8ac2028ec16171277256ad7f5537a4a305a16b2a5708c14e6ec7287608ad3120f1925aa418a0accb4b97fcb72d4a81d9a5305dbd018fec5504959ef4f7f688718b4bacbd3a5bc6771f0228e860393ddd5528193749ff2e8c9f0d4fa2616e9feaa354437739f7649b41f2ce932c8109570eab7d1f5f141edccba3816b71796d0388a1ac74fd3c1b156ddd4cb67b9c2133031dc7e80ecbd4cd0c11b257ee80a5c4a28cee002a101c733a76d4cef4d72d2da98754656fdf4dc92e47d383333e2a1709844e4f31125c557de1d208feb6903345a3c152149003666931766cc899370502d92fcb27e6411fda0398951511733d31419a0ed22d81cfef264808ac537f91b9b6deb5337dbf1cc6e7d4ac3fea24ad5a366871802b8f145154bc27cdc6ff5fdb427d09f72a0079314e034c5d28d7cbdd43ed190de18ced5da503ef03b7c6ec2edfaaea9a9ba7c67c89162f7f659f93055702094082fe12d55e9239fc6835884a86dacfcfe89fc6d288af2bc0dc36f18e948abd474c2a736b5eb604c95cef8abc4081a9f56bdbed047fb487741b5f878030112eb520e670c347af44dca70584ccc0a7c3e601059151e318766a1ae7841cb4ed8a2a2f205a476c3fb8996aeeca835d4cdd12688d846a1ed4ac344be7694ba922492c60148b65fc221ed94aad2359610055a7a42c51127f6e56a185a2c15d0bdbe7eb01f4c5a5ed6327b2f15fa0615ad9e7da8306531efc1d0e97337e11d8aef8e6146da3af1814e3b0c51ec97c0c32b1b375bb832dac4e587c2e78a8d24499f310cca9fdaa5987851821204d1a4373cd7677d3d90e06f49b6a3108bdd89a9a5e93937e0d69da9dda47fd55ef13ac258c605a007a6bac46639118aae6c6055670d58d4f59a990c56a2ef6c529636d64a8fff40fce7d092273f2715fd6edecbb3e99d0ca89cbb4f812c60e549cff19ee7741e3d2722682e0952666898518e65f9829e21ead88220857d53b0e252247aacde85a9ecaf94818ce3b9bc76d2be7d22bbe37e749f7dd8ad285cbfce0c82da12151f61d407371b4615d64db1cb4650af3d55dbbb813d72edf8c91e5954e2c6170ec9fb678aecbce8653f106376803c3f741f677f4059b984c6b81f1e5e3ba5c1a2e25c9a9a339aa1bae99b6dd2154b88faeac6a91879c2445320418af47febe8f20b6ded8ef772f6386bbcd5ad0490edda970219eb0d1ed299d7dadcdcfc5386958c471776a050460ff6c36c4fb562492ea34b9975409b09abc715a2bde520b587ec02e6e746d3a532ba420607f1e7324fe76e84c32d611392ffef2d3fcddbd05bc63556c8ce8622640367d6fb361f76c36a82105bf43057b641d3b3e41f645d1b46ebeafdc7be711c5389877b20bddee0a157f79226cfc78b99e5ae22b2a0321facbffafac24984cb3ebfe1ccb61c04bfc6a2d0df309004a54c3ee7ddb577a0772bf7044ca0fe8b9f02daf24463e8b1ef078d993bb72c1b82a638013e98c5f0adf06615aeb0fb3db88bc655ccea9cec5a6162a9b8f130372257e1b46485f2fac49b1e3236e3da8ee133a0d540d7b225aaf1ed23db6983dfcbf13ed1eaff9f6c93595435467794928b1851fcdd9d53930cae34521296d435890d47c9e8b36412a0ac00a6f7202901e73affb9ffaeebeff67273341ceb3c6b2e3a818add0fafea0832015c1a84d94860a56d289ed50e20d6828c0789dc8ebbf2d07c80c8f59faa9d73025c328deeafe858cffa0231650706de8a99bcc0dcad4a21cf906a6fa88b6cff8ee11a22fac936d86cc03ba86f7d0629093948938759be189def1f0c702d441f289eba400bc739353eacc8e480460ee2b5d9dbd024944591a14d495e4b76205824ea1386cde89ef243c83ace8a4b2e298c538ba447f70728b4e84f114e91040246597aef2dcd494540d8da1dcff43d33a776ddf33c5a46fd091c30ab228d595835a6a0204e99ea933521d8db865abb01fa49cecc8ecaea984d1ab44759dcb204cea5a9ab4b4da9825d1eed605aadfaf6b2abf0be9214ef0e586779d6458dfcabc811a218b2fed38ba99b795713144a51ca2d4e7fb079f6e67ca3d69e28c029cddfe08713f166fcef54b7b790cbbe24916e94bc7d9f500de81037e2f880a099d1ce1b5bc878934f33b3390ab696018970c798e89639f5483651c8719c85d408302c45d13a8ca5ddb00522e4e33dac958aa19bea6cfecfb43bc26dccfcd1e6e87705d3a0960ee415537e08223e153ffa4b57bf3a920acf96a94ba2a601fc3c06f8ea592e8480c243215f8a609b67b87bf0c6e1e52d109b007793514281565e2c528375c84dc0d6ae407be4d83a19de4f6eb662f028b9a2dd8f7cfb89d72c8e3744db047e30dab12d02a428324444cfb5408f5942958e5ff70ea494e84539acae226028b890f5a6fcc6d890e0093fce11ce8d07f8245614aea09dda74c0dbe4f263d3cebf7eb8400d42b1ec7966813dc06b197e4b2fe0625f5d6de61eff93f5b49f0daadea7bee9ffc491c0d1c22e1f1c58be5cf376c6ca1c809e3ece2d796f7ff5d14a376b1f7f3db19e1c1688b41cbec0124ddc8bb9077c410fe0ca3261ad93f87cc22d9d1cf4b38b7a6a6a64aa31cbe593b9ae8135d28608f4181df6656e4e18438db5176fd739bc914fb28e6f9fe304cb506708f66228ecf16d99aadc0bd1e26fdec972668e35193596dcb1a07f1e00dcbf9f63583f7136052798103d5569304582fe66dec3de629d59a2c3bd38b03b7fecd67b263c1e0130c500598d01e5e1beca172c35e9d36e97e3e846f98004b77b4498b3e74626cf846d96d57e5df49103e1a0277bb05611180fd6c9f812b584714115be5d1dbd328647f0cfb48da00f9cbe1351effa42240c23e0b2c22ac26868b698e1167bb644163cd393592200a9a3cb7336089e5d2ff6eadd104b7273d7285eaf28e67419adff2b2e4f3c6d6acdfed68c9f9b0c20d9cab6c390eae0e4d190300a11ee66926299ef904fda72c8a8d6fa4e20b24b96819ad3b997ca8e416fe4759b1adbf6354842704232a629fe57c5b5eb2566b19e17d45eed62517598c1d3807589b5af2b77d4fa3bfa0b0b1acb462ef7bc302c5483f38a6fc2162887d47f112b57315bee02136130466051a6b6d2c82e8ba0aee025e2c6d7db0cad271c2891c7676424acc0e822cf96a6f7b8871649d394a645f56d13e3d4ceced2b344b22d5b077f2c31af7bce46826e035b994d8215b090bcc04fe0d6c5123a9892232bffdc904023889d370cca6e856f81852cbbc8f7e4ebb0257b2f729e6537b9ec41c5b441fd8ffc48ad5f9bdfe83a4fea375192a7e276cc83b76785cbb7597d81a071161941afc752abeb7d0405a78ca187a785c015870c6529ba7eb37b68f977aa823ead6465656db414e58e47d3c6414d7f0a48173fe5688814b51efe7c2dc311f788cfa0bc21ce1d52565249521faca626e1e41d51dff240a7d9dae550165cda4e5fe58fcc7fcddb61b7ea50f9d33744737031b3e961fcc5fd459c2ee503c27b448fb1bbdefd1e475883b275faa433e980f55d8b3aed0ddeda6915803230c24c9cda1ec3667c2cae9d8cb45d5524341830f8b05450492da148286039859b4e9808c5e4f6b235da349ccb38a0544f80775220f44764dcb51f8a6551e21cf5ea93cee4f6dd7012ec91dc4b500503aeda57a2df891fa5c60e524cbcb3ddfefeb5baa47ae502bb0df6df3fbf5e6112394c02f7e5f6d6f064d1fe76c6a7ce51dd52b1175b18eda28f5c75d71c2fc3764bd8d8e09b76a05c68cb9ac1cd43e5eadcb4bc1ec02297a931870a51c25c8f1175c63edea93bd9bfb5802b287f0ab362b76e4d2b8b26f138c6c2c4133309612bcc8f2a93058075bca5866282be3da04d188c21989f1d4411c75b98a1cc7beafded83afd03c65ed91777dc84fdd62117a809dd9075750631bcdfcd9d7eca7459d556ac8d6a6db4c73e67d55704890e3ed6a66269f66a7d19958b2e3399f996eb2d8adb02c36aebf108c6b7eb9cf77ee4f36d5c8c8eebbb07989cbb6f7986f512d7b621b19736613c9c876ccbc48ca42b56ff5d054bedd100fdccbaeda39646d81252f9b0407fb427d2c1856f0272ffac13f0023ecee08d132fd2c8e9ac7f377ac666f81967dee07f06bf189e02934e4bde838b5e38fb9d602e39618595a8fa4588ed25a2672f4a12a695e15bd8824060a8ce7a3bc0d246bd9c028c9e37ef36565fcfc57dbdc83797c1c618794db780e82a6c29bc3c78071fbfcc19ba0ff78c6999b03d0b759cbd869a142020b8a031105bc7868a6792949f212da01c500d6641a4c30aaedb39929a2136d8705cb1bb959168c923d403d1f3c6568350ec873061388c2bfeb1796c35e3f8d3270ae75a632d5abe6d3150289111c77cd484e85a9acd9f9013d6c4263904d7835e9f48c6bfbf8c4f1c2a69761f7b1774b02fd08e521965c88f5cdd966e7072d2ea64a5f1e1d4cdde565f574005807aaa8f7807e2de92bed89fd871b9d51f1cdd565665d6aee8194f2de4eb034e3f91a13f7b147206e5c79b362dc07fbbc8a0d03dedec54363724f05ec6008e5eeedaa0fce19c9741d8a6f90a95c2f9e147d7803ecfa466489ae17b083a2618e6b2c06852ff00fabfbfed881c65df1d501f6260e6a46097c416a9692fb521a8b1bf8fc58f4403cbbedde9feb40a11e86200819d4c9323ac7c3752b0898fd67f957ea9d1fefdaae53e622e44d22f3e4b0323df9f3b9e35d1ac4ed63bf4844628192a13be26df885db6bc4cc97448714468925648799654b02931822c01191c7441497b050973ff867169aee7ed8295d6c556e82f2bbcf4078c1c5a601aed9209219771ff53f2035b12a03946a706eaaa0b6e76714830a2e6bd7335f603007c0358aa0a65619a61b957903fdf61eb157e3cd60f79a46343e50f00ec833ac060a7378783a19f98a5ac26f894295439f432ae514b33ad95c48acac1a826ecf4c61eb16427a04dfa5ffde663b462f6347c3522ccccde94c129ecf3d761ba822d1ce683d8d5125b1b6fb7e894959a3132877577a63c512cdb918eb2d47a557794482105e9394c0f9bd4abbe118a7840d1527cf083d06fc434557dfbca7d00d1615fac508f250173b94a0717df5e40c4da114b061ae7cb029da463fb153518f9830152f10f8c3f0e5aaf611879895cd6714865b66aac32f8edfe6fad0cd36a84595680e026242a182d51baaed4fb3bf23158890fb74b364f84e59c881b19eddf139c6bcc1a6829794f166d3c8099c46a696dd80e9417c62470bd7e5f4af357efe0382ca7870617eb39828ee9df8edfc6d9f46af78bb8b2f337e2a2081f05bbf4ada259ce37bbc0e89c4776b0c6bf0ca8af3257533b9772b1f7525b2c15ee347b168afa3b568c6b85f9e9edf28c8c7cfe0bed626f582586380d3a6c042e124b767a9333d14254c1042413e3dca27479eae123f6ff14738a1d3f66819751cd7232dda6c5447aaa9c84f4d38d55def786446f955c7297fff6d78f7e62e2d062f5c2a80755d279d8b46b50262f6f5398e11bdc246025b2b64dae928b397f21120960b13ee035c2d4fdcf58b6591c30fd9a047e97511665db7c1f2634baf01cea022baf4d413192b1c09d412f87c7e03a6180cd1ce8cb5e9f8a4d1773075ebe88a85c44ee7afba9847453e7b73781c8949dcc661148a95fb27212a2b7f2b30438f917874932641772a89ab7c78c297bbba93b689a0604dbe2d84f978dea267216485c75cd73f1e3b29ba8738a6a55dddedaa3bb9cafbab51a5341dc879df421243925670fb84f59dde7581408ba427022215b6cbbb30a878eb11b42c82ca00ddeaa19e71742ee7bba6125f8213655d586e05ee13a0f5f28439daafba0e4a001e8da852f27e10cebcc90c98294c08e7628624ca444081fd1f8e370be870e40b5443d036c75b952677c272aded914d41f1b324d14aaaa792352fbdec91d23cd9c5d64123113860b02dd02c446ccdd42aa45687f392e1edf371161755516d910c7dbfe8642f75d6144dc0db221c203a87dea16058bcc9c1ad954a188e7f70c0adb0a37941e31e039f8cc1a38f7bff669c185479bcaefa3f93f242f0fd20e0b9a29e7d6bdb56a00197c5606d78bd2d04dbd4357d0f5c46d61441ffd0e6e7d00a01cc2343e8cb19f5e2421e8c895d0054661e81f6a56a0cafd73f0ecb05943f8f07be1fe017a82ae3cf7f9630f91b0d9790ee4396e9532e47471842e625d0e270bcf33bff1b00f448ff2d1cdaffa79a2273e9efb0b56a4ce435531552ddf6b4f0df07071f9c91ff36258aa7691537ecf1379909d53c969c17a78b1441d93e7d3d0032330affe2feb7ccb2ec21dc9c723b54b6dd2a6bac0d543131a587db399e40fbbf35cb19e1c4978e2fa704ef0d6d3f37b96304af50b52539e6f8226c13ea474612cf71f4d18b27ed34ab83054470dc7870f579f5cb6d6a676e4e66734b6c24db43754d9e530ede5895a2e1fd5b0df4d3b905bb1f149fb088d96bc4ac8bdad4ca97c655ad0a919bccde18c3d223119b8c8977ce07d477af613e179bfe368dc73f27b17ff2797da5f0033731595d11999108988b0bae0600ca76faeb267b1c399e76fe84979d515ae64a673daa0192d0fe889042baadef0721a15e5585356b86a222e8870f0330e35dec916b2321ef2c1f7067bd97368b7e4f49588d852a3f1f8a8276fe742075422181dc5c78d8d016d53566e1fde89e38ea0c9cd91d8ba2f05641090c4230d77b482e9bd1f706b18b257b832890af366a6bc8501a817cf74eceafaad730c41f71fe73443a7b11704e3bdf93ef0ca708604250e97057bb46e55d541d1d28c1d74c34a90f615de2160195f335b48f08b0bedfaf710dce65ca0c9e8349d05c94cae6198bcfe1b80d73cd5af55a2605bb5a1d94ef437a4b20baa929252aea0b472ad1b4bc70fdc4456ad38fda7e8282e6023cd4d7bb868c86f6e3b86332b9a93b81a718d40e070d6b0348865c1237ee9459244014f0fe3675653508959b0df54a1f8dd2ea8683ff9d3788319dbfab988dade4ffc16d2a74afc0e1b0b0c334b5ae4f0725a999d460bb53c29710cb24bfe17dde17d0e307a3a7ceab9d0e17ee75b2bac7ef2354cde40c69386cbc60186a564e654de3e417ba796e4d16b0fdde2f0b8ea2b2c82ffdda029cce444549d8d702ad5f93be277d027c448033e6449dd115d848d1b77fee1305c2f712b323de61c8ee6fcc561547f6824e2026535668934cfcb08472c0d0be5da84db2d7a8da9b2a1f9b9c69892ee86b0201c0c68b7b2d23b446a910bf819fd2dabe9682ecfd93b5c2d1ba452e121743af1ab0ca3573cc6cd62bcf22813bf0974ebe32ca08d44b12639a621837dba92e7053fecdd496c744c6e06c9ff601b418178989709e42ba098b3cce1e5fa855d5657ba2b9a49bf07b76b39e7e88874a80337ef5fad78a45c45479747d0a3696e78e0754cc25a5ce21166a7dd42c345f3856bf1ad6cd48258d8c94520ea0acda5e633dc3e704a112dc9954f212145ba0bb932fcce7d38153cc2279390ebe6ebcd1f34497c79102c80e4b9fc79a98cea250ce7b3ad8d671a8e32b3a1d553d3a2c37e672407d35551fcdca91cb1381666f2a22861e3ed1f3ffe28dc4d90609087630cfa00a271c09642cc1886dbd73c73a6beb98f896bdd9f67e9ef0ad17ff9171ec7c991663207d41295964e60ad6ec6485733cb8556d31f5a87173f195e6b33e5f57ba1a20d62408906c6e4d45dd7f00b17bddb938e11b2c0ec7fbc23516fbd2810f648825f2bf4f7957c0dd9f88503c01048fcf4b4ba19c521bb2636166986ce24c2e3dcd0492c9d197272f00e422bb06a7166be7ab9dd6567e1674878b225e4bd66c017a568c7ca95cfb89c93c43e3e761c9468f5fd985581f6a928fecb47ae983020f15be98cbad4ac8b31fb4602a83ea565240cfc9aab9c57d81f93187aa9ad2a218d65fd7561ae6ed5163f29e3f237bcba52facda7d0dffe001ae814c5c002134abffb620a4fd26b987e25362d7bdc2c2e4a14a47ed3ecfdc350fd1b44fb9f68a84eeb7dfd64674ac4788ae1c59f594ba3dfeb39287727fbf80ba5e6eef836baa07be4bf0fccb19ad6a5a7096a8c8fdc9dd61ec7e4b7a9b9fccf64ef4c0f6ae3cf43ccd6c5d6af633847cee3120302b3193561633c9936af18014058cef422c71dea86986951242ffafb3a2cc06360c265bd38b8e6226b091cc3160dcfd10b5bca19dac074a083e80b76105f2e5a368802261509fa8dd7fb80b163ef7791c10e32d73c4be881604dca88d8df52b5a604cc4ccb079d5101e7cdfafeb3ba9b654311cdd366fc0233bf83cf744d3de61f4ba7d38cc7fa81f23ce8cac754413feb3a9295c35327569c62c2a99de1d14f722337b75e9306daa09ed7038be40a309ee342948ced8a40aeca25a876760bd5c00540bb228b10a509ed5b5891b4940ea4e1e69134b7b8a843d7d20ba0efc841450c9965977e178e515a39fc4b81399a0cb7bccaff6f49888ebc3b0643e10d2fe2cb6d15f4d0c55eacf942ed4dba35a5e63dd65be4a40217dfdfa37f8f61a87b15bb2414a79f92bfdf03d5625cf5ed8e9c6453a569822c03073d49fd670d05f0f6c7218a2527d47bb683c6b9f45c0ad881396b76933b9f665682f1e66b58a5fec91317eb7b2b011af7089d2d324569d76377e34d03257aafb01ad6d0c7bb616c0d4449c4cb99a046b22258bbf8c0a07cbebaf59f2ab5aacc819a42df56b0f049ea2f83614a5cede072bfc19ef97fbf722b25c718bafbd75e38cf2bcb783262f409045642da170830eed5487e4197495111fbdc5ee77032c91a601729292e27f8de39ad71abc510a53a48782071ba7e21895254449144b0845fec5cbee2d94ff38b0f457f0b95d8d21f9d214787e8084de7eb24e290391107d3e949bb794810bd22dbcc8ad2e0a7ae955638a4e1b5d9332c2531191090d9644aad677a687f7f0b5267c93c948d8415f10d54e5b075816b93c3ef94b3045eb90243e9a68336a57d32edf2a379f405487264e916f4f52c9c09e2e58a89e9e876b6d1440474a5d8f40f93d64a2158c5fafb2d139724766b55da44c40cd35c1c5244ef0a36201da65911f1977a4adb8505f25546284fd5f7ddf44d2cecba730e0178de9c4d0dd43b69f0d01f17dd0e51cdfcc0ddcc0244e37ca3f21c183f96c9b0065ecc63a9bae4d586fac69f1dd6d09cb4a6c571611665e3f3e3f350f3cbd5e8b736092595e937fe8141b365c73a6fdd88d71da45e2e6b9b3146bc5dca3296b224df2a4775d168f38b77abe60b0ebe06a257f6b9b67842c318fb95c778bd3796998f00890a94146073a74e97605238181fe67dc5f39a0048707af1c7dd5c8a65f25558bb300490952bc1c37a72b652111e049f801d9460c78a785d994814a011d40d32984b06841e6077bb1f0094b1c88b172f0a9ce0faa2e3e796bf55d0f26d6b32dcf0d25426e0d739fbecdf33ccd29156ee5d8a78eb66b156d1bd414dddf1099d59a17b5b042f6d8ebf2df42b81d2d268e81b62d1b3d2ad1b258617c9f221138e040796f2e82ca51002a18e04c7879d039d47d4c56787f0cbe13f745864e1c010068dd6c799a98baaba04160bc0fb968aef2127950fe16b305234e80cf105e7331583a960a939e80eeea305ab166403c9f5c849fdd611dfaf8896acc2bece72998ccfed5babae01955ed339024c0be6638650ad58d5452fdc241f0dd1988009dc958ef40a762667238f2b10500e03098c48d715515343929a752ce95fe99f330fa0270cb72221dc3630a30c19c1eade2fe739bf2b4f02427f413c0df8fd8ddb211374fd73ea15a11b693aaf9185698a73adf585869507aeb2d710dcd009c61d3e33c29e45471dc4a442535800eeefbe4ace230363812720bbffb140023531ea920698ab433ed6ce933053ee58f2830480c2578a2e6f52454e6a55206bc22e7a1691d8058642f5120efa88b119c8788c08f576320b2190f157550e7c9a38dc85db20391219121eaea646178963c80a3a14ac3607104bc9df6ea8f217d26fce5840ee5a78baf84c2a24d309ca773efda78b35d92ca31003f96dc937988c09f1c141436a41a0ac306e3281d2bedaf2b0864cd8d1cbdd25d89676d1a2bd72f2c1be66387bd53801beb8a78c2b38bc5f8c0dbc40784267cb4a156321612b7e272a2c017350eddce21ab2df996f022fc2c4beb6e2965e564413c3e07c7cc59cc822d409d027e6d5af95082c0aea226925549e6021f3be3607cb8bcda7dc7bab4cf248d532403169e7fb3436b4242ce76228803431317cc99d2abf8a6b5c55972f562b5abeab4a441b78a55c9409bfa5b8a16c15e575704c5ce0bad9356de037f31dcda14c2d759ac3f223b8d0080fe319bf7a64a71054ec0438b88046000c43a3fe38c7341edd6900f80991a67229cc4b3b9a497b22cf4a714562a178c19394498592a594e91785d5511e3f943fedb75d435792f8a17c27a7e52993d3b56d7a4219f096db8964a434850a43c07dae8d2ee9c752edcad6ab7af5b23fbca6f6e5e191e9c1ea460e7f11e30a4813493043bbd16b0e8beaa080cab74368121f3b3387ce9b5dd7171ed279805f0af09019caac5105d49bea6f84a804bdabb9d6d719f6843cf68ed5f249d834f3ab4131f36f2e4f3a459d71fbc0d87eabf59cea2d425091404298b89eddc25eb84c79763f61777f814afb75fbb8c5e3924ab9777742b20b6d14e91dd193cd46d718678f8a1b72812cf9fb1d327afd2431863353a208a2910786493468cf48cf70022c41291c07ff785aad8bedb061b066ea2bbfccc26e8309d364ce8552767b4d3a167088c9b9cd316c910ae5655e9c9163a865a598b964d4b54f05395710b99cb958c9c9f84749b03db9610092d71e161e313ceff794f9c85822c1495c94fabb83caa1fab1f634afef18551379fb63acf80da39ade73d0f281cedc11776c5c62a9f6247d449e4190b977e04231828187915f4d743e748aaccbd1d485a127cce411088eed2692afa040f442e2773b086d0dd1a4298976259b54914c1849c6a813f8e32d9fd19c90ffcadff6a2cde97ebac1d4dab468b07660d5b30f8c37e2dcc6db49f6d2e5333227056832ffc761cc22a81156294e18af05c606709c71f2615305939621905f763a81843b5156e79184896acc70f73a27e32654f1a0cd23b9b0e1f151204488a15bb5796e9a8cc1c0e190b83ae7fc9961630e3780ab90715c8d434446bd0b2aa59d6329f56e1f3ca1622aeedd181a54bda768b5d35fdb86112a9e1c4814cf97930d25817352ad982080f0a81a0d8c3b34d4af054c3f1a69a4978224dda84e85357cc5c6804c8507b6fbad6a3e6e2ca25a97144b75451a16e8f007ca9918612c5bcb4466dde2af3b7bb908cb3e26965539a70402ac097a7255b9a8989051136ac7b2dd938fb6c9f51b4eabc33e809032ddfecc5b0dcd968b2a954c5eb456c83a6be1694477f3e90cf735d72a751e77d183cac7679247e8be594c982688342b182270e0b0c7f60b55dcfeee1454c219e090a1b3dcb964cb198a65e7a02da83347707601018605e369aeea5c45e7d5961837ba1e08e6084060f445ae068f645396b941d1f86e2200973932f20beb0a290d0b43ae154c666ff9515faac54404921aff91231bbebcabb59642fd9456d6e65bf957a46224414a20942ec2dc4e5c0a5fb6d9bc422cba849e38ff20a7a7b06e9de70d172f2f38f3be7998e94b511e29c0d2157770cec6b45acf0cbba1dbe133967c4232218c9f9fc5da7583f7a8a088b727c8645b93d22032e8e8b8a436d033d95401dc07e0cbb04402886b073c63ee7b1a735b524b020667496e0abcced0f6f87c60cef785f9c550c70e3ae20ca862606546380e2d8684a194140bb575f47ebf2f940322ed959dc320d68ed484a224a42b0b620b31fd5d3ea3550683e22b23adb63ab62c11c3e1faa6ee40b0e3241e55a36d53020522419f52c1b897d67e6673cb6ba250bd092849751efcd8f6602cbdf9cb03ecdcc86beaa7fc9657c05525b32768d78cb0a2c0c56717f4e1c0d38b37e43fdec0017edc835d9482d1cfe148d1930977f18adf6fdcae80e68979c64a8a4f7af69b56e69d81a9dcae2bc3f6138ec07621e609cbe32f6c34c72d4ce54fda631371a3764a74281381831b691f331c32cf2ceefee54e83388a760b4cd2e0faf03570db1f7de0238366ae6a43a91ec75f2d5a421c62d11074c16861ceccc14d560b6bf579ff55d9e873cc8c746b1b7f9ede25afa7e2352fb04f237f1775cd1c6efd02c8b42dd3ffcb85f112af774b4acfed7e6f61c868737c19e820def50fca7f599cc2f95613f7144803ac0418681137ab99ef046416fd675dfce5b44b585938d5a1f893538dc99b7dc1a22a72b97d',
        salt = '3f97d2a0b338feadcbc1986bcaefa2e8',
        labelError = 'Bad password!',
        isRememberEnabled = false,
        rememberDurationInDays = 0; // 0 means forever

    // constants
    const rememberPassphraseKey = 'staticrypt_passphrase',
        rememberExpirationKey = 'staticrypt_expiration';

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param  hashedPassphrase
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassphrase) {
        const result = await decode(encryptedMsg, hashedPassphrase, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        document.write(plainHTML);
        document.close();
        return true;
    }

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        localStorage.removeItem(rememberPassphraseKey);
        localStorage.removeItem(rememberExpirationKey);
    }

    /**
     * Clear storage if we are logging out
     *
     * @returns  - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        if (!isRememberEnabled) {
            return false;
        }

        // show the remember me checkbox
        document.getElementById('staticrypt-remember-label').classList.remove('hidden');

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassphrase = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassphrase) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPassphraseQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPassphraseFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassphrase = hashedPassphraseFragment || hashedPassphraseQuery;

        if (hashedPassphrase) {
            return decryptAndReplaceHtml(hashedPassphrase);
        }

        return false;
    }

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        let hasDecrypted = await decryptOnLoadFromUrl();

        if (!hasDecrypted) {
            hasDecrypted = await decryptOnLoadFromRememberMe();
        }

        // if we didn't decrypt anything, show the password prompt. Otherwise the content has already been replaced, no
        // need to do anything
        if (!hasDecrypted) {
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const passphrase = document.getElementById('staticrypt-password').value,
            shouldRememberPassphrase = document.getElementById('staticrypt-remember').checked;

        // decrypt and replace the whole page
        const hashedPassphrase = await cryptoEngine.hashPassphrase(passphrase, salt);
        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

        if (isDecryptionSuccessful) {
            // remember the hashedPassphrase and set its expiration if necessary
            if (isRememberEnabled && shouldRememberPassphrase) {
                window.localStorage.setItem(rememberPassphraseKey, hashedPassphrase);

                // set the expiration if the duration isn't 0 (meaning no expiration)
                if (rememberDurationInDays > 0) {
                    window.localStorage.setItem(
                        rememberExpirationKey,
                        (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                    );
                }
            }
        } else {
            alert(labelError);
        }
    });
</script>
</body>
</html>
