<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #4CAF50;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #43A047;
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #76b852; /* fallback for old browsers */
            background: -webkit-linear-gradient(right, #76b852, #8DC26F);
            background: -moz-linear-gradient(right, #76b852, #8DC26F);
            background: -o-linear-gradient(right, #76b852, #8DC26F);
            background: linear-gradient(to left, #76b852, #8DC26F);
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>




<script>
    // do not remove this comment, it is used to detect the version of the script
    // STATICRYPT_VERSION: async

    const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 *
 * Mirrors the API of CryptoJS.enc.Hex
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassphrase) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassphrase
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassphrase) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassphrase(passphrase, salt) {
    // we hash the passphrase in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassphrase = await hashLegacyRound(passphrase, salt);

    hashedPassphrase = await hashSecondRound(hashedPassphrase, salt);

    return hashThirdRound(hashedPassphrase, salt);
}
exports.hashPassphrase = hashPassphrase;

/**
 * This hashes the passphrase with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(passphrase, salt) {
    return pbkdf2(passphrase, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(passphrase, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(passphrase),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassphrase, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
    const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassphrase = await cryptoEngine.hashPassphrase(password, salt);


    const encrypted = await cryptoEngine.encrypt(msg, hashedPassphrase);
    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassphrase, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassphrase
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassphrase
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassphrase,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassphrase = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassphrase, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassphrase = originalPassphrase || hashedPassphrase;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassphrase = await cryptoEngine.hashThirdRound(originalPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassphrase = await cryptoEngine.hashSecondRound(originalPassphrase, salt);
        updatedHashedPassphrase = await cryptoEngine.hashThirdRound(updatedHashedPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassphrase),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
    const decode = codec.init(cryptoEngine).decode;

    // variables to be filled when generating the file
    const encryptedMsg = 'df2ee782b572bce47ae61f112b6ceba10ac55ce4c92cbe0ebfff134528c271e699071ce97d43e368e37220d763ed0404d4b6710167cedb9eb00ab76fab44698c879960a7dc75c29e16650025ccea84515772a7d4fb46796e45fd7a6474d184720717b09e32f50199724893601d9549501a5c7baad797dc58b2e634cb4d43779674649d26f8235f5abfc63737334f09e4405337a8e0697b358d0282b26a9dff83d6a5f6a54d2154f8dde0c01ea65ddcaed0b2f10ba5634004cbbf4e0d55e9236f08e6cd1b969111c93f1eb30d33ed3b9a236c10868f862929cf819aae68b30f886ab36f0e8b0469b279ac7fd60ef7cc70c93952e76a982c872c128abda20e6f5cebb1b0e5b23d332d1e51ace02e26200f82e8f385049a9b57cd4f49e8bff4f8151d43d3de7fe36b60c23bf3191e3b7ffbafdb83e3fb1b5cd6ae4624af9502cb1e7e3dc0c817d26fe03f493ed73effdbdd468814dda599d675bf59289645d000dd6049258faeb6783ce79197a793c9cc675ec243bc6b553144849414652e906b2b56f9ee80c9e642975ec3eb89b49b04095cf3a9b9a9dc19aab6acf9dfdbcc3240580c46e1ed4fa69488399978d53d0db887def87415c28ae5ec1c41b99b93455e3fd68f5c338dd25a017e474856588dc8bcce1427831d65bf6c412451f815ee337ce3c40e83479925e271a9d913530b974c496fdc1b313997dcea7cfa31cd26f819c4f25b4ab8047a2c9f62b4eddc3e69d847ef0125f7e8bb50914994b621e9c9bb8c1938677e06f50740e110f0a796ceda49bb23215cddfbcf293e0790c7b8529d7c7660864a47abc28a2eb672d0cf083f07daba6f298e76fe473ab74ec9720518b3bfe84ab7e0007386771b550bac8b1cb0fe31a582bff2b2136b0a77deaf549c3fc2d21da54c972815cf2d899929ed9061c01b81fa5456073e97724044b22f03ea3a5ea810e700f1e596fad87ffc588595c153b3761e3b35780a7121d5891ebaf91eabaeb57bd893b42b62a872dcf73f8266f651720eba943d3de84b90efbdbc24835f826ac8dde53ef8d028dfb9bc689e7a42740221825c45cfd57cb018252164d702a61a8b569289efaea0f368be13d9f39ea442d4caca1d38dbc58b162834ad58e7b8182450b66cc8db7fb92cdcb8e5387a180561a46a7dce03432ac1f6b5cf9ceef0d6825fbf92a5f1dc2b421b57eeddc11660826224d9170e942f58980e59c50158fded4120fc85a3e6892e830ea308f9b0cf168b02e4e0369d0b495ce2ab5894ecae13c838bfadf59ac462441095fccd014be51ff738ab05c05a5e66d02d99934f7b88696df2d93f03e1e0f0e577b1a18fc5276a91b229c9cf53d807f51f5b22ec49f7f8d762dc70bf2345b3a90ac5762e414ec536dd64f5d850946bc1e1cfc0029a211df6f3cf5f864fc7d8a39c1b99ad4ba610771cb077fda28762d90fcaee5f0e2757204e2cdf229796e81895302a972d33a72c56654e0e0097d5dfbfdec4968d044ecc921ebc08548452a64decb1f64985223c3969bd2364b814ab4a003bf8ec2db804399f52dcd031d124b36ed35d6994b55170d808e7c51c6d4e61d537d143c8507fa1bf61f93dfe069da4bb68ef3feb887f54b838717a05d8b31f39dc1d3a9e1e5098bd8450d68b91fdade8f0bd2de68daf969e50e97526d37b234b1d8c451ebc7331c3e361f526c138718d478e7ecf3be6be53d4e1cd3436f2c2fd5f783e0919f43307b237143e93ff17151c59c0ac515708d07ab86a7bc6ed445b8bb20e3b1bb76b3c912404439ee6ca894b765364087d945d2c26afcb14e7a867ee40a9449738592c64e11e2e8a34750d988520b5618cefb2591144103633cef782d7a8f685484eb6bce6c832512a68ff769a4575b3dcec6ed35121d47f56aaff92cf376d8bcb813c0788eeea3c465e9a4322438f6b856795b7a04ce4caff7f1f8b694d6c781553697c7e04e243786e106e09d03cccd3daabb89f12b40bbae455aab01ef5964e960d1fd3ec77eac74226155f762b07954babeb7309a8f8a1d4f938b5fb1b11a7971808d9020444bf7e3c05da33d3a6d8c88e60d8504d3c07735cdc40646ae4f260b73ffe76589e1e4d8303d9c78c7214527c40a6ca0522787aaaa714c6c7ed68428f90e54003f769a9a1ef4bd655daa3cfeb4bc1650b5d639f3e7bf253d12cb4127f813eaec42df28351f0ecf20c21554ef3558742f5a8238e11ffd4fd8813828f9bd297ca38ddba5896b7f28e6b2ab20616abd92d45ef7597618106a814f2dceda452fc4f2c8ee214bfa2e46217c22cee49ba04c4c90b4e76ab1acd37bbcac93824430909b562b757326f2458f64d5b38f5dd0d74c1034f9fdb255a2be316d2956a78d25909d8e000abd1b116b89bb38f669ba48599621b0c552fd3b4b3610a8050abf8224821d5e9ab3223a816f7a9f2f7a0617048ccf243f33a23ac3378a7a1bbb92d8d943542311e02bc18317dfdfde619fe51c32797e2562411b29e4a36c86582ea42cdb5a7afd15db4314e1e58fe21a92a4430eed4eb82c90649ebf1314bf59cc5436b2a034db58849cca166f192111fd1a3ad335dff0537f2d5e4059aae18f3b1fb4914414e588a1416771e42407f884a435e57ffebb61786ae31cd3de30d062ae19831cee41afd7bc4adaebfbdfe88ad170d94ecdf744026bc2006deca04f47fde3f0c84364626ae9db1c62ceab0c248b0ed559847eeb56020e3a488e20491efde3643c80be3e8f6e77d149b9d21760ff6dde19e8078e42f4075c010ea623eeec49227da4a9d0f2206c6ee59438e47d0395083c23e8bde34da9d104edff0223ef5e35200260e1a9f1a5018103a006532719b4be2a853dcdb7e61e90a3e0e590b15f09706f08314a24f6ac898d7bf6eca0b87369e65de52036099018f658d8349642c0cf732645e197c294d2751b6f360f9e725f7d66e515f509886bd0925ffa0439cfb40db3963c035cd68e8fe00c426de433efa8338b0db42d839051aaf3479e36ebbde4ef348ca3a33f9796769ca6f800fcba11e8bb05c2f486859ea82bdb9c089f9d4336291823a9b24ac46e783d38749453d347a19506cd9bfde0ab7443b4972fd98f987276f652bb4704178c16dbab144f9f098b4915338bc4610dab7ac874db39e889e4dd59969667a63a64f4848e704f362e94e2b31ecf750a8484a678dcb5f23c21d23a9ced902b047a2cbdc7b5081d740ef9c01babec4127179a78c3f53f790e43afa16da569d6c88144c80d3f623664c8aaf5c3b69cf274003c8d22a916141223ca0b59c9b0b5b8574fc2a77a490c016f89bbc75638f4c3b8f92afc541742459f0e1dd04185068ff4fc6904fb825f6209a847d66bca0bc5f8e1c6a1acc5a2f4d715d188843ea3674707daa4aeb08297376012e2ce0d2e81ea5454025185733e7fdcad04f69bf00da1e28b78874f0f720ef37e5ff560df2ec58050e94496695c948cec8bd54951eb08d85d23e920545c0fc086489d9c14572b4d9e0f526aeb9e8372805520f76726aaa269b795f737f158e15868dfb31dd4ce2c10ef4385ff912fcf954d007a686f95d747927c34a49247307dcdc5806684a4761ba371977bcdac305d7072763f6c31463f47907168cb43651c2b0f7513e4c70b653a359f8232937273b05eb352813a07cc71624b1fa9100bff561ed8e78bc5f4adab08a2c872e8388d4e21a94dcbd3afbe40b0621f10eebd334c4033c6327a44f07b85136b6aabeb517950a0c1891292345834b24cff8a1f0e362d849312e380f39d15f7c178cc10520994397de8b821fa555a69b2046a012998b002316e49ca96a513f457ff8e0115fe41c731418c283eceeae083c8e9d04ea9724c275c60b95e8cda4b498d079f2780ed250152f8cfb433b50ccaa85c7359adf02d95991d0a9b1fa2bce93a85109c86d9cef8724b6e32fba492be2e79d608d7d0aeb193f51849382719b554d20f6d13ad741564972cbe06a4e150311f215d8ddcf80666b04d3cc97f39c622f2307403a2c04d8c73edf0769ec8b5a3669eb82b2894761a727d60dbfd3aa78f6a29f47a71930467c5770b99366b81ea2a3f9236e7873d8ecfc9802e4ec2ad6aa74b6a8821b5cec7668fa3ec063af647427770285360a87040abebf1a55807f34911e82a2960e3aec72fc659e49c382f15156d89a1de63300814a0f6a965b8e238490ff123d6d069429037b3fa2f81417e6c5f3f8ab1aa7d29c8d2cc6603c7df9721994559b98fc4b52dd28fb0e6ce521dac2c475c8d24aaa3c723c749e075539ca608f3a0cd29d74c6a5ec5f6236b6ecc6b224d430fdbff324bca339e8fa2d2c807857f3435e523b8333ae614f49e26c4aa0d91776e3e99252d3819bd00a204e2a44cded551040e4d3e444e8eb59d26bceb9d055e6647e443c64ca03f86c4b1ea361a4adeb699b8b24fdb3f1389360b4f1d40a5828441a11a78537f7ecba611056b309c2f8e1e7c638300480744f4982ab6912cfbee6c6f54fc5d25dc1ddd66e4d92a6fc068e6faf3fd2e2ac9c8d3322c6767c3f311975d7c9d0848ce536ec2a0f2f83979f40027fa46feb3995c7aa67001391b5ec694c3ddcf464e4881ff7d963af9d6a96ba44ca4fc43807c6a324b1be53d3f3080d36f134cc1f820adbcb2cf1ebac51e4c18f1dfe4ed26f0cb692862b8bd7ed5181156fb64bcc47fc48367d82084499de159952f6ff82ef548abbd33339efb5a183e6aa976eae5e41518e76280ff387c33ee07f096b0a336e343253f4d76dfb0e0512f5fbbf691e628f6538502002ccffba229133f1ca77f1e62a595220d80d5206a2757fe876709a19f4ceae56b3375e475e5290c6cb8718c8684c1fa510cc76a58ba2a145af45643a0ded6f4f2cb6289fc1d78f46ab3b4f9823a83d77905fd1616af7bf051f716ce1c8f1ad04b14774d130dd8a04e3957d8c4fd929a6da65768f1f07373ebd03621578f47931a47e7f6595133553ea8747c185e2fda502601fc489f5c9566c7208c5dbf549dc6d4a21c36a1e09920d15870679bf78d10d973ee89ac42d92606c85d4409f728946863dd269512b0c4292e6a3c8b164ab81477e36dce4b5bdf05191cef3e8550c17299fa9ac12739a32803213b74ca30e0b504ad4d8502049c85d6c881b0a244a318a1bfc1ad9cc181a2bb6e9a06ba23e93f1ded9a5f5cdbf4860599fc039630e9b9121d006e03ca5fb0379183cc8d557ea60240546ec0f1ac4663eba2df69027c8878693fa22c91d98ca4502753bdf411a96fc8dc9d5020a72832c96c7fbc1e8c74abda0968cd57b8a28181b62bbbca2f080a8b513313e82a6c16e64cd0f037b97b2279372de00db1f153f5ec419620f8fc88e352654a0f9e78182b68ee47deb90c39e7f7544257b1cf9325e855a91c6e626bc2041e94b429cfe4ce892493d8fa7be7f3cd08608437852ce35051a05df2c1f3dde62d1f40aa08206ba123437f271162ea71b15cdd06c7a5f1cc3fb8b1f8f6f3c8714104518f165b4148a1bb30fe1880261ce2a6471880a4a0a65e5353991324987799a2da1e0c2f128d6127824dc417180be853c1be05241fe62738dc65110195870af487c0802f7cbc87a1b48b9a374c56ed0e9e59f8c2870a0e14d82dc064d8c4deadba3b3d286d14997ce0d187081df5eb87c4c4bda8e5d493aefddb1be2293bb2dbce85a86c7cac560ece7027ad376742462d5fc5a60cc34d40ab0f18e212ce72780a782ee2d82ae31d8ee5972d24a00761bcd44a70b0e5d79735e9ae8f879a02e8454ef8440dec9d1adf696f09fe3a87b654363aea68c2c936cd9b7918e24cac1ec157f8154a460d7bf62604a87a74fe39502be82cca57b76450b35c3c02aadea13b6b5f499af2ba3243b51c441b50747fef8c63cce65f7125e80283c71c33a736859e1e1d1ad35cc87d496403ba8a0f0988014f4abf0a26a3b870c29d7b6df050e8a8c68bb807435943cd93c31c7a27a2f0d6d80d94cc1f2a10205ed201b71cad63d92a213acc92c905fbd168fa7641af5875cde54008bb6650f4683823b6674e2bc235325c9a22bc7cd5014629fad8a655cce07bc9d520678269516b23c929d80864312d91e1228e282204c07895a7f02a324e888d5a0d185513a647fd6ee882ecc1721af3474dd587f4ae5de26e0b8c853c222dcee769148cca6fa36581e6249c491bd182655ab9dfe7e54dc60b7f9bd40309a4267b77085ee64e6bf0a6a805ef5ef4267edb8d3896498e8e741d6ca16702bc1cc2c2707f9b3e2f3758e2f8e7eac2c7e945e755ee7d2939bb904000c016257344d68773013077cef5e996201a6ef07053c4355abf7f4204afca48d24984c1273122b2af056ff9e540520cf210ae4dc5151e4be77402278a8a01008addac4f549f24622dec885cd1f61c7852c9125887d3d90046827f8433e4a9c3bcded49c8d378cc7db8a31c0005c837975123024de6021ca0f10a59578858d4fc2fdb81351f3804c9f47eca27130b55b78b3e63363acd5097de8cd3ef32ec7b3a464772135fdc4ec13c26903c473c5ed12da16ec0677b828e95c4f759374269e0aad905d69abe43c80cceef9cba2595dc61d266677665ac58e42956102fa9e33133d34868202892b8ddaee9609a622f62d98d584836d07047cde160cd5b2227b7fca3eea90fb4bfacd4eaaae78573365d9e9bb6a447426dc79eb3a777712cc102b332fea5e392fe8cbea109279dae9dffccaaa2483c5538d2d37f9a42d19f7e4fca55b2867e647ce447bf5218559a4cfe08307e35f997747ea7f53ff0d2dc3089cc7c7993e4b1dec3adaa2a53b1645bc645b1b4ada662f9b169447fd1457293759a2bd6ac905cd8ea2c4b24f3c743f6398ceeceae0e565c79fa22c44ea41ee6cb73fae511ca12ca6c91b61534f7b51cb16668c4c5bcf9db2f8ae0e93a5ee9130305f4a88413ddd5fd4bba472435a8076af0a32cf74896ae4522d3ad412022bc2528b27957d0f72d24a109f9587b60c4a3cd51b8e951ab8ebb83da9cd2165b980d1ee976a35c8e5c0d09540979c0dd859b95439d9a87e6487cdcdc75d44bac2a7fa05e81250c816e03a49e29ec0dd3186b8090455235a0a6c46c4f1430845ac52b0909574b046ec154d85384ed8e01f8208195ce782b174c49d2deca80f0a1b9f8a151c41cd7fe728c867edba7a494e24f31c5d94497500d0930ad78433c16e07b36f561ee81512b7d0f840baa54ce7e960e1d7858bdec3187c0f408f6c5fb3f59352459a828dca90d8922776cd2f7620a217e3407076a44b9b5e6e269a888635adc4c6025c410fedc4e1df03b982a8412970bc272b4f58b6145850c6f391fe5ea7a6c100af61d44a702a02cfb6dfc2e84e13cb92badb2ce81cfa416fd90328735625c3dec2092203e4722228ce5336c07321b8f7bc55b98d2557162ddba0e71a98e3ee673cca91a67c918fd240780fbb5279040bdd59ea6ae60561fa143e964f7b58bdc50394187b5a0fc25486674142a06772762d5ea54396d99d1e3846caca9c0202a6524a8b5190b8fe24e05cd4848a0a48b9f77a7de66e805de8e1f96a39f22394caddd1dc480fe6684f526394e791b9799c0c8e862d2720b70b53bb9d0bee00763058e0692d8fe8eebd6b41075ae6ddcbd1b8e666c28a555ac680d131ff45200f89ee7ea15beb2e9ec3ddfa447a4de91e0e80546a89a784a3094bf4b24176246ffc55a0c1acc0b2953928a236ac41d8f43b1e1dff188e375795704aa28dbda9c52f31f095efc0dcb3afcd227ab85b49e9906abba5ec194d013ccd5cd40754739f84e05edb9378344b213117b52cdc815cf9347cce5889f92c47b2de729eaf787a792d5b66c3af15643d16eaf9c2716e3e920e7eb7e8c643684e371ec2e8f64a1039ff2147bca2debc02039756d1f9dcf053443ccdf4252a4bb8c345881a9096dd32e1f72021355e46b4822aceaad53719e6b4a55a01f3bde3a73cbb9c043f8115a4178786253851f852913cd0c48bfc46e8c745faa28f3d87d36a95b69838059c340e6106925dccf431dadbcc5f433aad353c89ee9c8d4f6720c65e96deb92509d03d1841e0c81295b9ed2d7fafba7d39f5bfa7808bec9d92b5460926772f50ab418857fdf195232ef1384958eed27acc6246fcf8fb264cb94f531d9df1f1505ccb9ba064998527a38fa65ac0b130d5498dfebb1cbdbe48160664ae7d9c084d4501c986ceba33efb437d104b2b29cb29436a681fb6a605a616f23f060505ec9663b11ef8f90ea3aabbfeb6800a5de00a43079f860ccfbf309bdd266ffe3bf46e0e640ef406b8fcd586038240a21d3599ab824191ab0e5df8d0327dc93d5cce5cd1f4ba8512afe491fc57c438aa334796f94a1a2c1487378081a3161634675b66b75a3276ca592f7103ec31eb0eb730f6f66a5c644a87ad83511cc3791e3087dfd7f660a6f81e53e421568655410ae4ad51a17829fcf88e1cec7da77c900789fbe4cd8f4f083bcee37bdb8b7b83e65690503ee5f954a1f6be076aa7cfe6e45c1f48406418a85998b66e6ceb4a14977dded293ad411e4e663f2574ec539adcb3edabbae0084b7c568ef4336964c4f97b42550fce42b687e1d3a8ca356110c702539efa966e162cd8d4f247110252cf2798da04597f5e4c265f92517ab83d93c1086e92d54ebb1fa571aac529a6927fe326a7af896d687c07447f0abc249d039eb2291e80884e8c4fb27be3027b825784aa2cd0365a489b4433d1460df287e93b5bb01ed101f2b013148891b1b7690a0df37830860e2844178be4d57871f2a2253bb4e8957d6dff94e3a2a6014896e24ce93189aae2eaaa8e89911aab7b6488cfa5a3ca94e5021adba8558256a2ea3972b5168adf732a431e46f11f491570194927bd551e76fc0efa64f79e413db88445641d9ae2acd5943e6f1f67940daf3e737d71f338bbf13d6ae93e6a3a376c42a1acb08f88cee2fa8c0a303a37ff5af7f3663546fb78854efbb7270a1769ae15487cb5b010d2424c3b5877e3f1210f39dd92fd6ffb1cd3efb0b5055e2a74d774044d9d37c42f63b8798e9cccb833dfe270e32418fd8aba2fb02f70a2e4e14ac22cf0e58f01ee236bd006afdedf98ecadcdc4438414b9fc1dada6f4ab4967274ad7df0cb7f82200938bd9068d082a3bc00a2da05454aafe7412a4e73500a0fe189cd0e23cb501690996cac22aa36cd5cbecd45848966940a59a918015c120bf79caffd55ca934236483e99d4c653e8eb93a700ad11aa8a01a2c783f425afe54674c32f3ceeb868ff706ecf92c4335a8e4b89a7d730bb674099f6366ba9574c466a31c4bcf6ec02539bd6f03309c8136b5cded4c9805630025593919a4cfecb6600e897a582651f35d9b78943cd5ee26108aa9936f0037fb7c72a0a8da29aa4ee844a0121bef64de3c53b6ca0d43ca69b0e6f16992bd0a99c5667bd36d8810b9ba0be549c4e58c9dc2542278bbd537aef2c58fca4610d9760bd66824bb48112f4163c1c69c68d830fa5b5ddcc57b78ac413e8019cc9543c1520afa170f020c58f3bee328c3cbbf48c0e7994657e11d71a179ea186de452a78a021652958f311eec298f62b6c2f14c44e9c5cbbfd21111ddc6b682e6e6171d6c1b963bb2e61d455c8f7989537eac576de8becec8ed4e20054da4171dbab9dbd616fa30b80626f25076fd460c7c45c40c9d86daa0cc476121b2320c4abe3ec3525fc7dfd546fcc0ffeddc7956c5a04acda91846a7c16f0393337fbcf795d0304e24918111d6f6af2fd8b512c89e31b23c4aec3a537e559719119d3ce32569e962fadb9feca54044873963e0af5325280279c5c42e38b2ce95958309e770564cd26a38a2435e55d20ac00b0c8c8e89729d4763dd6c92213dc5c4cd41983b2c803a007f8678cd8ab4abf8a6ca2a9081b2efdb4df65dff979171de5ca29a2c80868a2d5e1f3fd4d9a16552572187480c6935e2eff80c7909922e0a6e603f9ae29f9df5c2abd78a5dfd5025b75fbd7d579200bf422098aae1e2173d5893c054b350059c8164c8629a682c96193d56761ecbf6d567065fe1b29aca3980e558f64d2c33f0b5a89f009c10e75cc13c02a9d51b93ac028bc86d9087a784a0f5d5e73f71b28d502a038ab068e8255218cfa3d3a72ed1e9011d2add52ed2c3d7b5fef475f7918ba2634e57b4480be4c9438f4a36bde6b9d9ca45ad6ad7f778ce3a24c167370907a296061ce1944cfc2a65365da327b6ade5875ee12d5be47f0ccc8008b36db95887b32d0a314dda6bfe4893096a3eeaac9d3a778fb7725cac89e5123d143d42d282704f7c10063899053644999cb38647c69be9e17e529d2533bad7512bc281681f9101e5b81d98634c5147de7ed2b76aec77815161e3251b13f7e3614de4dae6e92f365fff9414867183287f735c3f80d9785dbd48d6976a0905b8a1ee6656ce6f0b47c4c82de92ba602e467dc5f14063b88630860bb209e527504462dcfce7328abec7ca94051f07641d2b3da9d011f22589649484e9f1e08b5724e95fd5e3cb9e5016af6fa1428c9cc69c0e2b1c8d7ced1e1a366483518e03ba40993cb179765118cd8e83a63a42a5c6f107bd12d40758b3cb8b8745aa54fc1d47525d48a1b7a9549dafd01b481c4e63c099b8dc09a0a1f09d2ef99cb2b50f2de8fe8c1e3a9ffdd46ce140646aa85aae28c3820b4889ce96fbc4a2990bcf045dd67350a8cce6b3373059528e24be29ea8e613fdbef08d4754104a7f18e05748d37ba3d0b26d0cac7f4a6c140baef5c79fb8a2d5b7b989b4fa44b673d3e011ad7e95c463f71288dc8a59fe29fde78d1fd8f0705c965b4f3541842c5bfdfcf4a775f55a6ffa3f610a7d1fcc71a41bf04e59667b323e6746133f50863043fc275ee4c7f61750d210fe856f2810da6a803a620d80861cdefc3cf81c64ea5d580b7d5ec8c99e1508994a6dd563c1f0c9e5b3920ecd40def50bac01d7d2089c55caca522fa9a56d012446f1979322e87e9defbd73b1cd9716c377379dc17a422ffb1eb84ba8fddb9f3391f53e159c84202b2c197a6d35426d019521a3426c0502bca1df798e209ec8b435ae29d02c8bf7ef42f75f382128f35cf2a11e84b13e6a0e7a2a913f63213e19c8dac383563a7cc1d366074255a5bdf1c5d58085f52faabae3e28168e6aa6280adee7d0c8c2f1fe7316e53fade447ff86b2091d6b86aed7bb66a2bc7a54a2993f5a9868dcb0a2ed6a99f5265fb53d6ab2f6f4f8f29924d14325d841599eb1aed9eb1da118c7f7bafefa8ce0dc6f813717833bc4ed05eb8a08965b2489cc2c6367aefebcae383450127a6bc606e42a813ddbfeb7b512cbf671a4e3350e4b414cee94d4c0c035d80cc56d5120b2d41e593219425b482891adeb9e8c0425460efc3410fa89678404bbb7b48a9e835a3da4dbde5fa16ce8584382cebb3f7e74857a7c8836ee5e1379b72b80f9437693033d98d492b068791143edcc7ee7dcfb26c4b7ecbf03d1de95e528ca6cda3d424662fdc96413877a898cdf32599cc1c86ac78b0844af9ee662908ddabb4f35bbf12d65a1cbee39c7b11f6d64562fb5e91dae87f0ac98c441bbe194ec7de9507cafa7f6df25544e276085cf4d0c4c18f2d7f1abad9e624558735a191ff2a650c917d06ef14213eba6de0fce1736ec9ad7bfbd482a581d7a23618c2ab0d23431ea14059646e5d834c1c64997f94e0a648f2fee518f1d67b862f866f5568d6afda722b87e46cef01b6e97339fb011477a64c85deda20980105dfd4299d62f26c00f04a8b3dc1f4cf399868fdcac209e9ff7f0d3035c03f55a3f75e6ded0d552166bddcbae485d68e1c9e9559e5a767f73eb5027d6bf48e2c3ef03ec1c9760163b4b6d7b56e521c80d0464caf5f1d7a663c59de910fc1c54e642c03d9f466be07960b9753c481b5a3a093872b28230d0f8c896bc2bf81cc387b6e5dc18c095d5121027dbab22a6c9717c4a1895dedd1944b17c7f2c07c873fe184fb44cf3b0f1f7d96b6bf869a1319187543d69f428f773aa9be2daa6dfd518160935c5ad090a49d0677d877cbe21fb92156cf7fc1c3e596693043ba775ef043d9ef50304ee5ec91651dbf119adfd50b54ca409cfcd80aaaf362fb3431a39f2cb5b67e96d1bfabb8fae7033ecba5489ad41e8ef72a660abc3cccb60952c0465c156730828ab9365e6b8bd685dd71972d79e5e8064ad1eb773602afd2fe1d5aeb87704f49e9357b62f1f2f044b9ab3bc9065d8bd03deb1201bbf6606c33b7d0aed9ef27dda027c12bce63f72829989506e612e53f743536fdb2c2fee7f9cbfa0d6793a42ee62088b429acaf8269703be8ff77835202f0ce6b02a7717844bc34cafc628f59ded2836721186710731730eef32145f0e6a5f70b36a829b3d159c5937f633aa3ff01d4c034bee561a2432dcf05cf70bb50012bb9e5beded03c60a1100a40226c2e858a4fec285fc40deaacd66f5b2f389bc4dab9129910d8c31dea655ee7d9f9d4619482ca3f469f31f846dc22a31fabda6b81a23d24150501dc34940b10e6f40e331acbbf46fe7cdd32c3f9da1e7190d4db824f9ea7550e4294d0cbf0c754ee5a90b6cac6d77a6d3f87e50ea119153cd7d9706bd3b233d85e7d16b525bdb4a1cfe6b92c5487ca12caf2e12d4ff27b2efe1d7a3bc44ab7be0ed0fadf22e1c9798017ee6956fe5ff010631caf96f23335752bd7648ce37bb237b7739a7a839c35235dc69aa81f871cf45b454514367c5bd0aadf74da679924e50593eda50094992b65938ea8ea21b38bf5d9d88ce29ee67940ad1d57f25ca15d8ea8c4136dba73dc80dfb6167c63d4f36bef9bb90bac5db33041d11cef624eb295d196913fe000fb2b255963ea82651746b36522f25e79ce5a0087b5d47a6681492d9d810e35e593bc39de1eab975c13a60905ff1bd054798828913dfc6f7e360975f17e01fcc379a81336695bc3883d4cca82ed8c152c480660b2e6a06253cb5eb83c5284b2a6ea6f4555fcaca609bb1d6d03a2149fc8a70def6b30ffec0d1c6ba27c8dca514e0067ca552dd3fea6e5dc2e4ee9e9f6cbe23ab790f3e8722b6bd2d717c2bb7f8cdb0f512e9ada756b9369f05094a39206261294958845c5a96e5e31f1ff11f3f15d93991b83080d50c2d8242e80d8318bca78fad7cb8de47070d542eab10669a4c75394442bf158887d2f9a8ae84a10fbae96ba1c71fa319743fcb00165e36da45be559ae2c4cb6af89d7d4932be8a37149cd4db7159fd735f34542e08c4718162b95123735062b1113a5079cbe8b6e4ff618ac94637cc710e0a2a3bfda3504c74b5226be7ff79197e92b449730654fc28550566f89018d7a607c6adf4cdb121651051fdf7604380cc7543d621237b41c8ed4a6df7de71bac26e38932e05e61adc9db5d217217e1f2d97e51f717e96fb0f78ea6d3f44d42410c5d334843fc3ff62806e33d111ec4917e9fb72c77764233fc83663cbb2740124d3b5727fde11d5ec6b3f61cbb411e140205ce2e09639da41f5857beea5291bda77dcd807b69879a88278bde3e908048cb971ebf6ec536c62f2192069f0274d513b7774d8ed01077816d6a739be7ff3644bf3376e23ac95ee83a8fcfdfb56f7ee3af10c383cdc19c6a0d0f1e8e79eed619ac9eb321dbef2e153e05a7b2cb6ccad87c5a66a6ee863fe6232bb616d76b5db86d96cc58d1955047b2204a53ecbe9524a7034c5f123eda6e33ad19d6e349802e42210b059378df880cda51ddeeb5d7cd0ef38fa13126c95ee932acf2ef979ae23797e1ec495a04906b451c683ee321e76ed05049260e831dace0392d0c7a747374365c98ead15dfcac103f9e774a84ff9605c40a547f875727f4ecc6544a6e2d988e87d7827f264df93244ae06680117d9520d84c9512de06e0a6b83cb355aacec388ad3d4f95b2d2275af9cf17ce6a0020f6bb27e420a1cc25ec6074334c6a0d37631a70b0794d289f15ffa03ee8d01642a288c28dd9e84f3d2789f9619cf73dea29e40f400d88a3c642cb8f34639d8bc0140f71c63ea275a23b007a3d5dd38f4ba192fa1a0ab6ebe5f11dca3c6d66700f228834c7f8da67fec39b0a268e0b4d29a5d0e2922e0c47ef4e58abf50854a542d681b95826a14640745a280c7797d1b35fcf61066ce3f7cdbd3f1f35b578459aa97b094933f769fa74af5e4408d078927ac14487db31fd683de7e3edb1defd836528a75ae1b961c3b3eaae4b377fd95959d52ca93f7da5e8f3bab488f66579f6db9fd888fb235cbb21a18cdfb3e6588206e56f9c70529e9c5ef71942c3e31e8ef2ab8ed351b5cf777530e48035ce05014065c4f1adff62933c51fff69193456249d336c685273885fe11c88d2c1536c3b70e9e0200c113f8679d7c1122a527c3f741e4359f47b8b65069b44234406c98dce42693d846d7327d1d39d14e49e9a46e6d5c241bbcba549e92466e120ee0a27015b3f7e053261ac1a0064cd6216ae5dda69e5d4b37d08b39d32148cab97b07dba30d2060b46858fd117435c384ef26a70debf4280767623e5c6812060ac28a1489517ec2fc12021cb42f6fdfa1bfb7f19b942039d032179188474a44d758a2c72951de0021ef446113f24141ee96949f37cba886587bd888e2cf723dc4f34c0418ca9430dc3ab9be57277e75cb6259ff92c636c6a96d05331045ae43c3c8258daa88a670fb194668352fb57c1cb8e19080ce30f25439f52f71cb5a7e721ec50da4309104e78d466d828a09bb1f791902f2107511626b0ee005124679a7ce77bb1ddde217341f4d0df3833bf5fab5a36db052b1782829d544deecb0d17dfbf87275f8221079aa2844ff423a91d0cb45a14fbd39a26b082e6f53e9441d4421024ef87f09b385d02508d9cf905cdc959b1316578ecbdc84a6ac73dec5a4b3add54d689abcd9ecc1679daa5ca6dabe8af924140baa2a0accb0a2f78746e2088ec65ddd4a1c4dede097091b949b5ee8ce4b4eb4dd1d347a03dca7e8e42be4d71d206253f518d57d5f8c803a048a042995c678b8ce0de4ea2b633212432b7c318b6102c101c3c12e7179a5e126193a4b61bc909973349379063e8d8e3c77b5df1a487fa85c4c8f3624d4e04a84ac8c8c889980b5ded99b647dd746faf2fd954ab017aba0ebbfbd09fa45078ecdf81832cd3231102f588876025c461f3fb2987cda1e3290fc78406ba14eff01358c8d31e018f7e1f18d9da5fac145b6be91b36dc6dce467ebc2044c8d1f57ed3729f3f4a0f11f0e5d8e0f75edd5709aa1264a364e654a79e59636bf416ffe980a0c136d585d64c8fda371e41ca669',
        salt = '6b80d381b26fd5179791c43d920564ea',
        labelError = 'Bad password!',
        isRememberEnabled = false,
        rememberDurationInDays = 0; // 0 means forever

    // constants
    const rememberPassphraseKey = 'staticrypt_passphrase',
        rememberExpirationKey = 'staticrypt_expiration';

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param  hashedPassphrase
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassphrase) {
        const result = await decode(encryptedMsg, hashedPassphrase, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        document.write(plainHTML);
        document.close();
        return true;
    }

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        localStorage.removeItem(rememberPassphraseKey);
        localStorage.removeItem(rememberExpirationKey);
    }

    /**
     * Clear storage if we are logging out
     *
     * @returns  - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        if (!isRememberEnabled) {
            return false;
        }

        // show the remember me checkbox
        document.getElementById('staticrypt-remember-label').classList.remove('hidden');

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassphrase = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassphrase) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPassphraseQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPassphraseFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassphrase = hashedPassphraseFragment || hashedPassphraseQuery;

        if (hashedPassphrase) {
            return decryptAndReplaceHtml(hashedPassphrase);
        }

        return false;
    }

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        let hasDecrypted = await decryptOnLoadFromUrl();

        if (!hasDecrypted) {
            hasDecrypted = await decryptOnLoadFromRememberMe();
        }

        // if we didn't decrypt anything, show the password prompt. Otherwise the content has already been replaced, no
        // need to do anything
        if (!hasDecrypted) {
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const passphrase = document.getElementById('staticrypt-password').value,
            shouldRememberPassphrase = document.getElementById('staticrypt-remember').checked;

        // decrypt and replace the whole page
        const hashedPassphrase = await cryptoEngine.hashPassphrase(passphrase, salt);
        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

        if (isDecryptionSuccessful) {
            // remember the hashedPassphrase and set its expiration if necessary
            if (isRememberEnabled && shouldRememberPassphrase) {
                window.localStorage.setItem(rememberPassphraseKey, hashedPassphrase);

                // set the expiration if the duration isn't 0 (meaning no expiration)
                if (rememberDurationInDays > 0) {
                    window.localStorage.setItem(
                        rememberExpirationKey,
                        (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                    );
                }
            }
        } else {
            alert(labelError);
        }
    });
</script>
</body>
</html>
