<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #4CAF50;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #43A047;
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #76b852; /* fallback for old browsers */
            background: -webkit-linear-gradient(right, #76b852, #8DC26F);
            background: -moz-linear-gradient(right, #76b852, #8DC26F);
            background: -o-linear-gradient(right, #76b852, #8DC26F);
            background: linear-gradient(to left, #76b852, #8DC26F);
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>




<script>
    // do not remove this comment, it is used to detect the version of the script
    // STATICRYPT_VERSION: async

    const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 *
 * Mirrors the API of CryptoJS.enc.Hex
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassphrase) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassphrase
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassphrase) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassphrase(passphrase, salt) {
    // we hash the passphrase in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassphrase = await hashLegacyRound(passphrase, salt);

    hashedPassphrase = await hashSecondRound(hashedPassphrase, salt);

    return hashThirdRound(hashedPassphrase, salt);
}
exports.hashPassphrase = hashPassphrase;

/**
 * This hashes the passphrase with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(passphrase, salt) {
    return pbkdf2(passphrase, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(passphrase, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(passphrase),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassphrase, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
    const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassphrase = await cryptoEngine.hashPassphrase(password, salt);


    const encrypted = await cryptoEngine.encrypt(msg, hashedPassphrase);
    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassphrase, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassphrase
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassphrase
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassphrase,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassphrase = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassphrase, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassphrase = originalPassphrase || hashedPassphrase;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassphrase = await cryptoEngine.hashThirdRound(originalPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassphrase = await cryptoEngine.hashSecondRound(originalPassphrase, salt);
        updatedHashedPassphrase = await cryptoEngine.hashThirdRound(updatedHashedPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassphrase),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
    const decode = codec.init(cryptoEngine).decode;

    // variables to be filled when generating the file
    const encryptedMsg = 'dc575488f97ff1073fac69cd538bdf7056cc2f0068a48cc1e96793b7fa411403a9b8246553dfc73e86c5a91a8d15413e41f06bd9b2167cbf21b35cf1af0500390106c94c93b42098d8adc7b6722158b0bd5c8dabc9f9f5404fe04d9d52e84b687d1e1fbf40480e9e1ad8a37d42e6fdabef3a4f2f3a484d0429d0226488fae32dc2d6d4598472d5bf78542310e966599843f05e13e24afad7de507f9f26d40cb867f8a251037a94bb0cc42fafb0bd85abe126c08b267ea956c1b9b3c1d122bfee881a294b62d24ea1e739ca2215a92afe6008cce541809fee23cec9535a2b8e7da00ae915a758a3f7843d9c2609735c116f9c6675b2741482231e2a0d1a6a82bd4c30d144f6a98e1e35499140aff1b578fcb14650a5cea0126153d0b1ef92835deb8d37c215d3e37ac4bd5d02c6874947c4cd0117df782abb49a692e08fd06c9b5818a6fed971f40993add96cd6e99533efadded3a55674c6a562f94b541401bde9bf20d23b494b55fdc38b7960520af7190d3ace48c5b24fa0f34cce33d7d467ac5f819817818d13c01d0e1e89f644f1d66519336d8f3678b656d000818d6d7a54c69658597f1a11d80e2cf4e96d4109e29858ebe75a91dee39b7ce04b30dfaec8c2b0e9057a68e1aa5093542f555f071e75a240d7d97cec1c0c18d3db5efd3655b2caa6c9b6734c9b0208f9669fa438c2d5d11a3dbecf47e182ba3cdf29cca0987dc32e43994ef73aaafd93102e42605bb6c4121a9afaa89820364af469bd33e0d6f1195c56ba2cce119e6ecdda6109771e5f93654f8924ee78a2dba884a7c2baaccf159827856abe34fc53f4f4b32030babe303e08d8c551096ac77c24d9da97e0200f654e9dde9e09b3a3b5983250c74d4377bf5923102b39bb8d1fb49f58b7121e36f3b9b38d41a87b3e6cb554beb93c83573dae83b8d70eb140d6ac8048addf552c693b635b94fffa2e4641339052eafb39f60d57716db6ee8101c0f102293d1e2279d553079d3d0165aeec5720a6d586b7b921a66374f84202ca5ad028c81ed83065c10146c43dd3f98b9ee72c90b2b48058e5eddacb3e03ca120644d6c44b2d5319a3b0c9f0842e5276bef9a510094863966d5982b6bf8342881b06ae81a9d7bd70e83f943b2f70429129426a987fc38a33e024acebbea75ce75f326cf67e7c4b8bf23b7d984a517d5da51aba5797ed8e716a5e1ebab9bdd716eaf0afa13abaeb5fa91804815f6ddb893a24c080f4a27a1b9f299709604af49e2f68ab82a1110323ccb3f715de46b206e7c8895f331f363ea8877ee981239f58016fe60213d377d340d0c74deb1705dc185838bc0958510336f1b83305de50c641c27c1b8bd0f4b694cb929df2e617f533a013b45c5878439e01dde4a98abbdf9509bf2099bbcdcb8bff9898a6a51714fa5f6beee0bd454b325937dc29c8dd6b82229b9b56e8478c0cefb45d70b889fb0f9801d4e5c0e9297295dbef4e40db9e7f8937c3ff7de04e48d0bfaea30951488461e423ac7e927574cf82661844d15e567ca2cf42938ac4b34ed3136f1ca4f4c37115f5961c445dec495ca186ae348f7179c58286b44887ab5bd5439acf20085aec95b447e3a0c407f5c34076b9e84725bdd318bbaf16cf1eff558d82ad8094e188b41bea351bdc00d8171b9aea3f476b46b05ba312bffd638b91a8b338a0cd3467d3356cf27d2ee1e4c05aa765bc1e4baf2ae328a3dc3450cb337b0dba6db4ccef28e5b6069e8630544d1afe171a40c1f790c9b2a513099951b3175d20495660c8df205209c21df3449fbba9d26464e476129928b4ad0db51fea332f5c87e49b7609fc7d319e01e4b7e3500c3521161946c117ca6dbb18086d1a3cd258b0cf6e7280e0022121d95d1d72f9b5d10049b800d37f35696e5d9b4df2d7495d3e1a5e585732b0ad3524409c6dd8b9bedc0116cb30faebe2b97aceee4651c724398284f4716351d472b9eca29b3fc485f49bf5c9fd1d89a5a36176605afca81877708f0662e0329f24aceab9aa859c10971d291b7ba4f2d749fb15cad1627e4b088dc33c2977775dd8580a915878f418b524b8942ed8e6ec92383a9fb2454b948643926bf9751051684d0875deaec3c27a9c328452d2c189731d8c02f2075ce0290b055f1596cde25ca72965479225eaa824d373dfee5602571403f317868ffd0340d102d0d92e4eaed9afbd02b0ce2764c085f9a8870992c70ab23b4209006557b4372b347bebf066c0539cc958d8bdb285fc660147cb27fcb3112fb344588b0bb75c127bf82fcc9692291167dded662fbef7171eb2c08efd60575e46182edbc87ec297d020d689f699afcd12be921cb6eac39702dbfa6bf2b5eaf8d24b66ae892bb7f9f75dac67b2f57ad4c5de5950d417d1fa6d2046b93e153b521657062a61283b5a6f9909452e5fe8a520fbd882d1e0738ce9b778647731eaaadde4cdd6a9617c84b8e80d6fea1b024309b94e0af9135fc397d470fa69ca3d5f2db51440c042b481c75e792d2e79b7dc8d3ddfbc195eb455c055fb91d60fc9f1625ad8039e448df7b665136323bbf7ffb177754f86583c589ab287af2b987b76d02672bb941b7f2898288d1a7a1f4b2b3679dfbeeb20b58c792258ffd7a102a2b0afed27c0113cd5d03bc001356b858a8afdf730585a6741389faeaec4212ce369601a07a2efd240794602ca69847353d87ac31380727a8fb37bcc0bbc75b1cddccfffb76372307b7857c20ece834378e28cb2b722b2c737d3d27ed468336cdd6c952a96ea0fb80e2f923160dd1079af8a064ba53db91f0cc1f7678c6261d1c17702a88f417acd2f741f44c0ec838c530c010f45ea135d9c52eff9251368075ec5c96bc4294e50b7ce3ab6fbd7b09a6e780152f12816f6b176915f87a207ba6642d03a1bf2e7c73e2e6713aa5c62616d55b83683bb35f85d4dabf54845d01a7098cb410e60b3dcafae29cfe07cb9c06e5eac27b800c2683244a6a0591f9bb2a1090f498aeea34254b307c25fcde2780fed877b3b643c0498b262bf935735e427508666511ea11abc3d9aaadcbf31e3933991e787eda6d97238ab4fe1c8ac6f44c3c80c47c40ba22f9ab652ec912bfd8a61b49820f829df2911be8d4d2c9be2f6e55ab4c09007a6ea74a1dfe37f911586dd64a8326004f5a65cf295cbb9301a4fa9391ff94ed944c48e0b453a88a83ee41808e809271a0868b0fe9cb1c5366607a828e1936192a4fba8afebc2e3282ccfb7328065485d970c4b6438b558963a5e6c095c783174521f35d6a73c98b2c89846b70da028fcab083e807f179caa38558ef1fa87fc05f944ed2bc46085f3a07c6c4f71bde588c1d5e1d800a9193eb21d3dbb5f3128996ad084625f5e3d3810ae9dd6a37762fd0cf36c18621bbf1ab7356ffe055f4d3d3e421b94d29d41aeb214edb12df7261b0f8765bb3b4f58c95eca630d9f8c6b347fbd1b1b908e346383c43db886e95b7811e69dd06132f3174c42297656d96709a59c5c9def2e93a78d07d914256028f28865a654285c0a662cc2855735e1de6b6ded29e13c2e17950b3a7d7145e72799943abbfc0212da1721ea9694ccc5dcc10f0e2ef6df5260f461708f61ab0542ea154aa1702f676650778ce8762174dbc17d0ca74add0f335ac77efb3c95cc58718e9517828e0d5f10513f8f01088c0060e0113f797d30291f7b6e68836d38097a0f8ac920ec0c4697b93a7766596181080f70b6a2907ddc157f565526079f721dbfd76d27e40cfab213f2cec1678f1a64f84044471d6d4c411b9a68f4455d55acdf54a47832105c4db6a5c418090844a95e1220a70de06b632155e6cd0601213df2335171f1aa570abbeba4a763fc88617a54dd7472474aac01ae9ebc702489807a4ebf03445701f6af58e169a80d5d7686f4626f2737ed014343d984ba9b7e7bc899291767c095e093a0e72fde2327d2ba911d7677be5aa700ad168962e71ec6d4a7276e9d093f47f3ce60a1ec4bf74a2d0d0ad1dc4e5bd4f3747ca965b64551834f57573485d444c3481992f54413eeaefb7313016ae73a553dd7fe2d57290691bf7456365926dc509536c06430f8d28d4b6a061778d61d9191ca576c8a362f8979ba61a902d4cb9660075c7bb089915e5c54dc7aedca08b540eafd7941a0b164c8798360d06836837fd56411dd579f3c5970b8cf79b7d4fb1842f3d6aa9f6552bdc8b7783a859fa803f1965ec9cf35d46841b795ce19c86f5d75ae00eba4a9a65536c564a7eb3c55c5ff8304f9e89a8394abe6ef2c48e683cd144cf0346b2a52490f9b435ba246dac4b2f7cf2c45e816fc50e66117fc0659ea45080cfddb5e2570bb63320f567928b560e40f96860a4d56338d10bf070cde3c9f82363ed5db1ad4d30826a62902750550e8853cc1451118498652f2b89e521758161f937b5972929dcd6b381296730270eb143b1d47e0ca10ad53380e826c45e528448da0a2d4768daed51bf9b11dcf4c5edc13cbd3fc83f0d516bddfbb420064ed974a0779717264146c845ecb5ce188203da8209bad322d97baa6ce184b30a13735bcf09a24bf2ffea12c456fe932b647141ec6d5768f43cf0556ed32d17e4b3553320f8c5352019989b451cd4484dbdb17dda87ca84325b04bfd0338c8350d3c2ad3afcbee452bf1b8a8e863cd3f133635d3a7c10d1fcf2b51b1182f3fb6caf38588446d84c0b0140d6eb9d0a3b564bd1174576e4db6ac22fc98b9c8dffbe4d6079fbf6f72810e8943e29b06c2dbbc75192fbbbe10d116108ec69f0f5cf6f21c5278f4a27d18ea45b65772883b3b361e68d2aecd3674b428031b8cda284df28de572cede40fdb467412f16f02142813e7891547bf698f88e93fdea79abe79f341a6fb9e25de1ef8489418dc3b9f67f11464ff1a88b122cfb1d5493b11644ae426876dc6050cd43b68cd552a15a6ec9a128351e0d7622573c0e0b1adefa88fac9baa241bd142f628847edb33d86bd7d37731d2a732c8f09d13fdb90c1d027d38a1f6212a1d9533f908ca432e1e9530c360ff8d507e134f2c756f66cccab9e5a05b2201f345a7dc59250dddd20430a0b5f7b0fb9e1684b584997fa06147bb893b131dec0ff7acebb75dd0fdc1f1f492d968558b281e154fe9fc1926c645c5cd709e4f8b07a4e952516de4615916c488d365f952d274b0e7468026dd904e90eb94f9a04536f4ba80c3eed2304ff935fd3a2c543882636a95cd8426bf638d5c90c367717ad60f0478895da35982cbec87d1ddd72d8abd9a4150722f0e61c857b89d6a0a37ee296f0a3f562235f2c496846743a6ff97aed50f3eb4d76a8cdf1b1c02ebf30e355b127ac4676392cd36094854008b38e620e4638fd6083e95ff8444d04423c85213d6d0460c45874622bdd6ed7753465e742012249b204f3484258820bd1d3be8d20ffa02f1f3b1e2171198bd113ef28b1d3f6a2536ca89a0d9255e623ddb0f91b0708ea4cabc354484f6ce00a7e35bb031bd0fb890c46ee7b0c40abf29b0addf387e64ab148fd641b4ab6b37606d7e4846fc24140d866bd32a51953cf148193b5b86310bb9a0ee4e3d9f50563d621cd281942301397fe1f3da147c1bd26abdcfce5dada459fc97319b3d57e261b0019400f81c06ec64e957053b2706218c94589f3329bc2fd94e7bfd63ce975a4bd1443eeb31411ca47b87f7a066fbdeb500f34458e4fdb8c0660933f3d6a8b1e6459a09bb639cbbcb99a5d82fa71e80b84c6c0d7089cff1dab186c35204eece9a99eb6b62c41cfa899f046001f5cdf36e15ca76fb5a1e6954333a3939669bb8fe9f05ce5c9e3d1c857f89357d18703f25cea4ca98cb4eab70c9ca79b86dd39565e986bf9961d7199f980f8470c152958f79582b8c4a96d5745233a79d34e086f5acf0c0229b6cb60d917a69abc89d03ffa4f2626ebcd63277399c12ea28093c7a4eb3d3b5e62e2a28d1002173ca27a85ab6869e078bc7373f64078e179a3e0257a13fe60c53894558889a4c468200da2d0be8204eb974b5acdf138eb6f384311f1955484afb4e7e8d3a3b4ca266ebc983c83f5ae809327bd321ce8d1ac81eac14c32ecd6c50ccff14660ff2d8a81de11612d154ea7653f6aae839d0251756d3a436f1ba8b02411752bbdb8e1615b064de982a4ef2b8df91248bf74423da14122984469fda0a45941d83c1ffe1662c5b26e89f424552146b7b5d52c1fd33172280e6e99bec16d856740f9444a7d1d51571bbf6074868e63ed6646214067b5970749aca19839f2f396f71a1455c7a5231ea600a29dab62fe21296d938888b8933854034d4b573649b6bf77234624dccadf2d348c0933756f2df45944a587bdcc86f8f9d7f57dd2bdf644af98d7c85df229cc5b8270d4ea04fb0aedb1b1e98ca3d580fed6b39e0716ecfd323681c8e3b0dc4e38bb19168f22eb7e16582e28c5978b5b2f70ed603c6613c107e3f414f52155449491e9ad0e5f03c5d197dcb3781646b216a9e5ad12478b7466a913fe5e3c512cf30a59af17318042f1a27b0fd5f626e12340d469b4d9632c2cc3a3f4b9f04df1e341d4154fef9bcc51c41d7be14ecd9cfb9db59e09ac34e99cdfa0baa6cb9c51307fcddf23f4048e12817ba42b8266d1517ddea47395b3cd8b3c86a90e1b586f494e68f677e38591d0686120abfaec8e02571f14982eb3c3940859d85bed5d927dedc55713e9501e65fcdc8a312761da2bfea6cf2f840ae0c8eeb4cfee7e97d84d2745f0f632f468513fce2b81dfe8c47b3cd0f844d9f587dda369a042fd3fbd2c4cf7b7a839b50c989dbec86b157b6a663d8041476460430df50e47f567f032371b5be6ad34ffe17e6b70869e2d02e29a54fd4eb57b2216c67622e880ef0526d496236b7000abbd57ffc3ef71e4b9632ed2c0c5361c6b7e1e0419dfb938bd8894c07eafb1d6b78c1aba3ddb8be8c911ed10603de58b4aa82f61a4717f1d082fdb02ec5352ecd72a39671f1a38fe1d51c31c7d5222b1052fbe45f735642e93aecb86dc99a9d9ef2c45f0b350a4579dda88b34d2be7cfaf492bcc177ae802deab5a08af3cc2c9210c8784ec77435d45449fbfac9abeb3104c5567783e6a7c404c9ebc3c4f4b477b89047e8c06854c9b4f38821a130147a523948ac0c7ea3935bad7563f57b429ac1047410824d968a43e4f4212ed19137f786012b48dda0ecc549a968b5e546a67a1fd0e4ffd3ef804ded2044acbcd029204aa6aab2599551d1c586838a00a11bc734d85921a4f9c19f3eef9c2f337f2aaba887e362a7de75920cb2a464ec0cafc70bd49605c7c9ecad4724501d12f86a4fc9e07008999c2a468e494b1b39851b194133ba14d90040cc50e1e320c8237b1272105ae8b5c073933eba03dc5600272ecd43b5aefee425e0c4c831b67d51e148b0e2dcf73681ed28e874f30169f9069eb34ef00cc2be34f1a520a22b8217ba218f3a009f3224032835b52a7ce746d665f03b2f996a752671878488c1fa5a4bbeaa3039f6b7e8321de66f8474fadc78edfdd71e8b35210db217ab771f00fda745b051898ba8b170739bf682790f151be662bfc9f431b766b854ca19a3341dbdce0e2a62cbf16378f743c3c0abb29a54606cbcae44e5e1216d1ba7e847c8cb76769f2b1d17fd0ee9e4e1d553553acdab37f577b369b82564db56648fa05a0e54166714c77049e9d448eb64fa8ac809ed8eccd535b2466191fe642b9ee7bc5ea4f3db273b73067b87836ccedab38a176a823e21cc4b0d92cb7e90cf4475ac13b59a8418af61371b4d5880d4b2f59846d11d70630324600e67d40aab432aef3c348bf532b8527cc816977053156dd9587570d646da12ffea0cd1a56642e40d9924700c6e3d12c896d8d249bab926c4dba3427fa3bd5830bbe586c421348df4cb11f2478a42487f146e851dcc114744ca8f594418ca199f6c12a1b09ce70d4af3822126c5d88e95d93a3c3421a3377a890eb42a854c83549361040d87777f5eeb6141f71cfc54b3d2ee56026419e6210c693c855348b80998b1d1286201c5a92a6eb793c3ae2b818ff899ce37e46eff41e94d4634c32e76bd7ecb35261f0bd5198c08cdc83f3f252584f32ed67d8caae02e62e0649f004fc9be51edefa2dca0bf98954f60a71f351edebec730e1ba0d808166337860a376f7020c1ccaddc399e25c45bd7883566801b67255fe115bab7d11f054626fe1aa233a4186e2f3934fb009e8c3a0f88a778c7cbf97a88e691770bad091262cb24705bfadf3d07a5c64fbbd4dd992f9c8f5c1f3e6027e454495f22c1627d70043a4e5e4690c563215796726ca018842c2d530045adb394c8a88297b1ed9feea5532ffe7f982682d7cb8ddf3dd288a7120d86f8acc7d42bb20e289fd032dbac4fead3eb476500117db7d2ff9ea18f74822f3abc6e8802e8e8738005bab6ea6b91b591cd5c72fc33671b25cbe42ec5db6f8c9f3f35636c94908dfaac4a31d6c319f2d214c935a2b0223dacdac8e1da5e7516bd467645c0f93bc441bf0aea5e718c61e2b399cfb0ae37e878946f4480e48c4511c3e62e14e8a07822bc57e237de43ba7f1703b25cb765e4c56f8c90e369537367e8adcae8ebc89ba61c11d82682836aab5cd414a6b7a2f7a6b5b0e5efe2c38926f3e4fe5e21b48085044958f0d158ff1dcd16436178bbcc07a5066ee31f8f07c61d6c179d81cbad370fb7c0bfbd929d1eabc30fe0d00d5deeed6b6b377271e20eff6918eb3a5707be6767a26888ec075092d78a9ffddde282ad3a93147914fd1790c4cb0d8c0df6b42b0b243eab0e7fdba938b9a2381e5253ee68498e80be7103d6b933e7f59715cbfc4debf14b168917386fd19ba098caa16e9a3c13ce1d500c204c8ca120666b438ac4df820ccd3c5934240fae5524f3b9232686297f612b1755b7f9091b3c09f3d83b529770daddeef9f112b4c8a30898e7b375b78fb9fba2f9488dc31ec84a77de64b7a572ea25195cdb32b142b67d6af194f54d340e3810036121a57818a2ab7e8df0fd4085d0c1ea8866dc58f9523f997febe7c28a428b5d53ce6642bdd440fd9fe8029e5aeb4bd91686d23a33ed747bcc33af0eda3b73fea06e2082998562116f08b2097fab4a108582663d1e80986a469ec3a8ada49dd7ff366002a7e67716a84b2f2e64c1be3ba48ef91ddfcc1606b4d5eaddafc90a1e928e4db70e8b3f56ee186ede7111b6ff051e8eb6e81784f368967b81846b58875bbaa0d84271e78cd25150cba68f643730fd59efaeba0b623fdf616bf7ef689c0815d76d86ee106d8665c3f5792e9a53cdc1f79e6d2ad91a6f16c7a079f5b56b95fca65db651e5301901b6869d42062051af16b55e6141f792d995f93542d7edc409019662c6d40ad31342f210fbf6acb498f90b07928aa69c07ca6ca3d003011556a8cff192d50b854b703febdd69e5d1ec1a926afba30a45faeaf10e8fbb8d79e289c6a50f2f6ea1e3c2284883703414e658ffea71a1333f903b98e525e2f889ed96a93e9978f13cf62dea4578ca76604eacf610a7ec13e282543ed49bdfb3a8f97f588143de018c1646a47d61a430a22d3d98efa2e9a806ae3571ca04d778975ab3bbb394365e0f5416e1d5486d793a6e61555a6f29b7e454b1713453bf66031228ebb00bd80aa0a4f081b195fae0a03dc27670d23f0631c834888548b961abd29bc201b2547b9e4825a9ce4540bd88bb53908faefee56b968c25af27b04756adab4a4fcbe1e9ec7b771f19562f923af647c1cf71f17b2956b02469b51033667b1861f2b1d076d8eca279de7425bcde437f83235c09ae902849350fbfbefbccf8772e778651df0c69921c381aae72fe53b8acf1ccb6b63c39241a24b4e830b21fa454a334abcfbbb0b3b43b36d52716438428d9abe86abf12acb21673f3d64ababc589114e1e3acb9f0e2b206b46e504ab325556b385e133ad30e61ad0ffaaeaf4fb7d60468b975915f3542d0474c87f887f9bfede4e3c85b186b61f3bcf078a26a78a82943a1c4bb0c16361bb71ecdae152fcf53faa52a6a0c300f4ca85d82d9a403bea5d736c1cc36ecb30d76b92e3255a4a09cbd1890f5151ed1d8118d7a7c83153c266813aec19e813a4455a4c24ecf325b70bbb0ac501e35bd673923e2790026286478d6eb7738a0761ac2ece27392ba6bd2e7b20cdca4cd1195307622b6975a1506488ac4afce051558ee369a4697db7d2953cc4d50ceabd5c017ae906c7c380be12a9b44f7e4b5e978c900541beb6319f3c7d8c70d76099f0125df429abf985dc26edff98abfc8c3ad13dc5cccca37c484d7095e84c8efb842633786dfb06caa7c31b958f7b99333f9f5e81b8586155cca67a3f2ab1b6e06cc4c3a9cadb8ceae120072ee52dfd176176f0be1271b5edf209112481930356e7b947c3e8a5fb47e64cf1bc83a213f9ebe6d77ee7bbb3c534367beebbb623876066140ef9c06a9150c849c1a9b5a736816f88df864796cf2928b2102358df4c51f98a1b31b5c23c140934c4edb1fba24c3ae6fb7499da19b34c4f53a905713170e0161561a2391528092c4eefc922c088f1ed974f6132ffe700fbb8f934b878c7f3f6747cd6e77263bca6e42867b5ad07c93b9ae1dbbda3d8a75a2f497ba45f9b7460c43c67e632525c8b453ad34b16fe2f3da39b2e286d75249080edb5015e09898bb8affc4b553d1e8847d2bcc5953054dd6b7bc351374bd41c83f9030c33231f4e662f53522dcde5143bcdc8ab57991a60c418214c99202318571b06f9dbd5b400530414b915e4aee291e1304fc7c988f9a0b65a558f1fa9444f51fe0af12743c60c6d677459553f09dc0af3cf2462b882e14439e5b25bff605aaf54d570eb495c42edd94bba1416017f017a8bed523e620f91e3fdb24d3ea25a171323b3bde32c01fc6652410f415b223f366df8b14435afdd05c5f65e5a4263d956813618d9b26febfcdd3e37d711a29a6d72359c27f2f313e17aea7d097afd6a0299f8302641756784b1ef99005ac1bb44e4a87e4eb88c1c70e5e0d63b6bfab5f3c0761203d479caa9c299fe7f7c3745672848bd447a7ea67d0c88096e276aea94b62898e3e25ee58c150dd936fb7f29bf4f0b9169bc536cba03a483c3bb133c8146f5ca2974219ee778f5b53b2de35b26478ada2aaa26a57cf5089c27fb687ec7eee97664f21813c33f2af70197eb4b28dbafea8f7a3b735c85c30de1e485de1363e02a14750303d5a60cf576c4229f126dd802d19c3dda7d1cab338688daee25a8c18821d6c08cf3d988cf6fbf2d52ddcd8a16e7a760da9a1c8d75ac9654ef30c25baf55f79a013385742316ab36a4ad6ee3a4cf880a497c24f72cf4a15dfa0233dedac6a03fc7a9e21448537f3f218458f7e76443c0f5246099728a5edcab47d272212e7ab4f5cdbd8807aa18e4f60fb5512aa0ab7a2ea86761bed6661bc0f94caa5dc9a2909d6bed9a39d4d0f0e7ba081323c1eadeabe777c151b289a69f7727a7caa4366e28057f117371d865abd60b4db71148524f4fac5d3d0370f843ae95003f42e52590c18a21370aa5260fdee9d0592ab2bf4606156effad55b19004e36bcbe6c8ce8ab69ec7337d33e27ab484ddb57081d9fad2f625e2e552db0d93063374ba67d8f782abc77d349594e7675619a09cbea2c09408ad72a526cb7faa87525abfaa811a811ea481c31cbaff9d66687beb2457e4fced67e5e47407c111af01c68668e1417670c54bea3a9c1e2877a9c2307dea6a7403e6855d3a7c1e94eb79733182a2746f283ef13b89ae6ee4ac8285cda1f097b3be05e506c98f297189ac63c1d3310a535de7ba16141a3225a73301d23a4adcfff1728f6949ce2be94240d87664ecaa671fc53ea7d707c3f6b0bb57b693e354cad0dede1079a9ca9a55afe6dc3c150c373b5a0b95e58b41d1d6db8b4e3a8547b30e9d5172f3db42dfd172291547a4c35a8a9bc8863347bd72cdee8e5c236599c9874c9a30b1ed873ba103112f76d78af27db9c954641882c18fa9a35ac7cdfeb5ef5c589ca6fef913b07bbb5c33529e4a6344e870f317537e8a541987a678a4751159a6efbb4ac5f136e2815e69e75ccec9ab4b08d69de6d72291e14f1578e6a5dff853d729474c092a7ab62c8ff5b71c1c3aceca37270bde5e4bb2e2b16e4be114c15b8bf34d018685fac2065ef8457129201b1e377ec947134b56f9eab19e38c995a6058b73dcd8fe0ab08b277f433cbb688fcc83577c8059b9da490e78b0effa36e8b78fc90fc6e21c108a628fd40c1dd2e10815733729482a1861ab4e18f4660890c05b932d5ed8d1cb30fe275d43923bd7075ee6cd611cb6152f4ac8519d84761c402ea966940dfa18777c9f07956d954549860b55bdc325a0bf59f3fee9a9755af8a03f9598df8efd59a4bed5aa9c6eca04258ab84bf9e4b761bce7fe7f5fcf71a24d30d6349d516209b442a11a39dfdad456c00f59792901e11b8dc90694f992003877d17ab3e67eaa79ba9d0b02489daff05b2f0ea748c9270dff062c6eb46c56de20a2eecdbeec1d3ea37f52d2b1dee3ac40ed55c45322504056422151fd199d3ba3501f6de83ff83ddd23874b2bfa12c48ed24e1947863d9d1c0f112f5a2218db98d01920e249ba2b13f94effe9c3d78ee1ba8967385cc5afc92761e57bdbee0cf95d9d60bd99b9e94d56363142242a37cf8221384224ba7a412b45a7e4ee0c93a77f67b00264cb1b92ec36c320447b8805d4c3a22390a988e3d3aae51f33f9e25ecc04d1280a5b083afb3efa384fa9e66201206b59c6d9180a426aaa194e6f9f50758224942e8941c5efc995e9006edb9de85737e0c17fac6ca1f2751406d12b1c016d2775df1cee852db4e709ba123205d5fc17bdfb6c0273308d41559c8fa345de09a82870650639e2af0e63de00809cb107f4a5c0174ef69ea3f33a4f4d94df9bc7da9d4a646783089796a23e838f72a8091b7512a7a917e87a73323389ecd29d81aa7821f40d725e83fb8e5affc908378fbdbf7114d8d13205bdaf49161d900c6bb6d1e72f74da5223d33c7d9f8e45f0779de720bb03ceabc5b6e6c4f1b4e0f4a1fe7b5a71dd4c61153bce450571d5203efa6cf8ff05660f49cd1810cf9b7834cb37932b4291a174506ea7c09121feac7c9309dff66a9db3371b312e503a4056b4b7a86c1e3a314fc315f981b132060455a4d473c84c847f9a3a2fc24fc567b7bec960a0ef1238db309e312eb44659334621efce686d6a67846397b2b8c3b0c7ed6c35b596108094d937b4e2fdd766c58e7e901992ddf970b20d00d8654bebfbc45b6e997ddbfe2fd14b525adc4b8ff0f8edd814d9f8f952f87237b4517a22945077b6d41c1c23e91a114ad3c6028aaf43692195e52cfee577f9dc7f36f6eacaf03b864275ddb61c38d5cc043878ad4587dd5bc5faed336ecdcc5a1ecfdaaf8257d676c03b6f7aadf72038138a85d08fdabb770524ddaf5539fbcf7f68c56b4555c4213d371943a6b166453a417b8a9b7f9a0731a97d65ff4d4ecd5e71c5323cb08e8383332bbccc8445dd4e3d9fb2b6090c2ca2197fc47086077a06b43a8d8f5eba0a815f73dc1f1f21198ebc21480b95bdbcb76d82186e8b934bb89b17805c0dbc9693b1e829667150d0320674e6bd74a1581c340c8f3bf7ee47c5bf27dc1bf93801b2af5f6a5ee46b3a3646953699bbf8f0aceb1fd09df72329dd0ae4d63a5f803bfa8fac0e940ff4fb3fc14e6a809936c0e2854eeca9b5c0995ffa8ce5ca4767d5aee5935e744acea57f3f1b3b4e6889ae6a9c8b745b88400c2465f3e22e75005acb0a8fcc1595c88e488b9160f888bb75a6ef5c5fcc724aa002251002fa3c478f2646c76ca985a3b8aa3222de8a71a0a0f2f34224e86a31c170a95c9ae0456a118c3d087fd44a988483daad1d99f94da5cc2875d481ba4d8e0732a9b3d541abd11fe39d43b3cfeb772f21d1cc9dca9f7241bfe69bfb682b44a2e2e26c3122a47d25cdc712085d27333b934c5349cba65cc1f061c66410192a4a9031068d48c51c88bf5ce59feb644c46e40a5e09e298999881eb673ea2943a76e480bb97f8507ee9892acf6e024a245d15520237b61bf06b76f204b353bb3d3e9ef59d0ad93d8075434aae2ca62329e2984d13761cfe4c536fca230be33275297c07828216a6c4006877b67643d17fa835a8bdf0bc5768d96c9b1b357ed82e04cc51a7f198d4bd00eca4d2719c5df4fcfe586ca89bcf726eb5654e931919503e7b77bbdb17f5d04e1f2467c3a7a318b1f1a57df3ed72cbf35c6972b234d24a549ea0e238f47a5e6c248d1059d4246d7b10817453e092362dba1b28ac2c849f6f4b9b03749881b48e0231f6b4a7602cea37be5894d33392cf87e979eb654fe47e2eb31f40a45260f92c9c9431e9ab9b44736811cf3ea8a4feba8941bff790c8b1b6c77d985b3ac274d7717e9c2e117146231735617395bca539041c59ee8196592b9ca2a33e0a1ae8e0f8f7a47c854f0bd3398568b2c9498b7fcb7b9593271970c83b4412ab0d6ffbcef327fbe39e12680f15f9a6c7d3772123affcc9f0364c8db69bb44facd3812236ac1bfdcdebbdcc0a7bca2e42073c5c04b7ec397bef758ec7c2ac45c287d68f96a281298a6fa268581993a1fe8a84ff483f155cb4c626c74540b8583b72ad2d1d7b13bdef19aa3ff0752c1480e340c310886ab99dedc614225983e44d7ad20dce10e2456b974456118aa0f250d7b198df9487334e3f8fa42bbbbd86db5c7d32d4bb8fb2e5973be88a040cf0de3fd37af618b1750c74084e94ab15e3d99d0ec9219803cfeccde6243f7349eb5959ea642486bdd665bb00d524a337f34c63cfb819eb1c7ad62d29e1ea64d9eb005f7f3ed8abd1accf93c809b16cfe58c15d38d1be40e87f211c39828fcba837a97eb16e6d7bad1003cab571f02ab8259e8acbe0cc4d5511b535a25204de86c86c06586d29a583f74e11329587dac58860b092de63c8e4ff8e6992d8174057820bf40205c3bb563e3d5a723bca5f47462ba86c79579897898b81f4dc8929e966bad632219bcf5727d51810b0becb06e520914d54810f35697a47310b84747c7e3146d4aaefe43dd5ee2e794ce8bc4a0ed3406d2f4e0e79e2617bc7c013de68910ae3c3e63bd2913dbe2eb6b7a6452c6cb9523d8549fce2ee0cc40ca966ddd5a58dbeb920c8f86883a326c4ccfb9d30fc0f4ff5da9182110b6612ecf70091ed204e600669a092d5ab723ad6b5759bbbfa914becaba518dbdcbbce05f53e0577457feefaafc2ffc38de821e937d71',
        salt = '677ecfac9f11dd50bef910335f76162a',
        labelError = 'Bad password!',
        isRememberEnabled = false,
        rememberDurationInDays = 0; // 0 means forever

    // constants
    const rememberPassphraseKey = 'staticrypt_passphrase',
        rememberExpirationKey = 'staticrypt_expiration';

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param  hashedPassphrase
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassphrase) {
        const result = await decode(encryptedMsg, hashedPassphrase, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        document.write(plainHTML);
        document.close();
        return true;
    }

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        localStorage.removeItem(rememberPassphraseKey);
        localStorage.removeItem(rememberExpirationKey);
    }

    /**
     * Clear storage if we are logging out
     *
     * @returns  - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        if (!isRememberEnabled) {
            return false;
        }

        // show the remember me checkbox
        document.getElementById('staticrypt-remember-label').classList.remove('hidden');

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassphrase = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassphrase) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPassphraseQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPassphraseFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassphrase = hashedPassphraseFragment || hashedPassphraseQuery;

        if (hashedPassphrase) {
            return decryptAndReplaceHtml(hashedPassphrase);
        }

        return false;
    }

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        let hasDecrypted = await decryptOnLoadFromUrl();

        if (!hasDecrypted) {
            hasDecrypted = await decryptOnLoadFromRememberMe();
        }

        // if we didn't decrypt anything, show the password prompt. Otherwise the content has already been replaced, no
        // need to do anything
        if (!hasDecrypted) {
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const passphrase = document.getElementById('staticrypt-password').value,
            shouldRememberPassphrase = document.getElementById('staticrypt-remember').checked;

        // decrypt and replace the whole page
        const hashedPassphrase = await cryptoEngine.hashPassphrase(passphrase, salt);
        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

        if (isDecryptionSuccessful) {
            // remember the hashedPassphrase and set its expiration if necessary
            if (isRememberEnabled && shouldRememberPassphrase) {
                window.localStorage.setItem(rememberPassphraseKey, hashedPassphrase);

                // set the expiration if the duration isn't 0 (meaning no expiration)
                if (rememberDurationInDays > 0) {
                    window.localStorage.setItem(
                        rememberExpirationKey,
                        (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                    );
                }
            }
        } else {
            alert(labelError);
        }
    });
</script>
</body>
</html>
