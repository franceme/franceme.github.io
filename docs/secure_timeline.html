<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #4CAF50;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #43A047;
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #76b852; /* fallback for old browsers */
            background: -webkit-linear-gradient(right, #76b852, #8DC26F);
            background: -moz-linear-gradient(right, #76b852, #8DC26F);
            background: -o-linear-gradient(right, #76b852, #8DC26F);
            background: linear-gradient(to left, #76b852, #8DC26F);
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>




<script>
    // do not remove this comment, it is used to detect the version of the script
    // STATICRYPT_VERSION: async

    const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 *
 * Mirrors the API of CryptoJS.enc.Hex
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassphrase) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassphrase
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassphrase) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassphrase(passphrase, salt) {
    // we hash the passphrase in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassphrase = await hashLegacyRound(passphrase, salt);

    hashedPassphrase = await hashSecondRound(hashedPassphrase, salt);

    return hashThirdRound(hashedPassphrase, salt);
}
exports.hashPassphrase = hashPassphrase;

/**
 * This hashes the passphrase with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(passphrase, salt) {
    return pbkdf2(passphrase, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(passphrase, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(passphrase),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassphrase, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
    const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassphrase = await cryptoEngine.hashPassphrase(password, salt);


    const encrypted = await cryptoEngine.encrypt(msg, hashedPassphrase);
    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassphrase, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassphrase
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassphrase
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassphrase,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassphrase = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassphrase, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassphrase = originalPassphrase || hashedPassphrase;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassphrase = await cryptoEngine.hashThirdRound(originalPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassphrase = await cryptoEngine.hashSecondRound(originalPassphrase, salt);
        updatedHashedPassphrase = await cryptoEngine.hashThirdRound(updatedHashedPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassphrase),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
    const decode = codec.init(cryptoEngine).decode;

    // variables to be filled when generating the file
    const encryptedMsg = 'a3a862d2bb52c425446c9ebbce765f92da3bdb1c4b402b0920bc4d64a80b5d69dca93b4039f7407a43d5959fb6f45d962f9f938a6b0cb4fbb50ee0c950fbd9ee214e39dd1f9e3719272041a2b2eb4d279b51c132db1fc03352ec576a3ce7b7cdf9908a2eec05ecec67bf360e11adb290415dd070c2a2b090b6540d51c2b6a3e1370078dfd76b04c797cee60620098960de7f881f632abf4b29ba4b3702fca35b8304b91572656e5c06297300d62df5da9c3adc503d7b92015109be073382f6c06afc34e32fb613d2d4d063a666744bb70bfa3257a8b27130888c865ac134f6ab940b80aaf88cd7ac5f06d779e7e03d55dce035e4171dbc3fc5127c1cf57318c02466e7d8dbadf3a350c0ada50d3e1ac2bd6ffa035116408e7aa7501b045d4c73704df6429dc1b74124f09035eb5c78b5ee762edb292ea268dd3c4f61416186136a1203d1187a9145a0e587488570ed106899c4e4565b18df9de333d143bca46c61a6031aad8fc6c710f3421b5d21c615c74b97ee3174379c7c20152c6e8027c21b7927891b2032d3483c344027c03590c86b092f00493453fc7dab1c922104f13b7d9a94aeab637cded34827eee42c38728e59f7dd1f569c7e2f13b520c5633c59be75be03e9e31926fbb96719c4a60934f416050674c3c358211351159b66a3a4f54ced4cc791fa785363c1ff3cc82bdada69fb3c281c4b97bd4cc127fcebf3590d0a645fef2b505b5fdce86235ba32b0979d025daf7376f5795de9a19601fc3bd134ea9d07681fceea0b1fbe64c5b4b667403beb63d3ddc226c5f2cbf0c0cab3f7c0ceaf7e6c694d0dd1723b4e7a4adc58121ef474bdf5d9c59620304239aab5d689f93343127f31f09929e2599f27c3b782bc69544496221b1a39232a3aff16263ffe0b17fcc579c663db941581b1309d96c593ca3277239f844728dce58c38878c42f80ecd1ba28493dcbe6097a8fe26029c891ad42df410f690968d5aff4edc990c9f2484aeafe64b90969af3853ee1c5ff3083eb86dc1d561b225653c954dc1535751d00c307af4f8922535caa2e2ac7c479fafc69a1a541b9f340e42f233869946bdec5c85dee2059c099d840fe95c888a37b19f173e3707d282c4fab570b1d5ca0b7eabfa706a2bbd96528a93603d09949088103c075ed73fe6a370ec3c50b3c6afff43b4ad2cc70a5ea0c58b9ece9feab180725ec69d43b54a4a43f773e5fcd79a54073512e2cedee5790129a048190ee37751eacfa765eb1e7cd4d0361411cf9600dcaa2d312e2bd9e2199dd956bc10420e51285daa339d45369998cec0d1c8be3248be0a11670d2706e08f2d12ac4524c0ef006638df34a0052a230452f1b11484e2205c8c201dc75dba3a1fc1b318b5534dab362a0583a6f067e8bb4464c04417acfd48fb8e985882c8b9ad26510b1c58fb18f9e888e5ccdde2bdbc11bf612a35d85878d4222fadad8874027343c8af9390aefaec00f2f059578b2f18cadafd24df763adaf900f7c667c46bf7014f01cd18925ff03c62a3153a55d72e9464527c85fd30826e5944a7198cf02660b5d8cfc34e9335e283f3fdc00de54c4a6f1d40482d2334815a418ad0f818cd015120ddc47285aeb5fca2c3e72dbccf3e95ec568b02835223b67b101912cd8d3d2c77327b1d2d948bb678b5b04abe181db3bedc9b3c5c81d2a88b0534b59f68cfe11358e7f5b9bf5a7d91647614fd0d0eac4b19374367c19d56a7b8484af619c7ad8f4d33ada65fb731dce93cb076ef712ae6da3a1604a05214d9600ca394f6dded59c8b882e1b219bd04b10dae9f92e5e8fdc7dd10a882fe008b85969c3f5284cfccc95a300a0e99df01f720b2f61ae434779cb0734e1c288ced928c6017c6635d63f9f55127c5565653c727e3b235c2d51e7ac97e89e3a9df8bf4efc58362878feccf80198bf84c900737cc462e6d2ee67117d158cf9c876b1783b3af8b745a949fa7de551eed9bc3dd3034593451ae5960a9e1a691dd27cbf6fb28b242bdc7230c8003efebcf6ca0c6b64e37de76ea6632fba69ad7aef8355e9b37cc97ee010f0928577b1ba9781f2eae008b296c4240e29e8572dce21a1169508f83e2a99f6a6d2cee4d48ef8ce34b34d04032d4e774de46a562ac5385d423a560e7c5d9cca6182128b4aa60f3a8edffc633c14b774b9251991a15b71c81c3269db855dc66cc4ae974145a7ee021200037381ee97c88a7f90181764ddd3294d144f76f46511d89a62256a0fb4907040294e5035e338c19dfe647406086a5f73cb48e3461fe848678e3c124b33717c4864eb8bc4b43b6ace877fa2560a4c80a3985fb15dea485029b414d9001d1cd469773755b3abe20cc920ed4431d6733671b5bd0884657aacf32568812093b8e0c219335a9a94af0cc2f0661c53841fdf6ba31e69f74cb7d644e4fdff4c71ae417d9a91fd9029f15d53e17f2a8228af148519e357fab56515da8c23411c31cad072bb1c8600b858daa1cd8e97b9b21289eabeee0e41224202043af413df2fdf8e586d909f0daefcc6b6062922f64ebddd8d0c9405ed958e332efc6203ec05fbdb591fc54f45f3e1f071772707609d23d7baf17f8a4404e51c457012c0be8aa6551d85db1220f27d033c6781d1abb6b46a4667b4eb3963e41a49975b65947f0c80e4346d4f3590f446f996059099bdbf4424af67b0a214d77b9365fdc65ba6817c1496b9e2e33c4285efc62d3aee2badb1fe695ebb5875112a96581db0a3d9bc52b3f85d62d350c2104630011730e2325ec025e292558f9a11e687b3001ffc07781c8df960ab27a9daedf87577f6881e0530cfb4f97f77ad4341fa08de52523ed9525e6f4730b8fca17308ac3cda7847ed9cd7d1c3d67ade618f9fd3504fa96d4e400e2ad3094c92928cb7b40ae09a66c6bc3f9bbdbf897040204d0e48445a9ea85cea2bc0657dcc4eacc5692d5b6b7efd758242b2b95aac8371a71ea263d521b28e0ecddda5d055934ee7e83eb0f7b8c05e2dd622f8da568c3d8164398d90ba9da18fb0bd1d9d7571adf50ce46fe63a2dbfea6bcbe4c03bbb03749a69d30d516e8aa16b226f8f73263d519a9d3447ed06c8f0fc8381fcbd0ccdf560775f5c4f320057b6a12cabf416d82387f6b4eaeb83294cc340bcba6035f0ec35c10bf503d46811002da12c6843c890e18ef0503d33be92066215e0199d92de1c430471e79d6bf967976ca7de0e7ed83641b2f129bfe1d96844d3556ede5060e0116b8d9399b7aafa9e2e27256f5ddafa28d85505c4724ec13f34d8fbe82c6ea962f825d209d8ff9b9894a2377780fbe7f480f64391b28aad0ac2283d4bf8bed668013dfe241665a3b2338a94a5779c036ac7958322af9ffbe39da10806a6a314728d84e380f7ae608015c3b03dadb6a70964b761bd73e761a4ef14577f381a6dac0659c87c71e103f65aafc93138c04cb56d5996a8dd330f81589d00fabf45d8ae4057320515e26c7071ebff2a54d6d4cf5070dbdece4973b6d1174cae77e0f33cfcbf5c5e56487d24e9ec1042484ae0c37b635493c2fec7d00901c4758e60ade4e7b83f597347714b894537d87cb9bddf418f6f6e488bdd0190eb61e3369eee249df3e868e4a589ad237ded9223aa1c28b303479eb05c003e2a3be7a876eb2c42ead75364e9fba30bd9dbf771de24e5311dff925bedba7e656a0b759248975663af470d6ad30eeca9beb196ac5e1e705255ed5771d494a58922bcf318341a0796c7dd3bc010e1b26a4142b80f1dcc466e973472fd9085c9c1f198146534a2ac8a55f28061c8ee8f0ce53beb4c43b21d310146056b6d2a3acd2405281e2a32183989cc9b88cbd36443ad26f7bb1e24e98ecb27d8014dfb40b561f259ee844f6a6e9241d7329e67ead7a238c8cab989ade6b1255298299a99018935d80824cd8b378818bd7a2587473bfb77404688ab0083afe65c25cccb0c2cd939837aecb69f673e68e2591693f2ef9abb90a4be4915fee8abd4851386c0723f356f053b093927d3762d4936d0db700a7bd4820bf5ad1476b2b13d34eb3e4bfeef7a10fb867cf65b9a3f46dc6a5cd0564b68f3c13d1526c9d15e477f1221ffdbae53376ba4a6104044e2933282d7cfae646bd92fdcb010f9846efecc79fbfb782a9ed75d350033a9640a6cac63ba594046ad8092f0dd21525b0ef2e12ba751b8567e8daf739336799ccd602e958a4fa661b000d4370f5d8c173671fd1fc142075d1bcc36668617e5afc8bb03a3691aefc20761f823446f3faebffaac6dae8caeeded22d8fcc855a1b2a389124ae7330806e3907155a6a2687362be0be6ec00b4afb45b48b12b85abacc3eaa5b20bf78fe196e271f522557f560ab1de3cdb59416ed8952d8bb0fe3563b58f4ca49fb70e85a9d725a6f428c55217f94873b0865cdbf4c8582960dbb0de88f6afbd0225ee780a57ba7cf1eb9b18969673a683827417c38f14901a3a11e1329acc0985a27964aad43df6004e40a6f8276968a51cc49cdd0dd16c69bb7df621921c481c6838d83e74be3192f5046bcab6e007a3d00754a0d3ae34a11d2461a6cdb169e47f196ee0caff1b4ddf9865515746c041c42b16c0673819051ef96ca311176acbd738a9b09f3cc0e67c01cc5c69662c24679d1abb088c0999c5bc36721cff4cfd6f8f7e764a437bf30a354a9e45ac89a606f047cc0d3275df2892b419cef014669b961c81437d06be6545233d44889fd6e10634c2b0b792495601498944f489153c0beb2ddb4e1690bba5de7189606efeecc1d8279e629e4e17346a50bfe6591e521e388c191a85c5f3d83e1becb1184b2cdc0049816ea5f78cf321c3961f3dd957a21f94e566423c2baa97c714832f8af8cdd3b81aab77d12b06acfee7c60478b084f5591deb82caaff52d4c1ef580e38153f757cb7e3464d7ab372528da821aab759c4bbfcdf5da8888972f475cee7cac010c1b02c99f9cadafaf92c97bf394a5df6004211f5fb9c7ca140531dbfeaf4801eee95392aea974db233b1ae4a059dd4867c233d7cafa6e4e167bd10ab50d2837e4ef7083fefa8eac44d6bb654a6cf12d22bc367cc9b92e1f267f9a28f5430c59d466578cf139872da305ff99299f19b953de75025ca7000a18532dc93339c656e27c38e06ca5750774c376b25f0c075cce7f865a757fcb2e3e564f89468ec9323108d4bc9b9cce0edb71805375c641543966512b0225a8820b71bf0b0405ae691e5444b42adb3e0243dbeba88337b6ea1eba6fa4dc998d971b9448ed2a84ca84298c90a6970ed9e9ad853ab03d01cd215c28d53a2b0665126d3f8de39dde31a9bc6e9574e84063982a301549fe338296eb3b80206b8466efec9226fa8a091ec069f173353fd5b845157e9b7e353c949727b7ecae6b7371babaae427e5601cad0b8e5f7adcb4aa8994899d7963e7cc226c23fcda33cb7ebee6e2b8ab90919f1a1bfdc42b312dab1ec1485c3c17e7d1e285b13089285ddbb9223ae3cb657c640c0208502dbed7f45f61345dc8c9f69c1b03cc4b38f6cce0628e4e6365515dffdd1022aaad8ab4be40d7d9ccf49000efd61462a2266979d37d6ea17e94129bf67e473acbb70983d3a1b8260c317dc75471831c1fd0308f809c5ab6173c20efe05c5a20f6feef0f082bfcf5f7b56659fecc64c5770621aaa8c885304b4036fb79b5eb2507eb0a498321fe79fb7f97c4b35740744bd41e4dfe2071905ad8a216ea52d057de4d1a515ec5fd51b343d625d2dfda34318556d5257f0157435681c8217df06ce4a9a0c7065dcc33a79976410c007c466009d28572321b23922f7988aad0a9974c8c5f7a8bff8677c69c5a547850eb3e01078e3c8dd31fc33f2880043b68d471846ffc2f473a263046943137ee991940943ab76db23babd9db403b280cb94fe72fd105ae3978305814cc50acc35fc3bf0d382c226ab267402236ee76117ae8060845eca16b87920c25914583b744888f94f248383a8cb10185e3714982a1a45682dd412fd90e83b9ac3c3e84058cecf68736895e8cf67fe322454afd2616d22dc213bff658a99bb5406b7bba24bf816f023d2a7f6333a64a484f6ba06b56818dd11263fa17889ab30fe236b22ca65ff571264846c210cd9a398b22d45c59ed8d164b43cd978d9d8c1c395d4d50bd85ffcc61753ad292db66f90080204567ead8b5ea5b161fe603d45ab6d82e850e155176a385575a4039b3b868c55140c84ab9a5e4a08e2b8845aecb6c905027e5f7ebddc1b1d92384e1d1ee0d8ca83a82253de436550f92adb3bc899af80068b1a3a539209f260b57d58465227134b2fef55c169c88c337e0840f9830c3d32fa83f1f1449778c799dfd7c4c58694ab0dcbc6e4b0fba19e6ab60cd141f672c00eee719f6f87aa9a2a997dde6eddef1105aace4378bcbed20c110cda5a53630de438ed7613b61108922adfcc00e28c3137c48b794dac976ab5d2bcdae11de3c4d6c692ea92145f3744ccd99e0bbb4bc9b286ae1e293342c4b8b3420784e3d127ee897dbf89c06dbbcc9f1cd030e47e89766a79bd5bb3fdee41e2c732df0bd57c1eb49e9c76e457ac2bb03f664ada53e35d064c16960dd4657d20edf3027ec782df0909d5a85e1d371982c507b616762acaa652c0afdc979363ebdc60dfbe3eeb1895a4bffcee0dd2e9736b0b687aa4899b4285d639c6195676bd33eb9596bd8384ffce951329a3c87dd114fabff4326bcb97b989e9b5690ba49674ceb38e655cc7d0b4f4099652f0057c44c882a8485275ba69d1e279ec1d2d3a92ad1ee2611ec4651e31dcc64e5d42a8cfa84a7934d988abf4cf298d5d3e20a380df331054a72f88b9ceeb9850c1b3018126289323c9bc94d9aa73d38700a87dbddf9cfd63c0f3b2887fc60eab8bcd91503268656bb7cc901902cfe265b201d6fcd058b58ca621f5382e3fc0e6a3d315e1626ea52fcdc287ea5123fd11cc3517badacc351506138cd747696e0450dcc3cd7e8e079b713d98450872439d110cfdd92c86ff2c85f553d41f28245941f2cb6abb7d1d87a0e04431b104544e3af877eb17a9fe6f44528ebcfcb4a91205b419a46513a0110c9a4bad4723f8401a7689b3acebdf37176ccb7e2086b616f186937bc0139be3f3a510c6344d62ee0fcc454b140398ea0bbd1d96cba0452f376b15264f93cf27e1dbe32b61d7c6c863765b7beb7c90c9be128cc1fc6a6f99b90e6d235efe662062294fb6a9ae92433fc289983d172e84ffaacf3f0197320d45b38ef04f93446e4b7a38272fc5abdaaf58542fbfdc79912dfab19e03ab03caa41f290c1b043d003c8bf66767c6e9216950da0f97f54648cfefda213f6a7f530970cf7932405213599389385a3009c9bc4df84d2a3e6f5ae9374395e3ddb394289ba725db778da74ccb5547a9a7a21c260cea9e17de75df44ebf69bf4b1cb24c93b0dc032ed72ad8a7f35763402401cb131f9d394d9d12178d1d201a23b846206f26c47a8e682ac97966cc8da009e37ed8fa1af4e53461c72753caa9cb58be1c4243a9e9faf419c1e5613649567c014372b39adf5b8e68eada2aa5dcb3502486014f201cd60e4a1b3fa64656d14535df497d89e120fec52a478cc452fdaf057e7ac3537b7b4330a0a54ae6d4eb588962e156ec0a5c199306be0553f8f1f1f7ad4364ecfd3bc13663748bf04b23f82b7d19047bd9c65de11fcd69d28e860cf02ed80990bcf8e0e9bb9e189ae8acb9ce22b9860f862391a54d6b23ba9435985845f268bc062253c87cc94353e3536383d5062cbfcb4bcb55febfbd67d9b233b96fc4c72e69897c1cceaffb6aefb2af6b42db3c350eeb325a5f45a16b7715df391b8f4ada49efaed5f344a83dbcd2f1796809a33c2d0a4174381cdcded60825751fcc1f7966dc4b843c62dce88dca7c4885e9ae5d22bd72b4770341753751bb24387c1b059d1878a2fbdaa344fed15fcd2aefda9b597e34f5fda055b03b7bc05cc532e7fa7b646afba80e356f09c4950bf4a3b553ee47d8726ac8580b1de766333bf28d02b3f39e4ccc0ec251197a3ec3bd011f85e34e13318a8f621caca376d434aeb5c21505e119e3857b06281cc98b98ea1dd24e1ad7c8330cba0d08bb7f14c55de49539d81df96ce1714f3aabf23b5df922b9c4b5f39ac0d2900e720a13c494da480d7adf66878a1f5f3783679256279ff66608afb366d9201ab6020c6e36fe20b2abba9837ff3d923325f967c4829f8cd42d129c5c1d2cd71506f084a7836690348196ad750896dabeba52fc70ab058a775b7d10d4917007974b733aa699f6bdb67d89a74321c3fed047dfbdf31e7234fe380e45ab5faf375f6cace241bb600f13b6854477d8817df0a2eef44608e7ad93b2036648e179babe9b7ebbc7a3189d338f0da421a39c23bf6f95b3bcfd8e644f478d49b4649e1ae71873eab2eeeb4ce9e8e963535eaa5a8b334769ad72e2cede20508600e26efd3ea4870172b1162c2c35bffde00d17a099b6da0c2ec995f6b63d097bdd4ccdc171ea75d2f95b1c9723caf3462e7356f721173cd5bdaa69f4b3ee7a6739c549085b530eef66d2f3adb18d745844bee0e859136bc8781d7db1d5a99c75c3c0e0014dbec7c65ba37b42f09a766c5a7867e66161d633bb728e2776adec5882b5b7c19f0abeee98b475ebbaa742f318f38d2abfc376a3d653f7bcc8f6e997b7a8884685a2129ccceac97838cecb2feecaf358bff49a2d08a3e43579f7d7ad6ac1f0ec6d1b082851843390dfdcb3c54fb2982230682f7b5e40baa5a1befa03a1b6381076b74b06dadb1029d35c91d1561f37f866615154548453a2c515745f339c128001846f6c62f5c0a6f33495762716665c491bfb6d30701121a93b4e2a326e8ad251afdf5c018a2b294383ea84b4879b8fb7e9897864674244ea074e2915880b75c7c10b31afb3897c81d3fd568b0c544f88f47c3fd2841a5602ec1af09618e7ac569c5904c6a54b6faf878ac71e9fbd0259375974dc2dbe6f677fc8000689adacbd729f57f992ef64369a60c8dce02ae4fe5336fa50244d488e2751dc3d8851cdd9e85dd312a5ac96765971ddfa79695e2fe301407c836cee366ecf82887ac11e9201380bd602b9ba284c1f67fa1a41dac7e347dbe1f037c8eda5ea8230579dae22195fd3026405b8df88d5c54a3f1f2285b2ec544bd705598d956b83ebbc9e91d23330bdfcf57c68d00123284c182692d48e5dc9e1bf4f4192387c4a7b5a8400f51dc1156137c90fdb5149f8418b8023ba8db6f1bb13ca59ca598a51491d8799d6f969448a5703be6dea370be65dd76e1bea0e6b9959131ea38486264473271830d8b1948089abf541234a96c904460ed8846e2f5540414804242e52d96fa52e7d7fe506174af2fc9c92c7ba9b67089665dc42c6c54bd990e1aa0d273028d05f4abd973d84e519d3d44d3abf9da6ded54cddacf9d3a198605dae9f8679ccb106f2764ac21752dcd1775fb682c5af452bb5ad893e7e62e16e9d1e5cb5997bdfbb3d889caf56de85ac1f1ae6f8238f244522681bf8b67261fbb9d176e45ce1e5768c9916915997ce6c335055cfd440bbc631ae543db1b59b331e71d5146e87bf58de03e70f56563630e215fa4b105e7ac21ff271c311ce78427fbd0cf576b7c51719ebdccbd9f2e979d2242f5d08a085af5312e84ac5d714919fbf18a23c22c8ac8a64e0f5a0191c8d47c8a726b92d7c0bf894b063c5c6da7cfa065d60c0efd92ca164db278d7f1282bdf3dc464333031d42286e891ca30e90df091d041fad5dba4dc2ae996abae25ea1453eb57b2a1b557000cb0e6848ca7c5c10f594ac1407a2d6e55e19e097f5913c3c1804c443c28b1cedbc786760173e6cffa25ba7a89bb997b74c611dd32bc2f73063d985c740dd056671175f0dad40d970ba57c95789d73242e68a2f09e59301d8aaf0a831491bf28a1cb7ec9ea7f804bd1ac48ac16e06a6f505e50c2289e71c266dfc17f20bd3de5f40721644abcd8c786b63aedc1becaaa1f254617f88bcc40852b9ea288fa87d09187263f5252d0d4fe604ca3a94e3dffc2ee83f18258252f00f5a1bc98798e9c6e914a560fcbc856c63ca5a5211fb8a06efb4786b17ca1387c23b1e638d1b9dadaddc7d2afafa5ffe241a3448f77d966880083fd3ffab9b3be7b2de9025dad79951d99bda052baf8b99b7608c78bb2e0f94194288a9a50201ad5b9f9caea9854d9ccf7602064391347459308a75d343db356054aade126545df90a918b6ff8d0d0d7fb151b6ce3a39c2dc10ce9a03788b5102fbc9da8f084c9abb7a979c1e87856cc764302b880c07756ed51b93795361e54b52581aa405cea4ff3600d2a56eb3f643e3d44b751f094c4045d7df96a6f151e75a3852f8a1cfc16280ec4dcf289d1a2fcf59cec93089316d676b63fd057ac8a51d757ba2167baace42ad8be477c106eeda34bee831122ada4e4812b9bbd26e1cd9cac3251d97fc0427e7c093a6e2470474bcf3f3f21151327b73fd4b1f763e1d77768c244a925b8574bea2af8c2bd227df9f0b4397ca2f61047fedc255a7163f971ac9ea28c8cf1f9ea1f8ff8c16c4a31b3d72f9a822647156baf45e69654ccf6da0e78c85b2df5a15466474aea3b7d23d37e3c379d604d82645c286a497b23772155d943a96ce4af05c478cd9f99e6d4a2e720476a1549612404e559b0d10aded0e79f8e38d5b4f6ee178d5a6519b546ef9d4333cb13b37aec6448be91653d3ef859328e16f08b2d175e769497ed7103d82b8e1a0886dde2c064b5a06f55c34ee2f67c72249c17396fdd7306556542004defcf9a06cb6ddf41190738489a87a0c5badf1dbab078199144141cdab4d40f76c7d46eeda9f2441a9953e49de0726896b0e386e34b9cdb68aca020eb44ccf67a30b0a1be5bd84704575a25ee8aee99b83cc067dc6cc1f9665357c76678c3793f63dcf145ac7b71919b13cb1f0d49c44f6887eabf74d86148113aa3d638881221fd9feaaefa3ae22ffd31a54710907f54abd5cef78bf98f260ca094e925372a3381e304ca1ae5fa88202e1aad407d613b11d82474961cce1d5af07632dcf658575ed344b801ce2edefeaab0699de1561a75b1a0ab3d708fba2c500847949d1e6c3c81ddf9ec547126294e1c53657f680f1e3e93004f383a44cf253d9dbacdfcb22834edf1c71e380669910022b134628a8c536c634b440b9de7bb9cd1b601988e39232659c6ae88f968cbe470dda54469c0f6e91871f9f25af04f861ff7da7ae3fca84e7d9d693a9c1829b9518ccc8ba6e624419863ccf35a39d9b64012edbad944c670b679f72290a550b7dd53fe4b9c6b6545f01dd628fba4ed39654843591386ee13ccc33b81455da7a5137ed34b6f3011fb54ffcf3b7fb0584b33b26ffd286c79c5378af9e40a5d9d59f269e8d43c94949a7a6886a2b9b074cf2f134a5c64b3b4cf5e92c04f9e965c3faab7e40d02a04771a8f5b2a9e73f4aeeb132ebc86a9b277bac46b87dda8a7375e9cd23079c8d74dab145708f17a9c32d6e531db9101b3e8d54e3a9c9246cd5b938b02e2c95996fab5e2308b46778ad5c6ac4cd062bf0ab83840d67556f84e8cb9b0123ad042baf130472a3da150d898c2c11a74309ef12cdfd7c43e904e6273ab737c91915442bf65c6418ea50923a2ab93e4f590edea83fdc78d877a6f462c3a249b7e3cfe7e566194b7e21116e59aca5c03867a235657d9c0faf9369d758ce9472ee660102814c853c1ef45248c16d37095ef8c6be5a0c10ce9d15c43fc5109499b5f37338bdd9ad97688231f33702b90c5a369a0480115f9cd9bd2e62361d3c0f5ec09c0223621fd2268b949f6c91fa3f745c46d07895535d58d1ae50e03ffab964e32c035b7997a037150ccd817000670ecaef037eeacf618cdfccd46476b107e9f800d608f91260d9db2380829c6278733a92891d2a1a4b72f01cc7c1df879ca55b3aee688422834f7449acb300d4f8b4503b40165180b5ac364825195f5cd7873fc4fd90d21d3b5179590436e8e3d0e66b04001cdee8f3c0e93c22134881a2ace12ce6b45733a66b4fc9c7cf20d60734755e70faa39542bafa852fecdef4c00c0b278996d182d4eabdb8c817a05db6beda8d89cc1732d86f52dddd5ce7c5dc12528474c1e1f7c8c721aefaa2b37c3726424a85e611aa6da28101c7578e5918fc8b6588f5997b8ccf460c8fb88d30c3e89e7730a9d296f7610aeff5279ab1800c2708a6012ab9c7d6a6df475af91ea943f356baa738d20ee09015a5c5177dd095a7d5a2d7d713777ef19d905bd13025a644f0709077d881ac6464397e57650e0e14062a73c37dbb6a8b0fd4f68d65e78437d2b9dbe107de08cb2a0b06b04abcae9d7c11fbd92b1e03dae3a5ef56643745463798659951160aec1cc75d88ecb66a7a169a1024f66f58857927b793f63f9b2ac8473f43c9872db04354cc441eb2ec00aeddd47b578d86e184d5b3847d839d9154f974d76375eda4115d41d8e45bfffa4e8bd5ded8a9785b566f47f24c7991ef920284900248d4dc9d24bd416d85c9468605b05cfebfe516be631c9864164bb5abda817b18edc88e765b80ba42d8ee9364b80e3299a3486c43874b80eb2cbbd6ef96d6c7a8b49f3dd849e09edddd39f9f43a02d82aa38d6221d8881ea36153f1684428781a1d6f615948413c1a412724c17bf56ee67cfde26c5b512d5fa9613ee71b8f2e7e66b1392f706b2da724a60a58841a28215228539793135056b3ed0f95fcbd8ea933c670a1087f197b8049f1b5afb3c7cec51118ff7f4029f2cd6ab88fa297941e8aedb5ebc2ea92e715907a49b45658837d93d3cb68ac79b0f39d6323b66e031dc8a4c412dfefc5edd1af523ac7899ca1089a82efa166ee9b4c060946202c938d6223854a54dac484fe651fb68e85fe7e3c68f5c665a4a4b3c956597550e178a294d786f30abc9c91aecb3afdbfc5479168fd0feb646f57a06daf5de4583b7fb1e3a9abe39a954e1b8cd61e17c817041b6ac7c51b2130047f2aab3598abb1387e7c15b9a7154bd3d87d4bdeb00033161fe1a1520e13366a3827e8638d9f6a0f5e890da117a66a78d55540aeabf3222a27da43e87dbff80eee82a555298bacc696bdeec7e0a236dfbd8750b9d7fcc852b81b942360b5ec824f2158d82d9a1565a9ee181657982f8dd72ad2b3e3e8be8d882cfcf2072baba448a8d03fdac8484766ca45a7ac84b4a7c01b4a1437025aa54a5515e222bb7f4f252b01fc3cc2ce950afc18eb1c0298f93c3b3734d4968eaf581cfd64e00d4df218f699168abdf75ae4b8a5e63c85b1ecef1bc0a557343c74059b5553e4cd4e5a6665257e653a1f7c43874daeaa9f4d50e25b65d7f38f3707b38826e2091a0377182391af53dcb1539bbffb4f8a3826334a33becb497c669ddf07bbbd97775e1fa5364ca15e4ab19d84802094887a1fc64ca763b9fbf7b3a1a80ca617aec7c37a8af2b9627cc829355ac915f5a2889ca557d6df4ed47f6896e8ab79fd7e93c50f28e616433c8753ffb585764987079eff25a3eed9f57209e624bd8085cebabec7ca5fec9b2e97172701b908824e85c4c95cdea65bb04f7b1af8a7ca47e68a6d0769b282276a13ea72e22720e512829d4b75d8e1eb538dec41ccd08c2005c25f68787f424c309e9356da854e48a73dd71ae299df6f0134c8afdd33c4b1cba0c1cba9d497ce3ae6a92e752a452cff0923accb9025f7150eaa04c9cf4714b6ae6835ed6506edb21b8c5b4a6d1c5db0984c94ed69dd863a079177957a803338b8cabee4a815de37c5c9b37fa812ac3e6d3988f4be888fffd735196c5e58a2f96c2898752185560af0bc0030b9040a84c6931f88d056b728a0bce4f1ef2951163f63222bea171db867581483d712b5ceeb2e89b0dec9e6aa469090f45d4482f0fc8dfd6eb49a940ece8bdf3c5cd626e8dfba5cde39c35735118534b941a07c6da57d754d5917e7c7ee2016e5db284d4f385abcdda6daa830fbd636804d680ab48c45dc940ef48899fcf6d8a8128ced9d4509771a43a9d308fc4a8fce742e922da7094317ce65645262d443675c34ef2af74ec633257c5c42395061d125a91d8f67d3a13021b3183557c4f10cc151fd481ec62f7a1400fbed4bbd46d7c9b1aa0090b5247508258924026d011f5463e65ab6b6eec790a30bad82756daf67191e701c7d2e1dd8c1a5d7e162d69ddbc397cc56a8cd8599dae93a2aefc3645eb3044df4a25a481a4a57925f6b581796f99570c62168b904a06b5e4d61acd5508ecadfdf5385004f4097dd876ba29732788768876161b5299b55390a17af0a0a4b853c30c4e7d1210fc563736e4e486cfd1eba92d664f6cbe54aaaf9afe31469695278f7aab3b586b16fcf5dff98aa4eae6249c5f24d4b0088cbdb8ebb79bdb071f62fda22efd3cb32b845979f2da0ac1e2945adc8e68e9cdfeb616358ce669e28df30ff8f785d0b288927f18b4057a805c7750e0b9f36da77441c29eb2ca6ff99ec81487f4c8b4f8c7266e1d45ab22b5181d2e009d642453a3726a1203192e50be63883e4aa442c5cac68013f8d72ef3cc7b35d7eab469ed45e9a21206caffd3f3eace68ea4694e9e26a9fc4df21ebcbf79a1bdd464b76f81f7fb8be2b2b76af660c138dd003bbd2022cba5c8a837ba12a9077b2f5469c7f16e367dfb7df6077a6a4e5dbf2ce0f1e0f698e194ed1e41276d4e1a724fca3126345a3247ca69cde0e3d5918b0b7646b92e903a72bc79f2732616ad75ef082a069ca89ea545aa1cea2bff88bf85b272049c99c06f6e738fb56b35c39c66a3948cc7898d42f07dad90b9f454c4b19700b85ced6114995ceb17b912baaa650aca15968e40f44f46728b9e74d9c183faab18d1f236f8bf7ed7109259b41d24834300c4cc33ef46af3f5a64f883237dcff9fe2acc5bcacb508aec7653d9b88a568f28c0ead708a49da1b390713e589d404b6cefc85ab0f5af0976fbc4396de32f62345084c43998afbbb3a3b04fc3f3375d4c70eb5c998d240d95ee643142518825052665e700e9754d1d9d42cf1c6ca0681682c0ea472ff7094cd23a8d7cc10b1e95cc08109dea31fe392e0d75300f77aec10151017d347ea3be88e03711844fe213bb92d5b0f50bbe6a440b1515bd72cc6ab2208b9ab459a714ad5e38a1afa6cb7ad8f0dd1a20e62c5518910782caff74d9eaea301a085511949ddf9181ea6d2bfcce85bfbae7849ed77398688ef8c7022f29ad393c3f1061b06b665cda8802f5fdbf9bfb0fd811b66fea872848',
        salt = 'b769dae761f99044a238ed1aa715fe60',
        labelError = 'Bad password!',
        isRememberEnabled = false,
        rememberDurationInDays = 0; // 0 means forever

    // constants
    const rememberPassphraseKey = 'staticrypt_passphrase',
        rememberExpirationKey = 'staticrypt_expiration';

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param  hashedPassphrase
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassphrase) {
        const result = await decode(encryptedMsg, hashedPassphrase, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        document.write(plainHTML);
        document.close();
        return true;
    }

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        localStorage.removeItem(rememberPassphraseKey);
        localStorage.removeItem(rememberExpirationKey);
    }

    /**
     * Clear storage if we are logging out
     *
     * @returns  - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        if (!isRememberEnabled) {
            return false;
        }

        // show the remember me checkbox
        document.getElementById('staticrypt-remember-label').classList.remove('hidden');

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassphrase = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassphrase) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPassphraseQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPassphraseFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassphrase = hashedPassphraseFragment || hashedPassphraseQuery;

        if (hashedPassphrase) {
            return decryptAndReplaceHtml(hashedPassphrase);
        }

        return false;
    }

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        let hasDecrypted = await decryptOnLoadFromUrl();

        if (!hasDecrypted) {
            hasDecrypted = await decryptOnLoadFromRememberMe();
        }

        // if we didn't decrypt anything, show the password prompt. Otherwise the content has already been replaced, no
        // need to do anything
        if (!hasDecrypted) {
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const passphrase = document.getElementById('staticrypt-password').value,
            shouldRememberPassphrase = document.getElementById('staticrypt-remember').checked;

        // decrypt and replace the whole page
        const hashedPassphrase = await cryptoEngine.hashPassphrase(passphrase, salt);
        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

        if (isDecryptionSuccessful) {
            // remember the hashedPassphrase and set its expiration if necessary
            if (isRememberEnabled && shouldRememberPassphrase) {
                window.localStorage.setItem(rememberPassphraseKey, hashedPassphrase);

                // set the expiration if the duration isn't 0 (meaning no expiration)
                if (rememberDurationInDays > 0) {
                    window.localStorage.setItem(
                        rememberExpirationKey,
                        (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                    );
                }
            }
        } else {
            alert(labelError);
        }
    });
</script>
</body>
</html>
