<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #4CAF50;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #43A047;
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #76b852; /* fallback for old browsers */
            background: -webkit-linear-gradient(right, #76b852, #8DC26F);
            background: -moz-linear-gradient(right, #76b852, #8DC26F);
            background: -o-linear-gradient(right, #76b852, #8DC26F);
            background: linear-gradient(to left, #76b852, #8DC26F);
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>




<script>
    // do not remove this comment, it is used to detect the version of the script
    // STATICRYPT_VERSION: async

    const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 *
 * Mirrors the API of CryptoJS.enc.Hex
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassphrase) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassphrase
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassphrase) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassphrase(passphrase, salt) {
    // we hash the passphrase in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassphrase = await hashLegacyRound(passphrase, salt);

    hashedPassphrase = await hashSecondRound(hashedPassphrase, salt);

    return hashThirdRound(hashedPassphrase, salt);
}
exports.hashPassphrase = hashPassphrase;

/**
 * This hashes the passphrase with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(passphrase, salt) {
    return pbkdf2(passphrase, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(passphrase, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(passphrase),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassphrase, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
    const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassphrase = await cryptoEngine.hashPassphrase(password, salt);


    const encrypted = await cryptoEngine.encrypt(msg, hashedPassphrase);
    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassphrase, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassphrase
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassphrase
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassphrase,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassphrase = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassphrase, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassphrase = originalPassphrase || hashedPassphrase;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassphrase = await cryptoEngine.hashThirdRound(originalPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassphrase = await cryptoEngine.hashSecondRound(originalPassphrase, salt);
        updatedHashedPassphrase = await cryptoEngine.hashThirdRound(updatedHashedPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassphrase),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
    const decode = codec.init(cryptoEngine).decode;

    // variables to be filled when generating the file
    const encryptedMsg = '292dd141ca518468996e7f1a0d3e40b92b7a586c1e969856cab951c50d3cb002bf4d42d01ee1413a2ca416b3aa40dc4cc87972083067169bf632a29e1ccf878bfa037db9970933e615137484f430faabab341e25facbd0be28fb5a0dfbf654be05ed7b4ad4d3128b416503ccae15bb9e049a4105c27228011d64bbe028665d91c043c9d6e7680a4bf33f1bec02865fb01fa9cf92d8ed93c531d15cb4cb1eb9e81f433d1d058880f11f915a452843ccae288e6b315c16c273ca8087b48eb0287ba5c90cb4ae45ad9996e66a1c6bf719e812a7bb38ada6c469cb8540dbd7c776e20f6d6988273ba1fea9aa1bb757db4b44836c4eef7eef14384111d36c51a25505141296c2920a55235b1cd3a4bb2100ddbb599ee469a5f320c34fa98a910c4654da0f0cc25d4a310889a22bca69e5a59e871a06ef51402f4eb0db76c74a5741405b8bf7edabcba256debd35cdf8670a445df8244bc0185e875960a18336a74801754ce3c8c9074846790588b11f4269eebed32988221d52329f31dcd35dc586b494b3a871ce123aa43db3beb7123c41a61581149b6b71dc5a4a1b388f5c07590155a7dc65d807936ac0f67f5ee5298d24c581053e89028ca8c2c355c475edb4ece8caa83499254e38937fc52872f1d816c3ae4eae1c56165e9db5f4e12721bd469c1790dcd8d39b01e8b1731880d490f79c6ae4263c5728f797f0e55b35cdce22bfab4f61737d28adab2edfe7d66dc3ecdd4ae1b03e475295b8aceff3c119a6b7e4011cd650b85c9d59f3448d2254348fef663af250fd0117a489bf58a7e65bba3bd5d8dfb7d98dcf4c855438b21ca5d540786b6c142f34892bc9ef04b0f167c43aa05a0bf17a33907dcf14dde14e8459b6db2ef72452e88bf079d25c5603ea201ea5216de010454f2e76919feb5fe240cbb86cf091a8a8a5a148a40364c2d5e822e5ce8f10d082334cc728abf807367b9206dd01eae1dbca0fec096af7e8afbedafb74edabe818885c5fee91d952aec27071f303eeed42207d181a0237e20ad9ae40b323f384d28480005e5379e8b636af3831149de504a2d3f53853254c0b3b110f137869c30bf7357b93755dca4b75dc181e6c931c9700e735f82977a913089481aa7af06e661807703534efab0cf366686584b51068f557b67924d8a29bf125681b3884a39f5d76a733654c2caf1801272b05b4305319276360f9e5f809f89cbc1f6a62337b495a6428a531409c6e377297e37cb5cf38112ada0c113a5ccb36886f6e65dabf51392cc3926473bfbf094ab83ff3f80c7ba0b73c905cb7d918e44b509cb949646c055ba6f34cd4b3e24a1f4864f9aa1115d9d42dbf53620ebdcb05611891e4101d55ec84dae9ffa268072736787f81f609b80b9478506634d4a545729d2c928a061ebed9f3dd407f38cc0febacd6e3bb92e6a9480e9a72e028add4495a25fc837a5470e0d1db424233ea41273aaf5720d151574eca235ad4290632fd4e5c7c4328dea103426816ebb34aef9219aa0a4cdc0e390a1e19f623d3983622c48f292bac976e3e5bb0addd86e3785a58f835ebb5619e95ceace978c99abfc8cd6a8a6e245093cda1dfe41f853697abbc0c216d80097a23d81c53842dbb2a8911a7b23b9b69c50eac7d2576e4bd6978b1a7d61b41733da872143ea5cd014ff352011e0a330a3a87da0a9ede5e8f077b4f3bd081aa97be6edbd51096abee6b4adb24244bf6cf817ff37b92d941a2ad78c1a95b4158be24f710fea88287dac31e4c49556500ecae64a2e5d3f028fa2b230076fbbebfefd40452636bb2db3322760087b827976529be4e08efa139664390d9892f3a63e0942cbc8c6434604a481d8df786c988ffd2eec09996a98b0c9464a35598380ee4f50156e6aaa88a3f8715a6df77ded1f1957d502b75f1e69cf19a93b7d4b2b9eb073e5536ae3fd1d007ffa1dc18ad22beb2f648af8092417c75a9710b2253f2ffbb93b2d3d3dffa3202b37f9026d2af827660f9d5eb47331830aa2ba460776c0d9309a20fe08fb775343831962ddeb387c99bf9bddcebab7daff5d8bc901603d18418b2f5a8102404488cbef65d640b35c11b11c206dae2ef597ce1a8706a7a113caf23eaf9bde9a63de97497dbcfdfde41635a8461dff6989a7390758a02021809e14a24cc23251954854b9904558385d75ae1c7ddf0324cbbdc2c9bd1641a15f2d6bd1c561fde6c9d1ed89dae40e55c513c2c3e88fc50940a804ae6d6b62c569ab0f47f01158be99c1a18b5722292c73d3b49c5f5245a2afc5e9e5d42b8ce45dba2e0abecabbdd9e6fd08104d779004fcaa0614b965899e22f659a2e4b5550e7a40b666641142e7a5835eded85c6e241ab91b1d5408f9ec3ba5f1e4b2f7e1cc7265912ecef09b3249cd9c427d3748f2b37d347a5fb498eeb5ae70a43c0f70dfebefaa1c6b79a539d9e475d6b86bea61c78e5287bdb216a36e5b562fd0d53264f4fcf09801b4766995137a9d2cb893ec3f5bfacf3d9c48e0b97b543e0a1fdd1e812306377ac142d1ba4df802fa07195bb88aae44b8086d3a125908ee8dc53b77b8aa8a95622bfd5f3b6ddd9d80a4b344675c6a434eccdb5ed4efbeaca032742004c0b7d1e5f250a7efc46d5c5c11d76fa509b7db8fc3c32b06f5566fa5fbbd5a1c7aff4f7276e74f231f8d384fbed594439397b8ffb0ba902fac4e3d1524c3e7ab5c996ddc298322d6191d261d522e524f315d35a590b175fa263ad5ae3533addb07c9d8b1733efbf21c938afb1980ce7375096c4768c38bc51645c158d9129a4cc49af3847759f093253be4e10d05022a9e48bae51a0872f3ae986b725321b2a56a50c2e3843caf68b75f8ec5cf38bad20e4eba0be2f9c781b8fa2039c38bb2db7bbd463f0401e4bf68cb227fb87404aa3c20a5d4b4a8b0ae028df3cf643665658e393d35565f1cc9ac813b102346b42c24be8091386f8556c4aac03138799cbddbeabf264e9c8eb13950ae0db38a10a0d9d0e17a09c188dff72411d3892f7a8df5c401c62ddf33fd0fa733e1d49af80f5ae41db66cca5b1cf95db4a485e5da0b8e10c51bc033bce8d238a2043a071490fcd07d3efae0bfbcf61fbc4835800b77759836d7f5881c95e25b055b6d186bc6c35f9671badd3c1fbf52b859e5521ae12462e9757016a669289ab04499a4171ec08f6b1b1eb5d511cce210d75aeeeccba0930ff77d414ce2602d3f02cb1f927c38db171ae5bdc49dbe5c1eaa006301c5f1bf9b7f44b5ee399433da3a95b29da7b44ace5732b3750eb8a361e461a18d2deff2277a1f09c032f1082624e040a81f6132ed50890dc35ebbd0af9fb1e49140d9a8281a5f83a69a3c160fd7dc8716f508312e3e762d4ad20045a32a15921da3b8b9f2fef29487e4da3e51423f669a5d9f58d96c78c4fb75bc61a6d4f5a5be0b22d8ad7ffc7aaa28284cbff75f0ce24929bbc2246172b329e9b996bcdbebc0c949d23d3bd4c3bb67f91876ae892e21e088ab45914516258a43c32f464f1ef15adfe013e70fc1c004303260413ef53b06cbc23df37896d1365514f323934ae8550afa211933d840683b2b97b54d9ac79e6cd86d051522ee384d13e2463f67350be4315bb6262b4efd2e2844ce8005edefd06b36c2ef74cb59b95cb04dd09e320e1e1b09974a92220b2969688036b053a70f4e7188d5e1f2b08a59b5620d5d1ba756c3f9c06269a95714f29f47175814c7e77ef84b29cf693d9f6a1b47ae39af71e00d582ff5b8a467c7089093f96b9f0118a8021880dfa782bd978bc3ab7ff7ec12233acc3bf629512cdc4a2fccddcdd550d9e014fe7db3367fb324f463a1f2eb4d6d5b5ccb7d30711e0ea09086035f5c097903b015780c4e425108bd050afb37ad51a6076e0a8fc729592d59f6874e0fb20cc229d3dd166c7316381564da2c3351e8e08bb62fa7d02d044d014ed3bebd86c03f62c5088f399ae8f5713bcc8ebab01b3d5886b3027fc020def9f62e695a00887ff250fa82122a044787b94d86a8018950de2239b235225cd26d70f13c1ff0b167db2bbc43a3ff55f820d708aa92c6df2e8bd0d0e615f781155d8a9f3c348e15fceabff2f10753787ec278ff61a37a3b28b2eb90f3a00d23d1a94b86e3e4f75d6cc2f5e2655a1d62b182e1bd5de37d51cf4e89020f6a27aacd3443dc4f2ab22119800c1fede0781d1775584fb7600cbcafad057a58ece13f195b16089a2f19d39791a84efd8f1b374fce489fc69c490093b3ccc0b0b2ac41ca3cab5fc2c222b763dc97cf0693a921aa77af67f8313a8485dbdc034e5b869a0542550d0ae8147364fda292ae89fde975160c8983e557e470cca255cf4ed408542a32757d8da15f38e1f2dc9d783256f43fccc2e2f5fca181c91d1b5152bb10b47517558abce55eee3a7fa96fc05af2ee638d91a3b884fa6c9dbd22d5171b0de3baaf24d29c25ca29d824070c83f943bf3e33c01cdfa635f80eef37374651b7b8cc2626a393be363ac4ac4318922fac1c98ccdb0a4babf80566e53c52700d577a047f4f45aaa9e9ca45cf5a004ad1d10e932caf8cc744e9a01e1159f00f146c8e8232bad3a70e6943e90900ea1fd53e8b2c0d66d147a014a2534da60068cdfd9370825d4492b31a58fea3fb314d77fa9b4a2b218b205bafdec4c7c76b02e880bdf69de6cf5e91d2f9330775ee02bcf8724317ba3094e0c3f0dea9f9c4babe0f416c3625443776ae9c40d53b2d13b12c00bc4b5c1cf9a52971476fa8a1b92ec5d400ce04e7568e0a95251d0c5a4213b39e6c2f4699dff438f3ad0109207ef6bdecbf707ea280e3a479cd83228c1be460e67fd754afb13b0bdfc8bb594f57a8702a98618452e98d8a9d04d4f005d8c9d2056af97948f194ab3f4aa3a3fccbbb11890f9b694bd6acf4f31e793be363cc466ccf71e0d5f7564e932ea3789b0a39206ed10e844afaf75289bb785792473f9a31c57e4a0a5e15b77301c7f4807b2fb240705cda8797e0eb9ac694eb30648597976daf7a7e62539ced6f6e43ba3bf3ca60ff728e39ef6af148f3bfb69cc1719f7ed8d9f33c61bf74bd4a794a7c129fd0cc7cb341007a98df34f1e9bc6490efa88bdcb443030b0e54221f1e30c74ea3544d04ec660e9bcd8268348f8aeedd18659d56629744565ffb30491bef8c7d1f1eb8a2db96cc7d5a0aa5abbca93c30b963c897387f38b5cfd6d112737128c94360c68c78158bd3ee78398870e6d1d7ed8fd5eb95c6f40aabce2a7fc436d5bab19e7166e2bd92e0b2b4be2b34fb26b1b0eb4bbe142d6126ae407f4eaa556f35b61d13884b5c7c78a24fb708feb01955a9b87b7a2dc86bead93c7b0cfbc2b5b61cfab49a9313f1e98c708363ddb6a8ecf0041b91256f54a838d56635c91a7f95cf2fb118631a1379de8460d9b001cd1aea7f243d649623cac86048644f741b46bf8293e974c56f857e233e1c1555143f10e3cf2fcc76232b6edf69d9d3f008f272abda06b5ffe72cea0f1afb024e7531e38bde57173c8b4a9e3c0ff320862bc3c83dd514a36b36ef408bd6cb49fd692cf8c895f4c67171889954d2115b4ee0bcc9c22b92b8bf01aa86caaad7249636eec47bfbdcb4bffb5f58394633694eee9f7a483e1585fea1c402edac233098c579f8e4ba25e1290ff431468eca65fee3b633d75b5d73e0436337f0094ebd608a1e700ff5580ef9fb8259cb3fcee21755b2c144b49b5c6a8e4812349990ae1a1083fedd72c499053f73336e06679bbd391719f2b413226208311432459ca73e9d1d61a468aabb2862bf0289d2ef448aafbdbaf7c333fa080276a6f53f2afa9185fbcaf81cee41251c493ad000c172d31bbb4b3d3e05e7e8e96dcfe94eab762f0f7491b171755afcd6bd43d7aeb70306939690063bad89d3d04886dc2bf7ee45e2a3c1bbb9f2f86762f40decdf894078cd3b4f6c2cfd981667a4ee78a7081dec040f2bce5c21d90f145caaa3af1a0d3f32e8507314647cdf12feeac9f2beeffb07d63b1801cd1f54648c8e722db626282e8b54642bbbc5f3e2edb74a65a2eb8a6bfc192069fcfb2a04dd90940374be2ca4ed013fbd15677bf4dea10be9e68ab3d84041d8e32a03004581c58b882a5cd28e07c1f85510c2fd8d6a82250da3222319cb572c0160cbbb79fe2f1f5b5db083644b0a54e62b9c506392a7abeace75242483c8b0e0f7a4637b17d7e7d644ab24b7023f4515c1c140424750d2ef4d4cc3b100e914924d2642b0d12e238e07a52c3a5432302befb200e551e7ef5da0ab2c5e0828b7dcd0cc29b81b8049edda8405fcd511f2fae319eb8ad7fe085151b0b561900c0e44ed8081a7331ae3039ce71a5ea18281c63538983578041e2c0d1d7694b1e67aa33843b678d4d060626de780b2c1f5cc51dc6c670fcb6d941a637c7044b0b6f78c8e1dbfde41e704867e8fcf90ac186f29ab7653887a27a31be905a5f7fe2769d4a6ead5ffa92452277d8dd6c89341837e6cd3598eb629015ba80009204b3ee4549d5e43b64d1c02d692b9a78650914132a20efe919ea64ba22d334f4b0a91002742c66256ec3e15ce5aaa53cf869c82b74fe1e9e0e44e7e2d6e2b8dcbc16f12ebcd5f22184e32706c2c6da80bdd48844150b9f2fb4428475c8fc0a9ceca0a158c14240ea485e066e215e8a5996d5101e497b3e5df280e9e9bd6e2b5aab4d47a95c1599d7196862d1623f9bd627ad731cd439207c7adecff28238c785d8870d74170664dd11eb6632a5d26d532ce07a69c7d7ead5ffbd58d7218404ea97e878768af0a4d674e83d8628d4dbbef0ba1d66ad8a52aff709c36deaba58895ab519499c3c350cf179ffadf2a8d63bf16f435f73c65872d88096a8908354e4e2a12d07ea645edacd74c1ee40cf24d556b284c4112c0776abedb39ced3580510666ddd270b0bbf83dc08f88bde6b7e3dd25c7df56757ea94c9060f1e82f9a0edcb28d2c8e63f601870349e76fecd1e5f1156bf2f8f4492dbffd994b187af2dc53eed27608c3b3d2f95dba06cc3518e3db89296015d6a9deadad450ec676ffa918d118f07ecabce61642aa4db2fdd70a0cc6377b899ed02c50874b90068f183016dc26eb28024c8a82b5a6afa7a089c1567855b4f69b3c6a78d8ed8ee8c61df6e9682705629dd604a524187fffb6c4fc181b113d4c4fae83794113a4242230c3ef9ffbb0d7ec97fdac73327bef77310b2fd9720fc14042826737e0e008d6627fcac9f1dbc897d1bd33e1c973ffa6a7367ee3c4391198b75a491de1798fdfa1d3a3c86636630fa2054c13d87fd244c0a9c4a58dce9001d58e6955ee204518841132c655e9feb8dfb00fa40365b0e6fbb4447e0bede44e31fd4b9d52d303b5a48e9f41f30171218d1a0cc44825dd6aaf056da748d4516122a6ac21621f0ab964b52b43f040bcfc7bbdb5dae47716a0b90925c472c7742af1524da737a2d4d9213ecae51ddb68e189358abdf7999d27edbfcccc3cdf15a7ce848d410a0f345062e69a7a8217da91ccb12a07770fc381e5485ed15567d9542a41f2a0d5adb451a2303ab4bf7fbe251b80f2157160f2c23c2dad2a8b4c328f52e185ee4cc56988da4285fcd2065c305848da9702448863f5d08f9edf98f97a6bc088d750657fbe0a98fd2fd5857e2a3341c5315d16d0cbae942a06dab0287e411fab3584e3ceeb694c1539b5ec0a85a0308bc12795680ec5598a4737a590d6238990d1515497d2933b7c36541d0f10f70c15bcab67648eee0ebbc157a9fd75bfa71f7a60eb2927e9dbc2c87147b1105319c462d98a0b4944b6e823c245bf08509054659ae92fad8d92992f3b5c6a8d21fd28df62e5151f4d682a45a57a015e911e87fc46ef02a7cd95a68fce44b9c21028fd6e5d50fd717c1288c8ed957e1d7400117fc0b569a93bd99d919e039ade361ff6ed08b943046c2d0a106f034ef3d12697d6967b438e33b2e276717830e346e302901ba255f8eb79dbacbdf1f27b01f0583dc601cd2bfe0c215c891386d10dabfe263f1b25d4efe981f71b058ab32e73c62da82641a568eb8ae8aaaf0fdba50162998ad0a2fadb8485fadbde480b2fd920646511bb569417f5918362a117f82f539b787e0c2591c28a2b34331127308e2c6aff7a5c5d27c34e8391d2aa0128cf1d0a3f6bbb33b0d40a791dfa37f77429439f1cde3d3c676fdb1e3b5a35a4333e20b23fb482b1d50a4101632a671a97595412db3383396e4d26e268dce5333bed78f5f637a3afb033365cb40955af6a2ad65dcc62eddacf445005e8c3fac891c6d4a77094948b7f5214cdb1343d1edf71edc41ad3eac652ee9d1fd522cf0a6bff75bc0862d3fb2d46eaa5ce1440d20d542b5783d3b706c8e812d229fa207a868b3357c1403fb96efe8521a7e116113f740bafbf45e58a8d0c6b9a3cb00f52ad9e2e0b6884a50edf74e408eb3ac4b7bd62afdfd1f46278e16c2ea796d284f98731a4325ea9fe09cc0bcf19f9e3429f8405ef7da4b27aaf6b4075358a4230d8fa8faea97899fdfd7fa1bcd1aefcd3f18ea08c506816104b868357d0608a93ef122e3b544352ec98189ba4f6dd3a29c6ec3a283fe218706bcd741b96d8d6f0d6d49d09e18a91d69429a90b4e8df8a7d4d52405c7df5012d0e0ece8694401ebeb3bf48ae2625812af52969f7d43957b529db0b260ba59a7f881d5967de6ff70f709a0f50602d5a08aa918054693a09d65dcf180287ca29d2224dd7915cf22c3e5f6192f33c6ae09fbbc08f90723eb1c71a2a981ce03bb843fa25398761122f2839c5518c13fb094c73f1587190844b8e1e5b93c91e01a6e82bd9d0da7889b436748b61645f4faf3cc2fee50576f7f8272d81dcf869e08b703f55471048b7b5aa14b2f79160c86c6ae7f77a03582d40cda5749b5b45fddccccf49ed620f6571ad0cd9eca8be7712cfab311a814bb0ed853850adab6081428d953ddd1b20cd9d283c5d2be706b7e6bfa0be0458e8212a3d3fa5251b8f29cc909b535aca4f668587c185e561911158d0760e8c72be1deb23f4ea11ef2b1e710e561646a98cab2f2e3446c71b7b3d52b89e6288e074f6bd46a77509cc0ff41f2cf383963986e4f60eeb19093daad05a121b14519843d9b05d801a46d2f6f3064afb6febc9c6463ec8cf499604c64ad89cb13f18109e33d6ec9e78b62a224b53b98303c01eb4348283293d08c4d4a2c1670fa8fe91be583e58d9f3e3b961c19a2c1513322737fbc47276d077eade271ba2caff8a2f8a9798c39d5cf7616c35acd40289fa36ea42ebf42aeeb2b77399d8ed40fcb358244e204000b7d02d3e1799a6919c340f25c1f649073fb5a102d84af0022a4e34c549c76a5703b393b5ed4d540bb8e543c5a356c6b93e3ac022302e46b41f1a04ad6a296c90fb061ba9a71b527cf29d54754d18847da0a753c069236db8ba683ab5bc179e86191dd4f6f2b39b8d57f478e6d80f4a00984a95c96bd0c5e12abfdf9ea1527c86fc03aafa05597867626a3846ff40e94b6262541895d2e93fa7e7ad5dbbe60804311974dcc62e78d59fa4866121e95c9181b53d9c3cce018bd17b4c1c128d5f35cfd64c18906f0553bb480a52eaf2830eeb1cb8c4aa8f4d0215496e78156da84c4d03a090d93aa13755ad79c6c0f8184976288614f3c78b72ef0a4fbe07aed5ead30144f8d4201d84e373f888b6c440e7be563aaa3a75e96677213032398e8f59b44e371836efe9536a37b329ad52e19df3cbcd3ab36d6dccbbd05cf9ee2983e64f524c8e4ac9a439a92d95d4a89c1646e841317d35e066f71f5c94edcbdbd22d692fc0bed3d9836caf0a17b2530a1891f606f04a9812a4a9bc8c432c4c5d6d12dd34bffa7c82ae6207c643871ffabb87c2e9219b504296f05d012c641da36d46d8ddfe8495eb891907184352c08e9312b4a7630786dfb59c073f356a65e82a8eb1c1b04a90be9bda6755cfc765bbf3b7d22df31288ce51d531c62cd1d0ccc639b4875d5c51f2f32742a57577473b928143eb5a1c3323e3c667741a3d8535bf110a5c39cbc6ab44b562dfcd0f28e1075eb4326e50a5a196c7b647d5e481f610f81531d003a00f5a8e7bc0f7172ad243374f63bd39b691cd33c5a7ccd1936e4087a9002a064e261ccaf441a41b5629b5af3fde80885f215ba35e6b72147745d62399f38a54b8e0e697e9d84e9d491e8628059af919456abe823a5a93b262ab980239c4bd0fbafc0e546f50e0fb689bddb96c43b2d186eb6c53318ce157b0a088177e314c5a744911c3e34f1bdd0ef77e6d92b29645f48933a6392e79c365750cfb645712ef8510794d13c4eacd88f8a1773a6fd3864d5d35c78a75c477b9c84af63fba603ae9de7bc041ac86de2fd393e8936f7f4003756ead1d92fd9bf702ae543b4b7e81a324312fdf58713d4940242a2f31d2c995e370b49c7ddfb573c9749d2debe758690cd3b406eb7f44a21704b32cf72a3dc02d42b365a9a2085a4c5ef0899efdadfee9ead0b6bbd03654f0ab7f10af158149e5120bb93f972474974fce033ad6c6a221f49018fec1a8e83832f1f181ee28250e6d80aa7bcbd5f47f147f762a7c33ff79b1ae91fadc5ffbe155aabe318cdf651024de3c4e9aa71eb42a0cb93af219f68ab6c8a89f30454892aa4c0f8a410e0c303ad59f4e2084328bb14431f5a2b251ba2912ee8b39698448caedd8637fa61666b5876416053ae8ae08273b5ca2869f68c569c3cba93d5b353a1d93907893579881d905943bc4c45e1d0de1481fcd7023f587147d926c301433e081bb9d060f9b9ce0e5276e24e3844d28e5d309f091f8f8750028b79b3f3423d323424a517da060196d00bd5892fd86cb275723014a54f0efd281dc6cb8abe334e29f7bc4318ec22bf55c5db4fe0a9e7993c43d5eea5ca4b37e4e84531c32cb9b73c14e25f998a544d2d750f282303c22402602c58c302d01f08064e064aff24aad39f83a46799a9d50a1cfd143d39ea50ee69f185b969722ca9bb221d3ee27e23b0f1e036a37bc29ce6c2df1b3f18c9127f1f8ef60dff86c89324ad9e85f26a81ef46b6337c5a458d15210a0e42cb716896177676c4923e3ffae8db94ea699d424d6c46fa9865d221db2d785b9d26d5c58a78a585c07be9ddedbd0f42799584c38110dd1669dd685f733d90fe3c3e7841207eefb03cc014d2331501beab499001905d598b2dcc111535936d3b2e9bc830f74813262dabad516fab2eb10645c1670e8d52241b9859d36dfabd88799c5659ecae42f20466b877e94492b8cccdcf3b331418b2e4b6cbaf641bfb9a6af752c770fa4ccfc67612c9a396b660787a0fa3e60b0ae4fbb6491bc85301c3d88d832db2a273d7acf1f8bc917943e6f9796e3d34480409408fe423f6c85eacf479247194c23deee3a90aa478419b5e590ab359bb69a673db7e2a53459a444fba63a05eee20b7951a345bf2755907a8f8c32b5412a40369b0a030e6a5b365680a88467bb2a9b507d56b096f345e87573d8ee32074b8419db797dd39434afe7b9063296a18df8e9caa808d99196e2a167618fafb2f4204a7aeeb7f0cdc70b156b7e550a3addabe5d04dc755a352b71026436cbb8d2b79fa8a1f52c117d077b7b4bf3f2d61a36c7c3942dd844d9c360b25d5ea4f1bbbddcb51e164a4a6518c5da558459a33be98aa5f0a351c363f7c0a51a3700100d92c7f477d13ea7799a2d8a07e961a101e459f427cbc230a7345caacd4c604343030131ff4db599eb4d598bda398ebbb064866767ac71aa52d310e8d7fc887035693f49992b703d31e9194794bc348dbb03c6aa7df68c134e703c44f4d94d6356dab2bea1a652d6aa270dfba08ad9a9e14624518b98f45967d764f7e6bc574e0994c784084f4010657e62a1e5e1852384fbe0145023397757b61b9a4aef84b3b1ec8bdd26ada73fa8eedc56ddcfe9fa4d65a83f5ae99652473b38007c703204e21e8d4e0ab7a42a5f0f85f4135f17964005715971354ef862a1250e3af5ac98b84102498da35a1a4ebecb5e5904e08cca8ade33959fa75f942fcdb98a3c6d1fc7e8280bf048b1ddcccea5099563564d27ec636dcbf64cd5bf0d7a1238da6c4aee1d7fc5b9d3886149cbdad67a689aec2c18e71749c8f3973351096b82454844e8392645ad9afc3b72c07f47b2c9915d7588d68d239e07d434bf449a8f5a9e6402f05f74c76f1cac30e07a8603b9adfdad29db91740893dea1527597485a1d52eb29df826e8126a26b8832bd5990e4d8f7670c5363d0fc239d3f8fa39ce6772e2e42683eacdf38a1e2651d330744697420ea8ea490b79af348698e4a72e84d7a601c7c5a760a0b70500ed6fdf79df1423524145bbd7a880d5d4755cc1a59b890164c025fb873e4046fa8692e1b29f9f081019bf8a732cb7f4a91862841478d8431ea17af39148c21d5718c7bdac6575485860a4a1823402ebe067e5205e875853a1c87f10b63262b5acebec093b312f2b1d224d6e4dc77a0fb76fff63b24671f1931c8b51def072810a858176fabdb4d25c1135b153c6926afb3819af5932b1d6aecfa1a617567113bbf4aa00efaf939b52214a7179c707b4f38497208bdd054822ca184708b846227d2233fb6308075f0ff13f09f6494874f7b9abec704e161bcfbb7fb575cd22a96bf476933d1ee8c9bd16165f4358bf7d5269d28c436e02978a9421e291c24dc4eea49b1311afcd3695078c7cbf78b8345cea5c85fc0cc23c9b21fc80d603d92cfb3931292dc1e77e47e28328c0aa574f273595844a0d4fc200f96392c4dce2afbd39fb6a9c91bc3a0f9d77a9e4b137c7134c2f9f32d0cf6f36199c0c7fbe8af4e0f7b5608bf9e131f678b5929a1e933eefd743c2656b319ed67a34033e99b558e35e20aa1267110adc4e5b159d00bbbcdf0517852f4f417468ac14f264c1fd39f592b1b7d169681a994e9dda6d3f99ef340f6916ec8c214bd47114e1395dab889573de542bd9cbecc6ab9ad67ee3d6ebf896a28c085d2061c739a5108845d27b3ee70fcf4278dd458829d5710431d9291d696405da273cc15de78736733f892a7478aa6900fba5076bf99fdf1560303abe7bcd7f55eaeaa94b362fe7cf672d47cbe82b509e03edc575d0506ba15de624a006e62a351f54e186f54e07b84cfe44562fc519ed4c2027dd8a0b9675a900eaddbdf08166c95bd152993a56db8c93604e4a7a1d842777f8c946bb5b189dee2babfd982753cb7b822f9ccfc5674986fa1cce3960085a92e56132d29fdc824afab33748bbd0a8a06aab7d300511e319f610d6446082134d04eac7fdec8a1f8a7f507776cf2782700a21cc3c96a9b285ae77b6373078121948acdbf3be402f30b4467dcb57e9f65c2cfa66763df631987767af800973e28e7ef8f9a3c4df64dea13bc4106b88611975b2212b61ba3dcacb2802e659a20eae8c08ecffbbf1f52bad497fd5165ec95f56959790097e44447d25d6b801ddfaa52fbde33d3184e26efd6f9b77255bf74711f25b3490ceb40a05f2f0fc427c0388ae6e33de8ff8d36ef2f583c57266c436dbfbf782eac8590fb84fd6c5e3a11d218f6223659b53ac35673828e68f9414df00acb00283219d36681aa814a78ba53b0dd3e0296569296560f7f135660b8af24280c53e4223af26193a251f3f81b9da5f917d0627d20e6029a77ffe2961e82838ce86912d54ce6e99c9a7d5b5f7da7b399df6df245cf6517579749e1aaa4bce91e1bc3601de9beb67575a5591bc1311883172fcd0e3e1bd18a571bfd3c51bac69b499ce89227d504861aea4fb5784188ab471901692a56de6270ff1f760a74a58f5b8434fd009748c685e03dc1677ff739646efa27ea10aae7d4fbb6972e2ee508fc6562783e611b7f24c4aa81e08efec7052a810f97ac5fec0bbeb4d38acc6fd331da4eea736cbf9189b79d44a062b0974a2562d378bc20389bbb72802e42f0e82c13423f64b9b0ac00a44d973285481827e55fd646c755ce89bfaf4d619c8c290f7376fd15f4ff56876e908c99dac85064bd1bb11c4dc2020f5ba72c589111ecf075e6f1bf49e65703624a5ed82d1330b61cfd3e3351eca552d9e3396f8feb4186ceee734dbfa4977aeda9abb0485d163d20516cc1a1b6ae8401d9d60e13f7b2f30899a06acc5241c3e0994d4c989b62f4886452d1f9ffbcf38f2687e59b79a8a1631c4497d5c9a4124a7f7156648c6b9eb5003a67b592ae62d98c54585a1c533cadd7e427fed59d4e383d8851536301ed265d766b0e36caf667ec4183dbfd79992811cd42b460bf1b4fafaf3e7712149aefa2d61ae1ab46642a2050b27815b296dfacd24177430a7b01fe238461c182e5a65fc6618feac595b6d06037b03affdef1b303207822e394df89c995250833769375e87c8326688b7ee6487e3f67e8709bd2b3b0c1542aeb25dff3559ceda084c6dd8eb5b854c0c90fc97dbe4c0aa213fe571c051c74da8fd2884109a5191f464aadc6a1003f3fd0f954590a9d0bc3c953f1894111dbaf5dbb619479cc918075f3771fb212af117f0073fd516701ecd9fb973a0c8910ff3b66865e68be91ab54dac433ee0065e4a3a4b63990318cc3e0542e9054cd1f1b0ae38e9f48c44b35505ba7ad87792232d90c0112085a955184576b2580037c9f506d8acf5d6f1389aed7315c2bc4c238e38c6e6f1717c4afc0c41b1d1daab050f84e956f3a56777b693d6a649c51243d04ca870f824849810be1147d2e555ef',
        salt = '3befbc09cffb66ad4021c8cbcede65a6',
        labelError = 'Bad password!',
        isRememberEnabled = false,
        rememberDurationInDays = 0; // 0 means forever

    // constants
    const rememberPassphraseKey = 'staticrypt_passphrase',
        rememberExpirationKey = 'staticrypt_expiration';

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param  hashedPassphrase
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassphrase) {
        const result = await decode(encryptedMsg, hashedPassphrase, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        document.write(plainHTML);
        document.close();
        return true;
    }

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        localStorage.removeItem(rememberPassphraseKey);
        localStorage.removeItem(rememberExpirationKey);
    }

    /**
     * Clear storage if we are logging out
     *
     * @returns  - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        if (!isRememberEnabled) {
            return false;
        }

        // show the remember me checkbox
        document.getElementById('staticrypt-remember-label').classList.remove('hidden');

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassphrase = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassphrase) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPassphraseQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPassphraseFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassphrase = hashedPassphraseFragment || hashedPassphraseQuery;

        if (hashedPassphrase) {
            return decryptAndReplaceHtml(hashedPassphrase);
        }

        return false;
    }

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        let hasDecrypted = await decryptOnLoadFromUrl();

        if (!hasDecrypted) {
            hasDecrypted = await decryptOnLoadFromRememberMe();
        }

        // if we didn't decrypt anything, show the password prompt. Otherwise the content has already been replaced, no
        // need to do anything
        if (!hasDecrypted) {
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const passphrase = document.getElementById('staticrypt-password').value,
            shouldRememberPassphrase = document.getElementById('staticrypt-remember').checked;

        // decrypt and replace the whole page
        const hashedPassphrase = await cryptoEngine.hashPassphrase(passphrase, salt);
        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

        if (isDecryptionSuccessful) {
            // remember the hashedPassphrase and set its expiration if necessary
            if (isRememberEnabled && shouldRememberPassphrase) {
                window.localStorage.setItem(rememberPassphraseKey, hashedPassphrase);

                // set the expiration if the duration isn't 0 (meaning no expiration)
                if (rememberDurationInDays > 0) {
                    window.localStorage.setItem(
                        rememberExpirationKey,
                        (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                    );
                }
            }
        } else {
            alert(labelError);
        }
    });
</script>
</body>
</html>
