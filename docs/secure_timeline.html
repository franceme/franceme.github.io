<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #4CAF50;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #43A047;
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #76b852; /* fallback for old browsers */
            background: -webkit-linear-gradient(right, #76b852, #8DC26F);
            background: -moz-linear-gradient(right, #76b852, #8DC26F);
            background: -o-linear-gradient(right, #76b852, #8DC26F);
            background: linear-gradient(to left, #76b852, #8DC26F);
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>




<script>
    // do not remove this comment, it is used to detect the version of the script
    // STATICRYPT_VERSION: async

    const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 *
 * Mirrors the API of CryptoJS.enc.Hex
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassphrase) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassphrase
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassphrase) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassphrase(passphrase, salt) {
    // we hash the passphrase in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassphrase = await hashLegacyRound(passphrase, salt);

    hashedPassphrase = await hashSecondRound(hashedPassphrase, salt);

    return hashThirdRound(hashedPassphrase, salt);
}
exports.hashPassphrase = hashPassphrase;

/**
 * This hashes the passphrase with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(passphrase, salt) {
    return pbkdf2(passphrase, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(passphrase, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(passphrase),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassphrase, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
    const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassphrase = await cryptoEngine.hashPassphrase(password, salt);


    const encrypted = await cryptoEngine.encrypt(msg, hashedPassphrase);
    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassphrase, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassphrase
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassphrase
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassphrase,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassphrase = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassphrase, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassphrase = originalPassphrase || hashedPassphrase;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassphrase = await cryptoEngine.hashThirdRound(originalPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassphrase = await cryptoEngine.hashSecondRound(originalPassphrase, salt);
        updatedHashedPassphrase = await cryptoEngine.hashThirdRound(updatedHashedPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassphrase),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
    const decode = codec.init(cryptoEngine).decode;

    // variables to be filled when generating the file
    const encryptedMsg = '237013b27fc034b7b72ca918d5b411e8e7fa353d1a711aa2241cc6b69e1fd2a0c746ce0eb7384a82d2e86dc32e47f5c851df6a8c99bae3a3f3e81b47cd7abc126e58b3fb98978609e9757e4ada2aaad44458522f48193c31178e4ee7d299e977e4e0525cf9a88e51bdc2b4ffcd25bdb7fd79ad69f95bccfe9081521c680a1dd41a9e662b0863dc20fbe6cb986c6a62233b48f2ae830a20b9da86ab2944a0c90bf64ffed7b89cf4d1c64861b577392e48647f3e1993d383b9fa1712fc568b214312587b8369e544e9490c2a1f12d72c89cbb0377562ad32dc5bd9dedf8a525107c39a876bbc88afd4842223ba382679a30ca73d8bb66a55ad71abfa70eee7811219066799af6f252ea8377912ddf549e23a3fbec2b4aa26c90be11123490521fe898685fff3dbb2dea26a6c677fcf25d9b443ae7bade896f4a1d62041e4a09b571f2158cbfed1d0d104c616f389742c1c75e223f8daccfdfd072bbf5ccc7faaf35cda1b0ac6cc2a54b1450b63ebcd605ec4cec2af13bc36e2ad30c11866d42da864371631e9a306ff4dc9063ab99194a8f39d8969554aa8f1ba6f42edc7065684e45f744567a3720873f6f0a7af0b6e76850114f051ccf8a579a113f47004d419f3eac5a70c95d4e5c3e56d197471ed62d7a4ec712126df5cf538693fe0d8e110448831030bf3593139a177ab8b378d9c4f3fc503c81688b8a4d49f081ebce2f2387783869ce4aa6e962f733e78cff497287dd4bd34131f9457574d96b649b9d62a1c56e23cca440d220437bccef09e7ee1b3462bf9ce4395889312a83d03461edc189ac9d14af1cab3d4cc8234db291be10e1ecabefe561c98f4a9736619f2aec0d71eaa3b6015848d60c7b28735b0efbd4c01cff49f01dee4cc781d186f54ee9bea20ee96593eb03a55e3419cfb227ef4ed4433b7a39c2a5fe51f72bd24905c4acc0309771cd4d7cbd7d84782a131a5d4b2e42599177f4354896ef1656547bff9e04ae86c6806adab89bcdbbeba27eea826a05a27cf37a320741d793edc72017c0ef549bda256090a81c8af8bd6a7344d5f6bffc4674555076478c241b8791aa84803732b41f6ac60007989aad75ba58d6f1eefce63a031a9368ee01a8d9e17174e31db5d7f911d3dd4426d1662317f4b2c28dd89282b15a0f28c9c0a99ba3e8ff88acbcba33b26ae80749609d01edabb785f1e4e40cc10739d0e77e4c5d07e8b24938e5cd3439ea76e0326bc4897772863af277dbd8cd06434d64e41c34e6fb4fa7f48b5ed319090f8f4a6372ee4bf8a8ac6e94f15933a43eee589037422750e10eb6fde16e9406f4867b949f0931fc51d688a6881bdef90b14e4e120319e354c0584b8c7014fa8582141ea1db4aad9b013037e57a579e4a5b368dc671f5f2033f2a1e79fb06d35227288436ef188eefd37e18feaac9045cadbe402469cdbe5f7855aa6478a896b8ebe04ff14fba7d23515652b0924cdf7d96638e42e3aef58121f5cb86d81dee44fea13e6b019e2123484154acf6c0b302a609da48b8c81e132ae8ac20d8bd6f0e639b7152a039ed0265ccc14a568c6be5fc085ff2a66d5271b83739f4482089682237251d8838eba99756e51db69f3a92eb4eef01ee4b7f1921253bdb83265256b9feb14bd0bb579868f8576100479fb04480c7bc0d5d9af8a04cc1601f7dbb27df612cc0a57b45014d642b266730a22a139ed80c8fb94dea956104498194421e8e603e6473d8fe84cfc37773a130bc671ff752ed586ea84fb6ded1de00c3a83839902d97032da4ac226899b8571569504d92885e3817e8cdffe0a653b6af97edde7ac0f493125e1f2c70ef31d810a6747bd8e49123f30462f847ad8e09fd9395090c0f09625ced46419cd5b1c5a41055c141b9f1ab6ec4b3fd626a915363727b233f5483b9b7e0ddfd2c14e9005805368448e4801146cf8815fb1eadb5de8ce0bec0294cdd4a633fd06bf10cd0185e7dd3752169a1270d560efc6eff528227fef84715a2aa2aa9314cc476ccf6648df531cccc3ec29fcbed29bb3b0278d010edb8b6f703ec72ddfef98d76410a9ae1491f9f20d7c233745a015826d361617d9af494df519b58042af89e89c7bf4cb44cd783ca16f82817263e74f754243221cc02b68d1f82d42694a27a749d766ac0e59af2f703089e82f7f18b9a7f55ab4c7cfc8aaa507873bf16d4115c40e102fec1be3aadd592c99a3a896e16bbfa27f6f9a9cf5411ab8abdea44e7b543257b343a17402a276523cb3392e3736b39cf0762e95a2a58983a56e723ff8492ec7022f07b7a4edffaa35984cea752806e9c05cd49476ebe3b18f23849ed8b338530c867fcf03e15df6b8267901cbbd963f3cf40e3d6df9e791af2991f985448644ed23aefbdfe0b842abccae9bf0dda2145da581a10488de3ac5b3e44ecfc234bf76bdc2fdc3be364ea44b1a7c55bd87bcfbd486e9e20bfa62edf3c361fe57775bd6d9f2eaeb2c85936deb2a03b24cec0241e376fa2811d43cdeee8df9c365291c070e12dfc4f3dbef65ee06afc30e6412d344145b2c352c5e24798d6c9dda04ceb9f0ecd6db2331b25bb1e0cc691cb522d47f3645e8a002f19aac3d7ec3c0d1f1c766360c1ced8d11c32c0840da464f913633340b844ca28690dd5e1ce33b1afea41ee9a90b7c146f7ff2249df9ae934450e9fa9ff82e054d25290f31b959bdf085ea65e144ef193d23aa8423e8333fa64e1f8893083ac1725b58669a4290bfba817312e6c70d8c5135a6cf88628c0e1200f92c6d92a7271954fafd0b007c5f262889ec43498932754b70fce664a98e91dbee9e7f313836556ec1743142a87c0dd3ed14d36e0a9db18516424835200148973b49aab38b9736e447a748d8a13b2894fa5441e49f119e752d8452d43d57e9c638d5da34108f2e6ab54d3c2ebeec53493ae64300d0b177a4997726e113f0736e72b22097ea54aa8b66e4201ab8dd987873ae5581bf3c0deeb06be72f8ab461bfd41046a57f1eeb4c17fd3fd5680e37a47d654609eddde7449a676e5c3d4372b4c3be01f7467351e6a16c22f9c93d98dacd5c598e453278473aef0a6b859892bba9a23e93e013f8e680fd61be2a3725f38420a33439c2060d48b52896eeaec50ccced36eaac7598f3509e860f8195edb4a186c8b67f081adf00df735a2256c2b987359b00a79484d3e7c7b8bcc438f76e31677cf42fcc446c930715591aa5fc832d254e277c26f0709fd6f431e529dcc15379dde1a5a28e0c1453d48c3d1e37b1a1b06c0f7a9b5ffb96bde445a8a2063ab1104cbce0e40859ee0b9fdf38564cb58b3a64cd8838563dffb23a33351f5101055b6825de9e59e95aa93466cef36409e5194951b09699e3d74f993120e2c735b1688aeefc01c0cef05ae1b92006433c913fb9168c93d2348a2096e7498677821be583f7b339b3aaa07e4942542b3d902ff9747fea78a148fd920347616c2ed7e83dde6b32ef17e00f866721a63459d4c726223d14175169d41666becf4bef23e3adfea87cc3a5bdbe9ee3b7cd8ddba0f03b9fec495b352d02a34ec764aa0561d3351fa7dba279a8552fdcfdecdde387ce1d26732e007c8c7dc48ad289412b1b8c95d4971b696732aff08d1f231e57b97560dfdb879b7b5a770c07cdbfe72d7192de08640b56119ecd942ef57808f66aa24a30539b18bb1c9e17d768474d459f6a5ccd189cf8e2778aebc1e6097664b31b85bfbf2ee3866f13b00c36ce3e9c610dcae3ad02723fad7a7575597baa9a002701671bfec0a317df40df54ea585fb29b9d7c985692bb35123c36b10c90bfcf2c22661cfb41da88ee08eb3ea23961defbbd2d62651827b30dce7b499974751a05c81ff028d41ae68cb4498954aab14fbc72f73af9a23b88adcaf30c0b936e2a306e3c46b27673a10e8a681b32f4bc7e9e1446ffaf53c7a2a162dd6c172f1c5373c34fc28bd563a390b36b8b092b74858fb858c09e9e8329556c3594339f7c2a375eeeeb2b1d63f123b624a5df0ddd315fc0c16c0474cae68551fc35e659cce1388a5d33e65f8721d8ea9e60215d5ba3ae640ad09d5517e37e9cc64529513f1cc409893d950df5bdb0215d2d42c339c059d31794efbc6d6a9198699c90306d9ef3fd9a7c8c2e3e92df4ff7c44a5bff582488d9b87c1d229503df9e5b8c599b46f1169f1e519c46ba2edd2be32fa7e39f1e6f252781a812632b787812eef26a723cb4f11d75bcd5a110f23c2410b5174be77d2d9f76f7126d9b38e33bb5783e228468ff419ff354ec081b3bb3979283531b96b43aabddd81605fd463e1734d91ed8545a7b7752b5444109f21f98190b42388b4a5e5db6593cf55beabeaf4d3b9096900071ea5cc76f24fbd771d5bd6020d52b91c1b502074048154cbca9024bf008946abe4921d025c8217d57e1a6caf518e8241532c51a4c725cab05745abdda70f9a7b26ac0ee21e763fe3a87a1d5a4ae2e9a531c3f794457f33d08112f4e88106bfb9d0fea78597d444433b6f0d2475df522cbef665817baaad934025c71f620829dd9012ee62f48f0f97b7884e114b7b18c0d83b54251e28783495f457839eb8b9a83d30471d9250ba887b0b88ed460d1956275697ea04ee2f861e68210f9e7cd087d3198da9011d0bec16443d0f8f7d8ea964b4e3c5eaae4cec7fc06fdde4fec407cca07aaab19c8136c47ba3e57273b14a6fc565bccba17c57579745badaefbc646578f0bb0e98ff75b13d6972ad6d73cf646c0f19792fc32c623f7274aa64271c8534e3e04dc0899c68257b127efa43481f7d6afccb3cabc82a0332024a2d7b34d049d05cbad03f361e1e3a945cc9f94fe0bf8ac55d3d4c775faf6976dc628c750529db19086e4d179c4ba40b6909af399ccc1e73b5898d4f7a348163ec7aa284820a2ee7f48d0a82ceb8ab16556a0e84a48069916f91702ce0d4e640e24721c86c7997450b919da7f2e917a1059a4ed9b002380cfbe00426336453a25295feb911040f7fe72498d830f56c05f2824c214e450451724edf2642d098f881e32eb286343a9b6e6594cbe720b58e7762f71116a32cf9415c67672eb113f43fc65396d722e05f7451130c722a3d8d6776ecaea8de2ec3f58df4617efe04c6867a306886b8d50f7231911721ccf83de67551c02aa0ca0d7538d2eafeab59d2ec489fa930ef221e226960bcedd8517e14f40d29115e1e820dab3c534d38420dc55250025345586f70cc738a4cf05cc9213431326f660d88d27832be2adf7830000d291ffa330a616718202c9a4b1c1836da132b599d470d031beb39c2b1f1671f3aa5d147316483c669350ab739db5d21d1b467ec41342b8271a124fe6d0a7c95ba99df2b65d86dbc3d75964e86838ab1b809bf7796840b30a865d9c3f9a996e6d9a354e0d0259828db44ef2d1c2c39664fde09817abe53844c44b58b31cd95e31a1b59d40682191b1bbacca6fac0f1534aa58d0607ddb85f0a7217379f354fd622c68ca2d19486779057aea31885bdbc83736f35e034afbf6927ca7a4608fa42428155c818b9e1116ac910f184d79d1f8675bb04677dcb6811c1a4ab7ace772406f55ef7d26e18c6f38fd2dad2a26055f14f7f2a28378c9e76f8ec3587c59cbed3e5acc251a01563b8b7203d341e8758c3d51b7dad5d2e84fe35b32cc9d10818bfa993e2139cd0359f2270380483e8f4e1b87d4baa937313acfc57c6ebc60f3a43c1e9388ff4acdff45b40c5792be94447ac7897700be136a673f4f4cc39122f4988a8cb14f38569814010a305770f04c6e68247428551570b4699ef21a84df66d1cfcbcbf8823395cb914dd93fce7886c885186cdfd43ffa723ac0e76ae901283ea9c6bd5dbe7b8aba990d5de0ad81d6a8b89d963ae00f0f1754630b55e4e70a99acf8242f476b26c47da319f0ade57fee253aa7a7ea07984af2cd996e39ca98e31b240529bc3921d8815815cda32920d86eb9a2373de53bd26737bcf4c6da5870ac196a0d7dc80ced28072148371cf860d9e93dadabaad85a5ee8a591d3fd060b3b8f0c32cc8aaecc0320f63bf2a61e5b0897ca7587aafa2ddb78502178ca541dbd929320fffce9f64beb423314711ed8259f3d5c31249586ae6cb9eab257de56b97b68b69fe8c4e8ef3a5ffe4dc1d2d97a3a4927f62e9687533dc3d6328db4bef52e917886217d0dbc75e569f5500d1464477ef4fd23d84d3a762f98c7c32394f82094b84201227973517da7e34581262cc3735bccf7066a3a42c603cfe80d70149e89575b934ef7771ed5711cdcc6e51fcd802f04bd8f9a69fd91aa8606b57d5b1ba451df2daebcd6f149b7274cfc9486404d540cd8eb562e3ed0934f2f063a74ddc248f3ece413c4447ee6dfa26c8da1ae2d69f37ba7b511607f40034c0945f07143156488742d157e0f8d7da5b1a41672b7ad82fe751a97fbd98d9d0bb9f9bd78651dd15b7949566d061e67b40c554d3b78be627b353921566fe5113362ce10bb12d784690073bee573c29f4625280ea7b63caaeb21ae2da2ae4d6ff18e633e86344b0e2ebf7cf4eccb8652ae9cadf7ca83fb02334b121a537811de87e208edf6304fad500d84d0c1ab644f59d80f7709b2b7ab0cf99d7cb71bd2cd67b6e7ab730135f2369e1b196a92c28c45231e0f4e55a8e75822f552c2131a7006ba5353cc741be091b5704a8e3e43037f1ecb14beffe3857a5da3d842d8c67c38be5dde391daca70b028fb1eb785fb00512db8ee6eacf6531c802d2a1df65c1766c42ccbd94b9c54b5979a682e647053765cff1c906ce23c6b4a3a20563aa8126f56a5b1e742b5667a1e9a31a1629be4bfe317e2896427c3dd4e77fa5ec9e227071af1d66f970bf5445da4fadca82ea2e9426b783a91646358c7cc7e46063dd428e9e6de30e0fa3b57f7169ca5b41d0518f84a38b8f8caf0824167e3161e19468bb89c3215a9dbcaafcee39f6b2b13e4f7e17e50424b2589b564689c87ee2d41a9c4c91a23fce1ac94df73a7c07022d511f3a077a19ce3992e39facac377a2852813d8952a14e7618c76bfaedefbad31dd12e350beec3199c2a814b77b63fcd1c28464c7bf68abd89e7fc755ca7544d9cc3101cf3ddb2a75e0b2b5155e8ff04afd395212d538d0bac9e1a69ae1b6094cb1532b1fec58d1b87f2bc6c2f345959d30ced289cff02a6da438f7a5cc959f3da2e2dd127a8a53bcf3e1aaa471a0c88030b8db9e3dd6569e65c7743cdf4d7e887d7ffa475efc6a38aa9d2e35eba13c3ff97e73e2a08e9a3f75f531495f3e9a51cd5248302bb00c71a5458404049cefad816852a66ce9fc6d7e9bc52bad2ecb374300684dc68d7411fa72dc72b5dfb947f5942d0a9001973f666f149952daa78bc06a6377c6bbbbb0f079b8a070e8f5934b2e6a825dc0f740643a03c1c229df2c430309903f4ee9b1299a06a00c2f5cfb8fa382e08e432246dc6b146cec2458e114fae99ee3f08cd2bc6b507a0db6d43c76fa2727cd8883a655980e886296bcfe6e1a425ef8e9942285398ebd9e471df2393cc54e52482b4e72beb3345b42018e6ab8420980c622da160ae18751c6ac6f2825f741cfb30f92032f07be27154dc5ca8becdaa1d1e78f6e61f90164c8810e27edce4476bc70c2994c0940d95b0d81ae7c3c925be4455378c3715ca605d2c6eb5de0d366d1596f9243a28a6e96cea130768a231e741560ed9cf1b1298ec8dc10d9588c7c10d3647c52f7b0c2ea829f86fbcca48aca00fc9aace61f145b3fd7f5e48413c75b38297273dd3817af6c0087b12429abb6247ded40a6ac54b6de1595e5054401632cff2d0b5bb79d8a397be1f9de9fa001a88617c230ff8b991f921566cab19f6025473f6031e867ebb6846b716a43decd15de51917ced4244a17cc5f0396b396edac96b4cb6eaeee2f1ddafba20e99b11689cfeae036d64734d4fd343e1d17aaa1fc18313df1f0e865db3603c8ac051cdb40c634cadce0e0dd7118ee7d80872a649e21b7c8a63c83c0caf10b26334a173bf10ae1ba062427760a53d89a5a7af9e97178001e136f55975ebc5fd3324b4550e6d9ffb12ccedc098514f255998716a5f65d87abb06c7f2ebfe353e7e1c95d2573d571af2c067689793175917ed8fa27452da0d62f74061c037d6fe095cd33f2f09987b87f5525f40b1d0158ebe00dba156110f693815effb4e51b23e5eda2f434737bd06b9c13c72ed764d00560da5c98280e103a06ddd350f8f77590bde442dd0977ea13cdbafce3ba150afcbcc1574c94e234515f32f7a1cfbca56fe1fb5f6d282535d25b0ea46b3bf0a1ff3c0cd01bd23c5920a5b4b2ed35fb6ddb0089e232e8a359635846b11d027f92e02cee2b65deb56289c082fca58b9d52408b27552a351822c27747291bbd97de29fcf9d1997c3271d7054b77b41d96b876b820d5cf7400803d9fb05fb79c8e562e3b9d78efdacfada6fe9bd6eed3b2b46fa23404c09f24f8f25a0e57629f342cd203e761ff60332a4a5d694fb5d6652e45e2d0b4011a2ae526594139fe425e7c7385baf29d61170296844e860f47744b047d3a94f71a13731d01e354ccd49019cb7abe775f73b6506c610599dd2a52b9252e6408770b7f7b8e9af66126b4d90ecdfa114dc98fad0c8626dd235055a42532fcf764ebf951f422f7557fb6b4d4031c927052b7ea6094d0114b381c38549bc13159a0c27d64ce43068fb5a67af4706f2428dbe12bab275c2f8aa930bc05421c1467317f187393b59ee122aff513688a07654c04ab3cfd2ac5234a1392f53c9cf480be98dcb309086d02097efc108ac45f0da6ae713ef218b5b5bdd4e1fe750f194002de2295a12c58ad51bcc55b4d0e70670196ebe4fc662a0100715988a15b587c2454117dd7912fb34067991129202ded38246cabbd44730c6537cdea9ce86ce38b08b888fa4c7348f16ed2a4d1a5d16fb6a9bda24854fb39373ae368c0dc7e6e09a0a5e564c291a5a446b32510417e31803a158c9c3978e43beae09b70ab0d14a8fc1830b87c40aa00b6dddcf17574082fde20c5f097aa7d44623b0cb2d1a7747d6a0e02446d15b897107bd4c755cc9fd0339ad82a72a6f46a9232fe1609153dc1052b3e3a3dd8ebc593752ddf454395a474c29d5b88e9083cddfe9e244bb6d3667bbe41dfbc76efe1817d6b46892558cb7e4eb837eb3246834a3a6ddb0d09a3f91ad6f07788381934e86378b4080718e19e1b33b8b5dfb2affd6f5908f3b977cb27b6fd8a3494a71e605ebc0b9afe81a9cc20f588190c8182b58ca177475e5981f59bee25cda3c77254340db62e808437a5f5b38d6f2a7d60df5534062db460ee0cf79387db6cd2d79c769fa604bbfb55e9c51c5a151e6992ad66c5c425af4eeae981410d42e10b6ed9c5ffdfa1bbe7296d0959001afc87ad829c59cac307b3ad749c17428c276d71cb370ddde1f3a0ac1904c3a7eb8eec6fa1db71e3eea39f705a4c854a54fe734c597ff96c0dde8fb61ca1d4490dfd5a51290274c098cd14e1cd4a191cf769d9ed8c618c7bdfb81734626dc791bc24b5aba57b5cdbb6ecdcc959118b0738eb1c70560f00f5a49a89d152dd39e9e615d6bbbb3e606faba62397526fee76bcbaf3719d4b42c7c2dc09c04d5d2704f02e66a6b0e5de319ba703a7f76003ae56d99e4a39dd52ecb48562d814ebc06943f73d4a159222c37fcfea799763e1caa6fbbe72ca285622ef6c2ea849f10389f7dd562b9a58d99bf32ee0e9345a9a5323809024f822a64103f17a993df44b6f6b44dada86e7a060025e81ee14fdd86efcd39c55092fb225c703ee16b9cf039e7f2e8fc27dd76c64fe72dc55581b9f6bf08c8b3958c261323ee94612264c8b58d0ad93c5bc8fc84fdf553adcbe32e59579f79c6158e44f67b6c7f41f088f521af171d90ca228477c4bf59a75fba994b2f709766dc35b8795105808dae8845175fdcb103afda29abf23cb08fe0ce456c33ebb93a2a875cf03f8f2d0f717842e7ea095a026bf0c95d67621739a4a7410dea632825fccc5c4996197761785da627e91ddfaded28c261f2326b10344b54577a08cd35f0b3edfe3c6f118e12be7df34c27311f8915014b55e39cc2977d25e85a8211574d55248d3aab75a916eb7970540685e93f5a5a2c4612e2c0bf10e6a035853aa07855b4821a3a96f87aba69d00100ae119183d5bf93581f21dabf50f85dd7b1333731f039f3fa0442304f90337c5d909a13fabac86a8ae75eaeb033d18e67e4f2e02c5c78601cd04b9e77a93ae24ef56d62b90b696161749a0bae8c4cbf1655e73dceb9f7e618374587da9f9a81d8ce9576401a6f9060d490dac01ed1b59a71de98318f4cfd33ef7e6074f8554cd6248d2b226fa6fb52f47a53e834e516f74ad2697998ba57519afc23651cf236a5ff4ccc85bcb0dc846928b0afe75fdb545e75f27d9d205891fe1917d862f16c92fa947e69e871373fb2ae52e89c0e1637467afc5fdad546a21ea4866ae3712d1288aee99c6348fab36eff470bc8a5d82ffba6d8b4986cc9617125edf1f332b59f2b57bdff2fb878d3e3ae946206df7e35dd18fec4327775cd3562d405a542c3ca096be2f59a94fa004a4f6eb6d12494668d8afb6aecabdf2d174222bea78eda1a9a20794229cd04f9afcc8c39a53a04636a4ab93b4aa9fcebc9a06f665812ea3dd1af652fe30568a351e92575351ef21b003894f0ca2a64d98c418f6bc513d66b7e2f96e9fa5a5d2b48699c6d079d2f68db827d365ab4d585cd15993dcd679226622a3d12aa039f62c4ae98b60c28665dd8a6f3be218cbd83f8d6e389b42efbd3265c9cef1902163d3fb567e78f5e130e0e5907013733714420722b3b929787b80d50f9bbc1dfb8bc4a8d80d81dabb1cc994e27c4abe2536b7aefe4ce85d79bf84a12eaef30e255be226008d29f61e18a43b51fe464ce372e226c1e2174abc9ecdba575f08194ba46aa1823258263b538bb8b41cd2a390202c7c8e99c71bbc4c0408fd33a611d31696cb9105bce1c8eb48baca48be1225f3c548e39eeae4c6a905dd92eeef937e8427583b27d914f0bd1e244186e13e30cc7523be6a299e2a94c79f68a2aa9d90be4cc610bea5e0fd5fcdd7a2beb8d758c5ed211f7ae1e206b427bfa7078d65db8449f9226b9f21c65d320a1c72ddb460ddc0fe62a2aab20cc58063ab0f9d0d129c04c22fcda3bdc3bdad548d412a345b06a5ca576d309f83f81b3830d1bdba7bac419275ee8525df8d26d575f5e835d0ef8c02b470c806de10e31e7b9e0b3b036efebff2f1938cb5f196f6e9877945aef57a41d1c517a17b01610577f4d4d26cb7a71e04d37b15a137fb00bc45b4d7c695bbe614504ddbbc0f297b6ead808fb57f7284830daf3c2d2ae48b3ee91cce5c99f1cad4b41ee24803addf9abadb15aa505b202cebe4bfaaf08869e5e363067e973707cc4558fd02f8797d331cb3523cb6291cb5cce894e1bea325885b38c78c399e86a2fac17352d53e406f7b391de0da950e75b7014901f4fed3d1c70c7b7709a903157cc275ee3d0235eada8a1d55f4d073afff3ec8cfd4573e4cef4085df03bb8f348c605a5e01bc8fef803adc2154387290a42e1d307c2cdd8da0fd3376aed889ead9de1641b6926202c7d5c7d050ab1ceed588313b2d26c51b9269ab9c04b43958d6d9fcb2a5c2c27dee88ee0559f8c8aa1c6c9e1ae945c5b7eaa89612068813c116bcb5eeef813a6a586cea394f8391d2c7a75eb61b136f33a4b8480163e36ea44c139ecf766690454fd36b28853f8bfcfb623a8f67dbb2de7475bab7113da29ec6ac5a69393824cc5661d75992de67ee55f6c79f57bab2434b085d3368f53d0f15dda17a932e2b74a967a603f9da2a0132413ebf1ea09c46d6c611d170db8964b23aa20d74631fba5fe14138f3d22bf134b31ae18042b8ac51237ecc01f0ed94f9dca874114307fd2b12df908a488e11283766124cc864c1252d6bde697a437c17e7b2e18527ce3ad98fbb46ba7d7467d0b8715ccbb9e116aa8f013ab53804a4ff5b0b2310fada4ea9d7e3b66100fb79c4a969c22eecca943d60a7ed5191098cfc8ff5894207c495a6aff2649d4abf89825b75628a1026e34c7a18cec3a5b783243c76309d70337ec3dacc680693c58d66b39e876af61989efcc6e5cc58d076c8ae43540c0b7216d81f62d71affbc6606efdabd6a6f163325e4bddd6c88169b5ccab4219042674d463cae6fc635f6b17cdbd6395f63892aac492f764ca299330dd59d982c5722e99d0261b92263d3d75440a7a7071d980e65b6cb11643a5011486bdec6d8ddecee0985e3ffb4fdb7f14b1682b37fa4c8806d777bddfbb02d71c7855f48602436258041a60cb1160dd2a5f16de67966625dbf955ba0d866095a76cc6984d8375653cca8b9c32508d8d9863cb353e8892a0ed2b19eb6336facb9b0ea7d018aa19504395ba5561597366201344d2f12ff7045c2214f4dd83bcb51aa3e5af250e5df5505ae89c2abca44b47aa92523e133cdc5fde57c83f297d118cae59d7b14a7d1ef5d9a6f07211031039ee03b344ca870d8f4056c475355df9ea451980da78ba11e791ed9cdbcdef4ddd991081ab60f8d53527ad54558d1ee3e7cc9f4164c7c5a20c17543b8e2509676e229962330a09c5b3165d08fcf46d836e51d0941c23f5d0fdbdd8f91d19e9a48395d7e21f458073a07ad74fa9091dc88b7de583b0184f73a93b07b7336246aa9044aa9e1628d7dae57de37366e65687d031184d0d523d7f429e58b03c9ad75754972d3dd8142587bfb2737d34b576e904b3ce19bb06099803180d5aa1062a026e2131faa5faf63a88b3e1c4732bbee9a8c70fd8ee028222bdadfd4f41a35bdc7f781f2c88ed8392e9069ae19576d88e4a608efc73792310cba29331ae4a4223b5e954659870eaa41e4630f3bb4637d8590a2c5eb79e7fcc2d231ebe3d9f46388490c6eedbad1ec11462af0d9ddcfc88b5873325c2cc30208d040bafcd0197ed3571d95f20e909f6448d6a00ec1751d4c9067e14d836c0cdf7580dede33f51f1346128df945cd6bfacbef43bea2fc01ef5a9cea895e67f635bc4bf2c3462d189ad97a83d3900989f97a6bb4208e9d377ea5f9fc194fa24d9411232deeb24e08c9d2fe7d434622d78aaf5ea7ba1b7043764e0abc8953ff8b14bbd5eaffd2c1059db3ddd011843c7e1f3f4ed7051790cdfd2b653042df254dc7884550c7bc1c3d299a8bea0027c47e57afe730f4e490d746384a815e7e5a155c3262e4c30ad64eb06743bd0803ea771c5ad2bee31d6f644e106fb16ca2c7be1b483e5338e5840600316f181376bd4c8b517630113a20cd2166c43beccfd783ec4c2efaaea29e1713d604aec17bee9dc08caed1171ad831128d09f772edaca49be1d54aeaab7c665377dcb51a2e78d9ea83c632b032b63f70c450caeaee3ba91e973c3f2e2b4d22cb125fe04a13017aae95903869df6603c261987395205d94ebbc1247a59f0466ed6a17e5fe69eb842488a0c584620dd909eee3427f8c6a1418f86c430136ecd4b97fdb98cc08018a36393128b23eda298ebac1cabf0944a91348cadc27e620d96a8918aeb3781031731080282e6322280cbc805bc7423471a0b92bdbd59e6ef49be76219f5032172cba07fcee5e47396aba1c239e3536f269ac49341101bbde95c4c29d3dd37c35af1cb52c04e801fbb0a019b153bf545d75a2ba048109dac9b96e36e8a99072466eac6f1b1adf1f4825f325b3dcce753ed072e4d851a62e273600c08436941e78d9db3964c5101dd158ceda5477843d2bb290ee02696f31f968708da8c28252c8da0052923700a2c97b77735ddad92972ff1b1c2a07c69c4a910fa4e74989c6e7e96d28263b58969c58149fad3e5b81aa947fc7ca0ba502ddda16a5222f2e30c49b3bb1e41d45b1bf2afd7a65d63ac42c503c7a7194e7ccad45a4c0f25ce5c132bc17a2f8f9a4565fb301589b8959cd1797e7a662377eb0594cfb2fb364cd5976b79e0fdb43d2bc24032ea4ff32607dcd59017503b4a928eb3c894d559f29a1552b8e74eab2dfba7d2bdb4f6dff63a00561b847eda7a52f45e787f0e02824fe90efef36e1a330197c6c1becb71721ba1bec1b64974e7c4a9d44ff98a61621886558950ee4fd91658552c41b764e3d35bd124eb556f09fc72224d26f8c93dde1ffd5eb7652aeea58b930e8b5ebcd62f88bf37101fd189e888ebd11732600f4af2dde49a1f6b185133c7759a9ddba80e1c86f7780425d17f5e765c0f0e1efa2b36208337c8feda3f690b2c7253af55d9eb7f32349852abfee8b03e4adee80f6844b4c888732ef437f93abc70914a60c415d527fbf218f23218850dd866d7d08227b3296e3be0e8fc1c359b37ee1a093e5a041f67cf1d9566ad288ed6129c52cf29bd80af893ed9627cab6050e362859ac2f2e364987a63450a1b65d2531663d8997ba5ffe5d8246ea04540a5ed9906fa3a5dd15e7bddb95475146ceb726a687b64c88dc7492f1619a7c0312c2838f3d3309df7830a5f74c0bd64983d591f74c6cdde2254c5981776661578cf8600f83179da7c77f768dc5ce0a96c121e99d324d07e663a6370bc1e929272b671e5a22bc137471a7f002e14f8806c6fe4c07d8aa9d3e0d3fbd5a7149f8017765f480e2dff865fb292826f45ccb2698a07b7bf601bf7455ca45cc3f804438673fc83505109f4fb891ee7e9b56885ab7fbd8e1c6d0b836b228b67f4fc03bd45363134598494eda1725883c18cc8a2ce13579c8f8dc0719fb97bf99b7a87efa335ea2b836a53d1d8e3fabfe048f8cf014c6a47e460e82797265fcb00ad9f9222bc080ef161f1ff27be458761dd111df059ac8113c8f5a72ecfadbde0f517d9c540edc1c62eecf0b9167c0c74527d9487eae51486f86b1da14ec2016f734b95336fbfba34be095c6ae074f89ce52eb0ec9c737a0bf0409b1f84c01a5aebdd794053efcfd0e847a778c8d67a39d58ef2306bca5b6d7f354db7cea31eba6bc09bbf577c87bcedbdc58836656fca7abf12f91451ff9405a70e738c1a1dcfa9704ee5927d5c912e5fb449b15c09842061f1d49f99d965545168be1474fbcc773c0a80082f65a3810e1f61cda61005a22fd06d8b5d66f40e6fb0da24db6cf58e904ba50c04d4f2ad664529c89bff8801f7f79a1e952358a9434bc7ee26c396f5e5d53ec134806cd2cea41b84ef45d5d5a6c12a34c4f704913af8349e680fdba69ece4e0b74b2c19509d1a6df114da02ae6db1534b983fdc5822f9a631edacbabe6e0ac7ab873',
        salt = '3b9168f09cb22851cc15d348a4cb5d96',
        labelError = 'Bad password!',
        isRememberEnabled = false,
        rememberDurationInDays = 0; // 0 means forever

    // constants
    const rememberPassphraseKey = 'staticrypt_passphrase',
        rememberExpirationKey = 'staticrypt_expiration';

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param  hashedPassphrase
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassphrase) {
        const result = await decode(encryptedMsg, hashedPassphrase, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        document.write(plainHTML);
        document.close();
        return true;
    }

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        localStorage.removeItem(rememberPassphraseKey);
        localStorage.removeItem(rememberExpirationKey);
    }

    /**
     * Clear storage if we are logging out
     *
     * @returns  - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        if (!isRememberEnabled) {
            return false;
        }

        // show the remember me checkbox
        document.getElementById('staticrypt-remember-label').classList.remove('hidden');

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassphrase = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassphrase) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPassphraseQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPassphraseFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassphrase = hashedPassphraseFragment || hashedPassphraseQuery;

        if (hashedPassphrase) {
            return decryptAndReplaceHtml(hashedPassphrase);
        }

        return false;
    }

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        let hasDecrypted = await decryptOnLoadFromUrl();

        if (!hasDecrypted) {
            hasDecrypted = await decryptOnLoadFromRememberMe();
        }

        // if we didn't decrypt anything, show the password prompt. Otherwise the content has already been replaced, no
        // need to do anything
        if (!hasDecrypted) {
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const passphrase = document.getElementById('staticrypt-password').value,
            shouldRememberPassphrase = document.getElementById('staticrypt-remember').checked;

        // decrypt and replace the whole page
        const hashedPassphrase = await cryptoEngine.hashPassphrase(passphrase, salt);
        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

        if (isDecryptionSuccessful) {
            // remember the hashedPassphrase and set its expiration if necessary
            if (isRememberEnabled && shouldRememberPassphrase) {
                window.localStorage.setItem(rememberPassphraseKey, hashedPassphrase);

                // set the expiration if the duration isn't 0 (meaning no expiration)
                if (rememberDurationInDays > 0) {
                    window.localStorage.setItem(
                        rememberExpirationKey,
                        (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                    );
                }
            }
        } else {
            alert(labelError);
        }
    });
</script>
</body>
</html>
