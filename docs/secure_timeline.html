<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #4CAF50;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #43A047;
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #76b852; /* fallback for old browsers */
            background: -webkit-linear-gradient(right, #76b852, #8DC26F);
            background: -moz-linear-gradient(right, #76b852, #8DC26F);
            background: -o-linear-gradient(right, #76b852, #8DC26F);
            background: linear-gradient(to left, #76b852, #8DC26F);
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>




<script>
    // do not remove this comment, it is used to detect the version of the script
    // STATICRYPT_VERSION: async

    const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 *
 * Mirrors the API of CryptoJS.enc.Hex
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassphrase) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassphrase
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassphrase) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassphrase(passphrase, salt) {
    // we hash the passphrase in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassphrase = await hashLegacyRound(passphrase, salt);

    hashedPassphrase = await hashSecondRound(hashedPassphrase, salt);

    return hashThirdRound(hashedPassphrase, salt);
}
exports.hashPassphrase = hashPassphrase;

/**
 * This hashes the passphrase with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(passphrase, salt) {
    return pbkdf2(passphrase, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(passphrase, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(passphrase),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassphrase, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
    const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassphrase = await cryptoEngine.hashPassphrase(password, salt);


    const encrypted = await cryptoEngine.encrypt(msg, hashedPassphrase);
    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassphrase, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassphrase
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassphrase
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassphrase,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassphrase = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassphrase, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassphrase = originalPassphrase || hashedPassphrase;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassphrase = await cryptoEngine.hashThirdRound(originalPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassphrase = await cryptoEngine.hashSecondRound(originalPassphrase, salt);
        updatedHashedPassphrase = await cryptoEngine.hashThirdRound(updatedHashedPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassphrase),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
    const decode = codec.init(cryptoEngine).decode;

    // variables to be filled when generating the file
    const encryptedMsg = 'ec07cd318c2fcbe5b67f211b462af7a9cfa278984105b5bbe808b263b63575278efe5d3d49300117ca7b98fd06b3dceb64b55dcce6c3845c946913e68330593ea91c0382eb1a55ebfab13f60b674e532f1c07eec703fd5cd4198168cf5c11f10f6d3f9333dd4ed96a023466382be9d576139ce83298afae4ecc4e6d6fa434716555fd2ddc0dcdacc60f2e1b13576ca03ee13650ea17946a1ec1f4a6498a6ad0b448bdc51214afadf776a12d1b3addff8092a597c4845a28e16b6fce9ceab008037876a5a2ca04ce2c37b3628fef4f572d4f99e2d3d54631f04d12700ad21b4932327bb5ccc08925a84cac9c87862329f5f18fb8e1a8bfa6ae6006aba6d8affe82688a8a9e000150ccea66d3dc7fe6c4c4352caa0c14248ce5bff328c0a4000550300434e537008502c2a63d25d76dc066e1589c910190a957b21cf6c204c93369868bed98d03b1318fbd208f2eb96fc61d0336fcd77f42b58f3717e988ef0588e058e0652c4bb8f5b6f9491b9dbeb8809a27e15cf35312d4020786bfda0087e9491e937ece9026d32a14ccc6a038861ac3b2318bfcaa71da3ad47461b6bda8ab9ee93d20a3af8838adbbee4a8e014588a9e571a8b5b7fec692567163a5016ac0dfc6b72c39e8ebe6457603b5ff8e0bad7182a75dd7f41df814dd2e082535cfafc98a26d7ce53b51973a18f1a65374ba8e28c2ca50fa7aa1694bcbc552c43e00063f7e55b7908a18fd111d6596fcbf9c9c173d709f52614f7a47b61e7614f37fe32d58d550dd97f08414a3edcfee1c6b44dc70d45d63045f03c3667af058b99112ba20f8da8c1c1bb36f09426f86a0d2a875093224fe1de7ee0fa89daa7b3213b47360cd35acc510ff73edf658344df0a88a7368f1ff4af5601f30b0bbde7e3bc5d1eba1bbf010419fe5c04ecdd58898b873dc7fb240aaed0f0daa59ade222ca8a7f61ddadebc73349b82405c00d6024c8afbcf216fe415eb6a1340d4befb820eb7d657a38d6e77178a457668c403a87f9450ef5c3eb819844d6eeafc5d27fa28a5611ab63e226a0d75dc42a27045d2ab4cb30383e549588863a832e0deb7fdeba1da4c7df1c3a56e8d7c97a4ee854e3ecc1c8c493b8fb16e0c194e12909ce90656efb53c032806452d7aa1a88f7a29a1dc9fa095577b1db91ff64cec00d4797c90f58723b13cd5270fa22c5bbd1d7d7d4fad0904c4840e33615e3dec486f1f25b459e7c8a36e32b5d9280c49d9f162e6f7930ec5429859960ffd891cd827752b66224d4a47b19a6bc4bf805badee58c0e809165386eecb519ef6b2c0d97e42ae0f29aa343479c54875b1382a2d3f2ed2b6d906a963960bda4716137d53aff5a653e344b75f86884dfa05fb86ba30778bbbe9564d135a0e96a872caf28b3a3e7070c77fb3b26f9fb69e32e3d6bc993da55d228f153efa2cb36c03ac286d74bfa4d1a217c9b8421f29e88cf603a4dcaefe9fecbbb6d734edd60d326fe8606f2310ca3e30446b43c613b4cc0aff74376e3113b2bed23b90fb1289b5f21797c6045a075e4dedb42b8fda0d3ac5ef8fb587b8c4da058157d8ee5ea3634423a13b1519631b10fe957d4d9862f8042a2fa17fee2566cb139e6fb80dab350446cf3b99ea160e3a23522dc3003e66dd3987f2dc1cca2bc1511b3fc434d7231d51d14253ded610e95c31a2b4a64444bb3b514ab380503917f52392271926daebf4c3ebcd14b02977f2b5b90558d29038757cc59a5d9e22f313d624fdc349140fa3c1974f31256edcd66b4a3f7434dbcf6ee1348bfeacb004483ad9002f8c5f515875315be9edee34426399ee75675f157b1db8991e7693a04e7d41c4fb1c8ae766063ddcdd7d1a7aaabefe8f89415cac6b7b395206c5bacab9e2aac6767fc964bda74abd964d50931784b26e7d717735a15e20f0c193bf6ad3cb990cc29554827e3d6ed83d5b8a3cb7ee4e707e42a75ab7e79c7c178bb19dc15f3af03ed30a5ce455245ebaca4c73347384c23d53b99b14b08cdd44fd91bfea0aa4145b8b4df74218eb7a8c95b7dc925f452ec68c60731864e01119edc0db897c81f11505c178d657e93869218cccf244cd200c6753f7ef5e0319f0d99ef5abfa0362b9efe8606b2aa81b4d8d0adf5c3745e616620a45a22426b74c5eae68205939bf032c2a63a25dd5f1d5abf60d91378866ca96954792d465f9a50592072602e61bca32d8027c682ea540d971e4f75c0c3938a150c15612ab8b6f708b97734ee95f8fb6a97173744760008f04a02b10b2aa83bc0d664735a7d2a716f116f56830ec51b3a25fe8a0acc19a095fbcd7fa0bd49b78e4cbea288e2168a8ba8e9b7ccca35153e894c0d95a91147c1efdf33f068f1a6e1a724b99c873cc9ed48916b36ab7282fd7a55bcf1ddf1e63923b04c4602c25a7e99297409cf4bca2ae20e1444faf606295cf0ea8fb074bee32a2714beba90bd03930d49ff6d18e830d6fb5d7abc520cbf41f0ede8c34bff09febbbadf39f63ae06b924a01bf14b8b43c2caecfb8fa3f98da9d250d256848b24cf67494f43038ec1b201e4d47b62eb705f73eba1bad729dbf1d4cf8818beee2bd37a439972346aa0e5241ff9830178282f6d61c8c44cc0d216b6503d7a9504ec9c64b851e1def963b592a4da57ed2195f4fc1c7572694e2d56ada90d91f737a1e55faa2a7c9aad960c60c94194f7b9bc014d60c31732532db9b82b34ba15f6660adb6e046b4285bfbf0e8e243f7180640bbcf7bdfecb25f731c9672fe5fc7b9d39248fb9f43dc8fc8dcb664991243013542148e770838b43b5f076a7460d93fd30f1d950a6b1c63b1c3fe191af802ac93255f7a761d19d2347f950e2ebff641ff84e2263371cd88f7550138737e44ccff80aa1d4250dabbb1d89a32c98c851b4cefae6db6ae22587c765ae7b0c83cc48206cb8c50d60a41677aefaeadf368d5f3babc0984a885912272adebaf0955bc809fe8d62c45429eaadab85f17923a70c9691f81839b85f340c89c2f774dda4b08f0e1a059291bdc711b4f3882eb71b9025c06cc7a529f10947b4b7c8f828837751aa609ba3caf4db8757a935df6647db632a9db597cc5d6d7d3a4e3175833560be5dfefe38251f07fded4ed76536f853cdaf7fd8e5d3522a1c3d5a9b120ad571ebfaa6f7450f5cb31c964b16bcb91cc54e99db5860f97acf81dc785136055fd367ccc071f06720c64d75c50ccb1a5cd1d6b42da531813ac64f2e346e90a2627990e28bdb2a593608e1a053fb6975a7cc4502ef102d46d5b739a911cfff9fbebc7c36d425ec1a0074e195941b7c05bf5d9c8adf07aa7256becbb3ddf1bf251bdfb33587a51507c0bcad81544a3811e08067ed01e46523ac8bc7a6357b4a40d6d3ced5a917b9f47d4775fcbcbeced2513077a032714068fd568ca72a6b2b711519d50dff96f138aa9eb6f74b767e4a46ab5d612ab064335b90736ee1a21cb8adb49c9dedca650ce2046796a0ce8e3430b88f64803410160d6d16dccd5093a006880f16e680d7d5a8ba67215f7b5032e7c6092b7974061bdce8abeb3577099cd3371b532544d05070b83f210c9a8c9d83b464e39075ea74ba70d54f3ec691fed4fa06953731932fac99b76c8cc83ed4323eb0ccb80876145da5233672623e0a328dceccff3af1f8ff1ca91f1c14cf4b3ffbcf3e0c13ec17eafaf139f1ffa20236a055856a71ef86d5c16ba782debb76c2a2f68a96203840eb8d6f94308d8d94db2bffae6bea9638ce83705ddbd0ce0d5e82a83a07c81493e9fa9f8cc535c3c82d10ea17f754c034dcdc4cffaf17a10561905c0bd7c31d10429a5c258f0b013016417568bb39fc6a7f6c1ea0bbba87ffd5d7d235e1686838b69b08454dbfaabd2f16d5795540df231a4cfc20431149ada5e357a4c5f41c26a8382be389fe30550434cb52b79284f5e20f28062528bdb65e41eef8641d4cffe87b02b9dc0a31f8591358660ddc5b9907ab3a08a849be5cd2ff622bfe54829d1a0678812db58907d528f08088a7d56e5ee1ff81972ac574d826218cd9e7bb583f2f61573a0e5ee6566abdcd3639fa7f3bb7655a090ab53f7c0d3df81b21e7c7344a82213211d511fffa6c6149c1df5d885987f23773cd9deced6d3aa7a5e00a9ebdf4e9a5855363affbcddb87753caa1c5ec3b162aadc563993fa9de03a03496cb2e08ad06c893c8041013a5931c8426ff422b9e113ac00c34234b89b8a42f7369fcafa65932af78500c255401392101e99dd78920f5d0fc2ccad7d1742f6bb45b5f7a258c6689c152d32c427aacda105c5f0e63861529ec360aa4dbf062d341ea343dfa8cddc18c88d981b17a7969a71d6e58a93acd109fa663085d140c0a23730fd330978003fec377d012cc395a973689e70718c26548a7c521aae3371175ce8540fdbd64a2d0c688cc2ff77c9f2bf4f95bfc6f20466e1adb026512235534cebe50d3f7072dcadde844d502e8dea9bf2737442b749a4dd3f115e93378dc79f96dd30842d921db0112f817bee87013e0be39b5a40ad6114a08f1eab1bf803ad2afabb9faa4e34cdd7e775fe88fe3d28854f32d86e31ec6322cb702163216e2198925272939332748e705f2bc23e43e94728ae945accbda6e958bdd70c9e8605ded49855f39caa1a019e54bc9861fbfe6dae55158b8c707a9c119ea9337bc1cf11588d24d1cc3840f80d8db3287d7a77e77a15a9eb3dc4ad9ade5e7612b75153b335f61f8a71084e86b15619f9160801f7d4e9dc956de5b16fabaa6fddc2101a099d320ba5c75f8f35526d45d0b29a97a806902783f538635477d424365f9ff25573d6b4f0b0f82716e71ddc488f4b2eafb2d3e902088a2b0b6bdd43adbdcdad85c7f066464e25c9506557696fc10dfdfba8aef5d178a897f31d1e5d27924b4fd088bd18d55eb9a0003fae4eae85f03f48e7e188d8c9c2a75c495f83a2f165cb0efb4ecf974f7161a57150870c3b41817eb879a5e0e1a8110b8a221bf38ea592835ed107199c9ccd220e2d5e54039aa0cfaa02fbb88175be678dc8b4f7cc713db2630f6cbf9a9dcb0b4e96fc1029d3c0a538b606e473670c8a2e7f5309b5a8bf03e1d11e0d747857327cb6828131285dcde1237c0c5357474a9d446a6ceb00fdcbf766633b57c5f66902e2a006968a047e8e3719e7a249df1725cb586075f100477d3eaf0d1f6aedc587afbc45c2704f6c5a9b1551a9b2afd63ae8034082e590c92ec9f7272c380a84c7feedba969b7fcb946b63579d70aef48bf5f5ee25f454332e0675a935e7186dad7a8decd21500d41ac9856fdc4430e2f693da9fc4c0d41a969786a0db590299810284d771582eed9c87c45d427c68808467229e924f213b4130c4ed23943977a7d27b320e1c2d0c2da7814672c2941e60a9279ec2924f10bc84f9200d6c59e4e5a15a5fd01db9861d9c1fcc7e5cb47b1ae42380cc099d5c4882cbe9d3de6916a67bd1b5fc851c1dcdf8568a12af1a8afd794dcd71612d24fbc9fbbfb390e2866bc1ef1004a7583f8beaed475a36ddc37ef8ca3ccfa44495014029f148051a025ee784057fc62ec1718baec988f1043a5cdb705af570695783ebda2a500e9365e6c5a99702e801b067517aa0de31d2ca4738a36cb537dfeba4e14f54a2d235576f20c0266f7ae4f97f61cfda5ef8759af92a91a99ebc83f95b6cfdbe04d676e2ad46f2728e4da4557d68608c19cc97f655d2e915f32046e233f838d8fdcc60aecd55457476d8ba226d4ee2f25bdda224e8cc48388121a26f90adc0e66f81c86edb79c161bf67df71ef3b3f80dbebb81a47dc4de5fd12e04a82fb13842faa46a24695b8362a2e2ca604536ad7c806859008a4493d099fbe29bffd31368bfa24a5fa9b1ad4267e5031a7921b643c5a56ae9741d7b428a50a2d9f08ab924d5646b9f5be1d74a8c7fa3c20d8db3ed14bf785a4b5da5839fa7d67dd1bf402b35f0dd39e7ab338983f6bf3954888a405ead523e553a98b87d87e28e647ef1776760f0ba1a3e104a453238344e408e0cd0d218bf8bd2be994c1bc7881ddbf99160f6cff2f2748915fc2d4436a91c5556351df3aeaaddc251d8159be7c3137760cfeb7809e95ee3614c878f7a620dc046ac5dcdfbdd8adae87b8650ad97a8cde0049c79c3a1df15dd34ea21bfbae748416729d616a3eecf3ee9098cf38825353dda3f847c686bcd6b90ed778fb35ca2ebec524a42738055e72cfca13250b633f11ad1d1a507d2d15719cec8a8d1508e50d220bde1763f209cfebc7b7d9840faa4741eea134dc0a572268f431f89ee4f47d37b6168e00858e40dfdb600496daf5b40823b179277340cc22dc33e161eccbdb6939d5d7189a730462961690cf06db8e73d8f86f30f0a96789145ae9c5363d0cd65b807dfa200c2d2f337ff0cc210316ab929842671097159adc740522b26947a5010a29dee2ab201db5056ef1da87e4b3e9f8f6198c41928b7a376a7acdaecc00139be8abed7454671857f50ff5ea82b337a429b3351f032e8cc3acad2eeafae1f84b3ad7d6535bc4b07efadad293e95b1fe3746fec0b5be559e632e532c65b47f229391126cd4a7984dc05cd783822c5fb67e51c251957fbb17b8a9f3b2bbad533038ce3b9ac29f08fb1df5d6b836fcae4f7ede58351c7ec5cce31ad7e2945ea5f9a1ebe3829a1d9d4f4bcfd5bb8f92ff6c8d02c9030d3d34e6fe0e431a9383fb04e1364e4dc748b3194838e5051931f86aa43045d00c40b50a8ffe683d443ce765da5fc6475b3aec47e45067a90746ebf7995a24ea176931f1f9d32ed88e92076b3d48b131753be8a56bbad14659c1c1632be8a73d0368cf4d3b74fa2fa1a77de70fd7b9e5fde418ef4b9d59e3db21c9569c02747b85ddb3ac1f957359899b48ed1e7f9efabe61e98c6c6ec84f9e024ac28ed1a910f8763e1d39cab14e9f9a4f279181264f203b4f755c007267cc20b261068bd1ddd6e8148180eaac89e68ae4b608d51592cb33a5bdb7bd610de9d1d68cfff1d06d7cbb6a521874248a429c76240693c52ff9d6f8aad3d5f33b9d998b9df327b34bf75b1af2a135d69c05485598cef6171756297953f5041dfadd9934cd396299d389c342d8d5de1514692dac22e8e2cb66acbbf6ba2e1d456c742c8ab21fb21a890d0f85654eb5c4f01a58cb9b3fc6b9dd53623627bc1e928669370259ab0d9b4d7acf7c60e6e721245546841a8c58b00ca9b1c52d062e78e0da8ffdd0f62aaec0f933cb0a6572d14b91798fd60656aee5375a813de4d556eed19899427686bd3c5d01bf284b4d800d33b431de2ec82b3f13869f0ee5a501309dfb0bb4437978dac85b861f6ab6c2ce300bd5b27f59211faad5a1ad4ce66620fd3de72b9ad49e6a21ad03842ba1031e4bdc8f3b08c9f66ab51f25998788fbfc7406f19bd5070974be81acff88f36eeec1a62bfe1f76ad10d1c44458676df1a8de5d4da54c2d6bf406b88aabbc4533408233d307aaccc0d47979fd2024f32f7902b22ead300dd6e6300d662458b980167ef4a12bce12162f335eb22aff4ad80fd0b4a8fc5592f382b3d3c209fc5d860b98bfb99228d0c50f76ad4f7e86303a579ca3dd2fe56c05023282a4f6d948aa13245adb8506454ccfd6045a4d178454348a74a8718fb2920333b9d02621a399914ca69d2fc287637eedae9629c5c958f2e40606ad7d0e07c4a48cbd50b0327a902acedd8f0bbecd01f3aeec8ea559e219b6bf5fcd91aa2613bf64ad924265f44b6cbaba44a08ecbaaa9bc5961dad2e5c73765ae78040b4df8343b8ebfcc4d3e083d24b079a2f537c11040d42d66dd892b54a253660b49c2ff0c159c0c3f9bd91b0d3f97fd087c18d19ed3120d24f8e27b10fa675de537ada39d3b6739b0fdfbcca519b0632f42d7b0f9c780d577f20e4126bb02e574bae00f0c4f866aff586fbfd14d643b86e5dd118e72065af4cfc862514201b27462a580f895d83e3e74397aad9556bfd0359221ae83b0336c363efa4c19d9f6056ec65b9e01d2764aa5d6b0e54f9dac4017efa96fbdce9e339e8331d241f937da92a4e90062ddee02894b09a1350126f2d3b5231e1cea2a27fe4c542dcde7f8e4476947dfaaa7e00b74935436c71c75b07d0c78577983a6c0599bc0c644fd07875b3ba2be0593638164a747f81d1843fa7512ae7d28b3f16db8a349188ee3ae4071618191e96108de40bdedc2a72034ab5b0b3df1b59cebf202dbb0ed6d17649fede12e3467c70d77b39eaacc1d2c99c39ab6a35851a4dfcd886c7d1e43789f1d0173e85a3450a19f9497acc88bf2399d123948932b6934f794531515bfa462823f99cf0e5ba1ee925a890e31912434b3d15624cd2c1f0ff64c95da0104290a49d74f5e5eddc9b8a09f023f95db609e52209dd45134c8e3a278c2dcda76c5edfa7dba6f21b5c5c9847abd3d6580167d57c71f692be2f36b214ab63858cbae4289e6e471a1ac53968d263ee25b9554cc5cc1734a04f60b7a30d543a09f848d4a76f24cd95fd1942d7dec932d1dd841fa7ddc45cfbd1ffdbfa2547be1c4a1802b9f689019023ebcfb1df59d3bab69470f7a842a180c086ac3e1a1f98c3c5f1a42faa005b54f8ccb94eac59ff8e145a3b2957b057e3e549ffb35d90c105c80909f515865772664f4058fb55cbf4e81ff52ff54162c9f9615d96dca337565f8dd26e02bcd62bd2e8d76040b69fd84eae2a9decdad7d05760d3c9aa609c6453f55820ac6030cbe5e5def0f3b28872218a590d15ba245922529ce49f775b03df563cf60f4fea176284763d7959dd43f8144646fa2b63920de5d0aa5bf6fb47fd5c7586e039b65bad697f7f99430ea2fc82ce666d7dc2da25aa33ab6da31a2ec9bded0b4fc55ac2a2777d1ebf37721535ff8a09449a407aeb8f55108a36b5334fcfd7a27a253ba9906635e1db6587cd89a7321435bad074db6461f7952ed59a113c1712a9aca15ff1cc8d4b22e7121d04a1a78b6125cd937a5e9ff774d88cf552cf5510d6bc5b605808e426f57987612ae90bc89455320f7aa069f7a9facefb8582d46db38e1b2272c4cfe02280bfd04fd1c645d7416674f441314debcbbf6af78a5333a2fc5c4b30eb969d420f44f08e9d7ae2426e182a60c1d4c79ec412c06f6947d26928352ed7b0ca3823ec430ecff6f762fe051537ae512bdd810ec6f1d0f842d3ebcb250017611d4ca86baf8981519fc365ef491bb4722f9c17fa53c709678a829db62bcb92dda6e45f0b9b21e549848b08b594b4b2e7236d7e182f2dab80e65da6d7f62ad3ee0a1a90a4072307e422e107ce693089f0fa84f0f89618f19e6d565ff22b3d3349246da2afd61a4617e19a11aa328c7af8e2d4ce59f1e5398bbd86aa66182d3fe261b4de7f946b3b92e6277309ab1cd1aee35eb82143d45deef11f29fb8cafd67ab8efdae7c7ab735a99a0ad7c510457b70ce5065176045831cdea7250042a9412a76ded0c157c1c4bf054e047d629126112d5119809dbb44182c38d01a521463b3e77ab25efeec3f4d4264631f623ea16220733b083b014a92ef018eb4dd4e6ec5d699a4c9b6f21413555fe2ad137c52feca853a59374ad5dd43aaa2df297d6e5076ccbad54867eb66edfef984664f6802c8446d745e600b3120453ac68291080ef8edebb2c5a7eaa1f7f18335b048847f2fcdde32f1743fbffbc77a9712d122a0f3262e40d15ef6c0a341074d23afa9c2f298ec276794babfc0180a6661a8118a92d299cb62942018b7363c18101be0b1039f556ea37b668fd9b9b22b7d2f34a1309db71ac6949073d2e9372fde12c50839f28ba1cd89934420304e2e2508a9c34c9735b8ee8cfea0e28c93cbacabe513f8cb49d2e42bde2f7caa82247e90ae60c431b1eee58765ffec4e7b2807dfea50e85a484517bcdd787cf0108d7521e64e377b60ab4c49cc64ed482d352973c1145fdd2e459afe43459428d5a8dd205079f2021f50441ff8dfa503ac522a4a52ef1d2187b683c70d12cc3ee4822474d5025f7063a0f6f85ec1b15702d1f73005b83dce664f7924cac5ef7f73335b7a94afc30d5561a3d109b7db974199f7df8de89bb423e80442bbec52127dd08a2e9b4f0f70bb2c08684ed096016f3c071bf16a05abd5ae0e91aab838a1962c2eae91601cf68fd4a5643c25ef55fffb2582534b0fc219b2ae15823cb6de9a20506e2a1041c9ec3b74f31a01d84f96d081a5ee33a1d3f3a8232dcdf983fde040ee9a83876b0937787b328215f915770e0b516dbd8d852f77c02a7f1fa76584f1059dbe09e44108182eb00c19143a74c8642f74998170f407229c462f4086d48149d5327ce2cec715d284e5c848ed5c39fbbc0364f62c42726e6bee8bdcebeac95484db465e7c5ff6ca3997ab6ba570b7570495e80c328504418a830f1347e080a6c61094f2da3f1748205b58be41d455a5f35b535f4f9b685f7b796429249805d84df144cd237ea864d2b37eb94d095cef1870065e55a9ab8b8ba42f045a3b8f22705859450157fa0a9e7885ccc238215baf02ffadc59029f7b54b32733f96f25811b877b6b77825018c214a0e6846df61889889b1dffba987f50cd2ccee657b4d09db24fdc44b3761989a6218460b35a34f8dd21fc49732cde79d62d903a8382799ab974fb9f150ef181effb41d4b2e7d15b41c8f59f66c5ded6ba842e33fa225c540e0d5b241c84acca0432d34c243ada513d88e40699af09ba350166a47ffe5cb312c1601424b47b593a074207812f837bcaea930e6dcb84f37da704cc573b7b9ec59f5036c5948ba41f040ea3260eaa618a57bdae0a7d1e9cc7cd62e330970652fee9e168c463756d83dfaeb99d5f21c7403eb1006cdb9ac03fca271463d8035ac3f55c4eb12b2d95ba7e53ccb80f205614cf98bd78e8d91d128b1264bb8181e4d07dabe6a7373c7acf0c8269770f1afb7b65df1af46755e589a128541bad05587c3d1d667a2e3524543a74141d38aa638942d5d2dd4330e3fd52635b767c2edc61c6943740320d43bde05a2485704fe70f4af68d094f8eff00a1c8659a94551435dec2dbc8351cb3c9550f660aa4ada8ab842e3c7ffae4e686fa845355c86d48aee5b4f120e32bdba5f3d37190548bc2db5e980aca53d2a254910b75fa11f92270921263df243c83b2d29e88a58270463968336aed999c41fd54646726b440a5c4bc9cbfeb5b05fb04c0d32f097dbe05ce016705788d713646d4a3de275aedf793423ce8246a00cceb2f75a3f166c887cff7fddb2f1e2a3c95afd4c9cc76a0da188ece05c5d1aa496cd76c4608ad2774734a9a5286c387e829f25c7de43cb8c2a7cf1bfafb8643d93cf5f4f690c6d27adc749d75a230d4c40ebf46f2732a4903727f32e3ba6190b4f4b5d80471865578af2a95caa94d92a1e3b0ac619a37c9242b2d05aceb59f07c07a9ccf95e09ca0100c09a9583e72109d21da7cc25f54ab7c32a761890339cb69dd5fc6fa33d9b36be3bdaa9c430b8e36ee1de614d1c0f2d92b9ff72ef8ff75460b4636be9c715f14d655d9e7a32deb99977cf074fd5e65a9c270e412a90baa2471e5d603878e67fb915f746e5875250d32513a4630d412b4e42721b900e78657ed7b510e671ce57b3a59826480865c903c7e288148cd9f0c475184e6a8508711420790c6da7885159fa18382717bcbf5395ac04f1c5d55a828b038f962bb6c84053f1b4b8ac4ff521acce7a397ecdb01a22e0353ea10a74a42f0d31a7aa1fbd334050d9f0c0771c7ef60caeb0e5a5c31f37bdd0cea6f7ba2a7f52a92e5edf7880e4ef1df34b489609285dec262f1a4fa44031fd5d024b7abb94404f5461d82894aaef32a2aa070f584f1b94f809f444666bb0d1ab16192d24537a067cf527771b68fd5afaad722eb16a8a40c6c98152d5f4632ee3151cf4a17d967add9c0a2f6295a621d7358dda96eae1c37aefa1509de8aea3b912e9a3fe1872ac8b373c55552e1888b93a92e0332eb30702cc3f04e38d25b8f88b512d6960bad3275b71489b0b949cf290cb189cdf6c9d39e0279f23662204aab63a18fe3f9c081e64c4335df5a06a8c35d319fa2777007729176fa99a4d6bf01f17c3bc002137e0c4e5c10e683b3e105b585e7aff93c25049c9584f834c9c4dd3398b1c924de7df42fcc532ccfcbf8c1e5a5943bcd055f3bbd6a010e693b76dd3b73840f1a1c1be1157b97662b43da4e171c9390b0c4c1c593254c327fddf3eb13c802f321813356f47d0470d7c737ba8773321c2d448827ed067ed3fd0a9df03a7e226cdccf5770edd2d0f61641c168697ea51ff0a616243eeba3e21dc904aef7a1f779ce31e7a35b4b97208457e6bef53522fe21321290071c9032057337ade15c915bfdce1973cfa3f8717fafef0100972a153391d26fd4734cf322800cbced0fbcdff27d2de620a1095f08d562876e2f5e3fb225e914ecc7ac541ec4eff1af52740276953735431de1708a89bd808a1de8d7030a17e26c33b0b329e4c9f7d784e23db00b37384f87deb24cebc087f08ebaacff1d6d764edd6c090f55f726eaff2b410496a5c9a627f40965c4ccd6c87ed510aca7639dc0db02cbb65978cfcdcd5dec710280d11ad754e65b2445aac416cb89fa10a9ffac0550bc727c5a033360d255a4054434b04d65433d7820d67d9a390c59980e2745601f0bd7da19ab10ad36f81069e9e9c7275b0fc4fd595fcf302d42fd464f1afc6ec4bb87c384a452aff6f2354f13bf32a8c0ac85efb42713a2c8e793a99c05a297b09b76696f7f90558c0dff6d20c4d213ed834ce977c52eb786f9df95970f25b78703528cba6d175089986db8dcb8a18c8614e3a3751e9fca4d1f60cf7d826e72a67de5d5db25ee6a63c7d03b62d8906b826e8233db5dccd84726819bb20e06e8d5599b04d6724dece793fedd8ef0a9810e15303e59e95e93e8144fd24432a10cbd4539798a1a3cea6e63ebde7a243c7c6a7323389c5cc033e4e157ff7a0baa5d23cbe879063683a98b51fbeb45e6017a579b55583524a0f12c68a1efad965b356c2df1c47998336a25b98a98afa4052eb3bab050cdd9a07d3a24425a7154252e20968ebfb4017493a0c3362e408a1a1bde6442cfbe646d70e0495f5d15f18019d1bc098a28913b3296a30fd9d0649f3a09dcbab6706320faa8a47feb3285fb973802fb1dd3cb499fc2b526919ceb71f138afb1bdbcbcac1db713fe256ba7f3c6f4ec306a9742fb94d755c5cea7e8299dc7dba6ce333600bf522b52c2e9315a57c65c935750d358daff3016115a196e537475ff0d0b0130ac2b6b61c4f773df14bbb294dc1921ff0c5f515f3ba2f3c90fa63d3a583a7b359c30c43f4d3d773bbdf969b4bfe7f417a6fca645703ac3504223b79441a22fb59a44707c24529bfec86012e98837fabc54ea71048346f1af812334849e5809f0da2494086a4a8a8bb3beb39533479c6e14bdc2276fcb6a13487d1429aea6d318b7cf48b0e22d611b8842a143ef36d740afdf8c8b43719bd9860557fabcdf68e0597a6538c28f9316b68240706b188064a5598e5bf68eaa1e7dd494215a15da2d01249d2b4ddce8b824a7238e46343cc3ba00e461e28dac6b89e0421819f60b6446154a477d803f721918374bc9c477788cee897ae51d995a9481b6e5724c9676ec874ca4787dcc72d6d3223547ff935bc5638d372456f4d1412300f265ddd45a83c46c10f84107ee0905e40feb4ee4ac24edd923731cf42a2e32e082de24cccc79679fffa9dec33287407c5d48e006872c64ebe1f8b11946042bbe9b6d8eb0e28a25793b7add1d423c21217056b0069fb51500946d035d5ba7901f61737dcaa31fed600eb08e87a1f86cfd95fa02f0bab70d3f00c55db8b2af38e416c3f62fba58c62a90cf9a653cc8bbc14244fdf565549c8fcb54d7efcc95c07d52f74fe39aa47ffe199b01b1b72a3cd8800cc4e189b4c0c07d13b8fcd1d0759c0de136399bcf3c57383304c7ea9b372fc85924b2f3c482ff418c08ea322c06c193a0351391401826e09aaee2edd47e22eb42dd0c26d05f42eb4fa71fd2c408d5ac259970c00bdb1147643deabe8e38b9a1993402bb799db1d293b9038649d567f2d53797de716ea01030cf5556b11a62c4ed3141419705123d067dcc8949297761b8280d3dae746a5119f5c6898d6a10b46a49c01c4b4d938b75497d86bf4328d3888b9eb9faf28459104c618b93f8af107a688ed45afa9a35fe4992128225282b3e8416aa7ac1573f32e44de7181f2f319fb6f3cfbcde5005c0ce37ec2bc1b22398390ee877ac929e32d289a96748ed0b3cd06bfa93a669805c756f2db0615b1a28e21e06f1c9a2e6fd1a126dcd60a91603549d01063a3cae5b6ce386087e466a42b1a003d17de439260125d13fd3ede5e2b76a3126264f3a37b0bc1ae0fe65b66efc8fee3643b5a92b29b97bee3547e86c17d464e434ad90751d8fec039f0b6ac03653239432d47fceea9f129a17a59f159d9171cf22aca10bd62f6d733d4fb605a1dce0a40f1a55413b461427c5ca66704dfcc1fb6f7453f866119f6501b846fccd4435470a33f01b2797277b28440b9c41812f9b6cb78ba0d7937bb3b38c1e819cb53d6a8509a01f6b27c92c8ac899264a01e366791e1623a6003fe90902c33095e5a8746816bff9aa07924ef070b46e90f2c183fac1271b6bbeda7c64af0f5dc63c7bb0a9b7e6c1d02e45a4f8e81da1abfaf1efe45996b789f290c70c9b0c1cf3ae7952702604e28f5e3a0ae2a67c94cb9e825ff692ff38e2237449b66ae5dba1815ada7fe853d8224705fc775f881d9e635b03ca83db0293e7cf7ecacbd55f7dc91de712e6dba1c3476e22e287424af02e7fd324592b7b39b4c54e2e70f74576cd04fea413eb68f4b037791694d683ae4eeb9b163e8449ea2b83718979e5419d59d3b1bcd01557f619ab4bafe32e3cfe9b2a3dc50358f73fdca032c08d17b97ebb93d4a2b5126be634e2517bdbbc09c5320bb68115f80a8681481b25734c4b265c2f535529a73148eb75aa0fff37b2ec549640685e5a153127cec470f579a4306b69d832af4fbc8bdc369d1621614eea98fd9cde8475d3131dcca57578e6ee9c9bc8680b1389fe61436166673e23ab875965d43a825b7a2462e678e605606106c482cd404328f6f8298b9187ac5433ae0888789a912abcaefb95a38139829c52bd3b709de2ab2528c92457fd2f383afd072c199efafc6740c23270f43fffe90116a4d6607f8dbf46f775c8b73bacc54b86101d057e7fa7b49bc1a038781081c0e0aee54b28d5712bad6588bc3',
        salt = '373e14613fc50037a6c01ebb49b66c73',
        labelError = 'Bad password!',
        isRememberEnabled = false,
        rememberDurationInDays = 0; // 0 means forever

    // constants
    const rememberPassphraseKey = 'staticrypt_passphrase',
        rememberExpirationKey = 'staticrypt_expiration';

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param  hashedPassphrase
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassphrase) {
        const result = await decode(encryptedMsg, hashedPassphrase, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        document.write(plainHTML);
        document.close();
        return true;
    }

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        localStorage.removeItem(rememberPassphraseKey);
        localStorage.removeItem(rememberExpirationKey);
    }

    /**
     * Clear storage if we are logging out
     *
     * @returns  - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        if (!isRememberEnabled) {
            return false;
        }

        // show the remember me checkbox
        document.getElementById('staticrypt-remember-label').classList.remove('hidden');

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassphrase = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassphrase) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPassphraseQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPassphraseFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassphrase = hashedPassphraseFragment || hashedPassphraseQuery;

        if (hashedPassphrase) {
            return decryptAndReplaceHtml(hashedPassphrase);
        }

        return false;
    }

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        let hasDecrypted = await decryptOnLoadFromUrl();

        if (!hasDecrypted) {
            hasDecrypted = await decryptOnLoadFromRememberMe();
        }

        // if we didn't decrypt anything, show the password prompt. Otherwise the content has already been replaced, no
        // need to do anything
        if (!hasDecrypted) {
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const passphrase = document.getElementById('staticrypt-password').value,
            shouldRememberPassphrase = document.getElementById('staticrypt-remember').checked;

        // decrypt and replace the whole page
        const hashedPassphrase = await cryptoEngine.hashPassphrase(passphrase, salt);
        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

        if (isDecryptionSuccessful) {
            // remember the hashedPassphrase and set its expiration if necessary
            if (isRememberEnabled && shouldRememberPassphrase) {
                window.localStorage.setItem(rememberPassphraseKey, hashedPassphrase);

                // set the expiration if the duration isn't 0 (meaning no expiration)
                if (rememberDurationInDays > 0) {
                    window.localStorage.setItem(
                        rememberExpirationKey,
                        (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                    );
                }
            }
        } else {
            alert(labelError);
        }
    });
</script>
</body>
</html>
