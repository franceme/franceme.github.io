<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #4CAF50;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #43A047;
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #76b852; /* fallback for old browsers */
            background: -webkit-linear-gradient(right, #76b852, #8DC26F);
            background: -moz-linear-gradient(right, #76b852, #8DC26F);
            background: -o-linear-gradient(right, #76b852, #8DC26F);
            background: linear-gradient(to left, #76b852, #8DC26F);
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>




<script>
    // do not remove this comment, it is used to detect the version of the script
    // STATICRYPT_VERSION: async

    const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 *
 * Mirrors the API of CryptoJS.enc.Hex
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassphrase) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassphrase
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassphrase) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassphrase(passphrase, salt) {
    // we hash the passphrase in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassphrase = await hashLegacyRound(passphrase, salt);

    hashedPassphrase = await hashSecondRound(hashedPassphrase, salt);

    return hashThirdRound(hashedPassphrase, salt);
}
exports.hashPassphrase = hashPassphrase;

/**
 * This hashes the passphrase with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(passphrase, salt) {
    return pbkdf2(passphrase, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(passphrase, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(passphrase),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassphrase, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
    const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassphrase = await cryptoEngine.hashPassphrase(password, salt);


    const encrypted = await cryptoEngine.encrypt(msg, hashedPassphrase);
    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassphrase, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassphrase
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassphrase
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassphrase,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassphrase = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassphrase, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassphrase = originalPassphrase || hashedPassphrase;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassphrase = await cryptoEngine.hashThirdRound(originalPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassphrase = await cryptoEngine.hashSecondRound(originalPassphrase, salt);
        updatedHashedPassphrase = await cryptoEngine.hashThirdRound(updatedHashedPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassphrase),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
    const decode = codec.init(cryptoEngine).decode;

    // variables to be filled when generating the file
    const encryptedMsg = '6b05039f0b841d459a6b303d10b8e84b4963020d6516a854971f6bdbb33a5048f1c0612528ef79e9b34e381302d28e27947e10c24bb394d776899feb3bc7966d1fa270c485cd3376a357142e5e98462287c6445370d2a892697ce43eb8e2b9047582f78292aebbc35d13b431e91acb248558a05ac4df1c687b55faa42be0f1923b24537b51e4f011a5964e7ed68132535a844fcb2ff490f2916eb36f78f225c09d688cdc9033f90dc947947051ff8b69ddf85b1d8ae606c7ded41256e78e07ae0312de96d3a59355ba64a33acbf75e05541c5dfd68c453d3c9ae79438578038784864f2504ddbb23faf6076b95ff9bd58f9cd5d92dca227097b13cd01914629487fd6e3697b72e9c21bed9c020dcae48c6f17c1a53f8d902f27c9693bcdb92f1e44f28febeadd69152a0da4c1503e3c87cb720196c13f90028ebb3537c0ca003ba9f428a67d41fcdde3539aaf569fc15575f04d6610f1cecb7649b3da910e0338bc02a6a04ab4c3b4c84ae74cf7dc9ef7f7dbe09aa71774eca5df6fdd21acb4eda5fccb55bccd3cc82ceaaaf5fbe6ea570886e5f8d9c27af10f8684535c3e5d5577526a8cec67ff47f4f49ef206a0799734ef28c37ead259769abf10ec5a11a5546ea745eb37db76023f337223a5db5fb01263faca2ae5e25a0db3cc3e4190d3e547d093ded716b53fedd9b77241b6bab3950a0a123afd0712cc80febc3bd48e9c59dc9910697f28fa0a8de2b1f2f52d54034da885756fb6fd28c3d91b5ed3a4632f50db9f467e4825ab2ec1da03471e56304328a9654c6a7a8e61c874cf89cb325c84fbb45ec47ea7933a4af482808eadc56ad26aca7daba14f30c15575577c2a31b040c8d66c9195f12c55ade4590cc6e001e47bdc622592b12f2c95553981ff89a02118b00f7ac471d55e8624531f4de3221b4d5857c2ad1bb3bfc3309575311f2b542845017ef71cb9dba7b19a91ff4ec702802a0beee0c65035d3794efc70a30109add3c81c1c7deb7dc2c3a3391bdc1509860ecca2a11521b46ebe15f849a6a12b6746e234ac7fc080968419decfbfefefcdd55ebe7212dc567ca8ce5e0f187be53fcefe5c1cb94b1af92f6d3cf9431a6172335dad33b4af278f2aeb0c834bb68d5d15a60ff05bdd1b8e2ddf9ed336c2c7c59525bc34921a34e1f16c2601520d04547c5f65f07d1f0cce7c9ae8b6e619983789f31b658427f7b893889f4fdb0d8f8b040a1d352dd29e6ca1aa226788c52414548fe7ee94322161b811a3096f761306a1a4c27e3a71b24a2e5a021f278df5969e9d6f49a7a6a4d3ba55f24b9b794fcce201464e5d0fb7fe4477d98338db40df6afec38e84a614e956e2dd0ad62f8efcacf4a2e879cca6fbbf864492eb706f7fb3ad66773737662be73db147f9c66e8f982443d81140580360c7580806a324e10d00d54527a50032126b346072c416c74f710a71bcfe722ff1aa2c5cf1aa915b3a778acef21a564c2b4bb1b17c9a362f2aec31121e5fb0ae9b4a19211955a67af71a0b46abf48aa28073327f2808c98b9f0797375ba8dc875817c778fe7c02344efbc3e1cef7e42a63ebc1972fcff51bfb6d6c5a50df7f0899b434ed44f1af28076c216ba0a690fcbd5ea72f5979bd818e98e4b0435cf9e6aeaae7d74b431ba94f174c88b3041576769f867709789d3c7072cb82fb0e2b2f46593b8ba7c79f5c0d98a91305b74d1743ff673993b9a8fde0383a8d973f2d224551e67d6d4721be0cc715b64b78c067238f80855cd5c696e611ae026b9bdaf9b5d958b6f791091a5d6fb9ca726bffc9c89fa76f62241a4c9c931de20c57487010a5ac5efe47bf19d3172e97ce49b7701d105fb6ed9313ccaf8bfa0bc45159680a5fd6120a65a8becdc57eb6e7ac9eb91f69f279aeb4fc89d9a2e3b573c3a17f9b3f20a7c75fbf035a28071996b1e3784b1a2dab2b31f200cbdfc322a9a39f4a367efc512855a4ae340a4379f2a645de355eff6e1330a00eeec64a2e509ab196f238a4ed7b597fc06f53c0381b51601607c77cff2d2caf40148faac5c5c083e379aee5336694bc77f64d61ffceb5ca1e3d5c77c88fcf6b5760921ae1cca9099a7414a0a3189b662d79aaf0619b69d90a16377b0f3eb9b1a1e7004f75121429924a32baa66cf9bb4b8a6d6b56bb14234ab1cb25a142840d79cae7cf7fd0b94d697013fb66aab16d62fa5091daa55f52634e299e28c694bff438815a627466fdf356514d648fdc7271d2f36faa2e6cc3a6f55a7ef9101a1fe90193a855b28a3bfe0a690e545ec0eb5d607a6104dd8b8053aa68f780726d55714d7d57d5aaede994f3e02d9e6d25d4b551d86b1ff972d71e354f7a43c21ff3ac0a91a9dacb39c05d36aedc6fafa6c86f98174fa824cfad6d80dd102b810a560d99115ffe370fedc54a3d4ac39690e435cfac0d500b88cae5301775db52ceaaa22cd676c538dd06a1262e288d7f2462c06529ef40f3772d3d744688d8aabe651b9241b68de1e96a681487e6ebf367b1be92e2bd7d08bfa2783e160dd6c4540423f1d526f8de432719067f479008d5886659197031d3255d279e7472b0842ea65ed988bfde3c63b483ddfcad464a3a2cb0e44b742822d207628264bce71b0c0ec8dc7d2afd91544e9236ae41a2de1e897aa5bb6cf0c9287ed865f28db2f69a0e69a462af38fdb3d87c048b90280fa4da6ae26e43c73a42833cde9483c93d990e7b615b690bc0d0c3d9bb4d1760ec273ba281b4bb6784b86c22456d9898a5e119c7f4b8fbb1373c23aab687a987dfa8e613db1fd50d0d735579006f0d04faf6795e7b54ef6eb5444f5356828455058f04bd02383396a7ad13c07aa1b794b4b7bc65c81fe8c295b818e37f02e3f860a7bba9f38043434fd7f3391ca01f3f7b12fb865c85b79ee77c3722ed6cc3d2244dfa1898f60126bcadf684d05bbe0995c6d78a5cf7344fd502506095f07019568b560c17c3ecc4bb692b2dd29414ebf162650879ef54fe969d67d69575494f433a47d50105bc3605d6d4f7f6654390ebce7041bfd330e7c130f0236477018a357edff6dc298a3ddea3bb6f43689d4f15ba117a918ba1a3c4e85bf11bcf471faa8ed68de3fe6ebe4c0a35fb5c9b3f1b664ee50fcf7eb0347dd675e32202340817f6dc028a96237160aa6cb8acb127bc8b7585f81cacd59e0625c917a774ea5ca5038f02cdeb42e4f1dfc277b2255872a5c15d47c7544a730dea2e4959f098d5dcdf7cb74a59594954b4ddedcbcffc0ee3ab1021b2a050d7663d1fed8ff2b1ed7053db8d83a752e16c8c5fc752993aa4d4b577b2de20e0634a2d2f63679facdd209cd25e565bdbad7a12711121218858cc0676368ab001640ae33fe7dbe8e733652b0d23673559e21e99e658cef46f2a7f7b92ba6ce54c5d614a128d0c92bce8a4e7f6b4abc06d2457f3f03698871420f48c8a2f296fb128f78d55d07307193f3fe0f0ea046605ac85c972d1e7244060cddf1bb2ddc657d31ebc2ac527eb99fed116b0a76866d095077224aa6af7b420043a491fdc4f54d4d48f813aafbf5a1ce00b8f4c004fd9eed5f18e83f455d10c3df67f5d3e4acd88ee451df7d0ae8833bce9798b8b2a13b39b6b5ea0db1295334d56ffd54cb7d9b883361a6b147e23a9b2544560b74766f6c1ea7658e53009ee58344f25e7a5dfc085ba125c8fd0a1cac24ed42ff06b81796d42a3c7ea9b099a293e3d73ebd59b906e494143c046c1942d72a1bff7c4da4133952ae966fde91f37436cbfdb94840543aa70aaf6a17c51b2e20ee3c23507c5df891eb286ffc9df4ac4eba21e3068f193a0b42d000d5ba4b6b0a3190cc3563061817512979cc131f40b762a4b23cd849285a750c36075168f010e0daf6eaabf80f23c0a2512d25190c72598d98e6e6daf13ab3d793abda9f39b5067f8a0318f06282360a8aad020a25683f4542e5a218db188d769708b09b5b73fce1874d65c66483df87c37fd08a124176ee852b333824c0152bf0c986492f9bbfea0972abbcb8e13891e2e706c3a4d6a8e04f4d489a3a87ac5d4b73b620f2a4d517706b702c8de03d6f1ade847239aae86745027ba47c7838eb01fab79e0d5006ec88dc23aed7c33d24c3c2634358527c927102ff89c358c34eeccb19f8f49cb9c236e2b5ed60d1e5313d91a62e21191ca228a9b82472533586d39be36abb023ce34ff505bd99163b2ff464bd6faaecfc11fee532302a4bbf46d86642c7b33d0f70c8ee3838d4a785339d6dae12a48061c7540d2cf93f4ec0ff70425c348eb485d8e412c51343a64785b7f9eab5d1469e3bdc0484a1fc3c5c512a8a36973ae393220d9b193cdcdf43674f4a2b57e3a01259bbe0f6b5e433352efef1315e86569c678339145a85c31410460cff54c7bc574e3f6c36bdf9a7fbe7c488aea81bb34b21e9e810c819ee59f74b1041ba9eeb031a6abb1ceb2ff383a2436241a81205d623142f0c467d65eab21873b7b30f89e54c40385e8c24101bb48855e7b200c66c1649d0453d136bb5e8356ccb400e5d5f9202097a92def009e234bcc5269de14eeeb48c0b8f170ee01f17802f6fb974bdd02a8c3161f8df1e77ac22a8a16bbf511987e60bd1b842d250aafeb68c3b2a4ef5529e9be63438c98cb162a279694c97acb585f6f9a9e9b55b5d098bfe5b133d424be919aaac1d51905dea5b50e18f8ccda817a94eeed7e1283f26f5fda7aa0e2dc9ecc800d039343d1717ad4da9083b48edcce6f9e325ef5233c8b84cb983f9234e8fe3f6a94903177461de5edeb6cfa1603724e5ae3a523e08f72c8f95eacc31f0b30b358c07d815a024780be37c35bc6f967e14390e159f96882dfab6eacddb95d5082e54fb13f1cc4674675af86c55101b32f02a6138c876af8905eca81a02e82a7f49210f7db0711edcebfd82915b00de9b017ccadcac7ee211e322750399e8c5667a6252cde4008128b6776e39d4023a841853d093a26c5e08c3abbe67a730ea4a0331df0f92bd32462b835fcea35831e4e566477b38fbc8ea9956baabc814d4d05808a3d5b8421c6d95764469eef32993d2695510a6853bd406773366e704189c2508d8a963e65712283646ad9cc064eeaddda3d4bbc1ffff6c3fee451ebded238243157501a2ac4a84b1273404ce28bfbaf40249859e947fb73a34164de140ef343827b56142d98c666c32bf2d254783340f4147d1542a16ba30ec5dcd044a2523903e61cdfa91ff9bfd132c803cdd50ad80e05e2be9e4261560f7e9e70d6042e7a529d6b0b31f8e2929d6d7dddf0d0a67489fa320058ac4bd32cc896dbc74384c5f28d5f3d9d419481fc9e41b26fa994ca407847aa522739cc0c56f299d15eccfbf06696d5cebcdd9af743e0911c735911a8dc6f0c31bbc447e3993dcba80d9ed747277fcb58957f0653e156d25bcb29fed6fbf345d4787e14e731007a44947622f271bd16c6ab80e7b8d7c1131b20ff80fc79b802221a84addbcce3898b27452e1fd4ceea07474fb1e091add35537d8d272ee076b0a45cb4dfe85990a2cdcedc047ec38f5ff9623cd0709f8d7422ef6e4f432c78a483cb519258ac1e557e3b8c123cfb2ca2efbbd96154b2e6cb0d17eb97a644ce551e82ac740aeb0fea3e32254e761889a3b760e27f7f143b6601f4b4b3900070d0a498d7c8375547087186e91271ec70992274ce2aa89bc802888b5aa1d260c62e174c0b4413adc3f24899e4a61c2c6dd8bd5e308c3a93d92be6558f76952db4d09cab979916de21a1aab74d38b6a0425c058087f453e8a8ad1c95280896d41afa0152c4e5cf3eecec4bc7e99587e1657ee287e01cd94c27559065cf012c578d43e94799742d0e4d0fe78c517f425daebfc0c83f105799eddafdcc45df42557390dfea88fd6f182f22e7e91a7d1cfdc44db3fe9c517ba75bf3ef143615f29356b50f187c34ba0b3716e5044ff71928a8e0e0ab4fb825a82bb31fd9ab1a4c60d41591fbd115aa274cee64be7507036507808e834521781dbd35d8a6c345b79935ead723e29a0d8059b293aad3892b22cf977b52dbf758dbf60404dec2750bb7b6fb2e8fcddf335155cd9bd96bfa8c876727e6c71aaaf05bb89c7e0f74951a991cc813858c8c987fec21d35d316a567ace1516a0e011e1c9cf4bd3961e0a71db4d12a18e97ca505ebbbe2c9ecc01485841d2f2db5480299ea8d2160e8ea5e2387eca67395142700569335917f9b24c3b28130152efd7dca7d943090d22b9adcb50deaaf8ccb55227b38dea964a9f11a035040728661b52242c804e419325a05c7ee161be6cc47707459072c9a8e83e0de88e09defd7b5099e4c32e2022ee1eda14d58ac896e53268a346590f309690da59e92050211fdad4b868f2c0263b3010d65cea341b79537300d27f4c7cce1654d07bf51e8c7c8f71cbe41fffc619be0ef3b0d835b50dba6c7991672425131f9ab3c1bbbe32f654a0a01c8d9fa2f7ebfc047a21d0dde33997f6c8f3bf9c050cea7f7c9fe589fb07e1f03a4c8eb391826ea550d4901b93225e83b1e22c9cd8d26e67ded436a17523e7d2e71d21671abdeb4c01981b3cbde5f2f3ca95b317a746e7b1dadc55f7062dd794724b3b10a214db62d220fc7834e2ee1bf5d07189cc41c6422c3f2616e60b43ff946e7cc93ac1d72e59f15728b06f58ac0dc14167a61eb4fd52ed8bfdbb2e29607b3a470d1c6381ce23d8c4acba6780129e8404327f21eb6e9e71950dfbe0b82026563879dcf021b0b95c1db5b70bc637d52268915b0a7657c22754411f5bd2ea769b812da59c4762cf5775cf3ebd3d65b9741b99a3b54004548fb94326c03e9f2bcf87bdad38b413daed0b145e1ba15ecebc2dd974d4e44f0635b68289ab0d24bf87d60866da4acd98a623eb001290bd8174a3fa47bb9a5692c7415291eaaaa64412796baadc104bf1aa35a4399f51b896812f3b5e950e981e8c49c945ba68241611172f1433dbae0636dd18b767e8c7497572376ac7cf025dae23531c1308bfacf510fec29a86f928222949560698c591f556d01ce0a001a1930189d7fb611c930e847cf6c21125781dced8cbe30e0388004adda0e799ead9c693c5b6c4c59cde776e6300f52ee0d712baaadc2c24a7a6e610439315c283ddf4f1c8cf43233cef5d05298efbfcecddfe93afac2a1cd072c114f20d077833d39be4643035ad729af365f147697d4211749a4cb36111c21dc76f86daad0122136855764588312fa7de8625687b88e33e6e01ac110b3e91d6f6526b728eface1dbb9a54fa6fa7bb4c94ef826d8592fd4eb6b250dc52a514d950277b543d2cefcce38683a01a20d17fb37f009d53c9c90811963ce62f1819efbd9859b4a09b1760bee31021b55d161a231035ecf74a94ec1abbd19beaf5169ff2d0c6f4446b13351e6bbdb474965e729f78c5784b30b03f754478f90c9c48abfff117f86a3fdc9e1fda2c93a8e2d2c2101a1a2e002ebdfdd277909e4ab771e3d7a869fc2fca167d32a5d7bb6838cfc9f76b70fd3f99bde0d21d44a333fa12195ab1ccc101a401a4505b3125a2c01bc720cc2e7e9763c53dc445052a452e915095eadaec0a850c7b924e65478c9973663fdf29bcd073c9e41912350a71aa8e8f14df143ede364026d58d2bf6dacf31aa1e7630999fa3aba5137360917f1f18ac8252bbf8a46ceeecbfc27c1f7152f34d9289467c492355bc8d9ca576a9424bf7b27a67836ea271d535b308b45e3f80b61213b17831e0417e238fbc76e18c5c2a54fbf59e6152d469c7c49683a448dadfa26d4f27ad611fa263ed2d6681935cfe6d9f701c4bbc7e7f3182db1cf2e6b812b06a2e15d3ef7b62f19f5fa1673c66a32faa6ffedc3d799768682e2307a6515f25869f56d47bd783e9dd4c1d64fe10545e61c6ba2607af13db10fdbf0fb65594b8ac5e80d65ef2ca045ad6aff38f4a8774a67e1420c42c94518d73901431925e18deb8bd980dee54ce66b4022b9584631d5a6185a6e5c6d1ab0bf1e3601fb1ad33430f357f3a63ba8d2f0dc0f865b12ca040f9e6ae6524487e54e7335bae8b6a56055b058013806c7be02c681a2675978451e3151ff0e84ecd1f239ad4d7795f9a74aa099f3c2696f86225cf871e7bdbff2f0121ca2dc5436729c7fef4fa8d307ede7cac6ab87e1880c8b51b7694db160d41a2580cb6c2620f106465ea99047a74afcbe61376db7fccf138de328f91d687f09b0f487f356c07d06eab1c8b67025269cf04326d0a14449714b15f7985c1c298c524e765ec2a1c4782365763cd61608e92ce49af16b107c7e2534a65528b9c896e2b0de35725c0673a42efaeae0828cbe2bef93bfc335c9ab654c69060dde56bd276e4e877411d4e86895dfc010775362d66d2b6b3e0513d30f4d21b5c3f79f46620e31aebb0a5b98b80caa0e24fc6ff4fe1b53cd8b6980427765eb3b813f17c4cb3309793b81cdf9ffa0544ae79a15ceffaf9d641e313d973fd0b008594c5263c9bcd67066bbd5f43838a6c34e0c6361b25d9a439ec8b7dcb29ce9dd3807e201131ffa6e971f42b963f1139f27449706514de70fcc9fcb455cd614db4302e239a9a61a1cf05746f677a84f1893bfef88bfe1e36fb307281503b4117109353506b7776178f33797c83376619bffb509d0f254b9b61660ec713fdaeb5c1ef3f9c0768be26420ca08342dcb6b9e279965d231dcdcf4db982b53f680006eb485f29d382f3e80cb6fbc6cc090ae88e84ac7b3c4bc89cea42b19f7c763b6eff0bce897df70e99e6e4777d8207817f289f1086eadf090b3b29c8c8f79d42f7b91758333d620250b976eaddef66044ad5aafedd10d89c78164153c1baa8053ff84941b49d716caaf330f9213564452d8d1fad3f37c06f7e69df3ea33d33a49dbd66ff1bd5eba331db580a52569b27fdcce06a7eb2d5e870ac70c20ac8f916e6b5f8b7f424e395cb111b35f431e68df0ca9ea751677e516403205d3676817356c6a9300f5ddb90889b0c7ad8c7b3652c24fb62bffaaa8bd6ca97f498404ff8606e3f63cf4e542e317947394340419d4ff5b7623377be4d39d3261daaf3c63814747443a79a9e2736aa1bc69a7cee1e8341c580df539a2153970576367d0ce29492307d3abb1962c62d18ffcbee4dd2d64520c5ae482135c3eca56f1ecc1c8f1091ffd3ad549dcac62814d499a8f8bb933f2bb90cb5eb69eefa950c6ef67c4ff8edffe781463466729cdbcdb9fbfa2ff4fd6d0d93c4d412836ef7422b4c2def73fcb25cb0580de9e6546ad5edb85862de7ba07cf490a88f93a3a3f3430b228f64d0c6b336f168fd577e86505ce102412df4fe4a3e27a8d2660f6c61a87ceeb4fd390c11e1848d36c7f1a4741d3cca57c5fe9034b5d76aca6d0f48e9ff5b9f561e408074bf586f373f5c1b16507acb1b84570f6218c0cf7ac157a622a5b27b946bbc03a4aeeee166c034f8795443444c17ce3e06502241791b88de9f6a5729d881603a8228875948d8deef5bd5f48b99acbc1a71db819a381d8050a5bad72bd217a888da21fa275b2c127cbb7839d48c4c36ad343567dbdfa970e279dc658a728288dbf091ddb315e931b32b7c698598ad766aa8e89a1632cf4b7a1339a4162cf62a2999566f4909a562d3730a1ba2e9f811746e4d99f7e290841e478653f48046b516e370263ce9574735b93dd17d24eb45c983f31da036981b580faa96f2a6ceb36b7bc880b3f518f21633645882d5d3066a3d606c0779cea2914cec1772c79fa710a285d0aca6b4646eaa4de1b8faf1353b449780a6198f9422979805cc17464434c2bd7d53e4f7b51be6864bce02f9a46a1a07de5d41a282979aa8e68816c805849a8092e657333759309430354038c032f9d9c248ab09c139823c862ff5689604c1677566e47d0284787b74d4ae21615e36b2c322f21ee56350a1ff66fb35295f5ed5a9ea28e6904f3b5c8d68c7b92dbcaa0380169d428bd963158df67d5395a8235294f6402752fc8ea03607647807517e4f230ddf92a9c08f61322c05369f72f4ed7c5abbffdce43ec5df26bab0e76d86ee746385fa197ffea482c6b89a85929f8d57793e4c792a4b9d78f2687c39097fc8716a0bef985a5b3f5f78bb39fcc8d4efb2055499c7ed9248bf1e8bf937b236cc63bf4f5c5516c63f30f9b11183f768b2c692870393feb80bf229f8c0a505386e138159609388121467e19dd5dfbccbb822b863b862d8e0c989602dd3587237b051872589cd7255547963eced00e313c5cb72d07a2e5148a62045783806f08b706c62546f2a8990819747b39246be92d6232d2df45028bee6954c4c42d6da7ae72c6cb66b083c072943dde6b6ca0cdce05fd1baad4e2fec0a6158cf1799c1b59e7ac47de982f598bd973f8dffd8724285f706c6b4f0b9d27753a3bbe6613cf058a4596c589b7283b08bd47c2fc13236dad95d1b0d0f8a24cfc73d34af025cc4bbd70c81afaf64fe29ce376da4d9ce7fb7c2d1af815f4b01206689cecc7372692f8e6f1d705c38a8f5962a189f10c6897d058cc023264bc998f69142b8c16d368dc053924150e2724d830d86bc5d6df3c36a07c360ad01b5f79d4fceb55dfcbdc7de6e5eb8e4630200be68f858f16068fa362a843890593c7fa474d4cb1cf10241ec917e1a3ef23b2321f162062cbcdb1f7444093c6ba4451f90c5af22a8f0a6f7e4fbd89bb820807bc2d77024e19c1ceda57168694158cefff14bf58fbadbce1fc21459b78d7770b0571100ca187547f31b672ff7c889d8af2479a8c40526f4eab074cb0c88c4f0acb92930dfffd646822cb8cf06287c0a346ec19c894308f2476ea19789ded9609c653b13259e381b80b39862bb4cbe98e5676f51dbd0c6b6d88c3b66b37be9ff219bccb0d7a02be15c5dd1362f5aa0b58e0ddd36117a872571634831dd9edf4ee5abc4334494b8e642674d569b65b223d5eac56bccd11cd5d46b1006bdf9d4fc6656a8d11e24fa2e22ebbffe02086dfb4dda45f649ed455ebf63b51238f3e1584035cb09a0f196cc3461f949a5e7887a924b537153ac1f0cdb18a1572c5260073d8a6c2fc4a6ae50389d828b13ddf1cf7b5f68b41b334a06912f23c8bd8732a7b90120cf950f32054f866e94d52bd2c4e436fe0329104a2b6a7057c4ea138f88ad31e653e54fce09b92230f9ae3b31de43e8e6be8238c54a295f70631e97147fb61c656007785b5ee0af68a55cd56f3f849b1f6bdb3bb356dfd90f3a105281987c847864bbea68da9af4ec2fa67e54983fcfa21e1689e89fc13646e99dba733147fef687fba6fbe2fc91ef414e8e183f9d4082d4d1e333689bddf36d6253fa4a15b78c56afc67221fa57423e5cc0e49e4e07dc940827539c9ed3783439fb8be2fc14815c64e12c37dd34e0cacdc83151c6b193acb1ec06b69fa0931a426c80ee8c687ec712204ef0ee905c4e0c7efba34474cf45ea316074031661a175397935305b7f6b4b0f90e723eb074a74f6f7a0120a8d62db137edba63ba96af87ac7215880c4adbe4589c8253ef91ee7f6432a5075883340c2b8bb2b0ad3ca349685b710a980215a29cd48fefe456a86b18a6d7d71e4d3fe2dc1559fbe089eddf8f11161521f835be3a4784383cffee7673b7906694ac7cbb9066e8a7149fe74cce0337bc8c9ee04bee25e5231f28259bcc9be3fc59d0bd98f35396dd0da1b080a4385c7d1a24ef97f92447ca877b41d6d5caff4758623a2a0978712eb1043bee5dd024a7d46c399e2ff18acec55d0d5df8b15dd3447ca0866f3ae90ee0aac4b95f42d44106b42dc5ad6ebc2e9cc04b830f3f729c1919a07d4eb5fcd0e1de74b128e9a0d941e498523cda71da656b01217d18eee6b5214942545592dd33d832662ac6e41293874e014cf5bb75aeb0a91aebcee539aca4a49c7dc7c54574d08ea7bed6ba0deca48d3fa88967f91440698f06aeb509cc43f9b344cd3a2f27b39982bda6386fdc82a8080ca9965fd3246f16504fddea09151b5d00d672c030c766eb168159f84c11e785bb9d46d46322e49224df65ac2aa23e3aee1678fd1820761fffc0519c65434f27cf88147ecf5f1744f22ac4971c07463070cc1a9c3ac0f14673dc9ef6775942189460aeba413ee3f37c0156345ce72c961e521b839b5f9ed665391b8d903ce9d9b5b921b90f1f101fc207aa17b18b0277f8162f2ffad09c99351cc9c0df3a2e94030730f979bffed35c54874cf598cdb0597ca35459a48e42b991e6f6d81378397c88327032ca910c6b71695b0efeb72623dfa847f19880a87de2e8375e99c1f5369c1efba31343d6751b303a7f4f4fe5acaa8c27bc37c545578772f6b4323a59287362b56394fe904f0a9ede812e5fd9fb13fdd4ef6bcf0e6cc9f1360b59f4df5a9230f657dbac81d66d8690eaef3a1e1883bc8088ea7ce37abb73210e3a1f7b2edbc0c02c731a36eafabcb59a630708d3b18c0e62566cf9de2bd4473d0114bff9027e47511af979be43607eab732888558553742986e74f198fb50d4d621d191045209e094bf1440fff3fd35f7fcfcecc742d6442fe5c495c36774882f744c04833ed77cf7e7453fe4ea03a2598b0e2ea0b02ef6a52ed55e3f8968a25fb1aa787a2c02da18bd39be310c91fed7adde596f4662fc31e6a2669add975334c4405c7b2f0875cb783f42b37a97c64e385726dc976db8f6d53adcc5586167ded7b8812b271e1f7ddc38f8f44e0fd9c21df8585c4c0a7b361b90690527ed9b3196601116dc2f96264ae62bd58be002d99448ed14ab98ddadabb8adbb2384b33b193ed419c8c8fcc1027029a9fc582c6072c5c64abde1542731229224e1cbbb841b76038becaf85f4b1638b593cd81a62452aca0fe5c5d8b7f4f1073ecdc6a72444b58e4a9df2367b9c114e2a0cac8d20feae66a7a66ae9694d52e12a18aa56700b3d986c8de000437eee0ce0168a5aca8a320e837c217273798ac262f8b5d2dfa4d682cc5cfc67dc00b7470640f161859e49035d45ad5ee42ed030c5da1c738861182239d8f639d26d1e5159a1ccb4062e3951b0380868621fbab612da731dad29dfdd8a449960292beb537a61b1ed67c0643b619e6d0fb1aa5f2b2e81c5c1d8a395a4d83924b2c9ca2aa6d18ce71355c9936ab7711a216e6459b3a69437e51ee287bd19378a52eeb4a4d61a1eef32f011141ea85ccdf7f85477bdd0be17dab61e1acbd9639789a130748f718a4f78eeaae588aaaee79141ce648ee3b7730b7946404ca8b126d596a34c2026acbdcc7a19ec27666854a68a054ea99712b93cdc356578a5fc8f3d747c844992d42c90278950ac41db9974d7921f037e5251f35e46e8acb4e09f75227cd77ff1277e2ed418f86337f6b86a96d69ab8edf72cc932dd4814c2efed0a0af49a97fe40b98c863b3279685c977fd10a61cc22d39233e236576297b124a9b1c23dc8977bfab1401bd28fd5e66b0789074d6054acdfef3e91f61f2b346d5db66cc36e3b064ae3f2a972070617fb8e6531c53bf4929c55e331eca31ec9e2017ae1601ddd668a6a2bf53e14356f2ef3c61304188b2aca1e6d48ce83f69667fa337623aeb9d16c061dd8c520468700036a2c3af266594faa3cba9e441694902f8e2096e30b92c',
        salt = '410ade69ab3c58ac350b123535c13d3f',
        labelError = 'Bad password!',
        isRememberEnabled = false,
        rememberDurationInDays = 0; // 0 means forever

    // constants
    const rememberPassphraseKey = 'staticrypt_passphrase',
        rememberExpirationKey = 'staticrypt_expiration';

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param  hashedPassphrase
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassphrase) {
        const result = await decode(encryptedMsg, hashedPassphrase, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        document.write(plainHTML);
        document.close();
        return true;
    }

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        localStorage.removeItem(rememberPassphraseKey);
        localStorage.removeItem(rememberExpirationKey);
    }

    /**
     * Clear storage if we are logging out
     *
     * @returns  - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        if (!isRememberEnabled) {
            return false;
        }

        // show the remember me checkbox
        document.getElementById('staticrypt-remember-label').classList.remove('hidden');

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassphrase = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassphrase) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPassphraseQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPassphraseFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassphrase = hashedPassphraseFragment || hashedPassphraseQuery;

        if (hashedPassphrase) {
            return decryptAndReplaceHtml(hashedPassphrase);
        }

        return false;
    }

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        let hasDecrypted = await decryptOnLoadFromUrl();

        if (!hasDecrypted) {
            hasDecrypted = await decryptOnLoadFromRememberMe();
        }

        // if we didn't decrypt anything, show the password prompt. Otherwise the content has already been replaced, no
        // need to do anything
        if (!hasDecrypted) {
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const passphrase = document.getElementById('staticrypt-password').value,
            shouldRememberPassphrase = document.getElementById('staticrypt-remember').checked;

        // decrypt and replace the whole page
        const hashedPassphrase = await cryptoEngine.hashPassphrase(passphrase, salt);
        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

        if (isDecryptionSuccessful) {
            // remember the hashedPassphrase and set its expiration if necessary
            if (isRememberEnabled && shouldRememberPassphrase) {
                window.localStorage.setItem(rememberPassphraseKey, hashedPassphrase);

                // set the expiration if the duration isn't 0 (meaning no expiration)
                if (rememberDurationInDays > 0) {
                    window.localStorage.setItem(
                        rememberExpirationKey,
                        (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                    );
                }
            }
        } else {
            alert(labelError);
        }
    });
</script>
</body>
</html>
